diff --git a/pom.xml b/pom.xml
index 3d4491cc9..3f5a66c4d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>org.springframework.data</groupId>
 	<artifactId>spring-data-jpa</artifactId>
-	<version>1.9.0.BUILD-SNAPSHOT</version>
+	<version>1.9.0.DATAJPA-307-SNAPSHOT</version>
 
 	<name>Spring Data JPA</name>
 	<description>Spring Data module for JPA repositories.</description>
@@ -22,12 +22,12 @@
 		<dist.key>DATAJPA</dist.key>
 
 		<eclipselink>2.6.0</eclipselink>
-		<hibernate>3.6.10.Final</hibernate>
+		<hibernate>4.1.12.Final</hibernate>
 		<hsqldb1>1.8.0.10</hsqldb1>
 		<jpa>2.0.0</jpa>
 		<openjpa>2.3.0</openjpa>
 		<querydsl>3.6.3</querydsl>
-		<springdata.commons>1.11.0.BUILD-SNAPSHOT</springdata.commons>
+		<springdata.commons>1.11.0.DATACMNS-293-SNAPSHOT</springdata.commons>
 
 		<sonar.dynamicAnalysis>reuseReports</sonar.dynamicAnalysis>
 
@@ -55,7 +55,7 @@
 		<profile>
 			<id>hibernate-5</id>
 			<properties>
-				<hibernate>5.0.0.Beta2</hibernate>
+				<hibernate>5.0.0.CR1</hibernate>
 			</properties>
 		</profile>
 		<profile>
@@ -137,7 +137,6 @@
 		<dependency>
 			<groupId>org.springframework</groupId>
 			<artifactId>spring-aspects</artifactId>
-			<scope>compile</scope>
 			<optional>true</optional>
 		</dependency>
 
@@ -145,9 +144,17 @@
 			<groupId>org.hsqldb</groupId>
 			<artifactId>hsqldb</artifactId>
 			<version>2.2.8</version>
+		
 			<scope>test</scope>
 		</dependency>
-
+		<!-- Do not upgrade to 173 as this drops support for indexes on BLOBs (which OpenJPA apparently turns -->
+		<dependency>
+			<groupId>com.h2database</groupId>
+			<artifactId>h2</artifactId>
+			<version>1.3.172</version>
+			<scope>test</scope>
+		</dependency>
+		
 		<dependency>
 			<groupId>joda-time</groupId>
 			<artifactId>joda-time</artifactId>
@@ -183,20 +190,8 @@
 			<artifactId>openjpa-persistence-jdbc</artifactId>
 			<version>${openjpa}</version>
 			<optional>true</optional>
-			<exclusions>
-				<exclusion>
-					<groupId>commons-logging</groupId>
-					<artifactId>commons-logging</artifactId>
-				</exclusion>
-				<!-- Transitive dependency pulls in JUnit 3.8.1 -->
-				<!-- http://sourceforge.net/tracker/?func=detail&aid=2572567&group_id=31479&atid=402282 -->
-				<exclusion>
-					<groupId>junit</groupId>
-					<artifactId>junit</artifactId>
-				</exclusion>
-			</exclusions>
 		</dependency>
-
+		
 		<!-- QueryDsl -->
 		<dependency>
 			<groupId>com.mysema.querydsl</groupId>
diff --git a/src/main/java/org/springframework/data/jpa/repository/JpaContext.java b/src/main/java/org/springframework/data/jpa/repository/JpaContext.java
new file mode 100644
index 000000000..465708418
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/JpaContext.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository;
+
+import javax.persistence.EntityManager;
+
+/**
+ * Interface for components to provide useful information about the current JPA setup within the current
+ * {@link org.springframework.context.ApplicationContext}.
+ * 
+ * @author Oliver Gierke
+ * @soundtrack Marcus Miller - Water Dancer (Afrodeezia)
+ * @since 1.9
+ */
+public interface JpaContext {
+
+	/**
+	 * Returns the {@link EntityManager} managing the given domain type.
+	 * 
+	 * @param managedType must not be {@literal null}.
+	 * @return the {@link EntityManager} that manages the given type, will never be {@literal null}.
+	 * @throws IllegalArgumentException if the given type is not a JPA managed one no unique {@link EntityManager} managing this type can be resolved.
+	 */
+	EntityManager getEntityManagerByManagedType(Class<?> managedType);
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/augment/AbstractJpaAnnotationBasedQueryAugmentor.java b/src/main/java/org/springframework/data/jpa/repository/augment/AbstractJpaAnnotationBasedQueryAugmentor.java
new file mode 100644
index 000000000..e888fb938
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/augment/AbstractJpaAnnotationBasedQueryAugmentor.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.augment;
+
+import java.lang.annotation.Annotation;
+
+import org.springframework.data.jpa.repository.support.JpaCriteriaQueryContext;
+import org.springframework.data.jpa.repository.support.JpaQueryContext;
+import org.springframework.data.jpa.repository.support.JpaUpdateContext;
+import org.springframework.data.repository.augment.AnnotationBasedQueryAugmentor;
+
+/**
+ * @author Oliver Gierke
+ */
+public abstract class AbstractJpaAnnotationBasedQueryAugmentor<T extends Annotation>
+		extends AnnotationBasedQueryAugmentor<T, JpaCriteriaQueryContext<?, ?>, JpaQueryContext, JpaUpdateContext<?, ?>> {
+
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/augment/JpaSoftDeleteQueryAugmentor.java b/src/main/java/org/springframework/data/jpa/repository/augment/JpaSoftDeleteQueryAugmentor.java
new file mode 100644
index 000000000..6209667b4
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/augment/JpaSoftDeleteQueryAugmentor.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.augment;
+
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.Predicate;
+
+import org.springframework.beans.BeanWrapper;
+import org.springframework.data.jpa.repository.support.JpaCriteriaQueryContext;
+import org.springframework.data.jpa.repository.support.JpaQueryContext;
+import org.springframework.data.jpa.repository.support.JpaUpdateContext;
+import org.springframework.data.repository.SoftDelete;
+import org.springframework.data.repository.augment.AbstractSoftDeleteQueryAugmentor;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
+
+/**
+ * JPA implementation of {@link AbstractSoftDeleteQueryAugmentor} to transparently turn delete calls into entity
+ * updates. Also filters queries accordingly.
+ * 
+ * @author Oliver Gierke
+ */
+public class JpaSoftDeleteQueryAugmentor
+		extends AbstractSoftDeleteQueryAugmentor<JpaCriteriaQueryContext<?, ?>, JpaQueryContext, JpaUpdateContext<?, ?>> {
+
+	/* 
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AnnotationBasedQueryAugmentor#prepareNativeQuery(org.springframework.data.repository.augment.QueryContext, java.lang.annotation.Annotation)
+	 */
+	@Override
+	protected JpaQueryContext prepareNativeQuery(JpaQueryContext context, SoftDelete expression) {
+
+		if (!context.getMode().in(QueryMode.FIND)) {
+			return context;
+		}
+
+		String string = context.getQueryString();
+		// TODO: Augment query;
+
+		return context; // context.withQuery(string);
+	}
+
+	/* 
+	 * (non-Javadoc)
+	 * @see org.springframework.data.jpa.repository.sample.JpaSoftDeleteQueryAugmentor#prepareQuery(org.springframework.data.jpa.repository.support.JpaCriteriaQueryContext, org.springframework.data.jpa.repository.support.GlobalFilter)
+	 */
+	@Override
+	protected JpaCriteriaQueryContext<?, ?> prepareQuery(JpaCriteriaQueryContext<?, ?> context, SoftDelete expression) {
+
+		CriteriaQuery<?> criteriaQuery = context.getQuery();
+		CriteriaBuilder builder = context.getCriteriaBuilder();
+
+		Predicate predicate = builder.equal(context.getRoot().get(expression.value()), expression.flagMode().activeValue());
+		Predicate restriction = criteriaQuery.getRestriction();
+
+		criteriaQuery.where(restriction == null ? predicate : builder.and(restriction, predicate));
+
+		return context;
+	}
+
+	/* 
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AbstractSoftDeleteQueryAugmentor#updateDeletedState(java.lang.Object)
+	 */
+	@Override
+	public void updateDeletedState(Object entity, JpaUpdateContext<?, ?> context) {
+		context.getEntityManager().merge(entity);
+	}
+
+	/* 
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AbstractSoftDeleteQueryAugmentor#prepareBeanWrapper(org.springframework.data.repository.augment.UpdateContext)
+	 */
+	@Override
+	protected BeanWrapper createBeanWrapper(JpaUpdateContext<?, ?> context) {
+		return new PropertyChangeEnsuringBeanWrapper(context.getEntity());
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/augment/LockModeQueryAugmentor.java b/src/main/java/org/springframework/data/jpa/repository/augment/LockModeQueryAugmentor.java
new file mode 100644
index 000000000..a966b7f14
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/augment/LockModeQueryAugmentor.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2013-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.augment;
+
+import javax.persistence.Query;
+
+import org.springframework.data.jpa.repository.Lock;
+import org.springframework.data.jpa.repository.support.JpaQueryContext;
+
+/**
+ * @author Oliver Gierke
+ */
+public class LockModeQueryAugmentor extends AbstractJpaAnnotationBasedQueryAugmentor<Lock> {
+
+	/* 
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AnnotationBasedQueryAugmentor#prepareNativeQuery(org.springframework.data.repository.augment.QueryContext, java.lang.annotation.Annotation)
+	 */
+	@Override
+	protected JpaQueryContext prepareNativeQuery(JpaQueryContext context, Lock expression) {
+
+		Query query = context.getQuery();
+		query.setLockMode(expression.value());
+
+		return context;
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/augment/PropertyChangeEnsuringBeanWrapper.java b/src/main/java/org/springframework/data/jpa/repository/augment/PropertyChangeEnsuringBeanWrapper.java
new file mode 100644
index 000000000..268e8112c
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/augment/PropertyChangeEnsuringBeanWrapper.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.augment;
+
+import java.lang.reflect.Method;
+
+import org.springframework.data.util.DirectFieldAccessFallbackBeanWrapper;
+import org.springframework.util.ReflectionUtils;
+
+/**
+ * Custom {@link DirectFieldAccessFallbackBeanWrapper} to hook in additional functionality when setting a property by
+ * field access.
+ * 
+ * @author Oliver Gierke
+ */
+class PropertyChangeEnsuringBeanWrapper extends DirectFieldAccessFallbackBeanWrapper {
+
+	public PropertyChangeEnsuringBeanWrapper(Object entity) {
+		super(entity);
+	}
+
+	/**
+	 * We in case of setting the value using field access, we need to make sure that EclipseLink detects the change.
+	 * Hence we check for an EclipseLink specific generated method that is used to record the changes and invoke it if
+	 * available.
+	 * 
+	 * @see org.springframework.data.support.DirectFieldAccessFallbackBeanWrapper#setPropertyUsingFieldAccess(java.lang.String,
+	 *      java.lang.Object)
+	 */
+	@Override
+	public void setPropertyValue(String propertyName, Object value) {
+
+		Object oldValue = getPropertyValue(propertyName);
+		super.setPropertyValue(propertyName, value);
+		triggerPropertyChangeMethodIfAvailable(propertyName, oldValue, value);
+	}
+
+	private void triggerPropertyChangeMethodIfAvailable(String propertyName, Object oldValue, Object value) {
+
+		Method method = ReflectionUtils.findMethod(getWrappedClass(), "_persistence_propertyChange", String.class,
+				Object.class, Object.class);
+
+		if (method == null) {
+			return;
+		}
+
+		ReflectionUtils.invokeMethod(method, getWrappedInstance(), propertyName, oldValue, value);
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/augment/QueryDslSoftDeleteQueryAugmentor.java b/src/main/java/org/springframework/data/jpa/repository/augment/QueryDslSoftDeleteQueryAugmentor.java
new file mode 100644
index 000000000..cc6fa536b
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/augment/QueryDslSoftDeleteQueryAugmentor.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.augment;
+
+import org.springframework.beans.BeanWrapper;
+import org.springframework.data.jpa.repository.support.QueryDslJpaQueryContext;
+import org.springframework.data.jpa.repository.support.QueryDslJpaUpdateContext;
+import org.springframework.data.jpa.repository.support.QueryDslQueryContext;
+import org.springframework.data.repository.SoftDelete;
+import org.springframework.data.repository.augment.AbstractSoftDeleteQueryAugmentor;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
+
+import com.mysema.query.jpa.JPQLQuery;
+import com.mysema.query.types.Predicate;
+import com.mysema.query.types.path.PathBuilder;
+
+/**
+ * Querydsl implementation of {@link AbstractSoftDeleteQueryAugmentor} to transparently turn delete calls into entity
+ * updates and filter queries accordingly.
+ * 
+ * @author Dev Naruka
+ */
+public class QueryDslSoftDeleteQueryAugmentor extends
+		AbstractSoftDeleteQueryAugmentor<QueryDslJpaQueryContext<?>, QueryDslQueryContext, QueryDslJpaUpdateContext<?>> {
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AnnotationBasedQueryAugmentor#prepareNativeQuery(org.springframework.data.repository.augment.QueryContext, java.lang.annotation.Annotation)
+	 */
+	@Override
+	protected QueryDslQueryContext prepareNativeQuery(QueryDslQueryContext context, SoftDelete expression) {
+
+		if (!context.getMode().in(QueryMode.FIND)) {
+			return context;
+		}
+
+		String string = context.getQueryString();
+		// TODO: Augment query;
+
+		return context.withQuery(string);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AnnotationBasedQueryAugmentor#prepareQuery(org.springframework.data.repository.augment.QueryContext, java.lang.annotation.Annotation)
+	 */
+	@Override
+	protected QueryDslJpaQueryContext<?> prepareQuery(QueryDslJpaQueryContext<?> context, SoftDelete expression) {
+
+		JPQLQuery query = context.getQuery();
+		PathBuilder<?> builder = context.getPathBuilder();
+
+		Predicate predicate = builder.get(expression.value()).eq(expression.flagMode().activeValue());
+		query.where(predicate);
+
+		return context;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AbstractSoftDeleteQueryAugmentor#updateDeletedState(java.lang.Object, org.springframework.data.repository.augment.UpdateContext)
+	 */
+	@Override
+	public void updateDeletedState(Object entity, QueryDslJpaUpdateContext<?> context) {
+
+		@SuppressWarnings("unchecked")
+		QueryDslJpaUpdateContext<Object> castedContext = (QueryDslJpaUpdateContext<Object>) context;
+		castedContext.update().set(castedContext.getRoot(), entity);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.augment.AbstractSoftDeleteQueryAugmentor#createBeanWrapper(org.springframework.data.repository.augment.UpdateContext)
+	 */
+	@Override
+	protected BeanWrapper createBeanWrapper(QueryDslJpaUpdateContext<?> context) {
+		return new PropertyChangeEnsuringBeanWrapper(context.getEntity());
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/augment/package-info.java b/src/main/java/org/springframework/data/jpa/repository/augment/package-info.java
new file mode 100644
index 000000000..2917e8668
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/augment/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * JPA specific {@link org.springframework.data.repository.augment.QueryAugmentor} implementations.
+ */
+package org.springframework.data.jpa.repository.augment;
\ No newline at end of file
diff --git a/src/main/java/org/springframework/data/jpa/repository/config/BeanDefinitionNames.java b/src/main/java/org/springframework/data/jpa/repository/config/BeanDefinitionNames.java
index 765657a95..0d6a478f2 100644
--- a/src/main/java/org/springframework/data/jpa/repository/config/BeanDefinitionNames.java
+++ b/src/main/java/org/springframework/data/jpa/repository/config/BeanDefinitionNames.java
@@ -24,4 +24,5 @@
 interface BeanDefinitionNames {
 
 	public static final String JPA_MAPPING_CONTEXT_BEAN_NAME = "jpaMappingContext";
+	public static final String JPA_CONTEXT_BEAN_NAME = "jpaContext";
 }
diff --git a/src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java b/src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java
index 48c365932..f3c073495 100644
--- a/src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java
+++ b/src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java
@@ -37,6 +37,7 @@
 import org.springframework.dao.DataAccessException;
 import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
 import org.springframework.data.jpa.repository.JpaRepository;
+import org.springframework.data.jpa.repository.support.DefaultJpaContext;
 import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
 import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
 import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
@@ -170,6 +171,13 @@ public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConf
 
 		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
 				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);
+
+		// Register bean definition for DefaultJpaContext
+
+		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
+		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
+
+		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
 	}
 
 	/**
diff --git a/src/main/java/org/springframework/data/jpa/repository/query/AbstractJpaQuery.java b/src/main/java/org/springframework/data/jpa/repository/query/AbstractJpaQuery.java
index d87ee193b..3c1904815 100644
--- a/src/main/java/org/springframework/data/jpa/repository/query/AbstractJpaQuery.java
+++ b/src/main/java/org/springframework/data/jpa/repository/query/AbstractJpaQuery.java
@@ -31,6 +31,10 @@
 import org.springframework.data.jpa.repository.query.JpaQueryExecution.SingleEntityExecution;
 import org.springframework.data.jpa.repository.query.JpaQueryExecution.SlicedExecution;
 import org.springframework.data.jpa.repository.query.JpaQueryExecution.StreamExecution;
+import org.springframework.data.jpa.repository.support.JpaEntityInformation;
+import org.springframework.data.jpa.repository.support.JpaEntityInformationSupport;
+import org.springframework.data.repository.augment.QueryAugmentationEngine;
+import org.springframework.data.repository.augment.QueryAugmentationEngineAware;
 import org.springframework.data.repository.query.RepositoryQuery;
 import org.springframework.util.Assert;
 
@@ -40,16 +44,19 @@
  * @author Oliver Gierke
  * @author Thomas Darimont
  */
-public abstract class AbstractJpaQuery implements RepositoryQuery {
+public abstract class AbstractJpaQuery implements RepositoryQuery, QueryAugmentationEngineAware {
 
 	private final JpaQueryMethod method;
 	private final EntityManager em;
 
+	private QueryAugmentationEngine augmentationEngine = QueryAugmentationEngine.NONE;
+	private JpaEntityInformation<?, ?> entityInformation;
+
 	/**
 	 * Creates a new {@link AbstractJpaQuery} from the given {@link JpaQueryMethod}.
 	 * 
-	 * @param method
-	 * @param em
+	 * @param method must not be {@literal null}.
+	 * @param em must not be {@literal null}.
 	 */
 	public AbstractJpaQuery(JpaQueryMethod method, EntityManager em) {
 
@@ -62,30 +69,54 @@ public AbstractJpaQuery(JpaQueryMethod method, EntityManager em) {
 
 	/*
 	 * (non-Javadoc)
-	 * 
-	 * @see
-	 * org.springframework.data.repository.query.RepositoryQuery#getQueryMethod
-	 * ()
+	 * @see org.springframework.data.repository.augment.QueryAugmentationEngineAware#setQueryAugmentationEngine(org.springframework.data.repository.augment.QueryAugmentationEngine)
 	 */
-	public JpaQueryMethod getQueryMethod() {
+	public void setQueryAugmentationEngine(QueryAugmentationEngine engine) {
+		this.augmentationEngine = engine;
+	}
 
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.query.RepositoryQuery#getQueryMethod()
+	 */
+	public JpaQueryMethod getQueryMethod() {
 		return method;
 	}
 
 	/**
-	 * @return the em
+	 * Returns the EntityManager to be used with the query.
+	 * 
+	 * @return will never be {@literal null}.
 	 */
 	protected EntityManager getEntityManager() {
-
 		return em;
 	}
 
+	/**
+	 * Returns the {@link JpaEntityInformation} for the query domain type.
+	 * 
+	 * @return will never be {@literal null}.
+	 */
+	protected JpaEntityInformation<?, ?> getEntityInformation() {
+
+		if (entityInformation == null) {
+			this.entityInformation = JpaEntityInformationSupport
+					.getEntityInformation(method.getEntityInformation().getJavaType(), em);
+		}
+
+		return entityInformation;
+	}
+
+	/**
+	 * @return the augmentationEngine
+	 */
+	public QueryAugmentationEngine getAugmentationEngine() {
+		return augmentationEngine;
+	}
+
 	/*
 	 * (non-Javadoc)
-	 * 
-	 * @see
-	 * org.springframework.data.repository.query.RepositoryQuery#execute(java
-	 * .lang.Object[])
+	 * @see org.springframework.data.repository.query.RepositoryQuery#execute(java.lang.Object[])
 	 */
 	public Object execute(Object[] parameters) {
 		return doExecute(getExecution(), parameters);
@@ -182,7 +213,8 @@ private Query applyEntityGraphConfiguration(Query query, JpaQueryMethod method)
 		Assert.notNull(query, "Query must not be null!");
 		Assert.notNull(method, "JpaQueryMethod must not be null!");
 
-		Map<String, Object> hints = Jpa21Utils.tryGetFetchGraphHints(em, method.getEntityGraph(), getQueryMethod().getEntityInformation().getJavaType());
+		Map<String, Object> hints = Jpa21Utils.tryGetFetchGraphHints(em, method.getEntityGraph(),
+				getQueryMethod().getEntityInformation().getJavaType());
 
 		for (Map.Entry<String, Object> hint : hints.entrySet()) {
 			query.setHint(hint.getKey(), hint.getValue());
@@ -191,8 +223,8 @@ private Query applyEntityGraphConfiguration(Query query, JpaQueryMethod method)
 		return query;
 	}
 
-	protected TypedQuery<Long> createCountQuery(Object[] values) {
-		TypedQuery<Long> countQuery = doCreateCountQuery(values);
+	protected Query createCountQuery(Object[] values) {
+		Query countQuery = doCreateCountQuery(values);
 		return method.applyHintsToCountQuery() ? applyHints(countQuery, method) : countQuery;
 	}
 
@@ -210,5 +242,5 @@ private Query applyEntityGraphConfiguration(Query query, JpaQueryMethod method)
 	 * @param values must not be {@literal null}.
 	 * @return
 	 */
-	protected abstract TypedQuery<Long> doCreateCountQuery(Object[] values);
+	protected abstract Query doCreateCountQuery(Object[] values);
 }
diff --git a/src/main/java/org/springframework/data/jpa/repository/query/AbstractStringBasedJpaQuery.java b/src/main/java/org/springframework/data/jpa/repository/query/AbstractStringBasedJpaQuery.java
index 697bfde1b..5d0de5c1c 100644
--- a/src/main/java/org/springframework/data/jpa/repository/query/AbstractStringBasedJpaQuery.java
+++ b/src/main/java/org/springframework/data/jpa/repository/query/AbstractStringBasedJpaQuery.java
@@ -17,8 +17,10 @@
 
 import javax.persistence.EntityManager;
 import javax.persistence.Query;
-import javax.persistence.TypedQuery;
 
+import org.springframework.data.jpa.repository.support.JpaQueryContext;
+import org.springframework.data.repository.augment.QueryAugmentationEngine;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
 import org.springframework.data.repository.query.EvaluationContextProvider;
 import org.springframework.data.repository.query.ParameterAccessor;
 import org.springframework.data.repository.query.ParametersParameterAccessor;
@@ -97,7 +99,9 @@ protected ParameterBinder createBinder(Object[] values) {
 	 * @return
 	 */
 	public Query createJpaQuery(String queryString) {
-		return getEntityManager().createQuery(queryString);
+		Query query = getEntityManager().createQuery(queryString);
+		query = potentiallyAugment(query);
+		return query;
 	}
 
 	/*
@@ -105,8 +109,13 @@ public Query createJpaQuery(String queryString) {
 	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
 	 */
 	@Override
-	protected TypedQuery<Long> doCreateCountQuery(Object[] values) {
-		return createBinder(values).bind(getEntityManager().createQuery(countQuery.getQueryString(), Long.class));
+	protected Query doCreateCountQuery(Object[] values) {
+
+		String queryString = countQuery.getQueryString();
+		EntityManager em = getEntityManager();
+
+		return createBinder(values).bind(
+				getQueryMethod().isNativeQuery() ? em.createNativeQuery(queryString) : em.createQuery(queryString, Long.class));
 	}
 
 	/**
@@ -122,4 +131,20 @@ public StringQuery getQuery() {
 	public StringQuery getCountQuery() {
 		return countQuery;
 	}
+
+	protected Query potentiallyAugment(Query query) {
+		return potentiallyAugment(query, QueryMode.FIND);
+	}
+
+	private Query potentiallyAugment(Query query, QueryMode mode) {
+
+		QueryAugmentationEngine engine = getAugmentationEngine();
+
+		if (engine.augmentationNeeded(JpaQueryContext.class, mode, getEntityInformation())) {
+			JpaQueryContext context = new JpaQueryContext(query, mode, getEntityManager(), getEntityInformation());
+			return engine.invokeNativeAugmentors(context).getQuery();
+		} else {
+			return query;
+		}
+	}
 }
diff --git a/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryExecution.java b/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryExecution.java
index 394946a19..521079803 100644
--- a/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryExecution.java
+++ b/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryExecution.java
@@ -22,11 +22,10 @@
 import javax.persistence.NoResultException;
 import javax.persistence.Query;
 import javax.persistence.StoredProcedureQuery;
-import javax.persistence.TypedQuery;
 
 import org.springframework.core.convert.ConversionService;
 import org.springframework.core.convert.support.ConfigurableConversionService;
-import org.springframework.core.convert.support.GenericConversionService;
+import org.springframework.core.convert.support.DefaultConversionService;
 import org.springframework.data.domain.PageImpl;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.domain.Slice;
@@ -53,7 +52,7 @@
 
 	static {
 
-		ConfigurableConversionService conversionService = new GenericConversionService();
+		ConfigurableConversionService conversionService = new DefaultConversionService();
 		conversionService.addConverter(JpaResultConverters.BlobToByteArrayConverter.INSTANCE);
 
 		CONVERSION_SERVICE = conversionService;
@@ -90,8 +89,8 @@ public Object execute(AbstractJpaQuery query, Object[] values) {
 			return result;
 		}
 
-		return CONVERSION_SERVICE.canConvert(result.getClass(), requiredType) ? CONVERSION_SERVICE.convert(result,
-				requiredType) : result;
+		return CONVERSION_SERVICE.canConvert(result.getClass(), requiredType)
+				? CONVERSION_SERVICE.convert(result, requiredType) : result;
 	}
 
 	/**
@@ -173,10 +172,10 @@ public PagedExecution(Parameters<?, ?> parameters) {
 		protected Object doExecute(AbstractJpaQuery repositoryQuery, Object[] values) {
 
 			// Execute query to compute total
-			TypedQuery<Long> projection = repositoryQuery.createCountQuery(values);
+			Query projection = repositoryQuery.createCountQuery(values);
 
-			List<Long> totals = projection.getResultList();
-			Long total = totals.size() == 1 ? totals.get(0) : totals.size();
+			List<?> totals = projection.getResultList();
+			Long total = totals.size() == 1 ? CONVERSION_SERVICE.convert(totals.get(0), Long.class) : totals.size();
 
 			ParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);
 			Pageable pageable = accessor.getPageable();
@@ -187,8 +186,8 @@ protected Object doExecute(AbstractJpaQuery repositoryQuery, Object[] values) {
 
 			Query query = repositoryQuery.createQuery(values);
 
-			List<Object> content = pageable == null || total > pageable.getOffset() ? query.getResultList() : Collections
-					.emptyList();
+			List<Object> content = pageable == null || total > pageable.getOffset() ? query.getResultList()
+					: Collections.emptyList();
 
 			return new PageImpl<Object>(content, pageable, total);
 		}
diff --git a/src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java b/src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java
index 6156f6802..19288e3d9 100644
--- a/src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java
+++ b/src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java
@@ -27,6 +27,11 @@
 import org.springframework.data.jpa.provider.PersistenceProvider;
 import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
 import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
+import org.springframework.data.jpa.repository.support.JpaCriteriaQueryContext;
+import org.springframework.data.jpa.repository.support.JpaEntityInformation;
+import org.springframework.data.jpa.repository.support.JpaEntityInformationSupport;
+import org.springframework.data.repository.augment.QueryAugmentationEngine;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
 import org.springframework.data.repository.query.ParametersParameterAccessor;
 import org.springframework.data.repository.query.parser.PartTree;
 
@@ -46,6 +51,8 @@
 	private final QueryPreparer countQuery;
 	private final EntityManager em;
 
+	private final JpaEntityInformation<?, ?> entityInformation;
+
 	/**
 	 * Creates a new {@link PartTreeJpaQuery}.
 	 * 
@@ -63,6 +70,9 @@ public PartTreeJpaQuery(JpaQueryMethod method, EntityManager em) {
 
 		this.countQuery = new CountQueryPreparer(parameters.potentiallySortsDynamically());
 		this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(parameters.potentiallySortsDynamically());
+
+		this.entityInformation = JpaEntityInformationSupport
+				.getEntityInformation(method.getEntityInformation().getJavaType(), em);
 	}
 
 	/*
@@ -125,7 +135,7 @@ public Query createQuery(Object[] values) {
 
 			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
 				JpaQueryCreator creator = createCreator(accessor);
-				criteriaQuery = creator.createQuery(getDynamicSort(values));
+				criteriaQuery = potentiallyAugment(creator.createQuery(getDynamicSort(values)));
 				expressions = creator.getParameterExpressions();
 			}
 
@@ -183,6 +193,23 @@ private Query restrictMaxResultsIfNecessary(Query query) {
 			return getEntityManager().createQuery(criteriaQuery);
 		}
 
+		protected <T> CriteriaQuery<T> potentiallyAugment(CriteriaQuery<T> query) {
+			return potentiallyAugment(query, QueryMode.FIND);
+		}
+
+		private <T> CriteriaQuery<T> potentiallyAugment(CriteriaQuery<T> query, QueryMode mode) {
+
+			QueryAugmentationEngine engine = getAugmentationEngine();
+
+			if (engine.augmentationNeeded(JpaCriteriaQueryContext.class, mode, entityInformation)) {
+				JpaCriteriaQueryContext<T, T> context = new JpaCriteriaQueryContext<T, T>(mode, getEntityManager(), query,
+						entityInformation, null);
+				return engine.invokeAugmentors(context).getQuery();
+			} else {
+				return query;
+			}
+		}
+
 		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor) {
 
 			EntityManager entityManager = getEntityManager();
@@ -247,6 +274,15 @@ protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor) {
 			return new JpaCountQueryCreator(tree, domainClass, builder, provider);
 		}
 
+		/* 
+		 * (non-Javadoc)
+		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#potentiallyAugment(javax.persistence.criteria.CriteriaQuery)
+		 */
+		@Override
+		protected <T> CriteriaQuery<T> potentiallyAugment(CriteriaQuery<T> query) {
+			return super.potentiallyAugment(query, QueryMode.COUNT_FOR_PAGING);
+		}
+
 		/**
 		 * Customizes binding by skipping the pagination.
 		 * 
diff --git a/src/main/java/org/springframework/data/jpa/repository/query/QueryUtils.java b/src/main/java/org/springframework/data/jpa/repository/query/QueryUtils.java
index 50346287b..6f853690c 100644
--- a/src/main/java/org/springframework/data/jpa/repository/query/QueryUtils.java
+++ b/src/main/java/org/springframework/data/jpa/repository/query/QueryUtils.java
@@ -531,4 +531,45 @@ private static boolean requiresJoin(Bindable<?> propertyPathModel, boolean forPl
 
 		return from.join(attribute, JoinType.LEFT);
 	}
+
+	public static String addFromAndWhere(String source, String from, String where) {
+
+		String lowerCase = source.toLowerCase(Locale.US);
+
+		int fromIndex = indexOrLength(lowerCase, "from");
+		int joinIndex = indexOrLength(lowerCase, "join");
+		int whereIndex = indexOrLength(lowerCase, "where");
+		int orderByIndex = indexOrLength(lowerCase, "order by");
+
+		int to = joinIndex < whereIndex ? joinIndex : whereIndex;
+
+		String fromClause = source.substring(fromIndex, to).trim();
+		String whereClause = source.substring(whereIndex, orderByIndex).trim();
+
+		StringBuilder builder = new StringBuilder();
+		builder.append(source.substring(0, fromIndex));
+		builder.append(fromClause);
+		builder.append(", ").append(from);
+
+		builder.append(to != whereIndex ? " " : "");
+
+		builder.append(source.substring(to, whereIndex));
+
+		builder.append(whereClause);
+		builder.append(whereIndex != source.length() ? " and " : " where ");
+
+		builder.append(where);
+
+		if (orderByIndex != source.length()) {
+			builder.append(" ").append(source.substring(orderByIndex, source.length()));
+		}
+
+		return builder.toString();
+	}
+
+	private static int indexOrLength(String source, String keyword) {
+
+		int index = source.indexOf(keyword);
+		return index == -1 ? source.length() : index;
+	}
 }
diff --git a/src/main/java/org/springframework/data/jpa/repository/query/SimpleJpaQuery.java b/src/main/java/org/springframework/data/jpa/repository/query/SimpleJpaQuery.java
index 2ee943f9a..75719d688 100644
--- a/src/main/java/org/springframework/data/jpa/repository/query/SimpleJpaQuery.java
+++ b/src/main/java/org/springframework/data/jpa/repository/query/SimpleJpaQuery.java
@@ -24,7 +24,7 @@
 
 /**
  * {@link RepositoryQuery} implementation that inspects a {@link org.springframework.data.repository.query.QueryMethod}
- * for the existence of an {@link org.springframework.data.jpa.repository.Query} annotation and creates a JPA
+ * for the existance of an {@link org.springframework.data.jpa.repository.Query} annotation and creates a JPA
  * {@link Query} from it.
  * 
  * @author Oliver Gierke
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/DefaultJpaContext.java b/src/main/java/org/springframework/data/jpa/repository/support/DefaultJpaContext.java
new file mode 100644
index 000000000..ace3b4a00
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/DefaultJpaContext.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import java.util.List;
+import java.util.Set;
+
+import javax.persistence.EntityManager;
+import javax.persistence.metamodel.ManagedType;
+
+import org.springframework.data.jpa.repository.JpaContext;
+import org.springframework.util.Assert;
+import org.springframework.util.LinkedMultiValueMap;
+import org.springframework.util.MultiValueMap;
+
+/**
+ * Default implementation of {@link JpaContext}.
+ * 
+ * @author Oliver Gierke
+ * @soundtrack Marcus Miller - Son Of Macbeth (Afrodeezia)
+ * @since 1.9
+ */
+public class DefaultJpaContext implements JpaContext {
+
+	private final MultiValueMap<Class<?>, EntityManager> entityManagers;
+
+	/**
+	 * Creates a new {@link DefaultJpaContext} for the given {@link Set} of {@link EntityManager}s.
+	 * 
+	 * @param entityManagers must not be {@literal null}.
+	 */
+	public DefaultJpaContext(Set<EntityManager> entityManagers) {
+
+		Assert.notNull(entityManagers, "EntityManagers must not be null!");
+		Assert.notEmpty(entityManagers, "EntityManagers must not be empty!");
+
+		this.entityManagers = new LinkedMultiValueMap<Class<?>, EntityManager>();
+
+		for (EntityManager em : entityManagers) {
+			for (ManagedType<?> managedType : em.getMetamodel().getManagedTypes()) {
+				this.entityManagers.add(managedType.getJavaType(), em);
+			}
+		}
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.jpa.repository.JpaContext#getByManagedType(java.lang.Class)
+	 */
+	@Override
+	public EntityManager getEntityManagerByManagedType(Class<?> type) {
+
+		Assert.notNull(type, "Type must not be null!");
+
+		if (!entityManagers.containsKey(type)) {
+			throw new IllegalArgumentException(String.format("%s is not a managed type!", type));
+		}
+
+		List<EntityManager> candidates = this.entityManagers.get(type);
+
+		if (candidates.size() == 1) {
+			return candidates.get(0);
+		}
+
+		throw new IllegalArgumentException(
+				String.format("%s managed by more than one EntityManagers: %s!", type.getName(), candidates));
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/JpaCriteriaQueryContext.java b/src/main/java/org/springframework/data/jpa/repository/support/JpaCriteriaQueryContext.java
new file mode 100644
index 000000000..8cca1f9ae
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/JpaCriteriaQueryContext.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import javax.persistence.EntityManager;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.Root;
+
+import org.springframework.data.repository.augment.QueryContext;
+import org.springframework.util.Assert;
+
+/**
+ * A {@link QueryContext}
+ * 
+ * @author Oliver Gierke
+ */
+public class JpaCriteriaQueryContext<S, T> extends QueryContext<CriteriaQuery<S>> {
+
+	private final EntityManager em;
+	private final Root<T> root;
+	private final JpaEntityInformation<?, ?> entityInformation;
+
+	/**
+	 * @param mode must not be {@literal null}.
+	 * @param em must not be {@literal null}.
+	 * @param query must not be {@literal null}.
+	 * @param entityInformation must not be {@literal null}.
+	 * @param root can be {@literal null}.
+	 */
+	public JpaCriteriaQueryContext(QueryMode mode, EntityManager em, CriteriaQuery<S> query,
+			JpaEntityInformation<?, ?> entityInformation, Root<T> root) {
+
+		super(query, mode);
+
+		Assert.notNull(em, "EntityManager must not be null!");
+		Assert.notNull(entityInformation, "JpaEntityInformation must not be null!");
+
+		this.em = em;
+		this.root = root;
+		this.entityInformation = entityInformation;
+	}
+
+	/**
+	 * Returns the {@link Root} of the {@link CriteriaQuery}.
+	 * 
+	 * @return the root can be {@literal null}.
+	 */
+	public Root<T> getRoot() {
+		return root;
+	}
+
+	public CriteriaBuilder getCriteriaBuilder() {
+		return em.getCriteriaBuilder();
+	}
+
+	/**
+	 * @return the entityInformation
+	 */
+	public JpaEntityInformation<?, ?> getEntityInformation() {
+		return entityInformation;
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/JpaQueryContext.java b/src/main/java/org/springframework/data/jpa/repository/support/JpaQueryContext.java
new file mode 100644
index 000000000..1a40e2ccb
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/JpaQueryContext.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2013-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.EntityManager;
+import javax.persistence.Query;
+
+import org.springframework.data.jpa.provider.PersistenceProvider;
+import org.springframework.data.jpa.provider.QueryExtractor;
+import org.springframework.data.jpa.repository.query.QueryUtils;
+import org.springframework.data.repository.augment.QueryContext;
+
+/**
+ * @author Oliver Gierke
+ */
+public class JpaQueryContext extends QueryContext<Query> {
+
+	private final EntityManager entityManager;
+	private final QueryExtractor extractor;
+	private final JpaEntityInformation<?, ?> entityInformation;
+
+	/**
+	 * @param query must not be {@literal null}.
+	 * @param queryMode must not be {@literal null}.
+	 * @param entityManager must not be {@literal null}.
+	 */
+	public JpaQueryContext(Query query, QueryMode queryMode, EntityManager entityManager,
+			JpaEntityInformation<?, ?> entityInformation) {
+
+		super(query, queryMode);
+		this.entityManager = entityManager;
+		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
+		this.entityInformation = entityInformation;
+	}
+
+	/**
+	 * @return the entityManager
+	 */
+	public EntityManager getEntityManager() {
+		return entityManager;
+	}
+
+	public String getQueryString() {
+		return extractor.extractQueryString(getQuery());
+	}
+
+	/**
+	 * @return the entityInformation
+	 */
+	public JpaEntityInformation<?, ?> getEntityInformation() {
+		return entityInformation;
+	}
+
+	/**
+	 * Creates a new {@link JpaQueryContext} from the current one augmenting the query with the given {@code from} and
+	 * {@code where} clause. The where clause can use a placeholder of <code>{alias}</code> to be replaced with the main
+	 * alias of the original query.
+	 * 
+	 * @param from must not be {@literal null}.
+	 * @param where must not be {@literal null}.
+	 * @return
+	 */
+	public JpaQueryContext augment(String from, String where, Map<String, Object> parameters) {
+
+		String queryString = getQueryString();
+		Query query = entityManager.createQuery(
+				QueryUtils.addFromAndWhere(queryString, from, where.replace("{alias}", QueryUtils.detectAlias(queryString))));
+
+		for (Entry<String, Object> parameter : parameters.entrySet()) {
+			query.setParameter(parameter.getKey(), parameter.getValue());
+		}
+
+		return new JpaQueryContext(query, getMode(), entityManager, entityInformation);
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/JpaUpdateContext.java b/src/main/java/org/springframework/data/jpa/repository/support/JpaUpdateContext.java
new file mode 100644
index 000000000..b1805aa56
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/JpaUpdateContext.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import java.io.Serializable;
+
+import javax.persistence.EntityManager;
+
+import org.springframework.data.repository.augment.UpdateContext;
+import org.springframework.util.Assert;
+
+/**
+ * JPA-specific extension of {@link UpdateContext} adding an {@link EntityManager} to it.
+ * 
+ * @author Oliver Gierke
+ */
+public class JpaUpdateContext<T, ID extends Serializable> extends UpdateContext<T> {
+
+	private final EntityManager em;
+	private final QueryExecutor<T, ID> executor;
+	private final JpaEntityInformation<T, ?> entityInformation;
+
+	/**
+	 * Creates a new {@link JpaUpdateContext} from the given entity and {@link EntityManager}.
+	 * 
+	 * @param entity
+	 * @param em must not be {@literal null}.
+	 */
+	public JpaUpdateContext(T entity, UpdateMode mode, EntityManager em, QueryExecutor<T, ID> executor,
+			JpaEntityInformation<T, ?> entityInformation) {
+
+		super(entity, mode);
+
+		Assert.notNull(em, "EntityManager must not be null!");
+
+		this.em = em;
+		this.executor = executor;
+		this.entityInformation = entityInformation;
+	}
+
+	/**
+	 * Returns the {@link EntityManager} to be used for this update.
+	 * 
+	 * @return the em will never be {@literal null}.
+	 */
+	public EntityManager getEntityManager() {
+		return em;
+	}
+
+	/**
+	 * @return the executor
+	 */
+	public QueryExecutor<T, ID> getQueryExecutor() {
+		return executor;
+	}
+
+	public boolean isNewEntity() {
+		return entityInformation.isNew(getEntity());
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaQueryContext.java b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaQueryContext.java
new file mode 100644
index 000000000..602a64330
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaQueryContext.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2011 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import org.springframework.data.repository.augment.QueryContext;
+
+import com.mysema.query.jpa.impl.JPAQuery;
+import com.mysema.query.types.EntityPath;
+import com.mysema.query.types.path.PathBuilder;
+
+/**
+ * @author Dev Naruka
+ */
+public class QueryDslJpaQueryContext<T> extends QueryContext<JPAQuery> {
+
+	private final EntityPath<T> root;
+	private final PathBuilder<T> pathBuilder;
+
+	public QueryDslJpaQueryContext(JPAQuery query, EntityPath<T> root, PathBuilder<T> builder, QueryMode queryMode) {
+		super(query, queryMode);
+		this.root = root;
+		this.pathBuilder = builder;
+	}
+
+	public EntityPath<T> getRoot() {
+		return root;
+	}
+
+	public PathBuilder<T> getPathBuilder() {
+		return pathBuilder;
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaRepository.java b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaRepository.java
index cbe350e86..9d505843a 100644
--- a/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaRepository.java
+++ b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaRepository.java
@@ -31,6 +31,9 @@
 import org.springframework.data.querydsl.QSort;
 import org.springframework.data.querydsl.QueryDslPredicateExecutor;
 import org.springframework.data.querydsl.SimpleEntityPathResolver;
+import org.springframework.data.repository.augment.QueryAugmentationEngine;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
+import org.springframework.data.repository.core.EntityInformation;
 
 import com.mysema.query.jpa.JPQLQuery;
 import com.mysema.query.jpa.impl.JPAQuery;
@@ -54,6 +57,7 @@
 	private final EntityPath<T> path;
 	private final PathBuilder<T> builder;
 	private final Querydsl querydsl;
+	private final EntityInformation<T, ID> entityInformation;
 
 	/**
 	 * Creates a new {@link QueryDslJpaRepository} from the given domain class and {@link EntityManager}. This will use
@@ -81,6 +85,7 @@ public QueryDslJpaRepository(JpaEntityInformation<T, ID> entityInformation, Enti
 		this.path = resolver.createPath(entityInformation.getJavaType());
 		this.builder = new PathBuilder<T>(path.getType(), path.getMetadata());
 		this.querydsl = new Querydsl(entityManager, builder);
+		this.entityInformation = entityInformation;
 	}
 
 	/*
@@ -177,6 +182,15 @@ protected JPQLQuery createQuery(Predicate... predicate) {
 			return query;
 		}
 
+		QueryAugmentationEngine engine = getAugmentationEngine();
+
+		if (engine.augmentationNeeded(QueryDslJpaQueryContext.class, QueryMode.FIND, entityInformation)) {
+
+			QueryDslJpaQueryContext<T> context = new QueryDslJpaQueryContext<T>(query, path, builder, QueryMode.FIND);
+			context = engine.invokeAugmentors(context);
+			query = context.getQuery();
+		}
+
 		LockModeType type = metadata.getLockModeType();
 		query = type == null ? query : query.setLockMode(type);
 
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaUpdateContext.java b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaUpdateContext.java
new file mode 100644
index 000000000..37d23831e
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslJpaUpdateContext.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import javax.persistence.EntityManager;
+
+import org.springframework.data.repository.augment.UpdateContext;
+
+import com.mysema.query.dml.DeleteClause;
+import com.mysema.query.dml.UpdateClause;
+import com.mysema.query.jpa.impl.JPADeleteClause;
+import com.mysema.query.jpa.impl.JPAUpdateClause;
+import com.mysema.query.types.EntityPath;
+import com.mysema.query.types.Path;
+
+/**
+ * @author Dev Naruka
+ */
+public class QueryDslJpaUpdateContext<T> extends UpdateContext<T> {
+
+	private final EntityPath<T> root;
+	private final EntityManager em;
+
+	public QueryDslJpaUpdateContext(T entity, EntityManager entityManager, EntityPath<T> root, UpdateMode mode) {
+		super(entity, mode);
+
+		this.root = root;
+		this.em = entityManager;
+	}
+
+	public Path<T> getRoot() {
+		return root;
+	}
+
+	public UpdateClause<JPAUpdateClause> update() {
+		return new JPAUpdateClause(em, root);
+	}
+
+	public DeleteClause<JPADeleteClause> delete() {
+		return new JPADeleteClause(em, root);
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/QueryDslQueryContext.java b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslQueryContext.java
new file mode 100644
index 000000000..6f98fc276
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/QueryDslQueryContext.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2011 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import org.springframework.data.repository.augment.QueryContext;
+
+import com.mysema.query.jpa.JPQLQuery;
+
+/**
+ * @author Dev Naruka
+ */
+// TODO Which native implementation to be used? (SQLQuery or JPASQLQuery)
+// TODO Where QueryDslQueryContext can be used? (in QueryDslRepositorySupport ???)
+public class QueryDslQueryContext extends QueryContext<JPQLQuery> {
+
+	public QueryDslQueryContext(JPQLQuery query, QueryMode queryMode) {
+		super(query, queryMode);
+	}
+
+	public String getQueryString() {
+		return null;
+	}
+
+	public QueryDslQueryContext withQuery(String string) {
+		return null;
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/QueryExecutor.java b/src/main/java/org/springframework/data/jpa/repository/support/QueryExecutor.java
new file mode 100644
index 000000000..c9e77ade9
--- /dev/null
+++ b/src/main/java/org/springframework/data/jpa/repository/support/QueryExecutor.java
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import static org.springframework.data.jpa.repository.query.QueryUtils.*;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.EntityManager;
+import javax.persistence.LockModeType;
+import javax.persistence.NoResultException;
+import javax.persistence.Query;
+import javax.persistence.TypedQuery;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.ParameterExpression;
+import javax.persistence.criteria.Path;
+import javax.persistence.criteria.Predicate;
+import javax.persistence.criteria.Root;
+
+import org.springframework.data.domain.Sort;
+import org.springframework.data.jpa.domain.Specification;
+import org.springframework.data.jpa.repository.EntityGraph;
+import org.springframework.data.jpa.repository.query.Jpa21Utils;
+import org.springframework.data.jpa.repository.query.JpaEntityGraph;
+import org.springframework.data.repository.augment.QueryAugmentationEngine;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
+import org.springframework.util.Assert;
+
+/**
+ * @author Oliver Gierke
+ */
+public class QueryExecutor<T, ID extends Serializable> {
+
+	private final EntityManager em;
+	private final JpaEntityInformation<T, ID> entityInformation;
+	private final QueryAugmentationEngine engine;
+	private final CrudMethodMetadata metadata;
+
+	/**
+	 * @param entityInformation
+	 */
+	public QueryExecutor(JpaEntityInformation<T, ID> entityInformation, EntityManager em, QueryAugmentationEngine engine,
+			CrudMethodMetadata metadata) {
+
+		this.entityInformation = entityInformation;
+		this.em = em;
+		this.engine = engine;
+		this.metadata = metadata;
+	}
+
+	@SuppressWarnings("unchecked")
+	public <R> R execute(String jpqlString, Map<String, Object> parameters) {
+
+		Query query = em.createQuery(jpqlString);
+
+		for (Entry<String, Object> parameter : parameters.entrySet()) {
+			query.setParameter(parameter.getKey(), parameter.getValue());
+		}
+
+		return (R) query.getSingleResult();
+	}
+
+	/**
+	 * Creates a {@link TypedQuery} for the given {@link Specification} and {@link Sort}.
+	 * 
+	 * @param spec can be {@literal null}.
+	 * @param sort can be {@literal null}.
+	 * @return
+	 */
+	public TypedQuery<T> getQuery(Specification<T> spec, Sort sort) {
+
+		CriteriaBuilder builder = em.getCriteriaBuilder();
+		CriteriaQuery<T> query = builder.createQuery(entityInformation.getJavaType());
+
+		Root<T> root = applySpecificationToCriteria(spec, query);
+
+		JpaCriteriaQueryContext<T, T> context = potentiallyAugment(query, root, QueryMode.FIND);
+		query = context.getQuery();
+		root = context.getRoot();
+
+		query.select(root);
+
+		if (sort != null) {
+			query.orderBy(toOrders(sort, root, builder));
+		}
+
+		return applyRepositoryMethodMetadata(em.createQuery(query));
+	}
+
+	public T executeFindOneFor(ID id) {
+
+		ByIdSpecification<T, ID> spec = new ByIdSpecification<T, ID>(entityInformation);
+		TypedQuery<T> typedQuery = getQuery(spec, (Sort) null);
+
+		try {
+
+			typedQuery.setParameter(spec.parameter, id);
+			return typedQuery.getSingleResult();
+
+		} catch (NoResultException e) {
+			return null;
+		}
+	}
+
+	public Long executeCountByIdFor(ID id, QueryMode mode) {
+
+		ByIdSpecification<T, ID> specification = new ByIdSpecification<T, ID>(entityInformation);
+
+		TypedQuery<Long> query = getCountQuery(specification, mode);
+		query.setParameter(specification.parameter, id);
+
+		return executeCountQuery(query);
+	}
+
+	public Long executeCountByIdFor(T entity, QueryMode mode) {
+		return executeCountByIdFor(entityInformation.getId(entity), mode);
+	}
+
+	public Long executeCountQueryFor(Specification<T> spec, QueryMode mode) {
+		return executeCountQuery(getCountQuery(spec, mode));
+	}
+
+	protected TypedQuery<Long> getCountQuery(Specification<T> spec, QueryMode mode) {
+
+		CriteriaBuilder builder = em.getCriteriaBuilder();
+		CriteriaQuery<Long> query = builder.createQuery(Long.class);
+
+		Root<T> root = applySpecificationToCriteria(spec, query);
+
+		JpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, mode);
+		query = context.getQuery();
+		root = context.getRoot();
+
+		if (query.isDistinct()) {
+			query.select(builder.countDistinct(root));
+		} else {
+			query.select(builder.count(root));
+		}
+
+		return applyRepositoryMethodMetadata(em.createQuery(query));
+	}
+
+	/**
+	 * Applies the given {@link Specification} to the given {@link CriteriaQuery}.
+	 * 
+	 * @param spec can be {@literal null}.
+	 * @param query must not be {@literal null}.
+	 * @return
+	 */
+	private <S> Root<T> applySpecificationToCriteria(Specification<T> spec, CriteriaQuery<S> query) {
+
+		Assert.notNull(query);
+		Root<T> root = query.from(entityInformation.getJavaType());
+
+		if (spec == null) {
+			return root;
+		}
+
+		CriteriaBuilder builder = em.getCriteriaBuilder();
+		Predicate predicate = spec.toPredicate(root, query, builder);
+
+		if (predicate != null) {
+			query.where(predicate);
+		}
+
+		return root;
+	}
+
+	/**
+	 * Executes a count query and transparently sums up all values returned.
+	 * 
+	 * @param query must not be {@literal null}.
+	 * @return
+	 */
+	private Long executeCountQuery(TypedQuery<Long> query) {
+
+		Assert.notNull(query);
+
+		List<Long> totals = query.getResultList();
+		Long total = 0L;
+
+		for (Long element : totals) {
+			total += element == null ? 0 : element;
+		}
+
+		return total;
+	}
+
+	private <Q> TypedQuery<Q> applyRepositoryMethodMetadata(TypedQuery<Q> query) {
+
+		if (metadata == null) {
+			return query;
+		}
+
+		LockModeType type = metadata.getLockModeType();
+		TypedQuery<Q> toReturn = type == null ? query : query.setLockMode(type);
+
+		return applyQueryHints(toReturn);
+	}
+
+	private <Q extends Query> Q applyQueryHints(Q query) {
+
+		for (Entry<String, Object> hint : getQueryHints().entrySet()) {
+			query.setHint(hint.getKey(), hint.getValue());
+		}
+
+		return query;
+	}
+
+	/**
+	 * Returns a {@link Map} with the query hints based on the current {@link CrudMethodMetadata} and potential
+	 * {@link EntityGraph} information.
+	 * 
+	 * @return
+	 */
+	protected Map<String, Object> getQueryHints() {
+
+		if (metadata.getEntityGraph() == null) {
+			return metadata.getQueryHints();
+		}
+
+		Map<String, Object> hints = new HashMap<String, Object>();
+		hints.putAll(metadata.getQueryHints());
+		hints.putAll(Jpa21Utils.tryGetFetchGraphHints(em, getEntityGraph(), entityInformation.getJavaType()));
+
+		return hints;
+	}
+
+	private JpaEntityGraph getEntityGraph() {
+
+		String fallbackName = this.entityInformation.getEntityName() + "." + metadata.getMethod().getName();
+		return new JpaEntityGraph(metadata.getEntityGraph(), fallbackName);
+	}
+
+	private <S> JpaCriteriaQueryContext<S, T> potentiallyAugment(CriteriaQuery<S> query, Root<T> root, QueryMode mode) {
+
+		JpaCriteriaQueryContext<S, T> context = new JpaCriteriaQueryContext<S, T>(mode, em, query, entityInformation, root);
+
+		if (engine.augmentationNeeded(JpaCriteriaQueryContext.class, mode, entityInformation)) {
+			context = engine.invokeAugmentors(context);
+		}
+
+		return context;
+	}
+
+	private static class ByIdSpecification<T, ID extends Serializable> implements Specification<T> {
+
+		private final JpaEntityInformation<T, ID> entityInformation;
+		private ParameterExpression<ID> parameter;
+
+		public ByIdSpecification(JpaEntityInformation<T, ID> entityInformation) {
+			this.entityInformation = entityInformation;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.jpa.domain.Specification#toPredicate(javax.persistence.criteria.Root, javax.persistence.criteria.CriteriaQuery, javax.persistence.criteria.CriteriaBuilder)
+		 */
+		public Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
+
+			Path<?> path = root.get(entityInformation.getIdAttribute());
+			parameter = cb.parameter(entityInformation.getIdType());
+			return cb.equal(path, parameter);
+		}
+	}
+}
diff --git a/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java b/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java
index 5376c13c1..c8f63bf1f 100644
--- a/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java
+++ b/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java
@@ -20,16 +20,13 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 
 import javax.persistence.EntityManager;
 import javax.persistence.LockModeType;
 import javax.persistence.NoResultException;
 import javax.persistence.Parameter;
-import javax.persistence.Query;
 import javax.persistence.TypedQuery;
 import javax.persistence.criteria.CriteriaBuilder;
 import javax.persistence.criteria.CriteriaQuery;
@@ -48,9 +45,11 @@
 import org.springframework.data.jpa.repository.EntityGraph;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
-import org.springframework.data.jpa.repository.query.Jpa21Utils;
-import org.springframework.data.jpa.repository.query.JpaEntityGraph;
 import org.springframework.data.jpa.repository.query.QueryUtils;
+import org.springframework.data.repository.augment.QueryAugmentationEngine;
+import org.springframework.data.repository.augment.QueryAugmentationEngineAware;
+import org.springframework.data.repository.augment.QueryContext.QueryMode;
+import org.springframework.data.repository.augment.UpdateContext.UpdateMode;
 import org.springframework.stereotype.Repository;
 import org.springframework.transaction.annotation.Transactional;
 import org.springframework.util.Assert;
@@ -67,16 +66,19 @@
  */
 @Repository
 @Transactional(readOnly = true)
-public class SimpleJpaRepository<T, ID extends Serializable> implements JpaRepository<T, ID>,
-		JpaSpecificationExecutor<T> {
+public class SimpleJpaRepository<T, ID extends Serializable>
+		implements JpaRepository<T, ID>, JpaSpecificationExecutor<T>, QueryAugmentationEngineAware {
 
 	private static final String ID_MUST_NOT_BE_NULL = "The given id must not be null!";
 
-	private final JpaEntityInformation<T, ?> entityInformation;
+	private final JpaEntityInformation<T, ID> entityInformation;
 	private final EntityManager em;
 	private final PersistenceProvider provider;
 
 	private CrudMethodMetadata metadata;
+	private QueryAugmentationEngine engine = QueryAugmentationEngine.NONE;
+
+	private QueryExecutor<T, ID> executor;
 
 	/**
 	 * Creates a new {@link SimpleJpaRepository} to manage objects of the given {@link JpaEntityInformation}.
@@ -84,7 +86,7 @@
 	 * @param entityInformation must not be {@literal null}.
 	 * @param entityManager must not be {@literal null}.
 	 */
-	public SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {
+	public SimpleJpaRepository(JpaEntityInformation<T, ID> entityInformation, EntityManager entityManager) {
 
 		Assert.notNull(entityInformation);
 		Assert.notNull(entityManager);
@@ -92,6 +94,8 @@ public SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityM
 		this.entityInformation = entityInformation;
 		this.em = entityManager;
 		this.provider = PersistenceProvider.fromEntityManager(entityManager);
+
+		this.executor = new QueryExecutor<T, ID>(entityInformation, entityManager, engine, null);
 	}
 
 	/**
@@ -100,8 +104,9 @@ public SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityM
 	 * @param domainClass must not be {@literal null}.
 	 * @param em must not be {@literal null}.
 	 */
+	@SuppressWarnings("unchecked")
 	public SimpleJpaRepository(Class<T> domainClass, EntityManager em) {
-		this(JpaEntityInformationSupport.getEntityInformation(domainClass, em), em);
+		this((JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, em), em);
 	}
 
 	/**
@@ -112,24 +117,36 @@ public SimpleJpaRepository(Class<T> domainClass, EntityManager em) {
 	 */
 	public void setRepositoryMethodMetadata(CrudMethodMetadata crudMethodMetadata) {
 		this.metadata = crudMethodMetadata;
+		this.executor = new QueryExecutor<T, ID>(entityInformation, em, engine, crudMethodMetadata);
 	}
 
 	protected CrudMethodMetadata getRepositoryMethodMetadata() {
 		return metadata;
 	}
 
-	protected Class<T> getDomainClass() {
-		return entityInformation.getJavaType();
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.repository.core.support.QueryAugmentationEngineAware#setQueryAugmentationEngine(org.springframework.data.repository.core.support.QueryAugmentationEngine)
+	 */
+	public void setQueryAugmentationEngine(QueryAugmentationEngine engine) {
+
+		this.engine = engine;
+		this.executor = new QueryExecutor<T, ID>(entityInformation, em, engine, metadata);
 	}
 
-	private String getDeleteAllQueryString() {
-		return getQueryString(DELETE_ALL_QUERY_STRING, entityInformation.getEntityName());
+	/**
+	 * @return the engine
+	 */
+	protected QueryAugmentationEngine getAugmentationEngine() {
+		return engine;
 	}
 
-	private String getCountQueryString() {
+	private Class<T> getDomainClass() {
+		return entityInformation.getJavaType();
+	}
 
-		String countQuery = String.format(COUNT_QUERY_STRING, provider.getCountQueryPlaceholder(), "%s");
-		return getQueryString(countQuery, entityInformation.getEntityName());
+	private String getDeleteAllQueryString() {
+		return getQueryString(DELETE_ALL_QUERY_STRING, entityInformation.getEntityName());
 	}
 
 	/*
@@ -144,8 +161,8 @@ public void delete(ID id) {
 		T entity = findOne(id);
 
 		if (entity == null) {
-			throw new EmptyResultDataAccessException(String.format("No %s entity with id %s exists!",
-					entityInformation.getJavaType(), id), 1);
+			throw new EmptyResultDataAccessException(
+					String.format("No %s entity with id %s exists!", entityInformation.getJavaType(), id), 1);
 		}
 
 		delete(entity);
@@ -159,7 +176,21 @@ public void delete(ID id) {
 	public void delete(T entity) {
 
 		Assert.notNull(entity, "The entity must not be null!");
-		em.remove(em.contains(entity) ? entity : em.merge(entity));
+
+		entity = em.contains(entity) ? entity : em.merge(entity);
+
+		if (engine.augmentationNeeded(JpaUpdateContext.class, null, entityInformation)) {
+
+			JpaUpdateContext<T, ID> context = new JpaUpdateContext<T, ID>(entity, UpdateMode.DELETE, em, executor,
+					entityInformation);
+			context = engine.invokeAugmentors(context);
+
+			if (context == null) {
+				return;
+			}
+		}
+
+		em.remove(entity);
 	}
 
 	/*
@@ -224,6 +255,10 @@ public T findOne(ID id) {
 
 		Class<T> domainType = getDomainClass();
 
+		if (engine.augmentationNeeded(JpaCriteriaQueryContext.class, QueryMode.FIND, entityInformation)) {
+			return executor.executeFindOneFor(id);
+		}
+
 		if (metadata == null) {
 			return em.find(domainType, id);
 		}
@@ -242,23 +277,7 @@ public T findOne(ID id) {
 	 * @return
 	 */
 	protected Map<String, Object> getQueryHints() {
-
-		if (metadata.getEntityGraph() == null) {
-			return metadata.getQueryHints();
-		}
-
-		Map<String, Object> hints = new HashMap<String, Object>();
-		hints.putAll(metadata.getQueryHints());
-
-		hints.putAll(Jpa21Utils.tryGetFetchGraphHints(em, getEntityGraph(), getDomainClass()));
-
-		return hints;
-	}
-
-	private JpaEntityGraph getEntityGraph() {
-
-		String fallbackName = this.entityInformation.getEntityName() + "." + metadata.getMethod().getName();
-		return new JpaEntityGraph(metadata.getEntityGraph(), fallbackName);
+		return executor.getQueryHints();
 	}
 
 	/* 
@@ -284,6 +303,10 @@ public boolean exists(ID id) {
 			return findOne(id) != null;
 		}
 
+		if (!entityInformation.hasCompositeId()) {
+			return executor.executeCountByIdFor(id, QueryMode.EXIST) == 1L;
+		}
+
 		String placeholder = provider.getCountQueryPlaceholder();
 		String entityName = entityInformation.getEntityName();
 		Iterable<String> idAttributeNames = entityInformation.getIdAttributeNames();
@@ -291,11 +314,6 @@ public boolean exists(ID id) {
 
 		TypedQuery<Long> query = em.createQuery(existsQuery, Long.class);
 
-		if (!entityInformation.hasCompositeId()) {
-			query.setParameter(idAttributeNames.iterator().next(), id);
-			return query.getSingleResult() == 1L;
-		}
-
 		for (String idAttributeName : idAttributeNames) {
 
 			Object idAttributeValue = entityInformation.getCompositeIdAttributeValue(id, idAttributeName);
@@ -320,7 +338,7 @@ public boolean exists(ID id) {
 	 * @see org.springframework.data.jpa.repository.JpaRepository#findAll()
 	 */
 	public List<T> findAll() {
-		return getQuery(null, (Sort) null).getResultList();
+		return executor.getQuery(null, (Sort) null).getResultList();
 	}
 
 	/*
@@ -345,7 +363,7 @@ public boolean exists(ID id) {
 		}
 
 		ByIdsSpecification<T> specification = new ByIdsSpecification<T>(entityInformation);
-		TypedQuery<T> query = getQuery(specification, (Sort) null);
+		TypedQuery<T> query = executor.getQuery(specification, (Sort) null);
 
 		return query.setParameter(specification.parameter, ids).getResultList();
 	}
@@ -355,7 +373,7 @@ public boolean exists(ID id) {
 	 * @see org.springframework.data.jpa.repository.JpaRepository#findAll(org.springframework.data.domain.Sort)
 	 */
 	public List<T> findAll(Sort sort) {
-		return getQuery(null, sort).getResultList();
+		return executor.getQuery(null, sort).getResultList();
 	}
 
 	/*
@@ -378,7 +396,7 @@ public boolean exists(ID id) {
 	public T findOne(Specification<T> spec) {
 
 		try {
-			return getQuery(spec, (Sort) null).getSingleResult();
+			return executor.getQuery(spec, (Sort) null).getSingleResult();
 		} catch (NoResultException e) {
 			return null;
 		}
@@ -389,7 +407,7 @@ public T findOne(Specification<T> spec) {
 	 * @see org.springframework.data.jpa.repository.JpaSpecificationExecutor#findAll(org.springframework.data.jpa.domain.Specification)
 	 */
 	public List<T> findAll(Specification<T> spec) {
-		return getQuery(spec, (Sort) null).getResultList();
+		return executor.getQuery(spec, (Sort) null).getResultList();
 	}
 
 	/*
@@ -407,8 +425,7 @@ public T findOne(Specification<T> spec) {
 	 * @see org.springframework.data.jpa.repository.JpaSpecificationExecutor#findAll(org.springframework.data.jpa.domain.Specification, org.springframework.data.domain.Sort)
 	 */
 	public List<T> findAll(Specification<T> spec, Sort sort) {
-
-		return getQuery(spec, sort).getResultList();
+		return executor.getQuery(spec, sort).getResultList();
 	}
 
 	/*
@@ -416,7 +433,7 @@ public T findOne(Specification<T> spec) {
 	 * @see org.springframework.data.repository.CrudRepository#count()
 	 */
 	public long count() {
-		return em.createQuery(getCountQueryString(), Long.class).getSingleResult();
+		return count(null);
 	}
 
 	/*
@@ -424,8 +441,7 @@ public long count() {
 	 * @see org.springframework.data.jpa.repository.JpaSpecificationExecutor#count(org.springframework.data.jpa.domain.Specification)
 	 */
 	public long count(Specification<T> spec) {
-
-		return executeCountQuery(getCountQuery(spec));
+		return executor.executeCountQueryFor(spec, QueryMode.COUNT);
 	}
 
 	/*
@@ -435,6 +451,16 @@ public long count(Specification<T> spec) {
 	@Transactional
 	public <S extends T> S save(S entity) {
 
+		if (engine.augmentationNeeded(JpaUpdateContext.class, null, entityInformation)) {
+
+			JpaUpdateContext<T, ID> context = engine
+					.invokeAugmentors(new JpaUpdateContext<T, ID>(entity, UpdateMode.SAVE, em, executor, entityInformation));
+
+			if (context == null) {
+				return entity;
+			}
+		}
+
 		if (entityInformation.isNew(entity)) {
 			em.persist(entity);
 			return entity;
@@ -500,7 +526,7 @@ public void flush() {
 		query.setFirstResult(pageable.getOffset());
 		query.setMaxResults(pageable.getPageSize());
 
-		Long total = executeCountQuery(getCountQuery(spec));
+		Long total = executor.executeCountQueryFor(spec, QueryMode.COUNT_FOR_PAGING);
 		List<T> content = total > pageable.getOffset() ? query.getResultList() : Collections.<T> emptyList();
 
 		return new PageImpl<T>(content, pageable, total);
@@ -516,118 +542,7 @@ public void flush() {
 	protected TypedQuery<T> getQuery(Specification<T> spec, Pageable pageable) {
 
 		Sort sort = pageable == null ? null : pageable.getSort();
-		return getQuery(spec, sort);
-	}
-
-	/**
-	 * Creates a {@link TypedQuery} for the given {@link Specification} and {@link Sort}.
-	 * 
-	 * @param spec can be {@literal null}.
-	 * @param sort can be {@literal null}.
-	 * @return
-	 */
-	protected TypedQuery<T> getQuery(Specification<T> spec, Sort sort) {
-
-		CriteriaBuilder builder = em.getCriteriaBuilder();
-		CriteriaQuery<T> query = builder.createQuery(getDomainClass());
-
-		Root<T> root = applySpecificationToCriteria(spec, query);
-		query.select(root);
-
-		if (sort != null) {
-			query.orderBy(toOrders(sort, root, builder));
-		}
-
-		return applyRepositoryMethodMetadata(em.createQuery(query));
-	}
-
-	/**
-	 * Creates a new count query for the given {@link Specification}.
-	 * 
-	 * @param spec can be {@literal null}.
-	 * @return
-	 */
-	protected TypedQuery<Long> getCountQuery(Specification<T> spec) {
-
-		CriteriaBuilder builder = em.getCriteriaBuilder();
-		CriteriaQuery<Long> query = builder.createQuery(Long.class);
-
-		Root<T> root = applySpecificationToCriteria(spec, query);
-
-		if (query.isDistinct()) {
-			query.select(builder.countDistinct(root));
-		} else {
-			query.select(builder.count(root));
-		}
-
-		return em.createQuery(query);
-	}
-
-	/**
-	 * Applies the given {@link Specification} to the given {@link CriteriaQuery}.
-	 * 
-	 * @param spec can be {@literal null}.
-	 * @param query must not be {@literal null}.
-	 * @return
-	 */
-	private <S> Root<T> applySpecificationToCriteria(Specification<T> spec, CriteriaQuery<S> query) {
-
-		Assert.notNull(query);
-		Root<T> root = query.from(getDomainClass());
-
-		if (spec == null) {
-			return root;
-		}
-
-		CriteriaBuilder builder = em.getCriteriaBuilder();
-		Predicate predicate = spec.toPredicate(root, query, builder);
-
-		if (predicate != null) {
-			query.where(predicate);
-		}
-
-		return root;
-	}
-
-	private TypedQuery<T> applyRepositoryMethodMetadata(TypedQuery<T> query) {
-
-		if (metadata == null) {
-			return query;
-		}
-
-		LockModeType type = metadata.getLockModeType();
-		TypedQuery<T> toReturn = type == null ? query : query.setLockMode(type);
-
-		applyQueryHints(toReturn);
-
-		return toReturn;
-	}
-
-	private void applyQueryHints(Query query) {
-
-		for (Entry<String, Object> hint : getQueryHints().entrySet()) {
-			query.setHint(hint.getKey(), hint.getValue());
-		}
-	}
-
-	/**
-	 * Executes a count query and transparently sums up all values returned.
-	 * 
-	 * @param query must not be {@literal null}.
-	 * @return
-	 */
-	private static Long executeCountQuery(TypedQuery<Long> query) {
-
-		Assert.notNull(query);
-
-		List<Long> totals = query.getResultList();
-		Long total = 0L;
-
-		for (Long element : totals) {
-			total += element == null ? 0 : element;
-		}
-
-		return total;
+		return executor.getQuery(spec, sort);
 	}
 
 	/**
diff --git a/src/main/resources/changelog.txt b/src/main/resources/changelog.txt
index abe36a433..32c404e85 100644
--- a/src/main/resources/changelog.txt
+++ b/src/main/resources/changelog.txt
@@ -1,6 +1,66 @@
 Spring Data JPA Changelog
 =========================
 
+Changes in version 1.6.6.RELEASE (2015-07-01)
+---------------------------------------------
+* DATAJPA-750 - Release 1.6.6 (Dijkstra).
+* DATAJPA-743 - Typo in README.
+* DATAJPA-736 - Count query creation fails when entity names contain non-ASCII characters.
+* DATAJPA-728 - PageImpl : wrong total count.
+* DATAJPA-726 - Pageable Always Adding From Entity to Sort Field Name.
+* DATAJPA-721 - Enable Slack notifications for Travis build.
+* DATAJPA-720 - Remove relative reference to parent POM to make sure the right Spring version is picked up.
+* DATAJPA-715 - Fix typo in @EnableJpaRepositories' JavaDoc.
+* DATAJPA-702 - Add convenience methods to ease building up a more complex JpaSort.
+* DATAJPA-699 - Upgrade to EclipseLink 2.5.2.
+* DATAJPA-681 - Execution of derived stored procedures fails if named parameters are used.
+* DATAJPA-672 - Activate Spring 4.2 build profile for travis.
+* DATAJPA-656 - Count query with group by returns wrong result.
+* DATAJPA-633 - Target entity type not considered for associations.
+
+
+Changes in version 1.7.3.RELEASE (2015-07-01)
+---------------------------------------------
+* DATAJPA-751 - Release 1.7.3 (Evans).
+* DATAJPA-743 - Typo in README.
+* DATAJPA-741 - Back-port DATAJPA-608 to Evans.
+* DATAJPA-736 - Count query creation fails when entity names contain non-ASCII characters.
+* DATAJPA-728 - PageImpl : wrong total count.
+* DATAJPA-726 - Pageable Always Adding From Entity to Sort Field Name.
+* DATAJPA-721 - Enable Slack notifications for Travis build.
+* DATAJPA-720 - Remove relative reference to parent POM to make sure the right Spring version is picked up.
+* DATAJPA-715 - Fix typo in @EnableJpaRepositories' JavaDoc.
+* DATAJPA-714 - Include new section on Spring Data and Spring Framework dependencies in reference documentation.
+* DATAJPA-712 - Bug in binding in clause parameters with SPEL.
+* DATAJPA-703 - Assert Hibernate 5 compatibilty.
+* DATAJPA-702 - Add convenience methods to ease building up a more complex JpaSort.
+* DATAJPA-699 - Upgrade to EclipseLink 2.5.2.
+* DATAJPA-689 - Allow @EntityGraph on findOne method of CrudRepository.
+* DATAJPA-681 - Execution of derived stored procedures fails if named parameters are used.
+* DATAJPA-672 - Activate Spring 4.2 build profile for travis.
+* DATAJPA-656 - Count query with group by returns wrong result.
+* DATAJPA-633 - Target entity type not considered for associations.
+
+
+Changes in version 1.8.1.RELEASE (2015-06-30)
+---------------------------------------------
+* DATAJPA-752 - Release 1.8.1 (Fowler).
+* DATAJPA-743 - Typo in README.
+* DATAJPA-736 - Count query creation fails when entity names contain non-ASCII characters.
+* DATAJPA-728 - PageImpl : wrong total count.
+* DATAJPA-726 - Pageable Always Adding From Entity to Sort Field Name.
+* DATAJPA-721 - Enable Slack notifications for Travis build.
+* DATAJPA-720 - Remove relative reference to parent POM to make sure the right Spring version is picked up.
+* DATAJPA-716 - JpaPersistentProperty should consider updatable flag of mapping annotations.
+* DATAJPA-715 - Fix typo in @EnableJpaRepositories' JavaDoc.
+* DATAJPA-714 - Include new section on Spring Data and Spring Framework dependencies in reference documentation.
+* DATAJPA-712 - Bug in binding in clause parameters with SPEL.
+* DATAJPA-703 - Assert Hibernate 5 compatibilty.
+* DATAJPA-702 - Add convenience methods to ease building up a more complex JpaSort.
+* DATAJPA-699 - Upgrade to EclipseLink 2.5.2.
+* DATAJPA-695 - Package reference in javadoc wrong in Jsr310JpaConverters, ThreeTenBackPortJpaConverters.
+
+
 Changes in version 1.9.0.M1 (2015-06-02)
 ----------------------------------------
 * DATAJPA-731 - Donwgrade to Querydsl 3.6.3.
diff --git a/src/test/java/org/springframework/data/jpa/domain/sample/User.java b/src/test/java/org/springframework/data/jpa/domain/sample/User.java
index 962972c46..78fb72ab2 100644
--- a/src/test/java/org/springframework/data/jpa/domain/sample/User.java
+++ b/src/test/java/org/springframework/data/jpa/domain/sample/User.java
@@ -38,6 +38,7 @@
 import javax.persistence.NamedStoredProcedureQuery;
 import javax.persistence.ParameterMode;
 import javax.persistence.StoredProcedureParameter;
+import javax.persistence.Table;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 
@@ -64,6 +65,7 @@
 @NamedStoredProcedureQuery(name = "User.plus1IO", procedureName = "plus1inout", parameters = {
 		@StoredProcedureParameter(mode = ParameterMode.IN, name = "arg", type = Integer.class),
 		@StoredProcedureParameter(mode = ParameterMode.OUT, name = "res", type = Integer.class) })
+@Table(name = "SD_User")
 public class User {
 
 	@Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id;
diff --git a/src/test/java/org/springframework/data/jpa/repository/JavaConfigUserRepositoryTests.java b/src/test/java/org/springframework/data/jpa/repository/JavaConfigUserRepositoryTests.java
index 5f4ad62f1..bb927fc55 100644
--- a/src/test/java/org/springframework/data/jpa/repository/JavaConfigUserRepositoryTests.java
+++ b/src/test/java/org/springframework/data/jpa/repository/JavaConfigUserRepositoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 package org.springframework.data.jpa.repository;
 
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 
 import javax.persistence.EntityManager;
@@ -37,6 +38,7 @@
 import org.springframework.data.jpa.repository.sample.SampleEvaluationContextExtension;
 import org.springframework.data.jpa.repository.sample.UserRepository;
 import org.springframework.data.jpa.repository.sample.UserRepositoryImpl;
+import org.springframework.data.jpa.repository.support.DefaultJpaContext;
 import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
 import org.springframework.data.repository.core.NamedQueries;
 import org.springframework.data.repository.core.support.PropertiesBasedNamedQueries;
@@ -78,7 +80,8 @@ public UserRepository userRepository() throws Exception {
 			factory.setEntityManager(entityManager);
 			factory.setBeanFactory(applicationContext);
 			factory.setRepositoryInterface(UserRepository.class);
-			factory.setCustomImplementation(new UserRepositoryImpl());
+			factory
+					.setCustomImplementation(new UserRepositoryImpl(new DefaultJpaContext(Collections.singleton(entityManager))));
 			factory.setNamedQueries(namedQueries());
 			factory.setEvaluationContextProvider(evaluationContextProvider);
 			factory.afterPropertiesSet();
diff --git a/src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java b/src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java
index 778c48bb2..f934b1317 100644
--- a/src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java
+++ b/src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,6 +56,7 @@
 public class JpaQueryLookupStrategyUnitTests {
 
 	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
+
 	@Mock EntityManager em;
 	@Mock EntityManagerFactory emf;
 	@Mock QueryExtractor extractor;
diff --git a/src/test/java/org/springframework/data/jpa/repository/query/QueryUtilsUnitTests.java b/src/test/java/org/springframework/data/jpa/repository/query/QueryUtilsUnitTests.java
index b5f5ea15e..96d5b443d 100644
--- a/src/test/java/org/springframework/data/jpa/repository/query/QueryUtilsUnitTests.java
+++ b/src/test/java/org/springframework/data/jpa/repository/query/QueryUtilsUnitTests.java
@@ -303,6 +303,33 @@ public void supportsNonAsciiCharactersInEntityNames() {
 		assertThat(createCountQueryFor("select u from Usr u"), is("select count(u) from Usr u"));
 	}
 
+	/**
+	 * @see DATAJPA-307
+	 */
+	@Test
+	public void augmentsQueryWithFromAndWhere() {
+
+		String query = "select p from Customer c join c.productOrder p where p.delayed = true";
+		String expected = "select p from Customer c, Permission p join c.productOrder p where p.delayed = true and p.domainType = example.Customer";
+
+		assertThat(addFromAndWhere(query, "Permission p", "p.domainType = example.Customer"), is(expected));
+
+		query = "select p from Customer c";
+		expected = "select p from Customer c, Permission p where p.domainType = example.Customer";
+
+		assertThat(addFromAndWhere(query, "Permission p", "p.domainType = example.Customer"), is(expected));
+
+		query = "select p from Customer c join c.productOrder p";
+		expected = "select p from Customer c, Permission p join c.productOrder p where p.domainType = example.Customer";
+
+		assertThat(addFromAndWhere(query, "Permission p", "p.domainType = example.Customer"), is(expected));
+
+		query = "select p from Customer c join c.productOrder p where p.delayed = true order by c.firstname";
+		expected = "select p from Customer c, Permission p join c.productOrder p where p.delayed = true and p.domainType = example.Customer order by c.firstname";
+
+		assertThat(addFromAndWhere(query, "Permission p", "p.domainType = example.Customer"), is(expected));
+	}
+
 	private void assertCountQuery(String originalQuery, String countQuery) {
 		assertThat(createCountQueryFor(originalQuery), is(countQuery));
 	}
diff --git a/src/test/java/org/springframework/data/jpa/repository/query/SimpleJpaQueryUnitTests.java b/src/test/java/org/springframework/data/jpa/repository/query/SimpleJpaQueryUnitTests.java
index b47df59fd..c42ef877d 100644
--- a/src/test/java/org/springframework/data/jpa/repository/query/SimpleJpaQueryUnitTests.java
+++ b/src/test/java/org/springframework/data/jpa/repository/query/SimpleJpaQueryUnitTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2014 the original author or authors.
+ * Copyright 2008-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,8 +44,8 @@
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.jpa.repository.sample.UserRepository;
 import org.springframework.data.repository.core.RepositoryMetadata;
-import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
 import org.springframework.data.repository.query.EvaluationContextProvider;
+import org.springframework.data.repository.query.ExtensionAwareEvaluationContextProvider;
 import org.springframework.data.repository.query.RepositoryQuery;
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 
@@ -60,14 +60,15 @@
 
 	static final String USER_QUERY = "select u from User u";
 	static final SpelExpressionParser PARSER = new SpelExpressionParser();
-	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
+	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = new ExtensionAwareEvaluationContextProvider();
 
 	JpaQueryMethod method;
 
 	@Mock EntityManager em;
 	@Mock EntityManagerFactory emf;
 	@Mock QueryExtractor extractor;
-	@Mock TypedQuery<Long> query;
+	@Mock javax.persistence.Query query;
+	@Mock TypedQuery<Long> typedQuery;
 	@Mock RepositoryMetadata metadata;
 	@Mock ParameterBinder binder;
 
@@ -78,7 +79,7 @@
 	public void setUp() throws SecurityException, NoSuchMethodException {
 
 		when(em.createQuery(anyString())).thenReturn(query);
-		when(em.createQuery(anyString(), eq(Long.class))).thenReturn(query);
+		when(em.createQuery(anyString(), eq(Long.class))).thenReturn(typedQuery);
 		when(em.getEntityManagerFactory()).thenReturn(emf);
 		when(emf.createEntityManager()).thenReturn(em);
 		when(metadata.getDomainType()).thenReturn((Class) User.class);
@@ -92,13 +93,13 @@ public void setUp() throws SecurityException, NoSuchMethodException {
 	public void prefersDeclaredCountQueryOverCreatingOne() throws Exception {
 
 		method = new JpaQueryMethod(SimpleJpaQueryUnitTests.class.getMethod("prefersDeclaredCountQueryOverCreatingOne"),
-				metadata, extractor); // mock(JpaQueryMethod.class);
-		when(em.createQuery("foo", Long.class)).thenReturn(query);
+				metadata, extractor);
+		when(em.createQuery("foo", Long.class)).thenReturn(typedQuery);
 
 		SimpleJpaQuery jpaQuery = new SimpleJpaQuery(method, em, "select u from User u", EVALUATION_CONTEXT_PROVIDER,
 				PARSER);
 
-		assertThat(jpaQuery.createCountQuery(new Object[] {}), is(query));
+		assertThat(jpaQuery.createCountQuery(new Object[] {}), is((javax.persistence.Query) typedQuery));
 	}
 
 	/**
@@ -112,8 +113,8 @@ public void doesNotApplyPaginationToCountQuery() throws Exception {
 		Method method = UserRepository.class.getMethod("findAllPaged", Pageable.class);
 		JpaQueryMethod queryMethod = new JpaQueryMethod(method, metadata, extractor);
 
-		AbstractJpaQuery jpaQuery = new SimpleJpaQuery(queryMethod, em, "select u from User u",
-				EVALUATION_CONTEXT_PROVIDER, PARSER);
+		AbstractJpaQuery jpaQuery = new SimpleJpaQuery(queryMethod, em, "select u from User u", EVALUATION_CONTEXT_PROVIDER,
+				PARSER);
 		jpaQuery.createCountQuery(new Object[] { new PageRequest(1, 10) });
 
 		verify(query, times(0)).setFirstResult(anyInt());
@@ -169,7 +170,7 @@ public void rejectsNativeQueryWithPageable() throws Exception {
 	public void doesNotValidateCountQueryIfNotPagingMethod() throws Exception {
 
 		Method method = SampleRepository.class.getMethod("findByAnnotatedQuery");
-		when(em.createQuery(contains("count"))).thenThrow(IllegalArgumentException.class);
+		when(em.createQuery(Mockito.contains("count"))).thenThrow(IllegalArgumentException.class);
 
 		createJpaQuery(method);
 	}
@@ -183,7 +184,7 @@ public void validatesAndRejectsCountQueryIfPagingMethod() throws Exception {
 
 		Method method = SampleRepository.class.getMethod("pageByAnnotatedQuery", Pageable.class);
 
-		when(em.createQuery(contains("count"))).thenThrow(IllegalArgumentException.class);
+		when(em.createQuery(Mockito.contains("count"))).thenThrow(IllegalArgumentException.class);
 		exception.expect(IllegalArgumentException.class);
 		exception.expectMessage("Count");
 		exception.expectMessage(method.getName());
@@ -205,7 +206,23 @@ public void createsANativeJpaQueryFromAnnotation() throws Exception {
 		assertThat(query instanceof NativeJpaQuery, is(true));
 	}
 
-	private RepositoryQuery createJpaQuery(Method method) {
+	/**
+	 * @see DATAJPA-757
+	 */
+	@Test
+	public void createsNativeCountQuery() throws Exception {
+
+		when(em.createNativeQuery(anyString())).thenReturn(query);
+
+		AbstractJpaQuery jpaQuery = createJpaQuery(
+				UserRepository.class.getMethod("findUsersInNativeQueryWithPagination", Pageable.class));
+
+		jpaQuery.doCreateCountQuery(new Object[] { new PageRequest(0, 10) });
+
+		verify(em, times(1)).createNativeQuery(anyString());
+	}
+
+	private AbstractJpaQuery createJpaQuery(Method method) {
 
 		JpaQueryMethod queryMethod = new JpaQueryMethod(method, metadata, extractor);
 		return JpaQueryFactory.INSTANCE.fromQueryAnnotation(queryMethod, em, EVALUATION_CONTEXT_PROVIDER);
diff --git a/src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java b/src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java
index 774b56a9e..3d968a27b 100644
--- a/src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java
+++ b/src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java
@@ -48,8 +48,8 @@
  * @author Oliver Gierke
  * @author Thomas Darimont
  */
-public interface UserRepository extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>,
-		UserRepositoryCustom {
+public interface UserRepository
+		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {
 
 	/**
 	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
@@ -224,7 +224,7 @@
 	/**
 	 * @see DATAJPA-117
 	 */
-	@Query(value = "SELECT * FROM User WHERE lastname = ?1", nativeQuery = true)
+	@Query(value = "SELECT * FROM SD_User WHERE lastname = ?1", nativeQuery = true)
 	List<User> findNativeByLastname(String lastname);
 
 	/**
@@ -268,7 +268,7 @@
 	 */
 	List<User> findByFirstnameContaining(String firstname);
 
-	@Query(value = "SELECT 1 FROM User", nativeQuery = true)
+	@Query(value = "SELECT 1 FROM SD_User", nativeQuery = true)
 	List<Integer> findOnesByNativeQuery();
 
 	/**
@@ -460,7 +460,7 @@
 	/**
 	 * @see DATAJPA-506
 	 */
-	@Query(value = "select u.binaryData from User u where u.id = ?1", nativeQuery = true)
+	@Query(value = "select u.binaryData from SD_User u where u.id = ?1", nativeQuery = true)
 	byte[] findBinaryDataByIdNative(Integer id);
 
 	/**
@@ -533,8 +533,8 @@
 	 * @see DATAJPA-564
 	 */
 	@Query(
-			value = "select * from (select rownum() as RN, u.* from User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}",
-			countQuery = "select count(u.id) from User u", nativeQuery = true)
+			value = "select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}",
+			countQuery = "select count(u.id) from SD_User u", nativeQuery = true)
 	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);
 
 	/**
diff --git a/src/test/java/org/springframework/data/jpa/repository/sample/UserRepositoryImpl.java b/src/test/java/org/springframework/data/jpa/repository/sample/UserRepositoryImpl.java
index b6812cceb..83c1133e1 100644
--- a/src/test/java/org/springframework/data/jpa/repository/sample/UserRepositoryImpl.java
+++ b/src/test/java/org/springframework/data/jpa/repository/sample/UserRepositoryImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +17,10 @@
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.data.jpa.domain.sample.User;
+import org.springframework.data.jpa.repository.JpaContext;
+import org.springframework.util.Assert;
 
 /**
  * Dummy implementation to allow check for invoking a custom implementation.
@@ -28,25 +31,24 @@
 
 	private static final Logger LOG = LoggerFactory.getLogger(UserRepositoryImpl.class);
 
+	@Autowired
+	public UserRepositoryImpl(JpaContext context) {
+		Assert.notNull(context, "JpaContext must not be null!");
+	}
+
 	/*
 	 * (non-Javadoc)
-	 * 
-	 * @see org.springframework.data.jpa.repository.sample.UserRepositoryCustom#
-	 * someCustomMethod(org.springframework.data.jpa.domain.sample.User)
+	 * @see org.springframework.data.jpa.repository.sample.UserRepositoryCustom#someCustomMethod(org.springframework.data.jpa.domain.sample.User)
 	 */
 	public void someCustomMethod(User u) {
-
 		LOG.debug("Some custom method was invoked!");
 	}
 
 	/*
 	 * (non-Javadoc)
-	 * 
-	 * @see org.springframework.data.jpa.repository.sample.UserRepositoryCustom#
-	 * findByOverrridingMethod()
+	 * @see org.springframework.data.jpa.repository.sample.UserRepositoryCustom#findByOverrridingMethod()
 	 */
 	public void findByOverrridingMethod() {
-
 		LOG.debug("A method overriding a finder was invoked!");
 	}
 }
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/DefaultJpaContextIntegrationTests.java b/src/test/java/org/springframework/data/jpa/repository/support/DefaultJpaContextIntegrationTests.java
new file mode 100644
index 000000000..c7966a75e
--- /dev/null
+++ b/src/test/java/org/springframework/data/jpa/repository/support/DefaultJpaContextIntegrationTests.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+import java.util.Arrays;
+import java.util.HashSet;
+
+import javax.persistence.EntityManager;
+import javax.persistence.EntityManagerFactory;
+
+import org.hibernate.ejb.HibernatePersistence;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.springframework.data.jpa.domain.sample.Category;
+import org.springframework.data.jpa.domain.sample.User;
+import org.springframework.data.jpa.repository.JpaContext;
+import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
+import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
+import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
+
+/**
+ * Integration tests for {@link DefaultJpaContext}.
+ * 
+ * @author Oliver Gierke
+ * @soundtrack Marcus Miller - Papa Was A Rolling Stone (Afrodeezia)
+ */
+public class DefaultJpaContextIntegrationTests {
+
+	public @Rule ExpectedException exception = ExpectedException.none();
+
+	static EntityManagerFactory firstEmf, secondEmf;
+
+	EntityManager firstEm, secondEm;
+	JpaContext jpaContext;
+
+	@BeforeClass
+	public static void bootstrapJpa() {
+
+		firstEmf = createEntityManagerFactory("spring-data-jpa");
+		secondEmf = createEntityManagerFactory("querydsl");
+	}
+
+	@Before
+	public void createEntityManagers() {
+
+		this.firstEm = firstEmf.createEntityManager();
+		this.secondEm = secondEmf.createEntityManager();
+
+		this.jpaContext = new DefaultJpaContext(new HashSet<EntityManager>(Arrays.asList(firstEm, secondEm)));
+	}
+
+	/**
+	 * @see DATAJPA-669
+	 */
+	@Test
+	public void rejectsUnmanagedType() {
+
+		exception.expect(IllegalArgumentException.class);
+		exception.expectMessage(Object.class.getSimpleName());
+
+		jpaContext.getEntityManagerByManagedType(Object.class);
+	}
+
+	/**
+	 * @see DATAJPA-669
+	 */
+	@Test
+	public void returnsEntitymanagerForUniqueType() {
+		assertThat(jpaContext.getEntityManagerByManagedType(Category.class), is(firstEm));
+	}
+
+	/**
+	 * @see DATAJPA-669
+	 */
+	@Test
+	public void rejectsRequestForTypeManagedByMultipleEntityManagers() {
+
+		exception.expect(IllegalArgumentException.class);
+		exception.expectMessage(User.class.getSimpleName());
+
+		jpaContext.getEntityManagerByManagedType(User.class);
+	}
+
+	private static final EntityManagerFactory createEntityManagerFactory(String persistenceUnitName) {
+
+		LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
+		factoryBean.setPersistenceProvider(new HibernatePersistence());
+		factoryBean.setDataSource(new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL).build());
+		factoryBean.setPersistenceUnitName(persistenceUnitName);
+		factoryBean.afterPropertiesSet();
+
+		return factoryBean.getObject();
+	}
+}
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/DefaultJpaContextUnitTests.java b/src/test/java/org/springframework/data/jpa/repository/support/DefaultJpaContextUnitTests.java
new file mode 100644
index 000000000..ebfb19c7d
--- /dev/null
+++ b/src/test/java/org/springframework/data/jpa/repository/support/DefaultJpaContextUnitTests.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import java.util.Collections;
+
+import javax.persistence.EntityManager;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link DefaultJpaContext}.
+ * 
+ * @author Oliver Gierke
+ * @soundtrack Marcus Miller - B's River (Afrodeezia)
+ * @since 1.9
+ */
+public class DefaultJpaContextUnitTests {
+
+	/**
+	 * @see DATAJPA-669
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public void rejectsNullEntityManagers() {
+		new DefaultJpaContext(null);
+	}
+
+	/**
+	 * @see DATAJPA-669
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public void rejectsEmptyEntityManagers() {
+		new DefaultJpaContext(Collections.<EntityManager> emptySet());
+	}
+}
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/EclipseLinkSoftDeleteIntegrationTests.java b/src/test/java/org/springframework/data/jpa/repository/support/EclipseLinkSoftDeleteIntegrationTests.java
new file mode 100644
index 000000000..5e291e139
--- /dev/null
+++ b/src/test/java/org/springframework/data/jpa/repository/support/EclipseLinkSoftDeleteIntegrationTests.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import org.springframework.test.context.ContextConfiguration;
+
+/**
+ * @author Oliver Gierke
+ */
+@ContextConfiguration("classpath:eclipselink.xml")
+public class EclipseLinkSoftDeleteIntegrationTests extends SoftDeleteIntegrationTests {
+
+}
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryUnitTests.java b/src/test/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryUnitTests.java
index 444658cdb..6fc121c83 100644
--- a/src/test/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryUnitTests.java
+++ b/src/test/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryUnitTests.java
@@ -210,7 +210,7 @@ public void throwingCheckedException() throws IOException {
 
 	static class CustomJpaRepository<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> {
 
-		public CustomJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {
+		public CustomJpaRepository(JpaEntityInformation<T, ID> entityInformation, EntityManager entityManager) {
 			super(entityInformation, entityManager);
 		}
 	};
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/OpenJpaSoftDeleteIntegrationTests.java b/src/test/java/org/springframework/data/jpa/repository/support/OpenJpaSoftDeleteIntegrationTests.java
new file mode 100644
index 000000000..ff91a0f65
--- /dev/null
+++ b/src/test/java/org/springframework/data/jpa/repository/support/OpenJpaSoftDeleteIntegrationTests.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import org.junit.Ignore;
+import org.springframework.test.context.ContextConfiguration;
+
+/**
+ * @author Oliver Gierke
+ */
+@ContextConfiguration("classpath:openjpa.xml")
+public class OpenJpaSoftDeleteIntegrationTests extends SoftDeleteIntegrationTests {
+
+	@Override
+	@Ignore
+	public void basicSaveAndDelete() {
+
+	}
+}
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/SimpleJpaRepositoryUnitTests.java b/src/test/java/org/springframework/data/jpa/repository/support/SimpleJpaRepositoryUnitTests.java
index 2536fb363..ccf7eaad6 100644
--- a/src/test/java/org/springframework/data/jpa/repository/support/SimpleJpaRepositoryUnitTests.java
+++ b/src/test/java/org/springframework/data/jpa/repository/support/SimpleJpaRepositoryUnitTests.java
@@ -15,10 +15,8 @@
  */
 package org.springframework.data.jpa.repository.support;
 
-import static java.util.Collections.singletonMap;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import static java.util.Collections.*;
+import static org.mockito.Mockito.*;
 
 import java.io.Serializable;
 
@@ -48,7 +46,7 @@
 @RunWith(MockitoJUnitRunner.class)
 public class SimpleJpaRepositoryUnitTests {
 
-	SimpleJpaRepository<User, Integer> repo;
+	SimpleJpaRepository<User, Long> repo;
 
 	@Mock EntityManager em;
 	@Mock CriteriaBuilder builder;
@@ -75,7 +73,7 @@ public void setUp() {
 		when(em.createQuery(criteriaQuery)).thenReturn(query);
 		when(em.createQuery(countCriteriaQuery)).thenReturn(countQuery);
 
-		repo = new SimpleJpaRepository<User, Integer>(information, em);
+		repo = new SimpleJpaRepository<User, Long>(information, em);
 		repo.setRepositoryMethodMetadata(metadata);
 	}
 
@@ -97,7 +95,7 @@ public void doesNotActuallyRetrieveObjectsForPageableOutOfRange() {
 	@Test(expected = EmptyResultDataAccessException.class)
 	public void throwsExceptionIfEntityToDeleteDoesNotExist() {
 
-		repo.delete(4711);
+		repo.delete(4711L);
 	}
 
 	/**
@@ -106,7 +104,7 @@ public void throwsExceptionIfEntityToDeleteDoesNotExist() {
 	 */
 	@Test
 	@SuppressWarnings({ "rawtypes", "unchecked" })
-	public void shouldPropagateConfiguredEntityGraphToFindOne() throws Exception{
+	public void shouldPropagateConfiguredEntityGraphToFindOne() throws Exception {
 
 		String entityGraphName = "User.detail";
 		when(entityGraphAnnotation.value()).thenReturn(entityGraphName);
@@ -115,8 +113,8 @@ public void shouldPropagateConfiguredEntityGraphToFindOne() throws Exception{
 		when(em.getEntityGraph(entityGraphName)).thenReturn((EntityGraph) entityGraph);
 		when(information.getEntityName()).thenReturn("User");
 		when(metadata.getMethod()).thenReturn(CrudRepository.class.getMethod("findOne", Serializable.class));
-		
-		Integer id = 0;
+
+		Long id = 0L;
 		repo.findOne(id);
 
 		verify(em).find(User.class, id, singletonMap(EntityGraphType.LOAD.getKey(), (Object) entityGraph));
diff --git a/src/test/java/org/springframework/data/jpa/repository/support/SoftDeleteIntegrationTests.java b/src/test/java/org/springframework/data/jpa/repository/support/SoftDeleteIntegrationTests.java
new file mode 100644
index 000000000..08b1ad072
--- /dev/null
+++ b/src/test/java/org/springframework/data/jpa/repository/support/SoftDeleteIntegrationTests.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.jpa.repository.support;
+
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.persistence.EntityManager;
+import javax.persistence.PersistenceContext;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.data.jpa.domain.sample.QUser;
+import org.springframework.data.jpa.domain.sample.User;
+import org.springframework.data.jpa.repository.augment.JpaSoftDeleteQueryAugmentor;
+import org.springframework.data.jpa.repository.augment.QueryDslSoftDeleteQueryAugmentor;
+import org.springframework.data.querydsl.QueryDslPredicateExecutor;
+import org.springframework.data.repository.CrudRepository;
+import org.springframework.data.repository.SoftDelete;
+import org.springframework.data.repository.SoftDelete.FlagMode;
+import org.springframework.data.repository.augment.QueryAugmentor;
+import org.springframework.data.repository.augment.QueryContext;
+import org.springframework.data.repository.augment.UpdateContext;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.transaction.annotation.Transactional;
+
+import com.mysema.query.types.Predicate;
+
+/**
+ * @author Oliver Gierke
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextConfiguration("classpath:infrastructure.xml")
+@Transactional
+public class SoftDeleteIntegrationTests {
+
+	@PersistenceContext EntityManager em;
+
+	SoftUserRepository softRepository;
+	SpecialUserRepository repository;
+
+	@Before
+	public void setUp() {
+
+		JpaRepositoryFactory factory = new JpaRepositoryFactory(em);
+		JpaSoftDeleteQueryAugmentor jpaAugmentor = new JpaSoftDeleteQueryAugmentor();
+		QueryDslSoftDeleteQueryAugmentor queryDslAugmentor = new QueryDslSoftDeleteQueryAugmentor();
+
+		List<QueryAugmentor<? extends QueryContext<?>, ? extends QueryContext<?>, ? extends UpdateContext<?>>> augmentors = //
+		new ArrayList<QueryAugmentor<? extends QueryContext<?>, ? extends QueryContext<?>, ? extends UpdateContext<?>>>();
+		augmentors.add(jpaAugmentor);
+		augmentors.add(queryDslAugmentor);
+
+		factory.setQueryAugmentors(augmentors);
+
+		softRepository = factory.getRepository(SoftUserRepository.class);
+		repository = factory.getRepository(SpecialUserRepository.class);
+	}
+
+	@Test
+	public void basicSaveAndDelete() {
+
+		User user = new User("Foo", "Bar", "foo@bar.de");
+		user = softRepository.save(user);
+
+		assertThat(repository.findAll(), hasItem(user));
+		assertThat(softRepository.findAll(), hasItem(user));
+
+		softRepository.delete(user);
+
+		assertThat(softRepository.findAll(), is(emptyIterable()));
+		assertThat(softRepository.count(), is(0L));
+		assertThat(softRepository.findOne(user.getId()), is(nullValue()));
+
+		assertThat(repository.count(), is(1L));
+		assertThat(repository.findAll(), hasItem(user));
+		assertThat(repository.findOne(user.getId()), is(notNullValue()));
+
+		Predicate predicate = QUser.user.firstname.eq("Foo");
+		assertThat(softRepository.findAll(predicate), is(emptyIterable()));
+		assertThat(softRepository.count(predicate), is(0L));
+		assertThat(softRepository.findOne(predicate), is(nullValue()));
+
+		assertThat(repository.count(predicate), is(1L));
+		assertThat(repository.findAll(predicate), hasItem(user));
+		assertThat(repository.findOne(predicate), is(notNullValue()));
+	}
+
+	@Test
+	public void basicSaveAndDeleteWithQueryDslPredicate() {
+
+		User user = new User("Tony", "Stark", "tony@stark.com");
+		user = softRepository.save(user);
+
+		assertThat(repository.findAll(), hasItem(user));
+		assertThat(softRepository.findAll(), hasItem(user));
+
+		softRepository.delete(user);
+
+		Predicate predicate = QUser.user.firstname.eq("Tony");
+		assertThat(softRepository.findAll(predicate), is(emptyIterable()));
+		assertThat(softRepository.count(predicate), is(0L));
+		assertThat(softRepository.findOne(predicate), is(nullValue()));
+
+		assertThat(repository.count(predicate), is(1L));
+		assertThat(repository.findAll(predicate), hasItem(user));
+		assertThat(repository.findOne(predicate), is(notNullValue()));
+	}
+
+	@SoftDelete(value = "active", flagMode = FlagMode.ACTIVE)
+	interface SoftUserRepository extends CrudRepository<User, Integer>, QueryDslPredicateExecutor<User> {
+
+		List<User> findByLastname();
+	}
+
+	interface SpecialUserRepository extends CrudRepository<User, Integer>, QueryDslPredicateExecutor<User> {
+
+		List<User> findAll();
+	}
+}
diff --git a/src/test/resources/application-context.xml b/src/test/resources/application-context.xml
index deee551f9..55c14fb44 100644
--- a/src/test/resources/application-context.xml
+++ b/src/test/resources/application-context.xml
@@ -12,7 +12,11 @@
 	<bean id="userDao" class="org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean">
 		<property name="repositoryInterface" value="org.springframework.data.jpa.repository.sample.UserRepository" />
 		<property name="customImplementation">
-			<bean class="org.springframework.data.jpa.repository.sample.UserRepositoryImpl" />
+			<bean class="org.springframework.data.jpa.repository.sample.UserRepositoryImpl">
+				<constructor-arg>
+					<bean class="org.springframework.data.jpa.repository.support.DefaultJpaContext" autowire="constructor" />
+				</constructor-arg>
+			</bean>
 		</property>
 		<property name="namedQueries">
 			<bean class="org.springframework.data.repository.core.support.PropertiesBasedNamedQueries">
@@ -40,5 +44,7 @@
 	<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />
 	
 	<bean id="expressionEvaluationContextProvider" class="org.springframework.data.repository.query.ExtensionAwareEvaluationContextProvider" />
+	
+	<bean class="org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor" />
 
 </beans>
diff --git a/src/test/resources/openjpa.xml b/src/test/resources/openjpa.xml
index 4ceca067d..c46992ec0 100644
--- a/src/test/resources/openjpa.xml
+++ b/src/test/resources/openjpa.xml
@@ -10,7 +10,7 @@
 		usage -->
 	<bean id="vendorAdaptor" class="org.springframework.orm.jpa.vendor.OpenJpaVendorAdapter"
 		parent="abstractVendorAdaptor">
-		<property name="database" value="HSQL" />
+		<property name="database" value="H2" />
 	</bean>
 
 	<util:properties id="jpaProperties">
@@ -21,5 +21,6 @@
 		make OpenJPA tests work. Open JPA doesn't work with hsqldb 2.x and runs with 
 		1.x instead which doesn't support stored procedures which leads to errors 
 		at runtime when the scripts/schema-stored-procedure.sql is executed, therefore we omit the script here. -->
-	<jdbc:embedded-database id="dataSource" type="HSQL" />
+	<jdbc:embedded-database id="dataSource" type="H2" />
+
 </beans>
