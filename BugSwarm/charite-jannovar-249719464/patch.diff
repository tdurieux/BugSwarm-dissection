diff --git a/CHANGELOG.md b/CHANGELOG.md
index 477805ce75..718857f57d 100755
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,13 +2,39 @@
 
 ## develop (unreleased)
 
+### overall
+
+* Changing Guava version to 0.22
+* Changing slf4j version to 1.7.24
+* Changing log4j version to 2.8.2
+
 ### jannovar-cli
 
+* Adding experimental support for annotating with VCF files.
+* Adding experimental support for annotating with tabix-indexed TSV files and dbNSFP.
 * Integrating the advanced pedigree-based filters (useful for filtration to de novo variants).
+* Making it possible to override database INI settings using user-specified INI files.
+
+### jannovar-core
+
+* Fixing stop loss annotation (#351).
+* Finishing renaming of TranscriptInfo to TranscriptModel (#348).
+* Upstream and downstream variant were considered "not off exome". They now are.
 
 ### jannovar-filter
 
 * Adding code for performing more advanced filtration/annotation filtering to de novo variants.
+* Improving documentation of `MaxFreqAr` and `MaxFreqAd` in header.
+
+
+### jannovar-vardbs
+
+* Adding experimental support for annotating with VCF files
+* Adding experimental support for annotating with tabix-indexed TSV files and dbNSFP
+
+### jannovar-filter
+
+* Fixing bug that ignored variant filters for recessive annotation
 
 ## v0.22
 
diff --git a/jannovar-cli/pom.xml b/jannovar-cli/pom.xml
index 7337cf2bc9..3ff459359b 100755
--- a/jannovar-cli/pom.xml
+++ b/jannovar-cli/pom.xml
@@ -23,7 +23,7 @@
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>slf4j-simple</artifactId>
-			<version>1.7.12</version>
+            <version>${slf4j.version}</version>
 		</dependency>
 
 		<!-- argparse4j used for parsing the command line -->
@@ -47,7 +47,7 @@
 		<dependency>
 			<groupId>com.google.guava</groupId>
 			<artifactId>guava</artifactId>
-			<version>19.0</version>
+			<version>${guava.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>org.ini4j</groupId>
diff --git a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/AnnotateVCFCommand.java b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/AnnotateVCFCommand.java
index 015db13fb8..f2b604725f 100755
--- a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/AnnotateVCFCommand.java
+++ b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/AnnotateVCFCommand.java
@@ -10,9 +10,10 @@
 import de.charite.compbio.jannovar.filter.facade.PedigreeFilterAnnotator;
 import de.charite.compbio.jannovar.filter.facade.PedigreeFilterHeaderExtender;
 import de.charite.compbio.jannovar.filter.facade.PedigreeFilterOptions;
-import de.charite.compbio.jannovar.filter.facade.ThresholdFilterAnnotator;
+import de.charite.compbio.jannovar.filter.facade.GenotypeThresholdFilterAnnotator;
 import de.charite.compbio.jannovar.filter.facade.ThresholdFilterHeaderExtender;
 import de.charite.compbio.jannovar.filter.facade.ThresholdFilterOptions;
+import de.charite.compbio.jannovar.filter.impl.var.VariantThresholdFilterAnnotator;
 import de.charite.compbio.jannovar.htsjdk.VariantContextAnnotator;
 import de.charite.compbio.jannovar.htsjdk.VariantContextWriterConstructionHelper;
 import de.charite.compbio.jannovar.htsjdk.VariantEffectHeaderExtender;
@@ -34,8 +35,15 @@
 import de.charite.compbio.jannovar.progress.GenomeRegionListFactoryFromSAMSequenceDictionary;
 import de.charite.compbio.jannovar.progress.ProgressReporter;
 import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions;
+import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions.MultipleMatchBehaviour;
 import de.charite.compbio.jannovar.vardbs.facade.DBVariantContextAnnotator;
 import de.charite.compbio.jannovar.vardbs.facade.DBVariantContextAnnotatorFactory;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationDriver;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationOptions;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationTarget;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVValueColumnDescription;
+import de.charite.compbio.jannovar.vardbs.generic_vcf.GenericVCFAnnotationDriver;
+import de.charite.compbio.jannovar.vardbs.generic_vcf.GenericVCFAnnotationOptions;
 import htsjdk.samtools.SAMSequenceDictionary;
 import htsjdk.samtools.util.CloseableIterator;
 import htsjdk.samtools.util.Interval;
@@ -48,7 +56,9 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import net.sourceforge.argparse4j.inf.Namespace;
@@ -94,22 +104,19 @@ public void run() throws JannovarException {
 		final String vcfPath = options.getPathInputVCF();
 
 		// whether or not to require availability of an index
-		final boolean useInterval = (options.getInterval() != null
-				&& !options.getInterval().equals(""));
+		final boolean useInterval = (options.getInterval() != null && !options.getInterval().equals(""));
 
 		try (VCFFileReader vcfReader = new VCFFileReader(new File(vcfPath), useInterval)) {
 			if (this.options.getVerbosity() >= 1) {
-				final SAMSequenceDictionary seqDict = VCFFileReader
-						.getSequenceDictionary(new File(vcfPath));
+				final SAMSequenceDictionary seqDict = VCFFileReader.getSequenceDictionary(new File(vcfPath));
 				if (seqDict != null) {
 					final GenomeRegionListFactoryFromSAMSequenceDictionary factory = new GenomeRegionListFactoryFromSAMSequenceDictionary();
 					this.progressReporter = new ProgressReporter(factory.construct(seqDict), 60);
 					this.progressReporter.printHeader();
 					this.progressReporter.start();
 				} else {
-					System.err.println(
-							"Progress reporting does not work because VCF file is missing the contig "
-									+ "lines in the header.");
+					System.err.println("Progress reporting does not work because VCF file is missing the contig "
+							+ "lines in the header.");
 				}
 			}
 
@@ -168,8 +175,7 @@ public void run() throws JannovarException {
 				DBAnnotationOptions gnomadOptions = DBAnnotationOptions.createDefaults();
 				gnomadOptions.setIdentifierPrefix(options.prefixGnomadExomes);
 				DBVariantContextAnnotator gnomadExomesAnno = new DBVariantContextAnnotatorFactory()
-						.constructGnomad(options.pathVCFGnomadExomes, options.pathFASTARef,
-								gnomadOptions);
+						.constructGnomad(options.pathVCFGnomadExomes, options.pathFASTARef, gnomadOptions);
 				gnomadExomesAnno.extendHeader(vcfHeader);
 				stream = stream.map(gnomadExomesAnno::annotateVariantContext);
 			}
@@ -181,8 +187,7 @@ public void run() throws JannovarException {
 				DBAnnotationOptions gnomadOptions = DBAnnotationOptions.createDefaults();
 				gnomadOptions.setIdentifierPrefix(options.prefixGnomadGenomes);
 				DBVariantContextAnnotator gnomadGenomesAnno = new DBVariantContextAnnotatorFactory()
-						.constructGnomad(options.pathVCFGnomadGenomes, options.pathFASTARef,
-								gnomadOptions);
+						.constructGnomad(options.pathVCFGnomadGenomes, options.pathFASTARef, gnomadOptions);
 				gnomadGenomesAnno.extendHeader(vcfHeader);
 				stream = stream.map(gnomadGenomesAnno::annotateVariantContext);
 			}
@@ -204,8 +209,7 @@ public void run() throws JannovarException {
 				DBAnnotationOptions clinVarOptions = DBAnnotationOptions.createDefaults();
 				clinVarOptions.setIdentifierPrefix(options.prefixClinVar);
 				DBVariantContextAnnotator clinvarAnno = new DBVariantContextAnnotatorFactory()
-						.constructClinVar(options.pathClinVar, options.pathFASTARef,
-								clinVarOptions);
+						.constructClinVar(options.pathClinVar, options.pathFASTARef, clinVarOptions);
 				clinvarAnno.extendHeader(vcfHeader);
 				stream = stream.map(clinvarAnno::annotateVariantContext);
 			}
@@ -221,26 +225,36 @@ public void run() throws JannovarException {
 				stream = stream.map(cosmicAnno::annotateVariantContext);
 			}
 
+			// Add step for annotating with variant effect
+			VariantEffectHeaderExtender extender = new VariantEffectHeaderExtender();
+			extender.addHeaders(vcfHeader);
+			VariantContextAnnotator variantEffectAnnotator =
+					new VariantContextAnnotator(refDict, chromosomeMap,
+							new VariantContextAnnotator.Options(!options.isShowAll(),
+									options.isEscapeAnnField(), options.isNt3PrimeShifting(),
+									options.isOffTargetFilterEnabled(),
+									options.isOffTargetFilterUtrIsOffTarget(),
+									options.isOffTargetFilterIntronicSpliceIsOffTarget()));
+			stream = stream.map(variantEffectAnnotator::annotateVariantContext);
+
 			// If configured, use threshold-based annotation (extend header to
 			// use for writing out)
+			ArrayList<String> affecteds = new ArrayList<>();
 			if (options.useThresholdFilters) {
 				// Build options object for threshold filter
 				ThresholdFilterOptions thresholdFilterOptions = new ThresholdFilterOptions(
 						options.getThreshFiltMinGtCovHet(), options.getThreshFiltMinGtCovHomAlt(),
 						options.getThreshFiltMaxCov(), options.getThreshFiltMinGtGq(),
 						options.getThreshFiltMinGtAafHet(), options.getThreshFiltMaxGtAafHet(),
-						options.getThreshFiltMinGtAafHomAlt(),
-						options.getThreshFiltMaxGtAafHomRef(), options.getPrefixExac(),
-						options.getPrefixDBSNP(), options.getPrefixGnomadGenomes(),
-						options.getPrefixGnomadExomes(),
-						options.getThreshFiltMaxAlleleFrequencyAd(),
+						options.getThreshFiltMinGtAafHomAlt(), options.getThreshFiltMaxGtAafHomRef(),
+						options.getPrefixExac(), options.getPrefixDBSNP(), options.getPrefixGnomadGenomes(),
+						options.getPrefixGnomadExomes(), options.getThreshFiltMaxAlleleFrequencyAd(),
 						options.getThreshFiltMaxAlleleFrequencyAr());
 				// Add headers
 				new ThresholdFilterHeaderExtender(thresholdFilterOptions).addHeaders(vcfHeader);
 				// Build list of affecteds; take from pedigree file if given.
 				// Otherwise, assume one single individual is always affected and otherwise warn
 				// about missing pedigree.
-				ArrayList<String> affecteds = new ArrayList<>();
 				if (options.pathPedFile == null) {
 					if (vcfHeader.getNGenotypeSamples() == 1) {
 						System.err.println(
@@ -270,16 +284,16 @@ public void run() throws JannovarException {
 										+ "only genotype FT");
 					}
 				}
-				ThresholdFilterAnnotator thresholdFilterAnno = new ThresholdFilterAnnotator(
-						thresholdFilterOptions, affecteds);
-				stream = stream.map(thresholdFilterAnno::annotateVariantContext);
+				GenotypeThresholdFilterAnnotator gtThresholdFilterAnno =
+						new GenotypeThresholdFilterAnnotator(thresholdFilterOptions);
+				stream = stream.map(gtThresholdFilterAnno::annotateVariantContext);
 
 				// When configured to use advanced pedigree filters (must come
 				// after threshold-based filtration)
 				if (options.useAdvancedPedigreeFilters) {
 					// Build options object from configuration and extend headers
 					PedigreeFilterOptions pedFilterOptions = new PedigreeFilterOptions(
-							options.getThreshDeNovoParentAd2());
+							options.getThreshDeNovoParentAd2(), options.isUseParentGtIsFiltered());
 					new PedigreeFilterHeaderExtender(pedFilterOptions).addHeaders(vcfHeader);
 
 					// Load pedigree
@@ -295,31 +309,63 @@ public void run() throws JannovarException {
 					}
 
 					// Construct annotator and register with pipeline
-					PedigreeFilterAnnotator pedFilterAnnotator = new PedigreeFilterAnnotator(
-							pedFilterOptions, pedigree);
+					PedigreeFilterAnnotator pedFilterAnnotator = new PedigreeFilterAnnotator(pedFilterOptions,
+							pedigree);
 					stream = stream.map(pedFilterAnnotator::annotateVariantContext);
 				}
-				
-				// Annotate from BED files
-				List<BedFileAnnotator> annotators = new ArrayList<>();
-				for (BedAnnotationOptions bedAnnotationOptions : options.getBedAnnotationOptions()) {
-					BedFileAnnotator annotator = new BedFileAnnotator(bedAnnotationOptions);
-					annotators.add(annotator);
-					annotator.extendHeader(vcfHeader);
-					stream = stream.map(annotator::annotateVariantContext);
+
+				if (options.useThresholdFilters) {
+					VariantThresholdFilterAnnotator varThresholdFilterAnno =
+							new VariantThresholdFilterAnnotator(thresholdFilterOptions, affecteds);
+					stream = stream.map(varThresholdFilterAnno::annotateVariantContext);
 				}
 			}
 
-			// Add step for annotating with variant effect
-			VariantEffectHeaderExtender extender = new VariantEffectHeaderExtender();
-			extender.addHeaders(vcfHeader);
-			VariantContextAnnotator annotator = new VariantContextAnnotator(refDict, chromosomeMap,
-					new VariantContextAnnotator.Options(!options.isShowAll(),
-							options.isEscapeAnnField(), options.isNt3PrimeShifting(),
-							options.isOffTargetFilterEnabled(),
-							options.isOffTargetFilterUtrIsOffTarget(),
-							options.isOffTargetFilterIntronicSpliceIsOffTarget()));
-			stream = stream.map(annotator::annotateVariantContext);
+			// Annotate from BED files
+			List<BedFileAnnotator> bedFileAnnotators = new ArrayList<>();
+			for (BedAnnotationOptions bedAnnotationOptions : options.getBedAnnotationOptions()) {
+				BedFileAnnotator annotator = new BedFileAnnotator(bedAnnotationOptions);
+				bedFileAnnotators.add(annotator);
+				annotator.extendHeader(vcfHeader);
+				stream = stream.map(annotator::annotateVariantContext);
+			}
+
+			// Annotate using dbNSFP
+			GenericTSVAnnotationDriver dbNsfpAnnotator;
+			if (options.getPathDbNsfp() != null) {
+				Map<String, GenericTSVValueColumnDescription> descriptions = new HashMap<>();
+				for (String colName : options.getColumnsDbNsfp()) {
+					descriptions.put(colName, DbNsfpFields.DBNSFP_FIELDS.get(colName));
+				}
+				GenericTSVAnnotationOptions dbNsfpAnnotationOptions = new GenericTSVAnnotationOptions(true, false,
+						options.getPrefixDbNsfp(), MultipleMatchBehaviour.BEST_ONLY, new File(options.getPathDbNsfp()),
+						GenericTSVAnnotationTarget.VARIANT, true, options.getDbNsfpColContig(),
+						options.getDbNsfpColPosition(), options.getDbNsfpColPosition(), 3, 4, false, 
+						options.getColumnsDbNsfp(), descriptions);
+				dbNsfpAnnotator = new GenericTSVAnnotationDriver(options.getPathFASTARef(), dbNsfpAnnotationOptions);
+				dbNsfpAnnotator.constructVCFHeaderExtender().addHeaders(vcfHeader);
+				stream = stream.map(dbNsfpAnnotator::annotateVariantContext);
+			}
+
+			// Annotate from generic TSV files
+			List<GenericTSVAnnotationDriver> tsvAnnotators = new ArrayList<>();
+			for (GenericTSVAnnotationOptions tsvAnnotationOptions : options.getTsvAnnotationOptions()) {
+				GenericTSVAnnotationDriver annotator = new GenericTSVAnnotationDriver(options.getPathFASTARef(),
+						tsvAnnotationOptions);
+				tsvAnnotators.add(annotator);
+				annotator.constructVCFHeaderExtender().addHeaders(vcfHeader);
+				stream = stream.map(annotator::annotateVariantContext);
+			}
+
+			// Annotate from generic VCF files
+			List<GenericVCFAnnotationDriver> vcfAnnotators = new ArrayList<>();
+			for (GenericVCFAnnotationOptions vcfAnnotationOptions : options.getVcfAnnotationOptions()) {
+				GenericVCFAnnotationDriver annotator = new GenericVCFAnnotationDriver(
+						vcfAnnotationOptions.getPathVcfFile(), options.getPathFASTARef(), vcfAnnotationOptions);
+				vcfAnnotators.add(annotator);
+				annotator.constructVCFHeaderExtender().addHeaders(vcfHeader);
+				stream = stream.map(annotator::annotateVariantContext);
+			}
 
 			// Extend header with INHERITANCE filter
 			if (options.pathPedFile != null || options.annotateAsSingletonPedigree) {
@@ -351,8 +397,8 @@ public void run() throws JannovarException {
 					(endTime - startTime) / 1000.0 / 1000.0 / 1000.0));
 		} catch (IncompatiblePedigreeException e) {
 			if (options.pathPedFile != null)
-				System.err.println("VCF file " + vcfPath + " is not compatible to pedigree file "
-						+ options.pathPedFile);
+				System.err
+						.println("VCF file " + vcfPath + " is not compatible to pedigree file " + options.pathPedFile);
 			else
 				System.err.println("VCF file " + vcfPath
 						+ " is not compatible with singleton pedigree annotation (do you have exactly one sample in VCF file?)");
@@ -376,11 +422,9 @@ public void run() throws JannovarException {
 	/**
 	 * Load pedigree from file given in configuration or construct singleton pedigree
 	 * 
-	 * @param vcfHeader
-	 *            {@link VCFHeader}, for checking compatibility and getting sample name in case of
-	 *            singleton pedigree construction
-	 * @throws PedParseException
-	 *             in the case of problems with parsing pedigrees
+	 * @param vcfHeader {@link VCFHeader}, for checking compatibility and getting sample name in
+	 *        case of singleton pedigree construction
+	 * @throws PedParseException in the case of problems with parsing pedigrees
 	 */
 	private Pedigree loadPedigree(VCFHeader vcfHeader)
 			throws PedParseException, IOException, IncompatiblePedigreeException {
@@ -393,10 +437,10 @@ private Pedigree loadPedigree(VCFHeader vcfHeader)
 				throw new IncompatiblePedigreeException(
 						"VCF file does not have exactly one sample but required for singleton pedigree construction");
 			final String sampleName = vcfHeader.getSampleNamesInOrder().get(0);
-			final PedPerson pedPerson = new PedPerson(sampleName, sampleName, "0", "0", Sex.UNKNOWN,
-					Disease.AFFECTED);
-			final PedFileContents pedContents = new PedFileContents(ImmutableList.of(),
-					ImmutableList.of(pedPerson));
+			final PedPerson pedPerson =
+					new PedPerson(sampleName, sampleName, "0", "0", Sex.UNKNOWN, Disease.AFFECTED);
+			final PedFileContents pedContents =
+					new PedFileContents(ImmutableList.of(), ImmutableList.of(pedPerson));
 			return new Pedigree(pedContents, pedContents.getIndividuals().get(0).getPedigree());
 		}
 	}
@@ -404,17 +448,12 @@ private Pedigree loadPedigree(VCFHeader vcfHeader)
 	/**
 	 * Construct the mendelian inheritance annotation processors
 	 * 
-	 * @param writer
-	 *            the place to put put the VariantContext to after filtration
-	 * @param vcfHeader
-	 *            {@link VCFHeader}, for checking compatibility and getting sample name in case of
-	 *            singleton pedigree construction
-	 * @throws IOException
-	 *             in case of problems with opening the pedigree file
-	 * @throws PedParseException
-	 *             in the case of problems with parsing pedigrees
-	 * @throws IncompatiblePedigreeException
-	 *             If the pedigree is incompatible with the VCF file
+	 * @param writer the place to put put the VariantContext to after filtration
+	 * @param vcfHeader {@link VCFHeader}, for checking compatibility and getting sample name in
+	 *        case of singleton pedigree construction
+	 * @throws IOException in case of problems with opening the pedigree file
+	 * @throws PedParseException in the case of problems with parsing pedigrees
+	 * @throws IncompatiblePedigreeException If the pedigree is incompatible with the VCF file
 	 */
 	private VariantContextProcessor buildMendelianProcessors(VariantContextWriter writer,
 			VCFHeader vcfHeader)
@@ -422,9 +461,9 @@ private VariantContextProcessor buildMendelianProcessors(VariantContextWriter wr
 		if (options.pathPedFile != null || options.annotateAsSingletonPedigree) {
 			final Pedigree pedigree = loadPedigree(vcfHeader);
 			checkPedigreeCompatibility(pedigree, vcfHeader);
-			final GeneWiseMendelianAnnotationProcessor mendelProcessor = new GeneWiseMendelianAnnotationProcessor(
-					pedigree, jannovarData, vc -> writer.add(vc),
-					options.isInheritanceAnnoUseFilters());
+			final GeneWiseMendelianAnnotationProcessor mendelProcessor =
+					new GeneWiseMendelianAnnotationProcessor(pedigree, jannovarData,
+							vc -> writer.add(vc), options.isInheritanceAnnoUseFilters());
 			return new CoordinateSortingChecker(mendelProcessor);
 		} else {
 			return new ConsumerProcessor(vc -> writer.add(vc));
@@ -434,21 +473,17 @@ private VariantContextProcessor buildMendelianProcessors(VariantContextWriter wr
 	/**
 	 * Check pedigree for compatibility
 	 * 
-	 * @param pedigree
-	 *            {@link Pedigree} to check for compatibility
-	 * @param vcfHeader
-	 *            {@link VCFHeader} to check for compatibility
-	 * @throws IncompatiblePedigreeException
-	 *             if the VCF file is not compatible with the pedigree
+	 * @param pedigree {@link Pedigree} to check for compatibility
+	 * @param vcfHeader {@link VCFHeader} to check for compatibility
+	 * @throws IncompatiblePedigreeException if the VCF file is not compatible with the pedigree
 	 */
 	private void checkPedigreeCompatibility(Pedigree pedigree, VCFHeader vcfHeader)
 			throws IncompatiblePedigreeException {
 		List<String> missing = vcfHeader.getGenotypeSamples().stream()
 				.filter(x -> !pedigree.getNames().contains(x)).collect(Collectors.toList());
-		if (!missing.isEmpty())
-			throw new IncompatiblePedigreeException(
-					"The VCF file has the following sample names not present in Pedigree: "
-							+ Joiner.on(", ").join(missing));
+		if (!missing.isEmpty()) throw new IncompatiblePedigreeException(
+				"The VCF file has the following sample names not present in Pedigree: "
+						+ Joiner.on(", ").join(missing));
 	}
 
 }
diff --git a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/DbNsfpFields.java b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/DbNsfpFields.java
new file mode 100755
index 0000000000..98680491ba
--- /dev/null
+++ b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/DbNsfpFields.java
@@ -0,0 +1,450 @@
+package de.charite.compbio.jannovar.cmd.annotate_vcf;
+
+import com.google.common.collect.ImmutableMap;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAccumulationStrategy;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVValueColumnDescription;
+import htsjdk.variant.vcf.VCFHeaderLineType;
+
+/**
+ * Configuration for annotation with dbNSFP (v3.4).
+ *
+ * <p>
+ * Defines preconfigured {@link GenericTSVValueColumnDescription}
+ * </p>
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class DbNsfpFields {
+
+	// TODO: implement accumulation in list instead of choose first/min/max only or special
+	// handling?
+
+	public static final ImmutableMap<String, GenericTSVValueColumnDescription> DBNSFP_FIELDS;
+
+	static {
+		ImmutableMap.Builder<String,
+				GenericTSVValueColumnDescription> builder = ImmutableMap.builder();
+
+		builder.put("hg38_chr",
+				new GenericTSVValueColumnDescription(1, VCFHeaderLineType.String, "hg38_chr",
+						"Value of dbNSFP column 'chr'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("hg38_pos",
+				new GenericTSVValueColumnDescription(2, VCFHeaderLineType.Integer, "hg38_pos",
+						"Value of dbNSFP column 'pos'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("ref",
+				new GenericTSVValueColumnDescription(3, VCFHeaderLineType.Character, "ref",
+						"Value of dbNSFP column 'ref'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("alt",
+				new GenericTSVValueColumnDescription(4, VCFHeaderLineType.Character, "alt",
+						"Value of dbNSFP column 'alt'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("aaref",
+				new GenericTSVValueColumnDescription(5, VCFHeaderLineType.Character, "aaref",
+						"Value of dbNSFP column 'aaref'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("aaalt",
+				new GenericTSVValueColumnDescription(6, VCFHeaderLineType.Character, "aaalt",
+						"Value of dbNSFP column 'aaalt'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("rs_dbSNP147",
+				new GenericTSVValueColumnDescription(7, VCFHeaderLineType.String, "rs_dbSNP147",
+						"Value of dbNSFP column 'rs_dbSNP147'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("hg19_chr",
+				new GenericTSVValueColumnDescription(8, VCFHeaderLineType.String, "hg19_chr",
+						"Value of dbNSFP column 'chr'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("hg19_pos",
+				new GenericTSVValueColumnDescription(9, VCFHeaderLineType.Integer, "hg19_pos",
+						"Value of dbNSFP column 'hg19_pos'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("hg18_chr",
+				new GenericTSVValueColumnDescription(10, VCFHeaderLineType.String, "hg18_chr",
+						"Value of dbNSFP column 'hg18_chr'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("hg18_pos",
+				new GenericTSVValueColumnDescription(11, VCFHeaderLineType.Integer, "hg18_pos",
+						"Value of dbNSFP column 'hg18_pos'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("genename",
+				new GenericTSVValueColumnDescription(12, VCFHeaderLineType.String, "genename",
+						"Value of dbNSFP column 'genename'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("cds_strand",
+				new GenericTSVValueColumnDescription(13, VCFHeaderLineType.Character, "cds_strand",
+						"Value of dbNSFP column 'cds_strand'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("refcodon",
+				new GenericTSVValueColumnDescription(14, VCFHeaderLineType.String, "refcodon",
+						"Value of dbNSFP column 'refcodon'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("codonpos",
+				new GenericTSVValueColumnDescription(15, VCFHeaderLineType.Integer, "codonpos",
+						"Value of dbNSFP column 'codonpos'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("codon_degeneracy",
+				new GenericTSVValueColumnDescription(16, VCFHeaderLineType.Integer,
+						"codon_degeneracy", "Value of dbNSFP column 'codon_degeneracy'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("Ancestral_allele",
+				new GenericTSVValueColumnDescription(17, VCFHeaderLineType.String,
+						"Ancestral_allele", "Value of dbNSFP column 'Ancestral_allele'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("AltaiNeandertal",
+				new GenericTSVValueColumnDescription(18, VCFHeaderLineType.String,
+						"AltaiNeandertal", "Value of dbNSFP column 'AltaiNeandertal'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("Denisova",
+				new GenericTSVValueColumnDescription(19, VCFHeaderLineType.String, "Denisova",
+						"Value of dbNSFP column 'Denisova'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("Ensembl_geneid",
+				new GenericTSVValueColumnDescription(20, VCFHeaderLineType.String, "Ensembl_geneid",
+						"Value of dbNSFP column 'Ensembl_geneid'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("Ensembl_transcriptid",
+				new GenericTSVValueColumnDescription(21, VCFHeaderLineType.String,
+						"Ensembl_transcriptid", "Value of dbNSFP column 'Ensembl_transcriptid'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("Ensembl_proteinid",
+				new GenericTSVValueColumnDescription(22, VCFHeaderLineType.String,
+						"Ensembl_proteinid", "Value of dbNSFP column 'Ensembl_proteinid'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		builder.put("aapos",
+				new GenericTSVValueColumnDescription(23, VCFHeaderLineType.Integer, "aapos",
+						"Value of dbNSFP column 'aapos'",
+						GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+
+		builder.put("SIFT_score",
+				new GenericTSVValueColumnDescription(24, VCFHeaderLineType.Float, "SIFT_score",
+						"Value of dbNSFP column 'SIFT_score', If a score is smaller than 0.05 the "
+								+ "corresponding NS is predicted as \"D(amaging)\" therwise it is "
+								+ "predicted as \"T(olerated)\".",
+						GenericTSVAccumulationStrategy.CHOOSE_MIN, "SIFT_score"));
+		builder.put("SIFT_converted_rankscore",
+				new GenericTSVValueColumnDescription(25, VCFHeaderLineType.Float,
+						"SIFT_converted_rankscore",
+						"Value of dbNSFP column 'SIFT_converted_rankscore', SIFTnew=1-SIFTori. "
+								+ "The larger the more damaging.",
+						GenericTSVAccumulationStrategy.CHOOSE_MIN, "SIFT_score"));
+		builder.put("SIFT_pred",
+				new GenericTSVValueColumnDescription(26, VCFHeaderLineType.Character, "SIFT_pred",
+						"Value of dbNSFP column 'SIFT_pred' (Damaging/Tolerated). If SIFTori is smaller "
+								+ "than 0.05 (SIFTnew>0.95) the corresponding NS is predicted as "
+								+ "\"D(amaging)\"; otherwise it is predicted as \"T(olerated)\".",
+						GenericTSVAccumulationStrategy.CHOOSE_MIN, "SIFT_score"));
+
+		builder.put("Uniprot_acc_Polyphen2",
+				new GenericTSVValueColumnDescription(27, VCFHeaderLineType.String,
+						"Uniprot_acc_Polyphen2", "Value of dbNSFP column 'Uniprot_acc_Polyphen2'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Uniprot_id_Polyphen2",
+				new GenericTSVValueColumnDescription(28, VCFHeaderLineType.String,
+						"Uniprot_id_Polyphen2", "Value of dbNSFP column 'Uniprot_id_Polyphen2'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Uniprot_aapos_Polyphen2",
+				new GenericTSVValueColumnDescription(29, VCFHeaderLineType.Integer,
+						"Uniprot_aapos_Polyphen2",
+						"Value of dbNSFP column 'Uniprot_aapos_Polyphen2'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Polyphen2_HDIV_score",
+				new GenericTSVValueColumnDescription(30, VCFHeaderLineType.Integer,
+						"Polyphen2_HDIV_score", "Value of dbNSFP column 'Polyphen2_HDIV_score'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Polyphen2_HDIV_rankscore",
+				new GenericTSVValueColumnDescription(31, VCFHeaderLineType.Integer,
+						"Polyphen2_HDIV_rankscore",
+						"Value of dbNSFP column 'Polyphen2_HDIV_rankscore'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Polyphen2_HDIV_pred",
+				new GenericTSVValueColumnDescription(32, VCFHeaderLineType.Integer,
+						"Polyphen2_HDIV_pred", "Value of dbNSFP column 'Polyphen2_HDIV_pred'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Polyphen2_HVAR_score",
+				new GenericTSVValueColumnDescription(33, VCFHeaderLineType.Integer,
+						"Polyphen2_HVAR_score", "Value of dbNSFP column 'Polyphen2_HVAR_score'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Polyphen2_HVAR_rankscore",
+				new GenericTSVValueColumnDescription(34, VCFHeaderLineType.Integer,
+						"Polyphen2_HVAR_rankscore",
+						"Value of dbNSFP column 'Polyphen2_HVAR_rankscore'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+		builder.put("Polyphen2_HVAR_pred",
+				new GenericTSVValueColumnDescription(35, VCFHeaderLineType.Integer,
+						"Polyphen2_HVAR_pred", "Value of dbNSFP column 'Polyphen2_HVAR_pred'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "Polyphen2_HDIV_score"));
+
+		builder.put("LRT_score",
+				new GenericTSVValueColumnDescription(36, VCFHeaderLineType.Integer, "LRT_score",
+						"Value of dbNSFP column 'LRT_score', first in case of multiple",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "LRT_score"));
+		builder.put("LRT_converted_rankscore",
+				new GenericTSVValueColumnDescription(37, VCFHeaderLineType.Integer,
+						"LRT_converted_rankscore",
+						"Value of dbNSFP column 'LRT_converted_rankscore', first in case of multiple",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "LRT_score"));
+		builder.put("LRT_pred",
+				new GenericTSVValueColumnDescription(38, VCFHeaderLineType.Integer, "LRT_pred",
+						"Value of dbNSFP column 'LRT_pred', first in case of multiple",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "LRT_score"));
+		builder.put("LRT_Omega",
+				new GenericTSVValueColumnDescription(39, VCFHeaderLineType.Integer, "LRT_Omega",
+						"Value of dbNSFP column 'LRT_Omega', first in case of multiple",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "LRT_score"));
+
+		builder.put("MutationTaster_score",
+				new GenericTSVValueColumnDescription(40, VCFHeaderLineType.Float,
+						"MutationTaster_score",
+						"Value of dbNSFP column 'MutationTaster_score', lower is more pathogenic",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationTaster_score"));
+		builder.put("MutationTaster_converted_rankscore",
+				new GenericTSVValueColumnDescription(41, VCFHeaderLineType.Float,
+						"MutationTaster_converted_rankscore",
+						"Value of dbNSFP column 'MutationTaster_converted_rankscore', lower is more pathogenic",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationTaster_score"));
+		builder.put("MutationTaster_pred",
+				new GenericTSVValueColumnDescription(42, VCFHeaderLineType.Character,
+						"MutationTaster_pred", "Value of dbNSFP column 'MutationTaster_pred'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationTaster_score"));
+		builder.put("MutationTaster_model",
+				new GenericTSVValueColumnDescription(43, VCFHeaderLineType.String,
+						"MutationTaster_model", "Value of dbNSFP column 'MutationTaster_model'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationTaster_score"));
+		builder.put("MutationTaster_AAE",
+				new GenericTSVValueColumnDescription(44, VCFHeaderLineType.String,
+						"MutationTaster_AAE", "Value of dbNSFP column 'MutationTaster_AAE'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationTaster_score"));
+
+		builder.put("MutationAssessor_UniprotID",
+				new GenericTSVValueColumnDescription(45, VCFHeaderLineType.String,
+						"MutationAssessor_UniprotID",
+						"Value of dbNSFP column 'MutationAssessor_UniprotID'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationAssessor_score"));
+		builder.put("MutationAssessor_variant",
+				new GenericTSVValueColumnDescription(46, VCFHeaderLineType.String,
+						"MutationAssessor_variant",
+						"Value of dbNSFP column 'MutationAssessor_variant'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationAssessor_score"));
+		builder.put("MutationAssessor_score",
+				new GenericTSVValueColumnDescription(47, VCFHeaderLineType.Float,
+						"MutationAssessor_score", "Value of dbNSFP column 'MutationAssessor_score'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationAssessor_score"));
+		builder.put("MutationAssessor_score_rankscore",
+				new GenericTSVValueColumnDescription(48, VCFHeaderLineType.Float,
+						"MutationAssessor_score_rankscore",
+						"Value of dbNSFP column 'MutationAssessor_score_rankscore'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationAssessor_score"));
+		builder.put("MutationAssessor_pred",
+				new GenericTSVValueColumnDescription(49, VCFHeaderLineType.String,
+						"MutationAssessor_pred", "Value of dbNSFP column 'MutationAssessor_pred'",
+						GenericTSVAccumulationStrategy.CHOOSE_MAX, "MutationAssessor_score"));
+
+		// TODO: add remaining ~150 columns
+
+		DBNSFP_FIELDS = builder.build();
+	}
+	public static String hg38_chr = "chr";
+	public static String hg38_pos = "pos(1-based)";
+	public static String ref = "ref";
+	public static String alt = "alt";
+	public static String aaref = "aaref";
+	public static String aaalt = "aaalt";
+	public static String rs_dbSNP147 = "rs_dbSNP147";
+	public static String hg19_chr = "hg19_chr";
+	public static String hg19_pos = "hg19_pos(1-based)";
+	public static String hg18_chr = "hg18_chr";
+	public static String hg18_pos = "hg18_pos(1-based)";
+	public static String genename = "genename";
+	public static String cds_strand = "cds_strand";
+	public static String refcodon = "refcodon";
+	public static String codonpos = "codonpos";
+	public static String codon_degeneracy = "codon_degeneracy";
+	public static String Ancestral_allele = "Ancestral_allele";
+	public static String AltaiNeandertal = "AltaiNeandertal";
+	public static String Denisova = "Denisova";
+	public static String Ensembl_geneid = "Ensembl_geneid";
+	public static String Ensembl_transcriptid = "Ensembl_transcriptid";
+	public static String Ensembl_proteinid = "Ensembl_proteinid";
+	public static String aapos = "aapos";
+	public static String SIFT_score = "SIFT_score";
+	public static String SIFT_converted_rankscore = "SIFT_converted_rankscore";
+	public static String SIFT_pred = "SIFT_pred";
+	public static String Uniprot_acc_Polyphen2 = "Uniprot_acc_Polyphen2";
+	public static String Uniprot_id_Polyphen2 = "Uniprot_id_Polyphen2";
+	public static String Uniprot_aapos_Polyphen2 = "Uniprot_aapos_Polyphen2";
+	public static String Polyphen2_HDIV_score = "Polyphen2_HDIV_score";
+	public static String Polyphen2_HDIV_rankscore = "Polyphen2_HDIV_rankscore";
+	public static String Polyphen2_HDIV_pred = "Polyphen2_HDIV_pred";
+	public static String Polyphen2_HVAR_score = "Polyphen2_HVAR_score";
+	public static String Polyphen2_HVAR_rankscore = "Polyphen2_HVAR_rankscore";
+	public static String Polyphen2_HVAR_pred = "Polyphen2_HVAR_pred";
+	public static String LRT_score = "LRT_score";
+	public static String LRT_converted_rankscore = "LRT_converted_rankscore";
+	public static String LRT_pred = "LRT_pred";
+	public static String LRT_Omega = "LRT_Omega";
+	public static String MutationTaster_score = "MutationTaster_score";
+	public static String MutationTaster_converted_rankscore = "MutationTaster_converted_rankscore";
+	public static String MutationTaster_pred = "MutationTaster_pred";
+	public static String MutationTaster_model = "MutationTaster_model";
+	public static String MutationTaster_AAE = "MutationTaster_AAE";
+	public static String MutationAssessor_UniprotID = "MutationAssessor_UniprotID";
+	public static String MutationAssessor_variant = "MutationAssessor_variant";
+	public static String MutationAssessor_score = "MutationAssessor_score";
+	public static String MutationAssessor_score_rankscore = "MutationAssessor_score_rankscore";
+	public static String MutationAssessor_pred = "MutationAssessor_pred";
+	public static String FATHMM_score = "FATHMM_score";
+	public static String FATHMM_converted_rankscore = "FATHMM_converted_rankscore";
+	public static String FATHMM_pred = "FATHMM_pred";
+	public static String PROVEAN_score = "PROVEAN_score";
+	public static String PROVEAN_converted_rankscore = "PROVEAN_converted_rankscore";
+	public static String PROVEAN_pred = "PROVEAN_pred";
+	public static String Transcript_id_VEST3 = "Transcript_id_VEST3";
+	public static String Transcript_var_VEST3 = "Transcript_var_VEST3";
+	public static String VEST3_score = "VEST3_score";
+	public static String VEST3_rankscore = "VEST3_rankscore";
+	public static String MetaSVM_score = "MetaSVM_score";
+	public static String MetaSVM_rankscore = "MetaSVM_rankscore";
+	public static String MetaSVM_pred = "MetaSVM_pred";
+	public static String MetaLR_score = "MetaLR_score";
+	public static String MetaLR_rankscore = "MetaLR_rankscore";
+	public static String MetaLR_pred = "MetaLR_pred";
+	public static String Reliability_index = "Reliability_index";
+	public static String M_CAP_score = "M-CAP_score";
+	public static String M_CAP_rankscore = "M-CAP_rankscore";
+	public static String M_CAP_pred = "M-CAP_pred";
+	public static String REVEL_score = "REVEL_score";
+	public static String REVEL_rankscore = "REVEL_rankscore";
+	public static String MutPred_score = "MutPred_score";
+	public static String MutPred_rankscore = "MutPred_rankscore";
+	public static String MutPred_protID = "MutPred_protID";
+	public static String MutPred_AAchange = "MutPred_AAchange";
+	public static String MutPred_Top5features = "MutPred_Top5features";
+	public static String CADD_raw = "CADD_raw";
+	public static String CADD_raw_rankscore = "CADD_raw_rankscore";
+	public static String CADD_phred = "CADD_phred";
+	public static String DANN_score = "DANN_score";
+	public static String DANN_rankscore = "DANN_rankscore";
+	public static String fathmm_MKL_coding_score = "fathmm-MKL_coding_score";
+	public static String fathmm_MKL_coding_rankscore = "fathmm-MKL_coding_rankscore";
+	public static String fathmm_MKL_coding_pred = "fathmm-MKL_coding_pred";
+	public static String fathmm_MKL_coding_group = "fathmm-MKL_coding_group";
+	public static String Eigen_coding_or_noncoding = "Eigen_coding_or_noncoding";
+	public static String Eigen_raw = "Eigen-raw";
+	public static String Eigen_phred = "Eigen-phred";
+	public static String Eigen_PC_raw = "Eigen-PC-raw";
+	public static String Eigen_PC_phred = "Eigen-PC-phred";
+	public static String Eigen_PC_raw_rankscore = "Eigen-PC-raw_rankscore";
+	public static String GenoCanyon_score = "GenoCanyon_score";
+	public static String GenoCanyon_score_rankscore = "GenoCanyon_score_rankscore";
+	public static String integrated_fitCons_score = "integrated_fitCons_score";
+	public static String integrated_fitCons_score_rankscore = "integrated_fitCons_score_rankscore";
+	public static String integrated_confidence_value = "integrated_confidence_value";
+	public static String GM12878_fitCons_score = "GM12878_fitCons_score";
+	public static String GM12878_fitCons_score_rankscore = "GM12878_fitCons_score_rankscore";
+	public static String GM12878_confidence_value = "GM12878_confidence_value";
+	public static String H1_hESC_fitCons_score = "H1-hESC_fitCons_score";
+	public static String H1_hESC_fitCons_score_rankscore = "H1-hESC_fitCons_score_rankscore";
+	public static String H1_hESC_confidence_value = "H1-hESC_confidence_value";
+	public static String HUVEC_fitCons_score = "HUVEC_fitCons_score";
+	public static String HUVEC_fitCons_score_rankscore = "HUVEC_fitCons_score_rankscore";
+	public static String HUVEC_confidence_value = "HUVEC_confidence_value";
+	public static String GERPpp_NR = "GERP++_NR";
+	public static String GERPpp_RS = "GERP++_RS";
+	public static String GERPpp_RS_rankscore = "GERP++_RS_rankscore";
+	public static String phyloP100way_vertebrate = "phyloP100way_vertebrate";
+	public static String phyloP100way_vertebrate_rankscore = "phyloP100way_vertebrate_rankscore";
+	public static String phyloP20way_mammalian = "phyloP20way_mammalian";
+	public static String phyloP20way_mammalian_rankscore = "phyloP20way_mammalian_rankscore";
+	public static String phastCons100way_vertebrate = "phastCons100way_vertebrate";
+	public static String phastCons100way_vertebrate_rankscore = "phastCons100way_vertebrate_rankscore";
+	public static String phastCons20way_mammalian = "phastCons20way_mammalian";
+	public static String phastCons20way_mammalian_rankscore = "phastCons20way_mammalian_rankscore";
+	public static String SiPhy_29way_pi = "SiPhy_29way_pi";
+	public static String SiPhy_29way_logOdds = "SiPhy_29way_logOdds";
+	public static String SiPhy_29way_logOdds_rankscore = "SiPhy_29way_logOdds_rankscore";
+	public static String G1000_Gp3_AC = "1000Gp3_AC";
+	public static String G1000_Gp3_AF = "1000Gp3_AF";
+	public static String G1000_Gp3_AFR_AC = "1000Gp3_AFR_AC";
+	public static String G1000_Gp3_AFR_AF = "1000Gp3_AFR_AF";
+	public static String G1000_Gp3_EUR_AC = "1000Gp3_EUR_AC";
+	public static String G1000_Gp3_EUR_AF = "1000Gp3_EUR_AF";
+	public static String G1000_Gp3_AMR_AC = "1000Gp3_AMR_AC";
+	public static String G1000_Gp3_AMR_AF = "1000Gp3_AMR_AF";
+	public static String G1000_Gp3_EAS_AC = "1000Gp3_EAS_AC";
+	public static String G1000_Gp3_EAS_AF = "1000Gp3_EAS_AF";
+	public static String G1000_Gp3_SAS_AC = "1000Gp3_SAS_AC";
+	public static String G1000_Gp3_SAS_AF = "1000Gp3_SAS_AF";
+	public static String TWINSUK_AC = "TWINSUK_AC";
+	public static String TWINSUK_AF = "TWINSUK_AF";
+	public static String ALSPAC_AC = "ALSPAC_AC";
+	public static String ALSPAC_AF = "ALSPAC_AF";
+	public static String ESP6500_AA_AC = "ESP6500_AA_AC";
+	public static String ESP6500_AA_AF = "ESP6500_AA_AF";
+	public static String ESP6500_EA_AC = "ESP6500_EA_AC";
+	public static String ESP6500_EA_AF = "ESP6500_EA_AF";
+	public static String ExAC_AC = "ExAC_AC";
+	public static String ExAC_AF = "ExAC_AF";
+	public static String ExAC_Adj_AC = "ExAC_Adj_AC";
+	public static String ExAC_Adj_AF = "ExAC_Adj_AF";
+	public static String ExAC_AFR_AC = "ExAC_AFR_AC";
+	public static String ExAC_AFR_AF = "ExAC_AFR_AF";
+	public static String ExAC_AMR_AC = "ExAC_AMR_AC";
+	public static String ExAC_AMR_AF = "ExAC_AMR_AF";
+	public static String ExAC_EAS_AC = "ExAC_EAS_AC";
+	public static String ExAC_EAS_AF = "ExAC_EAS_AF";
+	public static String ExAC_FIN_AC = "ExAC_FIN_AC";
+	public static String ExAC_FIN_AF = "ExAC_FIN_AF";
+	public static String ExAC_NFE_AC = "ExAC_NFE_AC";
+	public static String ExAC_NFE_AF = "ExAC_NFE_AF";
+	public static String ExAC_SAS_AC = "ExAC_SAS_AC";
+	public static String ExAC_SAS_AF = "ExAC_SAS_AF";
+	public static String ExAC_nonTCGA_AC = "ExAC_nonTCGA_AC";
+	public static String ExAC_nonTCGA_AF = "ExAC_nonTCGA_AF";
+	public static String ExAC_nonTCGA_Adj_AC = "ExAC_nonTCGA_Adj_AC";
+	public static String ExAC_nonTCGA_Adj_AF = "ExAC_nonTCGA_Adj_AF";
+	public static String ExAC_nonTCGA_AFR_AC = "ExAC_nonTCGA_AFR_AC";
+	public static String ExAC_nonTCGA_AFR_AF = "ExAC_nonTCGA_AFR_AF";
+	public static String ExAC_nonTCGA_AMR_AC = "ExAC_nonTCGA_AMR_AC";
+	public static String ExAC_nonTCGA_AMR_AF = "ExAC_nonTCGA_AMR_AF";
+	public static String ExAC_nonTCGA_EAS_AC = "ExAC_nonTCGA_EAS_AC";
+	public static String ExAC_nonTCGA_EAS_AF = "ExAC_nonTCGA_EAS_AF";
+	public static String ExAC_nonTCGA_FIN_AC = "ExAC_nonTCGA_FIN_AC";
+	public static String ExAC_nonTCGA_FIN_AF = "ExAC_nonTCGA_FIN_AF";
+	public static String ExAC_nonTCGA_NFE_AC = "ExAC_nonTCGA_NFE_AC";
+	public static String ExAC_nonTCGA_NFE_AF = "ExAC_nonTCGA_NFE_AF";
+	public static String ExAC_nonTCGA_SAS_AC = "ExAC_nonTCGA_SAS_AC";
+	public static String ExAC_nonTCGA_SAS_AF = "ExAC_nonTCGA_SAS_AF";
+	public static String ExAC_nonpsych_AC = "ExAC_nonpsych_AC";
+	public static String ExAC_nonpsych_AF = "ExAC_nonpsych_AF";
+	public static String ExAC_nonpsych_Adj_AC = "ExAC_nonpsych_Adj_AC";
+	public static String ExAC_nonpsych_Adj_AF = "ExAC_nonpsych_Adj_AF";
+	public static String ExAC_nonpsych_AFR_AC = "ExAC_nonpsych_AFR_AC";
+	public static String ExAC_nonpsych_AFR_AF = "ExAC_nonpsych_AFR_AF";
+	public static String ExAC_nonpsych_AMR_AC = "ExAC_nonpsych_AMR_AC";
+	public static String ExAC_nonpsych_AMR_AF = "ExAC_nonpsych_AMR_AF";
+	public static String ExAC_nonpsych_EAS_ACExAC_nonpsych_EAS_AF = "ExAC_nonpsych_EAS_ACExAC_nonpsych_EAS_AF";
+	public static String ExAC_nonpsych_FIN_AC = "ExAC_nonpsych_FIN_AC";
+	public static String ExAC_nonpsych_FIN_AF = "ExAC_nonpsych_FIN_AF";
+	public static String ExAC_nonpsych_NFE_AC = "ExAC_nonpsych_NFE_AC";
+	public static String ExAC_nonpsych_NFE_AF = "ExAC_nonpsych_NFE_AF";
+	public static String ExAC_nonpsych_SAS_AC = "ExAC_nonpsych_SAS_AC";
+	public static String ExAC_nonpsych_SAS_AF = "ExAC_nonpsych_SAS_AF";
+	public static String clinvar_rs = "clinvar_rs";
+	public static String clinvar_clnsig = "clinvar_clnsig";
+	public static String clinvar_trait = "clinvar_trait";
+	public static String clinvar_golden_starsInterpro_domain = "clinvar_golden_starsInterpro_domain";
+	public static String GTEx_V6_gene = "GTEx_V6_gene";
+	public static String GTEx_V6_tissue = "GTEx_V6_tissue ";
+
+}
diff --git a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/JannovarAnnotateVCFOptions.java b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/JannovarAnnotateVCFOptions.java
index 743ff2b3b1..9e1bac07dc 100755
--- a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/JannovarAnnotateVCFOptions.java
+++ b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/annotate_vcf/JannovarAnnotateVCFOptions.java
@@ -1,22 +1,19 @@
 package de.charite.compbio.jannovar.cmd.annotate_vcf;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.function.BiFunction;
-
 import de.charite.compbio.jannovar.UncheckedJannovarException;
 import de.charite.compbio.jannovar.cmd.CommandLineParsingException;
 import de.charite.compbio.jannovar.cmd.JannovarAnnotationOptions;
 import de.charite.compbio.jannovar.cmd.JannovarBaseOptions;
 import de.charite.compbio.jannovar.filter.facade.PedigreeFilterOptions;
 import de.charite.compbio.jannovar.filter.facade.ThresholdFilterOptions;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationOptions;
+import de.charite.compbio.jannovar.vardbs.generic_vcf.GenericVCFAnnotationOptions;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.BiFunction;
 import net.sourceforge.argparse4j.impl.Arguments;
-import net.sourceforge.argparse4j.inf.Argument;
-import net.sourceforge.argparse4j.inf.ArgumentAction;
 import net.sourceforge.argparse4j.inf.ArgumentGroup;
 import net.sourceforge.argparse4j.inf.ArgumentParser;
-import net.sourceforge.argparse4j.inf.ArgumentParserException;
 import net.sourceforge.argparse4j.inf.Namespace;
 import net.sourceforge.argparse4j.inf.Subparser;
 import net.sourceforge.argparse4j.inf.Subparsers;
@@ -162,17 +159,40 @@
 	 */
 	private boolean inheritanceAnnoUseFilters;
 
+	/** Whether or not to enable the "parent GT is filtered" GT filter, default is true. */
+	private boolean useParentGtIsFiltered;
+
 	/** Maximal support of alternative allele in parent for de novo variant. */
 	private Integer threshDeNovoParentAd2;
 
 	/** Configuration for annotation with BED files. */
 	private List<BedAnnotationOptions> bedAnnotationOptions = new ArrayList<>();
 
+	/** Column of contig name in dbNSFP. */
+	private int dbNsfpColContig;
+
+	/** Column of contig name in dbNSFP. */
+	private int dbNsfpColPosition;
+
+	/** Prefix for dbNSFP annotations. */
+	private String prefixDbNsfp;
+
+	/** Configuration for annotation with dbNSFP. */
+	private String pathDbNsfp;
+
+	/** Fields to annotate with from dbNSFP. */
+	private List<String> columnsDbNsfp = new ArrayList<>();
+
+	/** Configuration for annotation with generic TSV files. */
+	private List<GenericTSVAnnotationOptions> tsvAnnotationOptions = new ArrayList<>();
+
+	/** Configuration for annotation with VCF files. */
+	private List<GenericVCFAnnotationOptions> vcfAnnotationOptions = new ArrayList<>();
+
 	/**
 	 * Setup {@link ArgumentParser}
 	 * 
-	 * @param subParsers
-	 *            {@link Subparsers} to setup
+	 * @param subParsers {@link Subparsers} to setup
 	 */
 	public static void setupParser(Subparsers subParsers) {
 		BiFunction<String[], Namespace, AnnotateVCFCommand> handler = (argv, args) -> {
@@ -195,8 +215,8 @@ public static void setupParser(Subparsers subParsers) {
 		requiredGroup.addArgument("-d", "--database").help("Path to database .ser file")
 				.required(true);
 
-		ArgumentGroup annotationGroup = subParser
-				.addArgumentGroup("Annotation Arguments (optional)");
+		ArgumentGroup annotationGroup =
+				subParser.addArgumentGroup("Annotation Arguments (optional)");
 		requiredGroup.addArgument("--interval").help("Interval with regions to annotate (optional)")
 				.required(false).setDefault("");
 		annotationGroup.addArgument("--pedigree-file")
@@ -242,15 +262,44 @@ public static void setupParser(Subparsers subParsers) {
 				.help("Use filters in inheritance mode annotation").setDefault(false)
 				.action(Arguments.storeTrue());
 
-		ArgumentGroup bedAnnotationGroup = subParser
-				.addArgumentGroup("BED-based Annotation (optional)");
+		ArgumentGroup dbNsfpAnnotationGroup =
+				subParser.addArgumentGroup("Annotation with dbNSFP (experimental; optional)");
+		dbNsfpAnnotationGroup.addArgument("--dbnsfp-tsv").help("Patht to dbNSFP TSV file")
+				.required(false);
+		dbNsfpAnnotationGroup.addArgument("--dbnsfp-col-contig").type(Integer.class)
+				.help("Column index of contig in dbNSFP").setDefault(1);
+		dbNsfpAnnotationGroup.addArgument("--dbnsfp-col-position").type(Integer.class)
+				.help("Column index of position in dbNSFP").setDefault(2);
+		dbNsfpAnnotationGroup.addArgument("--dbnsfp-prefix").help("Prefix for dbNSFP annotations")
+				.setDefault("DBNSFP_").required(false);
+		dbNsfpAnnotationGroup.addArgument("--dbnsfp-columns")
+				.help("Columns from dbDSFP file to use for annotation").action(Arguments.append());
+
+		ArgumentGroup bedAnnotationGroup =
+				subParser.addArgumentGroup("BED-based Annotation (experimental; optional)");
 		bedAnnotationGroup.addArgument("--bed-annotation")
 				.help("Add BED file to use for annotating. The value must be of the format "
 						+ "\"pathToBed:infoField:description[:colNo]\".")
 				.action(Arguments.append());
 
-		ArgumentGroup threshFilterGroup = subParser
-				.addArgumentGroup("Threshold-filter related arguments");
+		ArgumentGroup vcfAnnotationGroup =
+				subParser.addArgumentGroup("Generic VCF-based Annotation (experimental; optional)");
+		vcfAnnotationGroup.addArgument("--vcf-annotation")
+				.help("Add VCF file to use for annotating. The value must be of the format "
+						+ "\"pathToVfFile:prefix:field1,field2,field3\".")
+				.action(Arguments.append());
+
+		ArgumentGroup tsvAnnotationGroup =
+				subParser.addArgumentGroup("TSV-based Annotation (experimental; optional)");
+		tsvAnnotationGroup.addArgument("--tsv-annotation")
+				.help("Add TSV file to use for annotating. The value must be of the format "
+						+ "\"pathToTsvFile:oneBasedOffset:colContig:colStart:colEnd:colRef(or=0):"
+						+ "colAlt(or=0):isRefAnnotated(R=yes,A=no):colValue:fieldType:fieldName:fieldDescription:"
+						+ "accumulationStrategy\".")
+				.action(Arguments.append());
+
+		ArgumentGroup threshFilterGroup =
+				subParser.addArgumentGroup("Threshold-filter related arguments");
 		threshFilterGroup.addArgument("--use-threshold-filters").help("Use threshold-based filters")
 				.setDefault(false).action(Arguments.storeTrue());
 		ThresholdFilterOptions threshDefaults = ThresholdFilterOptions.buildDefaultOptions();
@@ -315,6 +364,8 @@ public static void setupParser(Subparsers subParsers) {
 		optionalGroup.addArgument("--3-letter-amino-acids")
 				.help("Enable usage of 3 letter amino acid codes").setDefault(false)
 				.action(Arguments.storeTrue());
+		optionalGroup.addArgument("--disable-parent-gt-is-filtered").setDefault(true)
+				.dest("use_parent_gt_is_filtered").action(Arguments.storeFalse());
 
 		JannovarBaseOptions.setupParser(subParser);
 	}
@@ -346,10 +397,45 @@ public void setFromArgs(Namespace args) throws CommandLineParsingException {
 		pathCosmic = args.getString("cosmic_vcf");
 		prefixCosmic = args.getString("cosmic_prefix");
 		inheritanceAnnoUseFilters = args.getBoolean("inheritance_anno_use_filters");
-		
-		for (Object o : args.getList("bed_annotation")) {
-			final String s = (String)o;
-			bedAnnotationOptions.add(BedAnnotationOptions.parseFrom(s));
+		useParentGtIsFiltered = args.getBoolean("use_parent_gt_is_filtered");
+
+		dbNsfpColContig = args.getInt("dbnsfp_col_contig");
+		dbNsfpColPosition = args.getInt("dbnsfp_col_position");
+		prefixDbNsfp = args.getString("dbnsfp_prefix");
+		pathDbNsfp = args.getString("dbnsfp_tsv");
+		if (args.getList("dbnsfp_columns") != null) {
+			for (Object o : args.getList("dbnsfp_columns")) {
+				final String s = (String) o;
+				for (String s2 : s.split(",")) {
+					if (!DbNsfpFields.DBNSFP_FIELDS.containsKey(s2)) {
+						throw new RuntimeException(
+								"Unknown field from dbNSFP or not yet supported: " + s);
+					} else {
+						columnsDbNsfp.add(s2);
+					}
+				}
+			}
+		}
+
+		if (args.getList("bed_annotation") != null) {
+			for (Object o : args.getList("bed_annotation")) {
+				final String s = (String) o;
+				bedAnnotationOptions.add(BedAnnotationOptions.parseFrom(s));
+			}
+		}
+
+		if (args.getList("tsv_annotation") != null) {
+			for (Object o : args.getList("tsv_annotation")) {
+				final String s = (String) o;
+				tsvAnnotationOptions.add(GenericTSVAnnotationOptions.parseFrom(s));
+			}
+		}
+
+		if (args.getList("vcf_annotation") != null) {
+			for (Object o : args.getList("vcf_annotation")) {
+				final String s = (String) o;
+				vcfAnnotationOptions.add(GenericVCFAnnotationOptions.parseFrom(s));
+			}
 		}
 
 		useThresholdFilters = args.getBoolean("use_threshold_filters");
@@ -372,7 +458,8 @@ public void setFromArgs(Namespace args) throws CommandLineParsingException {
 
 		if (pathFASTARef == null && (pathVCFDBSNP != null || pathVCFExac != null
 				|| pathVCFUK10K != null || pathClinVar != null || pathCosmic != null
-				|| pathVCFGnomadExomes != null || pathVCFGnomadGenomes != null))
+				|| pathVCFGnomadExomes != null || pathVCFGnomadGenomes != null || pathDbNsfp != null
+				|| !tsvAnnotationOptions.isEmpty() || !vcfAnnotationOptions.isEmpty()))
 			throw new CommandLineParsingException(
 					"Command --ref-fasta required when using dbSNP, ExAC, UK10K, ClinVar, or COSMIC annotations.");
 	}
@@ -690,6 +777,78 @@ public void setBedAnnotationOptions(List<BedAnnotationOptions> bedAnnotationOpti
 		this.bedAnnotationOptions = bedAnnotationOptions;
 	}
 
+	public Integer getThreshDeNovoParentAd2() {
+		return threshDeNovoParentAd2;
+	}
+
+	public void setThreshDeNovoParentAd2(Integer threshDeNovoParentAd2) {
+		this.threshDeNovoParentAd2 = threshDeNovoParentAd2;
+	}
+
+	public String getPrefixDbNsfp() {
+		return prefixDbNsfp;
+	}
+
+	public void setPrefixDbNsfp(String prefixDbNsfp) {
+		this.prefixDbNsfp = prefixDbNsfp;
+	}
+
+	public String getPathDbNsfp() {
+		return pathDbNsfp;
+	}
+
+	public void setPathDbNsfp(String pathDbNsfp) {
+		this.pathDbNsfp = pathDbNsfp;
+	}
+
+	public List<String> getColumnsDbNsfp() {
+		return columnsDbNsfp;
+	}
+
+	public void setColumnsDbNsfp(List<String> columnsDbNsfp) {
+		this.columnsDbNsfp = columnsDbNsfp;
+	}
+
+	public List<GenericTSVAnnotationOptions> getTsvAnnotationOptions() {
+		return tsvAnnotationOptions;
+	}
+
+	public void setTsvAnnotationOptions(List<GenericTSVAnnotationOptions> tsvAnnotationOptions) {
+		this.tsvAnnotationOptions = tsvAnnotationOptions;
+	}
+
+	public int getDbNsfpColContig() {
+		return dbNsfpColContig;
+	}
+
+	public void setDbNsfpColContig(int dbNsfpColContig) {
+		this.dbNsfpColContig = dbNsfpColContig;
+	}
+
+	public int getDbNsfpColPosition() {
+		return dbNsfpColPosition;
+	}
+
+	public void setDbNsfpColPosition(int dbNsfpColPosition) {
+		this.dbNsfpColPosition = dbNsfpColPosition;
+	}
+
+	public List<GenericVCFAnnotationOptions> getVcfAnnotationOptions() {
+		return vcfAnnotationOptions;
+	}
+
+	public void setVcfAnnotationOptions(List<GenericVCFAnnotationOptions> vcfAnnotationOptions) {
+		this.vcfAnnotationOptions = vcfAnnotationOptions;
+	}
+
+	public boolean isUseParentGtIsFiltered() {
+		return useParentGtIsFiltered;
+	}
+
+	public void setUseParentGtIsFiltered(boolean useParentGtIsFiltered) {
+		this.useParentGtIsFiltered = useParentGtIsFiltered;
+	}
+
 	@Override
 	public String toString() {
 		return "JannovarAnnotateVCFOptions [escapeAnnField=" + escapeAnnField + ", pathInputVCF="
@@ -716,16 +875,13 @@ public String toString() {
 				+ ", offTargetFilterUtrIsOffTarget=" + offTargetFilterUtrIsOffTarget
 				+ ", offTargetFilterIntronicSpliceIsOffTarget="
 				+ offTargetFilterIntronicSpliceIsOffTarget + ", inheritanceAnnoUseFilters="
-				+ inheritanceAnnoUseFilters + ", threshDeNovoParentAd2=" + threshDeNovoParentAd2
-				+ ", bedAnnotationOptions=" + bedAnnotationOptions + "]";
-	}
-
-	public Integer getThreshDeNovoParentAd2() {
-		return threshDeNovoParentAd2;
-	}
-
-	public void setThreshDeNovoParentAd2(Integer threshDeNovoParentAd2) {
-		this.threshDeNovoParentAd2 = threshDeNovoParentAd2;
+				+ inheritanceAnnoUseFilters + ", useParentGtIsFiltered=" + useParentGtIsFiltered
+				+ ", threshDeNovoParentAd2=" + threshDeNovoParentAd2 + ", bedAnnotationOptions="
+				+ bedAnnotationOptions + ", dbNsfpColContig=" + dbNsfpColContig
+				+ ", dbNsfpColPosition=" + dbNsfpColPosition + ", prefixDbNsfp=" + prefixDbNsfp
+				+ ", pathDbNsfp=" + pathDbNsfp + ", columnsDbNsfp=" + columnsDbNsfp
+				+ ", tsvAnnotationOptions=" + tsvAnnotationOptions + ", vcfAnnotationOptions="
+				+ vcfAnnotationOptions + "]";
 	}
 
 	/**
@@ -740,8 +896,7 @@ public void setThreshDeNovoParentAd2(Integer threshDeNovoParentAd2) {
 		 * The value must have the format: <code>pathToBed:infoField:description[:colNo]</code>
 		 * </p>
 		 * 
-		 * @param strValue
-		 *            String to parse from
+		 * @param strValue String to parse from
 		 * @return Constructed {@link BedAnnotationOptions} from the given string value.
 		 */
 		public static BedAnnotationOptions parseFrom(String strValue) {
diff --git a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/download/DownloadCommand.java b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/download/DownloadCommand.java
index b853c9c640..207531bb74 100755
--- a/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/download/DownloadCommand.java
+++ b/jannovar-cli/src/main/java/de/charite/compbio/jannovar/cmd/download/DownloadCommand.java
@@ -1,5 +1,6 @@
 package de.charite.compbio.jannovar.cmd.download;
 
+import com.google.common.collect.Lists;
 import de.charite.compbio.jannovar.JannovarException;
 import de.charite.compbio.jannovar.cmd.CommandLineParsingException;
 import de.charite.compbio.jannovar.cmd.JannovarCommand;
@@ -32,14 +33,15 @@ public void run() throws JannovarException {
 		System.err.println("Options");
 		System.err.println(options.toString());
 
-		DatasourceOptions dsOptions = new DatasourceOptions(options.getHttpProxy(), options.getHttpsProxy(),
-				options.getFtpProxy(), options.isReportProgress());
+		DatasourceOptions dsOptions = new DatasourceOptions(options.getHttpProxy(),
+				options.getHttpsProxy(), options.getFtpProxy(), options.isReportProgress());
 
-		DataSourceFactory factory = new DataSourceFactory(dsOptions, options.dataSourceFiles);
+		DataSourceFactory factory =
+				new DataSourceFactory(dsOptions, Lists.reverse(options.dataSourceFiles));
 		for (String name : options.getDatabaseNames()) {
 			System.err.println("Downloading/parsing for data source \"" + name + "\"");
-			JannovarData data = factory.getDataSource(name).getDataFactory().build(options.getDownloadDir(),
-					options.isReportProgress());
+			JannovarData data = factory.getDataSource(name).getDataFactory()
+					.build(options.getDownloadDir(), options.isReportProgress());
 			String filename = PathUtil.join(options.getDownloadDir(),
 					name.replace('/', '_').replace('\\', '_') + ".ser");
 			JannovarDataSerializer serializer = new JannovarDataSerializer(filename);
diff --git a/jannovar-core/pom.xml b/jannovar-core/pom.xml
index 2656d62116..e2dce16594 100755
--- a/jannovar-core/pom.xml
+++ b/jannovar-core/pom.xml
@@ -32,7 +32,7 @@
 		<dependency>
 			<groupId>com.google.guava</groupId>
 			<artifactId>guava</artifactId>
-			<version>19.0</version>
+			<version>${guava.version}</version>
 		</dependency>
 		<!-- HGVS variant description -->
 		<dependency>
diff --git a/jannovar-core/src/main/java/de/charite/compbio/jannovar/annotation/VariantEffect.java b/jannovar-core/src/main/java/de/charite/compbio/jannovar/annotation/VariantEffect.java
index 4f4f8435e2..85ccdc3135 100755
--- a/jannovar-core/src/main/java/de/charite/compbio/jannovar/annotation/VariantEffect.java
+++ b/jannovar-core/src/main/java/de/charite/compbio/jannovar/annotation/VariantEffect.java
@@ -964,7 +964,6 @@ public boolean isOffExome(boolean isUtrOffExome, boolean isIntronicSpliceNonCons
 		case DIRECT_TANDEM_DUPLICATION:
 		case DISRUPTIVE_INFRAME_DELETION:
 		case DISRUPTIVE_INFRAME_INSERTION:
-		case DOWNSTREAM_GENE_VARIANT:
 		case EXON_LOSS_VARIANT:
 		case EXON_VARIANT:
 		case FEATURE_TRUNCATION:
@@ -990,7 +989,6 @@ public boolean isOffExome(boolean isUtrOffExome, boolean isIntronicSpliceNonCons
 		case SYNONYMOUS_VARIANT:
 		case TF_BINDING_SITE_VARIANT:
 		case TRANSCRIPT_ABLATION:
-		case UPSTREAM_GENE_VARIANT:
 			return false;
 		default:
 			return true;
diff --git a/jannovar-core/src/main/java/de/charite/compbio/jannovar/mendel/MendelianInheritanceChecker.java b/jannovar-core/src/main/java/de/charite/compbio/jannovar/mendel/MendelianInheritanceChecker.java
index 200de346f2..d7d1a97df8 100755
--- a/jannovar-core/src/main/java/de/charite/compbio/jannovar/mendel/MendelianInheritanceChecker.java
+++ b/jannovar-core/src/main/java/de/charite/compbio/jannovar/mendel/MendelianInheritanceChecker.java
@@ -57,45 +57,74 @@ public MendelianInheritanceChecker(Pedigree pedigree) {
 	 * Perform checking for compatible mode of inheritance
 	 * 
 	 * @param calls
-	 *            {@link Collection} of {@link GenotypeCalls} objects to perform the mode of inheritance check for
+	 *            {@link Collection} of {@link GenotypeCalls} objects to perform the mode of inheritance check for in
+	 *            case of non-recessive mode of inheritance
+	 * @param recessiveCalls
+	 * 			  {@link Collection} of {@link GenotypeCalls} objects to perform the mode of
+	 *            inheritance check for in case of recessive mode of inheritance
 	 * @return {@link Map} that, for each {@link ModeOfInheritance}, contains the {@link Collection} of compatible
 	 *         {@link GenotypeCalls} from <code>list</code>
 	 * @throws IncompatiblePedigreeException
 	 *             if the individuals in <code>calls</code> do not fit to the pedigree
 	 */
 	public ImmutableMap<ModeOfInheritance, ImmutableList<GenotypeCalls>> checkMendelianInheritance(
-			Collection<GenotypeCalls> calls) throws IncompatiblePedigreeException {
+			Collection<GenotypeCalls> calls, Collection<GenotypeCalls> recessiveCalls) throws IncompatiblePedigreeException {
 		ImmutableMap.Builder<ModeOfInheritance, ImmutableList<GenotypeCalls>> builder = new ImmutableMap.Builder<>();
-		for (ModeOfInheritance mode : ModeOfInheritance.values())
-			if (mode != ModeOfInheritance.ANY)
-				builder.put(mode, filterCompatibleRecords(calls, mode));
-			else
+		for (ModeOfInheritance mode : ModeOfInheritance.values()) {
+			if (mode == ModeOfInheritance.ANY) {
 				builder.put(mode, ImmutableList.copyOf(calls));
+			} else {
+				if (mode == ModeOfInheritance.AUTOSOMAL_RECESSIVE || mode == ModeOfInheritance.X_RECESSIVE) {
+					builder.put(mode, filterCompatibleRecords(recessiveCalls, mode));
+				} else {
+					builder.put(mode, filterCompatibleRecords(calls, mode));
+				}
+			}
+		}
 		return builder.build();
 	}
 
+	public ImmutableMap<ModeOfInheritance, ImmutableList<GenotypeCalls>> checkMendelianInheritance(
+			Collection<GenotypeCalls> calls) throws IncompatiblePedigreeException {
+		return checkMendelianInheritance(calls, calls);
+	}
+
 
 	/**
 	 * Perform checking for compatible sub mode of inheritance
 	 * 
 	 * @param calls
 	 *            {@link Collection} of {@link GenotypeCalls} objects to perform the mode of inheritance check for
+	 * @param compHetRecessiveCalls
+	 * 			  {@link Collection} of {@link GenotypeCalls} objects to perform the mode of
+	 *            inheritance check for in case of compound het. recessive mode of inheritance
 	 * @return {@link Map} that, for each {@link SubModeOfInheritance}, contains the {@link Collection} of compatible
 	 *         {@link GenotypeCalls} from <code>list</code>
 	 * @throws IncompatiblePedigreeException
 	 *             if the individuals in <code>calls</code> do not fit to the pedigree
 	 */
 	public ImmutableMap<SubModeOfInheritance, ImmutableList<GenotypeCalls>> checkMendelianInheritanceSub(
-			Collection<GenotypeCalls> calls) throws IncompatiblePedigreeException {
+			Collection<GenotypeCalls> calls, Collection<GenotypeCalls> compHetRecessiveCalls) throws IncompatiblePedigreeException {
 		ImmutableMap.Builder<SubModeOfInheritance, ImmutableList<GenotypeCalls>> builder = new ImmutableMap.Builder<>();
-		for (SubModeOfInheritance mode : SubModeOfInheritance.values())
-			if (mode != SubModeOfInheritance.ANY)
-				builder.put(mode, filterCompatibleRecordsSub(calls, mode));
-			else
+		for (SubModeOfInheritance mode : SubModeOfInheritance.values()) {
+			if (mode == SubModeOfInheritance.ANY) {
 				builder.put(mode, ImmutableList.copyOf(calls));
+			} else {
+				if (mode == SubModeOfInheritance.AUTOSOMAL_RECESSIVE_COMP_HET || mode == SubModeOfInheritance.X_RECESSIVE_COMP_HET) {
+					builder.put(mode, filterCompatibleRecordsSub(compHetRecessiveCalls, mode));
+				} else {
+					builder.put(mode, filterCompatibleRecordsSub(calls, mode));
+				}
+			}
+		}
 		return builder.build();
 	}
 
+	public ImmutableMap<SubModeOfInheritance, ImmutableList<GenotypeCalls>> checkMendelianInheritanceSub(
+			Collection<GenotypeCalls> calls) throws IncompatiblePedigreeException {
+		return checkMendelianInheritanceSub(calls, calls);
+	}
+
 	/**
 	 * Filters records in <code>calls</code> for compatibility with <code>mode</code>
 	 * 
diff --git a/jannovar-filter/pom.xml b/jannovar-filter/pom.xml
index d50150458d..006f9a46bf 100755
--- a/jannovar-filter/pom.xml
+++ b/jannovar-filter/pom.xml
@@ -23,7 +23,7 @@
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>slf4j-simple</artifactId>
-			<version>1.7.12</version>
+            <version>${slf4j.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>com.github.samtools</groupId>
@@ -39,7 +39,7 @@
 		<dependency>
 			<groupId>com.google.guava</groupId>
 			<artifactId>guava</artifactId>
-			<version>19.0</version>
+			<version>${guava.version}</version>
 		</dependency>
         <dependency>
             <groupId>de.charite.compbio</groupId>
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/GenotypeThresholdFilterAnnotator.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/GenotypeThresholdFilterAnnotator.java
new file mode 100755
index 0000000000..67c81e8b1a
--- /dev/null
+++ b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/GenotypeThresholdFilterAnnotator.java
@@ -0,0 +1,53 @@
+package de.charite.compbio.jannovar.filter.facade;
+
+import de.charite.compbio.jannovar.filter.impl.gt.GenotypeFilterAnnotator;
+import htsjdk.variant.variantcontext.Genotype;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.variantcontext.VariantContextBuilder;
+import java.util.ArrayList;
+
+/**
+ * Perform annotation (sof-filtering) based on coverage/alternative allele fraction/genotype call
+ * quality
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenotypeThresholdFilterAnnotator {
+
+	/** Configuration for the threshold-based filter */
+	private final ThresholdFilterOptions options;
+
+	/** Helper for genotype-wide application of filters */
+	private final GenotypeFilterAnnotator gtAnnotator;
+
+	public GenotypeThresholdFilterAnnotator(ThresholdFilterOptions options) {
+		this.options = options;
+		this.gtAnnotator = new GenotypeFilterAnnotator(this.options);
+	}
+
+	/**
+	 * Annotate VariantContext with the threshold-based filters.
+	 *
+	 * @param vc the {@link VariantContext} to annotate
+	 * @return copy of <code>vc</code> with applied annotations
+	 */
+	public VariantContext annotateVariantContext(VariantContext vc) {
+		VariantContextBuilder builder = new VariantContextBuilder(vc);
+		annotateGenotypes(builder, vc);
+		return builder.make();
+	}
+
+	/**
+	 * Annotate genotypes individually in <code>vc</code>
+	 * 
+	 * @param builder the {@link VariantContextBuilder} used for building variant
+	 * @param vc {@link VariantContext} to annotate
+	 */
+	private void annotateGenotypes(VariantContextBuilder builder, VariantContext vc) {
+		ArrayList<Genotype> gts = new ArrayList<>();
+		for (Genotype gt : vc.getGenotypes())
+			gts.add(gtAnnotator.gtWithAppliedFilters(gt));
+		builder.genotypes(gts);
+	}
+
+}
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterAnnotator.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterAnnotator.java
index 83a5c0c92f..4322e9339d 100755
--- a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterAnnotator.java
+++ b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterAnnotator.java
@@ -11,8 +11,10 @@
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -23,9 +25,9 @@
  * </p>
  *
  * <p>
- * Note that this filter has to be applied <b>after</b> {@link ThresholdFilterAnnotator} because the
- * de novo filtration settings would otherwise conflict with the "all affected individuals filtered"
- * variant filter.
+ * Note that this filter has to be applied <b>after</b> {@link GenotypeThresholdFilterAnnotator}
+ * because the de novo filtration settings would otherwise conflict with the "all affected
+ * individuals filtered" variant filter.
  * </p>
  *
  * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
@@ -47,8 +49,7 @@ public PedigreeFilterAnnotator(PedigreeFilterOptions options, Pedigree pedigree)
 	/**
 	 * Annotate VariantContext with the pedigree-based filters
 	 *
-	 * @param vc
-	 *            the {@link VariantContext} to annotate
+	 * @param vc the {@link VariantContext} to annotate
 	 * @return copy of <code>vc</code> with applied annotations
 	 */
 	public VariantContext annotateVariantContext(VariantContext vc) {
@@ -61,35 +62,63 @@ public VariantContext annotateVariantContext(VariantContext vc) {
 	private List<Genotype> annotateGenotypes(VariantContextBuilder builder, VariantContext vc) {
 		ArrayList<Genotype> gts = new ArrayList<>();
 
+		// First, collect extra FT entries without "is parent filtered"
+		Map<String, List<String>> extraFts = new HashMap<>();
 		for (Genotype gt : vc.getGenotypes()) {
-			GenotypeBuilder gtBuilder = new GenotypeBuilder(gt);
+			// Enforce registration of samples in extraFts.
+			extraFts.put(gt.getSampleName(), new ArrayList<>());
 
-			List<String> extraFts = new ArrayList<>();
+			GenotypeBuilder gtBuilder = new GenotypeBuilder(gt);
 
 			// Get de novo allele, null if not de novo
 			final Allele deNovoAllele = getDeNovoAllele(vc, gt.getSampleName());
-			gtBuilder.attribute(PedigreeFilterHeaderExtender.FORMAT_GT_DE_NOVO,
-					(deNovoAllele != null) ? "Y" : "N");
-
 			if (deNovoAllele != null) {
+				final List<String> sampleFts = extraFts.get(gt.getSampleName());
+
 				// Add flag for support in parent above threshold
 				if (deNovoGtSharedWithSibling(vc, gt.getSampleName(), deNovoAllele)) {
-					extraFts.add(PedigreeFilterHeaderExtender.FILTER_GT_DE_NOVO_IN_SIBLING);
+					sampleFts.add(PedigreeFilterHeaderExtender.FILTER_GT_DE_NOVO_IN_SIBLING);
 				}
 
 				// Add flag with support in parents
-				final int maxCountInParent = getMaxCountInParents(vc, gt.getSampleName(),
-						deNovoAllele);
+				final int maxCountInParent =
+						getMaxCountInParents(vc, gt.getSampleName(), deNovoAllele);
 				if (maxCountInParent > options.getDeNovoMaxParentAd2()) {
-					extraFts.add(PedigreeFilterHeaderExtender.FILTER_GT_DE_NOVO_PARENT_AD2);
+					sampleFts.add(PedigreeFilterHeaderExtender.FILTER_GT_DE_NOVO_PARENT_AD2);
 				}
 			}
 
-			if (!extraFts.isEmpty()) {
+		}
+
+		// Then, add "is parent filtered" if enabled.
+		if (options.isApplyParentGtFilteredFilters()) {
+			for (Genotype gt : vc.getGenotypes()) {
+				final int count = filteredParentGtCount(vc, extraFts, gt.getSampleName());
+				final List<String> sampleFts = extraFts.get(gt.getSampleName());
+				if (count == 1) {
+					sampleFts.add(PedigreeFilterHeaderExtender.FILTER_GT_ONE_PARENT_FILTERED);
+				} else if (count == 2) {
+					sampleFts.add(PedigreeFilterHeaderExtender.FILTER_GT_BOTH_PARENTS_FILTERED);
+				}
+			}
+		}
+
+		// Build final Genotype objects, also incorporating existing genotype filters.
+		for (Genotype gt : vc.getGenotypes()) {
+			GenotypeBuilder gtBuilder = new GenotypeBuilder(gt);
+			if (!extraFts.get(gt.getSampleName()).isEmpty()) {
 				if (gt.isFiltered()) {
-					extraFts.add(0, gt.getFilters());
+					extraFts.get(gt.getSampleName()).add(0, gt.getFilters());
 				}
-				gtBuilder.filters(extraFts);
+				gtBuilder.filters(extraFts.get(gt.getSampleName()));
+			}
+
+			final Allele deNovoAllele = getDeNovoAllele(vc, gt.getSampleName());
+			gtBuilder.attribute(PedigreeFilterHeaderExtender.FORMAT_GT_DE_NOVO,
+					(deNovoAllele != null) ? "Y" : "N");
+
+			if (areParentsRef(vc, gt.getSampleName())) {
+				gtBuilder.attribute(PedigreeFilterHeaderExtender.FORMAT_PARENTS_REF, "Y");
 			}
 
 			gts.add(gtBuilder.make());
@@ -98,7 +127,71 @@ public VariantContext annotateVariantContext(VariantContext vc) {
 		return gts;
 	}
 
-	// TODO(holtgrewe): right now, only works for GATK
+	/**
+	 * Query whether parents show reference allele.
+	 *
+	 * @param vc {@link VariantContext} to check.
+	 * @param sampleName Name of the sample to check.
+	 * @return {@code true} if the parents are reference homozygous, {@code false} otherwise.
+	 */
+	private boolean areParentsRef(VariantContext vc, String sampleName) {
+		final Person person = this.pedigree.getNameToMember().get(sampleName).getPerson();
+
+		if (person.getFather() == null) {
+			return false;
+		}
+		final Genotype gtFather = vc.getGenotype(person.getFather().getName());
+		if (gtFather == null || !gtFather.isHomRef()) {
+			return false;
+		}
+
+		if (person.getMother() == null) {
+			return false;
+		}
+		final Genotype gtMother = vc.getGenotype(person.getMother().getName());
+		if (gtMother == null || !gtMother.isHomRef()) {
+			return false;
+		}
+
+		return true;
+	}
+
+	/**
+	 * Return number of filtered genotypes in parents of {@code sampleName}.
+	 *
+	 * @param vc {@link VariantContext} with the variant.
+	 * @param extraFts Additional filters to add for each sample name.
+	 * @param sampleName The name of the child to consider.
+	 * @return The number of parents with filtered VC.
+	 */
+	private int filteredParentGtCount(VariantContext vc, Map<String, List<String>> extraFts,
+			String sampleName) {
+		final Person person = this.pedigree.getNameToMember().get(sampleName).getPerson();
+
+		final int valFather;
+		if (person.getFather() != null) {
+			final String fatherName = person.getFather().getName();
+			final Genotype gtFather = vc.getGenotype(fatherName);
+			valFather = (gtFather != null
+					&& (gtFather.isFiltered() || !extraFts.get(fatherName).isEmpty())) ? 1 : 0;
+		} else {
+			valFather = 0;
+		}
+
+		final int valMother;
+		if (person.getMother() != null) {
+			final String motherName = person.getMother().getName();
+			final Genotype gtMother = vc.getGenotype(motherName);
+			valMother = (gtMother != null
+					&& (gtMother.isFiltered() || !extraFts.get(motherName).isEmpty())) ? 1 : 0;
+		} else {
+			valMother = 0;
+		}
+
+		return valFather + valMother;
+	}
+
+	// TODO(holtgrewe): right now only works for GATK
 	private int getMaxCountInParents(VariantContext vc, String sampleName, Allele deNovoAllele) {
 		final int alleleIdx = vc.getAlleleIndex(deNovoAllele);
 
@@ -111,7 +204,7 @@ private int getMaxCountInParents(VariantContext vc, String sampleName, Allele de
 
 		int result = 0;
 
-		for (int[] ad : new int[][] { adFather, adMother }) {
+		for (int[] ad : new int[][] {adFather, adMother}) {
 			if (ad != null && ad.length > alleleIdx) {
 				result = Math.max(result, ad[alleleIdx]);
 			}
@@ -126,8 +219,8 @@ private boolean deNovoGtSharedWithSibling(VariantContext vc, String sampleName,
 		final Person index = this.pedigree.getNameToMember().get(sampleName).getPerson();
 
 		final PedigreeQueryDecorator pedigreeDecorator = new PedigreeQueryDecorator(pedigree);
-		final ImmutableMap<Person, ImmutableList<Person>> siblings = pedigreeDecorator
-				.buildSiblings();
+		final ImmutableMap<Person, ImmutableList<Person>> siblings =
+				pedigreeDecorator.buildSiblings();
 		for (Person sibling : siblings.get(index)) {
 			final Genotype gtSibling = vc.getGenotype(sibling.getName());
 			if (gtSibling.countAllele(deNovoAllele) != 0) {
@@ -141,23 +234,22 @@ private boolean deNovoGtSharedWithSibling(VariantContext vc, String sampleName,
 	/**
 	 * Get de novo allele in <code>sampleName</code> or <code>null</code> if there is none
 	 *
-	 * @param vc
-	 *            {@link VarianContext} to query
-	 * @param sampleName
-	 *            Name of the sample
+	 * @param vc {@link VarianContext} to query
+	 * @param sampleName Name of the sample
 	 * @return De novo allele
 	 */
 	private Allele getDeNovoAllele(VariantContext vc, String sampleName) {
 		final Person person = this.pedigree.getNameToMember().get(sampleName).getPerson();
-		if (person.getFather() == null || person.getMother() == null)
-			return null; // cannot make any judgement
+		if (person.getFather() == null || person.getMother() == null) return null; // cannot make
+																					// any judgement
 		final Genotype gtPerson = vc.getGenotype(sampleName);
 		final Genotype gtFather = vc.getGenotype(person.getFather().getName());
 		final Genotype gtMother = vc.getGenotype(person.getMother().getName());
-		if (gtPerson.isNoCall() || gtFather.isNoCall() || gtMother.isNoCall())
-			return null; // cannot make any judgement
-		if (!gtPerson.isHet())
-			return null; // impossible or too unlikely
+		if (gtPerson.isNoCall() || gtFather.isNoCall() || gtMother.isNoCall()) return null; // cannot
+																							// make
+																							// any
+																							// judgement
+		if (!gtPerson.isHet()) return null; // impossible or too unlikely
 		// Count non-reference alleles not yet seen in parents. Should be exactly one.
 		final Set<Allele> personAlleles = new HashSet<>(gtPerson.getAlleles());
 		personAlleles.remove(vc.getReference());
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterHeaderExtender.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterHeaderExtender.java
index 3b57f1b2ca..302b5df465 100755
--- a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterHeaderExtender.java
+++ b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterHeaderExtender.java
@@ -21,6 +21,15 @@
 	/** Whether or not a genotype look de novo */
 	public static String FORMAT_GT_DE_NOVO = "DN";
 
+	/** Whether or not parents are reference */
+	public static String FORMAT_PARENTS_REF = "PR";
+
+	/** One parent was filtered out. */
+	public static String FILTER_GT_ONE_PARENT_FILTERED = "OneParentGtFiltered";
+
+	/** Both parents were filtered out. */
+	public static String FILTER_GT_BOTH_PARENTS_FILTERED = "BothParentsGtFiltered";
+
 	/** Configuration */
 	private final PedigreeFilterOptions options;
 
@@ -31,8 +40,7 @@ public PedigreeFilterHeaderExtender(PedigreeFilterOptions options) {
 	/**
 	 * Add header entries.
 	 * 
-	 * @param header
-	 *            The {@link VCFHeader} to extend.
+	 * @param header The {@link VCFHeader} to extend.
 	 */
 	public void addHeaders(VCFHeader header) {
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_DE_NOVO_PARENT_AD2,
@@ -44,6 +52,20 @@ public void addHeaders(VCFHeader header) {
 		header.addMetaDataLine(
 				new VCFFormatHeaderLine(FORMAT_GT_DE_NOVO, 1, VCFHeaderLineType.Character,
 						"Whether the variant looks de novo by genotype, one of {'Y', 'N'}."));
+		header.addMetaDataLine(
+				new VCFFormatHeaderLine(FORMAT_PARENTS_REF, 1, VCFHeaderLineType.Character,
+						"Whether both parent's genotype is reference, one of {'Y', 'N'}."));
+
+		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_ONE_PARENT_FILTERED,
+				"One parent was filtered or no-call, filter child as well, important for inheritance "
+						+ "filtration as filtered variants count as no-call which counts as "
+						+ "wild-card by default; \"one/both parents filtered\" don't count. (enabled: "
+						+ options.isApplyParentGtFilteredFilters() + ")"));
+		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_BOTH_PARENTS_FILTERED,
+				"Both parents are filtered or no-call, filter child as well, important for inheritance "
+						+ "filtration as filtered variants count as no-call which counts as "
+						+ "wild-card by default; \"one/both parents filtered\" don't count. (enabled: "
+						+ options.isApplyParentGtFilteredFilters() + ")"));
 	}
 
 }
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterOptions.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterOptions.java
index f98db3a40e..0a30ff0777 100755
--- a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterOptions.java
+++ b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/PedigreeFilterOptions.java
@@ -7,27 +7,40 @@
  */
 public class PedigreeFilterOptions {
 
+
+	public static PedigreeFilterOptions buildDefaultOptions() {
+		return new PedigreeFilterOptions(1, true);
+	}
+
 	/**
 	 * Maximal allelic depth of alternative allele to tolerate in parent before
 	 * flagging with ParentAd2.
 	 */
 	private final int deNovoMaxParentAd2;
 
-	public PedigreeFilterOptions(int deNovoMaxParentAd2) {
-		this.deNovoMaxParentAd2 = deNovoMaxParentAd2;
-	}
+	/**
+	 * Whether or not to apply {@code OneParentGtFiltered} and {@code BothParentGtFiltered} genotype filter. 
+	 */
+	private final boolean applyParentGtFilteredFilters;
 
-	public int getDeNovoMaxParentAd2() {
-		return deNovoMaxParentAd2;
+
+	public PedigreeFilterOptions(int deNovoMaxParentAd2, boolean applyParentGtFilteredFilters) {
+		this.deNovoMaxParentAd2 = deNovoMaxParentAd2;
+		this.applyParentGtFilteredFilters = applyParentGtFilteredFilters;
 	}
 
 	@Override
 	public String toString() {
-		return "PedigreeFilterOptions [deNovoMaxParentAd2=" + deNovoMaxParentAd2 + "]";
+		return "PedigreeFilterOptions [deNovoMaxParentAd2=" + deNovoMaxParentAd2
+				+ ", applyParentGtFilteredFilters=" + applyParentGtFilteredFilters + "]";
 	}
 
-	public static PedigreeFilterOptions buildDefaultOptions() {
-		return new PedigreeFilterOptions(1);
+	public int getDeNovoMaxParentAd2() {
+		return deNovoMaxParentAd2;
+	}
+
+	public boolean isApplyParentGtFilteredFilters() {
+		return applyParentGtFilteredFilters;
 	}
 
 }
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterAnnotator.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterAnnotator.java
deleted file mode 100755
index a0267e3fab..0000000000
--- a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterAnnotator.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package de.charite.compbio.jannovar.filter.facade;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import com.google.common.collect.ImmutableList;
-
-import de.charite.compbio.jannovar.filter.impl.gt.GenotypeFilterAnnotator;
-import de.charite.compbio.jannovar.filter.impl.var.VariantFilterAnnotator;
-import htsjdk.variant.variantcontext.Genotype;
-import htsjdk.variant.variantcontext.VariantContext;
-import htsjdk.variant.variantcontext.VariantContextBuilder;
-
-/**
- * Perform annotation (sof-filtering) based on coverage/alternative allele
- * fraction/genotype call quality
- *
- * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
- */
-public class ThresholdFilterAnnotator {
-
-	/** Configuration for the threshold-based filter */
-	private final ThresholdFilterOptions options;
-
-	/**
-	 * Names of samples of affected individuals; used for pushing information
-	 * from genotype-level to variant level
-	 */
-	private final ImmutableList<String> affecteds;
-
-	/** Helper for genotype-wide application of filters */
-	private final GenotypeFilterAnnotator gtAnnotator;
-
-	/** Helper for pushing genotype-based filters to variant-wise ones */
-	private final VariantFilterAnnotator varAnnotator;
-
-	public ThresholdFilterAnnotator(ThresholdFilterOptions options, Collection<String> affected) {
-		this.options = options;
-		this.affecteds = ImmutableList.copyOf(affected);
-		this.gtAnnotator = new GenotypeFilterAnnotator(this.options);
-		this.varAnnotator = new VariantFilterAnnotator(this.options, this.affecteds);
-	}
-
-	/**
-	 * Annotate VariantContext with the threshold-based filters
-	 *
-	 * @param vc
-	 *            the {@link VariantContext} to annotate
-	 * @return copy of <code>vc</code> with applied annotations
-	 */
-	public VariantContext annotateVariantContext(VariantContext vc) {
-		VariantContextBuilder builder = new VariantContextBuilder(vc);
-		List<Genotype> gts = annotateGenotypes(builder, vc);
-		varAnnotator.annotateVariant(builder, vc, gts);
-		return builder.make();
-	}
-
-	/**
-	 * Annotate <code>vc</code> and return modified object
-	 * 
-	 * @param builder
-	 *            the {@link VariantContextBuilder} used for building variant
-	 * @param vc
-	 *            the {@link VariantContext} to base builder configuration upon
-	 * @param affected
-	 *            names of the samples from affected individuals
-	 * @return modified <code>vc</code> object
-	 */
-	VariantContextBuilder annotate(VariantContextBuilder builder, VariantContext vc) {
-		List<Genotype> gts = annotateGenotypes(builder, vc);
-		varAnnotator.annotateVariant(builder, vc, gts);
-		return builder;
-	}
-
-	/**
-	 * Annotate genotypes individually in <code>vc</code>
-	 * 
-	 * @param builder
-	 *            the {@link VariantContextBuilder} used for building variant
-	 * @param vc
-	 *            {@link VariantContext} to annotate
-	 * @return {@link List} of genotypes after annotation
-	 */
-	private List<Genotype> annotateGenotypes(VariantContextBuilder builder, VariantContext vc) {
-		ArrayList<Genotype> gts = new ArrayList<>();
-		for (Genotype gt : vc.getGenotypes())
-			gts.add(gtAnnotator.gtWithAppliedFilters(gt));
-		builder.genotypes(gts);
-		return gts;
-	}
-
-}
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterHeaderExtender.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterHeaderExtender.java
index e9f8defb94..ba38469d21 100755
--- a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterHeaderExtender.java
+++ b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/facade/ThresholdFilterHeaderExtender.java
@@ -31,6 +31,11 @@
 	/** Minimal alternative allele fraction for hom ref */
 	public static String FILTER_GT_MAX_AAF_HOM_REF = "MaxAafHomRef";
 
+	/** One parent was filtered out. */
+	public static String FILTER_GT_ONE_PARENT_FILTERED = "OneParentGtFiltered";
+	/** Both parents were filtered out. */
+	public static String FILTER_GT_BOTH_PARENTS_FILTERED = "BothParentsGtFiltered";
+
 	// Variant-wise filter strings
 
 	/** All affected individual's genotypes are filtered */
@@ -52,28 +57,27 @@ public ThresholdFilterHeaderExtender(ThresholdFilterOptions options) {
 	/**
 	 * Add header entries.
 	 * 
-	 * @param header
-	 *            The {@link VCFHeader} to extend.
+	 * @param header The {@link VCFHeader} to extend.
 	 */
 	public void addHeaders(VCFHeader header) {
-		if (!header.hasFormatLine("FT"))
-			header.addMetaDataLine(
-					new VCFFormatHeaderLine("FT", 1, VCFHeaderLineType.String, "Filters applied to genotype call"));
+		if (!header.hasFormatLine("FT")) header.addMetaDataLine(new VCFFormatHeaderLine("FT", 1,
+				VCFHeaderLineType.String, "Filters applied to genotype call"));
 
-		header.addMetaDataLine(
-				new VCFFilterHeaderLine(FILTER_GT_MAX_COV, "Genotype has coverage >" + options.getMaxCov()));
+		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MAX_COV,
+				"Genotype has coverage >" + options.getMaxCov()));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MIN_COV_HET,
 				"Het. genotype call has coverage <" + options.getMinGtCovHet()));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MIN_COV_HOM_ALT,
 				"Hom. alt genotype call has coverage <" + options.getMinGtCovHomAlt()));
-		header.addMetaDataLine(
-				new VCFFilterHeaderLine(FILTER_GT_MIN_GQ, "Genotype has quality (GQ) <" + options.getMinGtGq()));
+		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MIN_GQ,
+				"Genotype has quality (GQ) <" + options.getMinGtGq()));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MIN_AAF_HET,
 				"Het. genotype has alternative allele fraction <" + options.getMinGtAafHet()));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MAX_AAF_HET,
 				"Het. genotype has alternative allele fraction >" + options.getMaxGtAafHet()));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MIN_AAF_HOM_ALT,
-				"Hom. alt genotype has alternative allele fraction <" + options.getMinGtAafHomAlt()));
+				"Hom. alt genotype has alternative allele fraction <"
+						+ options.getMinGtAafHomAlt()));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_GT_MAX_AAF_HOM_REF,
 				"Wild-type genotype has AAF >" + options.getMaxGtAafHomRef()));
 
@@ -81,9 +85,14 @@ public void addHeaders(VCFHeader header) {
 				"The genotype calls of all affected individuals have been filtered for this variant."));
 
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_VAR_MAX_FREQUENCY_AD,
-				"Variant frequency >" + options.getMaxAlleleFrequencyAd() + " (threshold for AD inheritance)"));
+				"Variant frequency >" + options.getMaxAlleleFrequencyAd()
+						+ " (threshold for AD inheritance), variant will be annotated with "
+						+ "compatibility with dominant inheritance regardlessly"));
 		header.addMetaDataLine(new VCFFilterHeaderLine(FILTER_VAR_MAX_FREQUENCY_AR,
-				"Variant frequency >" + options.getMaxAlleleFrequencyAd() + " (threshold for AR inheritance)"));
+				"Variant frequency >" + options.getMaxAlleleFrequencyAd()
+						+ " (threshold for AR inheritance), variant will not be considered for "
+						+ "composite recessive inheritance but for homozygous recessive inheritance "
+						+ "regardlessly"));
 	}
 
 }
diff --git a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/impl/var/VariantFilterAnnotator.java b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/impl/var/VariantThresholdFilterAnnotator.java
similarity index 86%
rename from jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/impl/var/VariantFilterAnnotator.java
rename to jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/impl/var/VariantThresholdFilterAnnotator.java
index ceb5aebe10..cc79f32f4b 100755
--- a/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/impl/var/VariantFilterAnnotator.java
+++ b/jannovar-filter/src/main/java/de/charite/compbio/jannovar/filter/impl/var/VariantThresholdFilterAnnotator.java
@@ -1,25 +1,24 @@
 package de.charite.compbio.jannovar.filter.impl.var;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.NoSuchElementException;
-
 import com.google.common.collect.ImmutableList;
-
 import de.charite.compbio.jannovar.filter.facade.ThresholdFilterHeaderExtender;
 import de.charite.compbio.jannovar.filter.facade.ThresholdFilterOptions;
 import htsjdk.variant.variantcontext.Genotype;
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.NoSuchElementException;
 
 /**
- * Class for pushing genotype-based filters to the variant level
+ * Class for pushing genotype-based filters to the variant level, also consider population
+ * frequencies.
  *
  * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
  */
-public class VariantFilterAnnotator {
+public class VariantThresholdFilterAnnotator {
 
 	/** Configuration for threshold-based filter */
 	private final ThresholdFilterOptions options;
@@ -30,30 +29,28 @@
 	 */
 	private final ImmutableList<String> affecteds;
 
-	public VariantFilterAnnotator(ThresholdFilterOptions options, ImmutableList<String> affecteds) {
+	public VariantThresholdFilterAnnotator(ThresholdFilterOptions options,
+			List<String> affecteds) {
 		this.options = options;
-		this.affecteds = affecteds;
+		this.affecteds = ImmutableList.copyOf(affecteds);
 	}
 
 	/**
 	 * Annotate FILTER of <code>vc</code> with genotype-based filters and based on the list of
 	 * affected samples
 	 * 
-	 * @param builder
-	 *            {@link VariantContextBuilder} to create new variant context for
-	 * @param vc
-	 *            {@link VariantContext} to annotate
-	 * @param gts
-	 *            Updated genotypes with filter annotation
+	 * @param builder {@link VariantContextBuilder} to create new variant context for
+	 * @param vc {@link VariantContext} to annotate
 	 * @return reference to <code>builder</code> after the update
 	 */
-	public VariantContextBuilder annotateVariant(VariantContextBuilder builder, VariantContext vc,
-			List<Genotype> gts) {
+	public VariantContext annotateVariantContext(VariantContext vc) {
+		VariantContextBuilder builder = new VariantContextBuilder(vc);
+		
 		// If all genotype calls are filtered out then add filter to variant-level FILTER column
 		HashSet<String> filters = new HashSet<String>(vc.getFilters());
 		if (!affecteds.isEmpty()) {
 			HashSet<String> unfilteredAffecteds = new HashSet<>(affecteds);
-			for (Genotype gt : gts)
+			for (Genotype gt : vc.getGenotypes())
 				if (affecteds.contains(gt.getSampleName()) && gt.isFiltered())
 					unfilteredAffecteds.remove(gt.getSampleName());
 			if (unfilteredAffecteds.isEmpty())
@@ -101,7 +98,7 @@ public VariantContextBuilder annotateVariant(VariantContextBuilder builder, Vari
 		}
 
 		builder.filters(filters);
-		return builder;
+		return builder.make();
 	}
 
 }
diff --git a/jannovar-filter/src/test/java/de/charite/compbio/jannovar/filter/impl/facade/TresholdFilterAnnotatorTest.java b/jannovar-filter/src/test/java/de/charite/compbio/jannovar/filter/impl/facade/TresholdFilterAnnotatorTest.java
index 9d3ccecc74..61d984290e 100755
--- a/jannovar-filter/src/test/java/de/charite/compbio/jannovar/filter/impl/facade/TresholdFilterAnnotatorTest.java
+++ b/jannovar-filter/src/test/java/de/charite/compbio/jannovar/filter/impl/facade/TresholdFilterAnnotatorTest.java
@@ -1,18 +1,12 @@
 package de.charite.compbio.jannovar.filter.impl.facade;
 
-import java.util.ArrayList;
-
+import de.charite.compbio.jannovar.filter.facade.GenotypeThresholdFilterAnnotator;
+import de.charite.compbio.jannovar.filter.facade.ThresholdFilterOptions;
+import htsjdk.variant.variantcontext.VariantContext;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import com.google.common.collect.Lists;
-
-import de.charite.compbio.jannovar.filter.facade.ThresholdFilterAnnotator;
-import de.charite.compbio.jannovar.filter.facade.ThresholdFilterOptions;
-import htsjdk.variant.variantcontext.VariantContext;
-import htsjdk.variant.variantcontext.VariantContextBuilder;
-
 /**
  * Test for ThresholdFilterAnnotator
  *
@@ -20,12 +14,12 @@
  */
 public class TresholdFilterAnnotatorTest extends TresholdFilterTestBase {
 
-	ThresholdFilterAnnotator annotator;
+	GenotypeThresholdFilterAnnotator annotator;
 
 	@Before
 	public void setUp() {
-		ArrayList<String> affected = Lists.newArrayList("individual");
-		annotator = new ThresholdFilterAnnotator(ThresholdFilterOptions.buildDefaultOptions(), affected);
+		annotator =
+				new GenotypeThresholdFilterAnnotator(ThresholdFilterOptions.buildDefaultOptions());
 	}
 
 	/**
@@ -39,7 +33,7 @@ public void testAnnotateVariant() throws Exception {
 
 		VariantContext updatedVC = annotator.annotateVariantContext(variant);
 
-		Assert.assertEquals("[AllAffGtFiltered]", updatedVC.getFilters().toString());
+		Assert.assertEquals("[]", updatedVC.getFilters().toString());
 		Assert.assertEquals(
 				"[VC Unknown @ 1:17452 Q35.74 of type=SNP alleles=[G*, A] attr={} "
 						+ "GT=[[individual G*/A GQ 10 DP 5 AD 4,0 PL 63,6,0 FT MinAafHet;MinCovHet;MinGq]]",
diff --git a/jannovar-hgvs/pom.xml b/jannovar-hgvs/pom.xml
index 6350821422..e750d07d80 100755
--- a/jannovar-hgvs/pom.xml
+++ b/jannovar-hgvs/pom.xml
@@ -24,13 +24,13 @@
 		<dependency>
 			<groupId>com.google.guava</groupId>
 			<artifactId>guava</artifactId>
-			<version>19.0</version>
+			<version>${guava.version}</version>
 		</dependency>
 		<!-- Antlr4 runtime -->
 		<dependency>
 			<groupId>org.antlr</groupId>
 			<artifactId>antlr4-runtime</artifactId>
-			<version>4.5.1-1</version>
+			<version>${antlr.version}</version>
 		</dependency>
 	</dependencies>
 
diff --git a/jannovar-htsjdk/pom.xml b/jannovar-htsjdk/pom.xml
index 55d7a2fcd4..efd6192630 100755
--- a/jannovar-htsjdk/pom.xml
+++ b/jannovar-htsjdk/pom.xml
@@ -32,7 +32,7 @@
         <dependency>
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
-            <version>19.0</version>
+            <version>${guava.version}</version>
         </dependency>
         <dependency>
             <groupId>com.github.samtools</groupId>
diff --git a/jannovar-htsjdk/src/main/java/de/charite/compbio/jannovar/mendel/bridge/VariantContextMendelianAnnotator.java b/jannovar-htsjdk/src/main/java/de/charite/compbio/jannovar/mendel/bridge/VariantContextMendelianAnnotator.java
index a1ead3b48e..73d92176a4 100755
--- a/jannovar-htsjdk/src/main/java/de/charite/compbio/jannovar/mendel/bridge/VariantContextMendelianAnnotator.java
+++ b/jannovar-htsjdk/src/main/java/de/charite/compbio/jannovar/mendel/bridge/VariantContextMendelianAnnotator.java
@@ -33,23 +33,29 @@
 import htsjdk.variant.variantcontext.VariantContextBuilder;
 
 /**
- * Helper class for annotating one {@link VariantContext} or a {@link Collection} thereof for compatibility with
- * Mendelian inheritance
+ * Helper class for annotating one {@link VariantContext} or a
+ * {@link Collection} thereof for compatibility with Mendelian inheritance
  * 
  * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
  */
 public class VariantContextMendelianAnnotator {
 
 	// Known variant-wise filters
-	private final static ImmutableSet<String> VAR_FILTERS = ImmutableSet.of("AllAffGtFiltered", "MaxFreqAd",
-			"MaxFreqAr", "OffExome");
-	private final static ImmutableSet<String> VAR_FILTERS_AD = ImmutableSet.of("MaxFreqAd");
-	private final static ImmutableSet<String> VAR_FILTERS_AR = ImmutableSet.of("MaxFreqAr");
+	private final static ImmutableSet<String> VAR_FILTERS = ImmutableSet
+			.of("AllAffGtFiltered", "MaxFreqAd", "MaxFreqAr", "OffExome");
+	private final static ImmutableSet<String> VAR_FILTERS_AD =
+			ImmutableSet.of("MaxFreqAd");
+	private final static ImmutableSet<String> VAR_FILTERS_AR =
+			ImmutableSet.of("MaxFreqAr");
 	// Known genotype-wise filters
-	private final static ImmutableSet<String> GT_FILTERS = ImmutableSet.of("MaxCov", "MinGq");
-	private final static ImmutableSet<String> GT_FILTERS_HOM_REF = ImmutableSet.of("MinAafHomRef");
-	private final static ImmutableSet<String> GT_FILTERS_HOM_ALT = ImmutableSet.of("MinCovHomAlt", "MinAafHomAlt");
-	private final static ImmutableSet<String> GT_FILTERS_HET = ImmutableSet.of("MinCovHet", "MinAafHet", "MaxAafHet");
+	private final static ImmutableSet<String> GT_FILTERS =
+			ImmutableSet.of("MaxCov", "MinGq");
+	private final static ImmutableSet<String> GT_FILTERS_HOM_REF =
+			ImmutableSet.of("MinAafHomRef");
+	private final static ImmutableSet<String> GT_FILTERS_HOM_ALT =
+			ImmutableSet.of("MinCovHomAlt", "MinAafHomAlt");
+	private final static ImmutableSet<String> GT_FILTERS_HET =
+			ImmutableSet.of("MinCovHet", "MinAafHet", "MaxAafHet");
 
 	/** Pedigree to use for checking for Mendelian compatibility */
 	private final Pedigree pedigree;
@@ -60,8 +66,8 @@
 	/** Whether or not to interpret variant-wise filters */
 	boolean interpretVariantFilters;
 
-	public VariantContextMendelianAnnotator(Pedigree pedigree, boolean interpretGenotypeFilters,
-			boolean interpretVariantFilters) {
+	public VariantContextMendelianAnnotator(Pedigree pedigree,
+			boolean interpretGenotypeFilters, boolean interpretVariantFilters) {
 		this.pedigree = pedigree;
 		this.mendelChecker = new MendelianInheritanceChecker(this.pedigree);
 		this.interpretGenotypeFilters = interpretGenotypeFilters;
@@ -69,80 +75,62 @@ public VariantContextMendelianAnnotator(Pedigree pedigree, boolean interpretGeno
 	}
 
 	/**
-	 * Annotate {@link VariantContext} with compatibility for Mendelian inheritance
+	 * Annotate {@link VariantContext} with compatibility for Mendelian
+	 * inheritance
 	 * 
 	 * @param vc
-	 *            {@link VariantContext} to check for compatibility and to annotate
-	 * @return Copy of <code>vc</code> with mendelian inheritance compatibility annotation
+	 *            {@link VariantContext} to check for compatibility and to
+	 *            annotate
+	 * @return Copy of <code>vc</code> with mendelian inheritance compatibility
+	 *         annotation
 	 * @throws CannotAnnotateMendelianInheritance
 	 *             on problems with annotating the {@link VariantContext}
 	 */
-	public VariantContext annotateRecord(VariantContext vc) throws CannotAnnotateMendelianInheritance {
+	public VariantContext annotateRecord(VariantContext vc)
+			throws CannotAnnotateMendelianInheritance {
 		return annotateRecords(ImmutableList.of(vc)).get(0);
 	}
 
 	/**
 	 * Annotate {@link List} of {@link VariantContext} objects
 	 * 
-	 * If <code>self.interpretVariantFilters</code> then the variant contexts to be considered for compound heterozygous
-	 * will be prefiltered to those with appropriately high frequency and not being annotated as synonymous variant.
+	 * If <code>self.interpretVariantFilters</code> then the variant contexts to
+	 * be considered for compound heterozygous will be prefiltered to those with
+	 * appropriately high frequency and not being annotated as synonymous
+	 * variant.
 	 * 
 	 * @param vcs
 	 *            {@link VariantContext} objects to annotate
-	 * @return An {@link ImmutableList} of {@link VariantContext} copies of <code>vcs</code>
+	 * @return An {@link ImmutableList} of {@link VariantContext} copies of
+	 *         <code>vcs</code>
 	 * @throws CannotAnnotateMendelianInheritance
 	 *             on problems with annotating the {@link VariantContext}s
 	 */
-	public ImmutableList<VariantContext> annotateRecords(List<VariantContext> vcs)
+	public ImmutableList<VariantContext> annotateRecords(
+			List<VariantContext> vcs)
 			throws CannotAnnotateMendelianInheritance {
-		// TODO: filter for synonymous variant currently broken if annotating with all variants... :(
-		final String synonymous = VariantEffect.SYNONYMOUS_VARIANT.getSequenceOntologyTerm();
-
-		// Filter functor for recessive filtration
-		Predicate<VariantContext> keepFreqRecessive;
-		if (interpretVariantFilters) {
-			keepFreqRecessive = vc -> {
-				return !isFiltered(vc.getFilters(), VAR_FILTERS, VAR_FILTERS_AR)
-						&& !vc.getAttributeAsString("ANN", "").contains(synonymous);
-			};
-		} else {
-			keepFreqRecessive = vc -> true;
+		// Super-ugly mapping from variant context to index in vcs
+		Map<Integer, Integer> identityToIndex = new HashMap<>();
+		for (int i = 0; i < vcs.size(); i++) {
+			identityToIndex.put(System.identityHashCode(vcs.get(i)), i);
 		}
 
-		// Create mapping from MOH to genotype calls and pre-filter if configured to do so
-		HashMap<SubModeOfInheritance, List<GenotypeCalls>> origCalls = new HashMap<>();
-		final List<GenotypeCalls> allCalls = buildGenotypeCalls(vcs);
-		final List<GenotypeCalls> recessiveCalls = buildGenotypeCalls(
-				vcs.stream().filter(keepFreqRecessive).collect(Collectors.toList()));
-		origCalls.put(SubModeOfInheritance.AUTOSOMAL_DOMINANT, allCalls);
-		origCalls.put(SubModeOfInheritance.X_DOMINANT, allCalls);
-		origCalls.put(SubModeOfInheritance.AUTOSOMAL_RECESSIVE_COMP_HET, recessiveCalls);
-		origCalls.put(SubModeOfInheritance.AUTOSOMAL_RECESSIVE_HOM_ALT, allCalls);
-		origCalls.put(SubModeOfInheritance.X_RECESSIVE_COMP_HET, recessiveCalls);
-		origCalls.put(SubModeOfInheritance.X_RECESSIVE_HOM_ALT, allCalls);
-
-		// Filter to compatible records
-		HashMap<SubModeOfInheritance, List<GenotypeCalls>> filteredGenotypeCalls = new HashMap<>();
-		try {
-			for (Entry<SubModeOfInheritance, List<GenotypeCalls>> e : origCalls.entrySet())
-				filteredGenotypeCalls.put(e.getKey(),
-						mendelChecker.filterCompatibleRecordsSub(e.getValue(), e.getKey()));
-		} catch (IncompatiblePedigreeException e) {
-			throw new CannotAnnotateMendelianInheritance(
-					"Problem with annotating VariantContext for Mendelian inheritance.", e);
-		}
+		// Compute compatible sub types
+		ImmutableMap<SubModeOfInheritance, ImmutableList<VariantContext>> compatibleSubModes =
+				computeCompatibleInheritanceSubModes(vcs);
 
 		// Build map of compatible Mendelian inheritance modes for each record
 		HashMap<Integer, Set<String>> map = new HashMap<>();
 		HashMap<Integer, Set<String>> subMap = new HashMap<>();
-		for (Entry<SubModeOfInheritance, List<GenotypeCalls>> e : filteredGenotypeCalls.entrySet()) {
-			final SubModeOfInheritance mode = e.getKey();
-			final List<GenotypeCalls> calls = e.getValue();
-			for (GenotypeCalls gc : calls) {
-				Integer key = (Integer) gc.getPayload();
+		for (Entry<SubModeOfInheritance, ImmutableList<VariantContext>> e : compatibleSubModes
+				.entrySet()) {
+			final SubModeOfInheritance subMode = e.getKey();
+			for (VariantContext vc : e.getValue()) {
+				int key = identityToIndex.get(System.identityHashCode(vc));
 				map.putIfAbsent(key, new TreeSet<String>());
 				subMap.putIfAbsent(key, new TreeSet<String>());
-				switch (mode) {
+
+				switch (subMode) {
 				case AUTOSOMAL_DOMINANT:
 					map.get(key).add("AD");
 					break;
@@ -170,49 +158,60 @@ public VariantContext annotateRecord(VariantContext vc) throws CannotAnnotateMen
 			}
 		}
 
-		// Construct extended VariantContext objects with INHERITED and INHERITANCE_RECESSIVE_DETAIL attributes
+		// Construct extended VariantContext objects with INHERITED and
+		// INHERITANCE_RECESSIVE_DETAIL attributes
 		ArrayList<VariantContextBuilder> vcBuilders = new ArrayList<>();
 		for (int i = 0; i < vcs.size(); ++i)
 			vcBuilders.add(new VariantContextBuilder(vcs.get(i)));
 		for (Entry<Integer, Set<String>> e : map.entrySet()) {
 			VariantContextBuilder vcBuilder = vcBuilders.get(e.getKey());
 			vcBuilder.attribute(MendelVCFHeaderExtender.key(), e.getValue());
-			vcBuilder.attribute(MendelVCFHeaderExtender.keySub(), subMap.get(e.getKey()));
+			vcBuilder.attribute(MendelVCFHeaderExtender.keySub(),
+					subMap.get(e.getKey()));
 		}
 
 		// Build final result list
-		ImmutableList.Builder<VariantContext> resultBuilder = new ImmutableList.Builder<>();
+		ImmutableList.Builder<VariantContext> resultBuilder =
+				new ImmutableList.Builder<>();
 		for (int i = 0; i < vcs.size(); ++i)
 			resultBuilder.add(vcBuilders.get(i).make());
 		return resultBuilder.build();
 	}
 
 	/**
-	 * Compute compatible modes of inheritance for a list of {@link VariantContext} objects
+	 * Compute compatible modes of inheritance for a list of
+	 * {@link VariantContext} objects
 	 * 
 	 * @param vcs
 	 *            {@link VariantContext} objects to check for compatibility
-	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of {@link VariantContext} in <code>vcs</code>
-	 *         that is compatible with each mode
+	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of
+	 *         {@link VariantContext} in <code>vcs</code> that is compatible
+	 *         with each mode
 	 * @throws CannotAnnotateMendelianInheritance
 	 *             on problems with annotating mendelian inheritance
 	 */
 	public ImmutableMap<ModeOfInheritance, ImmutableList<VariantContext>> computeCompatibleInheritanceModes(
-			List<VariantContext> vcs) throws CannotAnnotateMendelianInheritance {
+			List<VariantContext> vcs)
+			throws CannotAnnotateMendelianInheritance {
 		// Perform annotation, preceded by building GenotypeCalls list
 		List<GenotypeCalls> gcs = buildGenotypeCalls(vcs);
+		List<GenotypeCalls> recessiveGCs = buildRecessiveGenotypeCalls(vcs);
 		ImmutableMap<ModeOfInheritance, ImmutableList<GenotypeCalls>> checkResult;
 		try {
-			checkResult = mendelChecker.checkMendelianInheritance(gcs);
+			checkResult = mendelChecker.checkMendelianInheritance(gcs, recessiveGCs);
 		} catch (IncompatiblePedigreeException e) {
 			throw new CannotAnnotateMendelianInheritance(
-					"Problem with annotating VariantContext for Mendelian inheritance.", e);
+					"Problem with annotating VariantContext for Mendelian inheritance.",
+					e);
 		}
 
 		// Build final result
-		ImmutableMap.Builder<ModeOfInheritance, ImmutableList<VariantContext>> builder = new ImmutableMap.Builder<>();
-		for (Entry<ModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult.entrySet()) {
-			ImmutableList.Builder<VariantContext> listBuilder = new ImmutableList.Builder<>();
+		ImmutableMap.Builder<ModeOfInheritance, ImmutableList<VariantContext>> builder =
+				new ImmutableMap.Builder<>();
+		for (Entry<ModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult
+				.entrySet()) {
+			ImmutableList.Builder<VariantContext> listBuilder =
+					new ImmutableList.Builder<>();
 			for (GenotypeCalls gc : e.getValue())
 				listBuilder.add(vcs.get((Integer) gc.getPayload()));
 			builder.put(e.getKey(), listBuilder.build());
@@ -221,31 +220,39 @@ public VariantContext annotateRecord(VariantContext vc) throws CannotAnnotateMen
 	}
 
 	/**
-	 * Compute compatible modes of inheritance for a list of {@link VariantContext} objects
+	 * Compute compatible modes of inheritance for a list of
+	 * {@link VariantContext} objects
 	 * 
 	 * @param vcs
 	 *            {@link VariantContext} objects to check for compatibility
-	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of {@link VariantContext} in <code>vcs</code>
-	 *         that is compatible with each mode
+	 * @return A {@link Map} from {@link ModeOfInheritance} to the list of
+	 *         {@link VariantContext} in <code>vcs</code> that is compatible
+	 *         with each mode
 	 * @throws CannotAnnotateMendelianInheritance
 	 *             on problems with annotating mendelian inheritance
 	 */
 	public ImmutableMap<SubModeOfInheritance, ImmutableList<VariantContext>> computeCompatibleInheritanceSubModes(
-			List<VariantContext> vcs) throws CannotAnnotateMendelianInheritance {
+			List<VariantContext> vcs)
+			throws CannotAnnotateMendelianInheritance {
 		// Perform annotation, preceded by building GenotypeCalls list
 		List<GenotypeCalls> gcs = buildGenotypeCalls(vcs);
+		List<GenotypeCalls> recessiveGCs = buildRecessiveGenotypeCalls(vcs);
 		ImmutableMap<SubModeOfInheritance, ImmutableList<GenotypeCalls>> checkResult;
 		try {
-			checkResult = mendelChecker.checkMendelianInheritanceSub(gcs);
+			checkResult = mendelChecker.checkMendelianInheritanceSub(gcs, recessiveGCs);
 		} catch (IncompatiblePedigreeException e) {
 			throw new CannotAnnotateMendelianInheritance(
-					"Problem with annotating VariantContext for Mendelian inheritance.", e);
+					"Problem with annotating VariantContext for Mendelian inheritance.",
+					e);
 		}
 
 		// Build final result
-		ImmutableMap.Builder<SubModeOfInheritance, ImmutableList<VariantContext>> builder = new ImmutableMap.Builder<>();
-		for (Entry<SubModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult.entrySet()) {
-			ImmutableList.Builder<VariantContext> listBuilder = new ImmutableList.Builder<>();
+		ImmutableMap.Builder<SubModeOfInheritance, ImmutableList<VariantContext>> builder =
+				new ImmutableMap.Builder<>();
+		for (Entry<SubModeOfInheritance, ImmutableList<GenotypeCalls>> e : checkResult
+				.entrySet()) {
+			ImmutableList.Builder<VariantContext> listBuilder =
+					new ImmutableList.Builder<>();
 			for (GenotypeCalls gc : e.getValue())
 				listBuilder.add(vcs.get((Integer) gc.getPayload()));
 			builder.put(e.getKey(), listBuilder.build());
@@ -254,18 +261,22 @@ public VariantContext annotateRecord(VariantContext vc) throws CannotAnnotateMen
 	}
 
 	/**
-	 * Convert a {@link List} of {@link VariantContext} objects into a list of {@link GenotypeCalls} objects
+	 * Convert a {@link List} of {@link VariantContext} objects into a list of
+	 * {@link GenotypeCalls} objects
 	 * 
 	 * @param vcs
 	 *            input {@link Collection} of {@link VariantContext} objects
 	 * @return {@link List} of corresponding {@link GenotypeCalls} objects
 	 */
-	private List<GenotypeCalls> buildGenotypeCalls(Collection<VariantContext> vcs) {
+	private List<GenotypeCalls> buildGenotypeCalls(
+			Collection<VariantContext> vcs) {
 		ArrayList<GenotypeCalls> result = new ArrayList<>();
 
 		// Somewhat hacky but working inclusion of X and mitochondrial genomes
-		final ImmutableList<String> xNames = ImmutableList.of("x", "X", "23", "chrx", "chrX", "chr23");
-		final ImmutableList<String> mtNames = ImmutableList.of("m", "M", "mt", "MT", "chrm", "chrM", "chrmt", "chrMT");
+		final ImmutableList<String> xNames =
+				ImmutableList.of("x", "X", "23", "chrx", "chrX", "chr23");
+		final ImmutableList<String> mtNames = ImmutableList.of("m", "M", "mt",
+				"MT", "chrm", "chrM", "chrmt", "chrMT");
 
 		int i = 0;
 		for (VariantContext vc : vcs) {
@@ -286,26 +297,32 @@ else if (mtNames.contains(vc.getContig()))
 
 				boolean isFiltered = false;
 				if (gt.isHet()) {
-					if (interpretGenotypeFilters && isFiltered(gtFilters, GT_FILTERS, GT_FILTERS_HET))
+					if (interpretGenotypeFilters && isFiltered(gtFilters,
+							GT_FILTERS, GT_FILTERS_HET))
 						isFiltered = true;
 				} else if (gt.isHomRef()) {
-					if (interpretGenotypeFilters && isFiltered(gtFilters, GT_FILTERS, GT_FILTERS_HOM_REF))
+					if (interpretGenotypeFilters && isFiltered(gtFilters,
+							GT_FILTERS, GT_FILTERS_HOM_REF))
 						isFiltered = true;
-				} else { // hom-alt or two overlapping hets, treated the same for filtration
-					if (interpretGenotypeFilters && isFiltered(gtFilters, GT_FILTERS, GT_FILTERS_HOM_ALT))
+				} else { // hom-alt or two overlapping hets, treated the same
+						 // for filtration
+					if (interpretGenotypeFilters && isFiltered(gtFilters,
+							GT_FILTERS, GT_FILTERS_HOM_ALT))
 						isFiltered = true;
 				}
 
 				GenotypeBuilder gtBuilder = new GenotypeBuilder();
 				for (Allele allele : gt.getAlleles()) {
 					if (isFiltered) {
-						gtBuilder.getAlleleNumbers().add(de.charite.compbio.jannovar.mendel.Genotype.NO_CALL);
+						gtBuilder.getAlleleNumbers().add(
+								de.charite.compbio.jannovar.mendel.Genotype.NO_CALL);
 					} else {
 						final int aIDX = vc.getAlleleIndex(allele);
 						gtBuilder.getAlleleNumbers().add(aIDX);
 					}
 				}
-				builder.getSampleToGenotype().put(gt.getSampleName(), gtBuilder.build());
+				builder.getSampleToGenotype().put(gt.getSampleName(),
+						gtBuilder.build());
 			}
 
 			result.add(builder.build());
@@ -314,12 +331,40 @@ else if (mtNames.contains(vc.getContig()))
 		return result;
 	}
 
+	/**
+	 * Build and return List of GenotypeCalls object filtered with recessive
+	 * filter settings.
+	 */
+	List<GenotypeCalls> buildRecessiveGenotypeCalls(List<VariantContext> vcs) {
+		// TODO: filter for synonymous variant currently broken if annotating
+		// with all variants... :(
+		final String synonymous =
+				VariantEffect.SYNONYMOUS_VARIANT.getSequenceOntologyTerm();
+
+		// Filter functor for recessive filtration
+		Predicate<VariantContext> keepFreqRecessive;
+		if (interpretVariantFilters) {
+			// TODO: this needs refinement
+			keepFreqRecessive = vc -> {
+				return !isFiltered(vc.getFilters(), VAR_FILTERS, VAR_FILTERS_AR)
+						&& !vc.getAttributeAsString("ANN", "")
+								.contains(synonymous);
+			};
+		} else {
+			keepFreqRecessive = vc -> true;
+		}
+
+		return buildGenotypeCalls(vcs.stream().filter(keepFreqRecessive)
+				.collect(Collectors.toList()));
+	}
+
 	/**
 	 * Helper function for filtered variants/genotypes
 	 * 
 	 * @return whether or not variant is filtered based on filters
 	 */
-	private boolean isFiltered(Collection<String> vcFilters, Collection<String> filtersA, Collection<String> filtersB) {
+	private boolean isFiltered(Collection<String> vcFilters,
+			Collection<String> filtersA, Collection<String> filtersB) {
 		Set<String> filterIntersection = new HashSet<>(filtersA);
 		filterIntersection.addAll(filtersB);
 		filterIntersection.retainAll(vcFilters);
@@ -331,7 +376,8 @@ private boolean isFiltered(Collection<String> vcFilters, Collection<String> filt
 	 * 
 	 * @return whether or not variant is filtered based on filters
 	 */
-	private boolean isFiltered(Collection<String> vcFilters, Collection<String> filtersA) {
+	private boolean isFiltered(Collection<String> vcFilters,
+			Collection<String> filtersA) {
 		return isFiltered(vcFilters, filtersA, ImmutableList.<String> of());
 	}
 
diff --git a/jannovar-stats/pom.xml b/jannovar-stats/pom.xml
index 26bb83ee28..0947ad2920 100755
--- a/jannovar-stats/pom.xml
+++ b/jannovar-stats/pom.xml
@@ -23,7 +23,7 @@
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>slf4j-simple</artifactId>
-			<version>1.7.12</version>
+            <version>${slf4j.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>com.github.samtools</groupId>
@@ -39,7 +39,7 @@
 		<dependency>
 			<groupId>com.google.guava</groupId>
 			<artifactId>guava</artifactId>
-			<version>19.0</version>
+			<version>${guava.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>org.ini4j</groupId>
diff --git a/jannovar-vardbs/pom.xml b/jannovar-vardbs/pom.xml
index d2627003f2..835516554b 100755
--- a/jannovar-vardbs/pom.xml
+++ b/jannovar-vardbs/pom.xml
@@ -23,7 +23,7 @@
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>slf4j-simple</artifactId>
-			<version>1.7.12</version>
+            <version>${slf4j.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>com.github.samtools</groupId>
@@ -39,7 +39,7 @@
 		<dependency>
 			<groupId>com.google.guava</groupId>
 			<artifactId>guava</artifactId>
-			<version>19.0</version>
+			<version>${guava.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>org.ini4j</groupId>
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AbstractDBAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AbstractDBAnnotationDriver.java
index 1e2cfa8a6a..033cffded4 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AbstractDBAnnotationDriver.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AbstractDBAnnotationDriver.java
@@ -1,14 +1,11 @@
 package de.charite.compbio.jannovar.vardbs.base;
 
-import java.io.File;
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.variant.variantcontext.VariantContext;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 
-import htsjdk.samtools.util.CloseableIterator;
-import htsjdk.variant.variantcontext.VariantContext;
-import htsjdk.variant.vcf.VCFFileReader;
-
 /**
  * Abstract base class for annotation based on VCF files.
  * 
@@ -17,21 +14,20 @@
 public abstract class AbstractDBAnnotationDriver<RecordType> implements DBAnnotationDriver {
 
 	/** Path to dbSNP VCF file */
-	protected final String vcfPath;
+	protected final DatabaseVariantContextProvider variantProvider;
 	/** Helper objects for matching alleles */
 	protected final AlleleMatcher matcher;
 	/** Helper for converting from VariantContex to DBSNP record */
 	protected final VariantContextToRecordConverter<RecordType> vcToRecord;
 	/** Configuration */
 	protected final DBAnnotationOptions options;
-	/** VCFReader to use for loading the VCF records */
-	protected final VCFFileReader vcfReader;
 
 	/**
 	 * Create annotation driver for a coordinate-sorted, bgzip-compressed, VCF file
 	 * 
-	 * @param fastaPath
-	 *            FAI-indexed FASTA file with reference
+	 * @param variantProvider
+	 *            {@link DatabaseVariantContextProvider} for querying database for
+	 *            {@link VariantContext} objects describing annotations from database.
 	 * @param vcfPath
 	 *            Path to VCF file with dbSNP.
 	 * @param options
@@ -41,20 +37,21 @@
 	 * @throws JannovarVarDBException
 	 *             on problems loading the reference FASTA/FAI file or incompatible dbSNP version
 	 */
-	public AbstractDBAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options,
-			VariantContextToRecordConverter<RecordType> vcToRecord) throws JannovarVarDBException {
-		this.vcfPath = vcfPath;
+	public AbstractDBAnnotationDriver(DatabaseVariantContextProvider variantProvider, String fastaPath,
+			DBAnnotationOptions options, VariantContextToRecordConverter<RecordType> vcToRecord)
+			throws JannovarVarDBException {
+		this.variantProvider = variantProvider;
 		this.matcher = new AlleleMatcher(fastaPath);
 		this.vcToRecord = vcToRecord;
-		this.vcfReader = new VCFFileReader(new File(this.vcfPath), true);
 		this.options = options;
 	}
 
 	@Override
 	public VariantContext annotateVariantContext(VariantContext obsVC) {
-		try (CloseableIterator<VariantContext> iter = vcfReader.query(obsVC.getContig(), obsVC.getStart(),
+		try (CloseableIterator<VariantContext> iter = variantProvider.query(obsVC.getContig(), obsVC.getStart() - 1,
 				obsVC.getEnd())) {
-			// Fetch all overlapping and matching genotypes from database and pair them with the correct allele from vc.
+			// Fetch all overlapping and matching genotypes from database and pair them with the
+			// correct allele from vc.
 			List<GenotypeMatch> genotypeMatches = new ArrayList<>();
 			List<GenotypeMatch> positionOverlaps = new ArrayList<>();
 			while (iter.hasNext()) {
@@ -72,7 +69,8 @@ public VariantContext annotateVariantContext(VariantContext obsVC) {
 					positionOverlaps, false);
 			HashMap<Integer, AnnotatingRecord<RecordType>> emptyMap = new HashMap<>();
 
-			// Use these records to annotate the variant call in obsVC (record-wise but also per alternative allele)
+			// Use these records to annotate the variant call in obsVC (record-wise but also per
+			// alternative allele)
 			if (options.isReportOverlappingAsMatching())
 				return annotateWithDBRecords(obsVC, dbRecordsOverlap, emptyMap);
 			else if (options.isReportOverlapping())
@@ -85,15 +83,18 @@ else if (options.isReportOverlapping())
 	/**
 	 * Build mapping from alternative allele number to db VCF record to use
 	 * 
-	 * For SNVs, there should only be one value in the value set at which all alleles point to for most cases. The
-	 * selection of the record for each observed allele is delegated to the subclass' {@link #pickAnnotatingDBRecords}.
+	 * For SNVs, there should only be one value in the value set at which all alleles point to for
+	 * most cases. The selection of the record for each observed allele is delegated to the
+	 * subclass' {@link #pickAnnotatingDBRecords}.
 	 * 
 	 * @param genotypeMatches
-	 *            List of {@link GenotypeMatch} objects to build the annotating database records from
+	 *            List of {@link GenotypeMatch} objects to build the annotating database records
+	 *            from
 	 * @param isMatch
-	 *            whether or not to consider true matching alleles (<code>true</code>) or only position-based overlaps
-	 *            (<code>false</code>)
-	 * @return Resulting map from alternative observed allele ID (starting with 1) to the database record to use
+	 *            whether or not to consider true matching alleles (<code>true</code>) or only
+	 *            position-based overlaps (<code>false</code>)
+	 * @return Resulting map from alternative observed allele ID (starting with 1) to the database
+	 *         record to use
 	 */
 	private HashMap<Integer, AnnotatingRecord<RecordType>> buildAnnotatingDBRecordsWrapper(
 			List<GenotypeMatch> genotypeMatches, boolean isMatch) {
@@ -120,8 +121,8 @@ else if (options.isReportOverlapping())
 	 * @param matchToRecord
 	 *            Mapping from alternative allele number to record
 	 * @param isMatch
-	 *            whether or not to consider true matching alleles (<code>true</code>) or only position-based overlaps
-	 *            (<code>false</code>)
+	 *            whether or not to consider true matching alleles (<code>true</code>) or only
+	 *            position-based overlaps (<code>false</code>)
 	 * @return Mapping from alternative allele number to <code>RecordType</code>
 	 */
 	protected abstract HashMap<Integer, AnnotatingRecord<RecordType>> pickAnnotatingDBRecords(
@@ -131,15 +132,17 @@ else if (options.isReportOverlapping())
 	/**
 	 * Annotate the given {@link VariantContext} with the given database records
 	 * 
-	 * There can be more than one database record, for example in the case that a SNV is squished together with an
-	 * indel.
+	 * There can be more than one database record, for example in the case that a SNV is squished
+	 * together with an indel.
 	 * 
 	 * @param vc
 	 *            The {@link VariantContext} to annotate
 	 * @param dbRecordMatches
-	 *            Map from alternative allele index to annotating <code>RecordType</code> with matching allele
+	 *            Map from alternative allele index to annotating <code>RecordType</code> with
+	 *            matching allele
 	 * @param dbRecordOverlaps
-	 *            Map from alternative allele index to annotating <code>RecordType</code> with overlapping positions
+	 *            Map from alternative allele index to annotating <code>RecordType</code> with
+	 *            overlapping positions
 	 */
 	protected abstract VariantContext annotateWithDBRecords(VariantContext vc,
 			HashMap<Integer, AnnotatingRecord<RecordType>> dbRecordMatches,
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AlleleMatcher.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AlleleMatcher.java
index f2a4555acf..fa5483879e 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AlleleMatcher.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/AlleleMatcher.java
@@ -3,7 +3,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-
+import com.google.common.collect.Lists;
 import htsjdk.variant.variantcontext.VariantContext;
 
 /**
@@ -31,7 +31,8 @@ public AlleleMatcher(String pathFasta) throws JannovarVarDBException {
 	}
 
 	/**
-	 * Match genotypes of two {@link VariantContext}s (chrom, position, ref, and alt have to be equal)
+	 * Match genotypes of two {@link VariantContext}s (chrom, position, ref, and alt have to be
+	 * equal)
 	 * 
 	 * Indels will be left-shifted and normalized when necessary
 	 * 
@@ -53,7 +54,7 @@ public AlleleMatcher(String pathFasta) throws JannovarVarDBException {
 			int j = 1; // excludes reference allele
 			for (VariantDescription dbVar : dbVars) {
 				if (dbVar.equals(obsVar))
-					result.add(new GenotypeMatch(i, j, obsVC, dbVC));
+					result.add(new GenotypeMatch(i, j, obsVC, dbVC, true));
 				j += 1;
 			}
 
@@ -64,10 +65,11 @@ public AlleleMatcher(String pathFasta) throws JannovarVarDBException {
 	}
 
 	/**
-	 * Pair genotypes of two {@link VariantContext}s based on their position, regardless of their genotype
+	 * Pair genotypes of two {@link VariantContext}s based on their position, regardless of their
+	 * genotype
 	 * 
-	 * In the end, all genotypes will be matched regardless of matching alleles, such that later the "best" (e.g., the
-	 * highest frequency one) can be used for annotating a variant.
+	 * In the end, all genotypes will be matched regardless of matching alleles, such that later the
+	 * "best" (e.g., the highest frequency one) can be used for annotating a variant.
 	 * 
 	 * @param obsVC
 	 *            {@link VariantContext} describing the observed variant
@@ -86,8 +88,11 @@ public AlleleMatcher(String pathFasta) throws JannovarVarDBException {
 		for (VariantDescription obsVar : obsVars) {
 			int j = 1; // excludes reference allele
 			for (VariantDescription dbVar : dbVars) {
-				if (dbVar.overlapsWith(obsVar))
-					result.add(new GenotypeMatch(i, j, obsVC, dbVC));
+				if (dbVar.equals(obsVar)) {
+					result.add(new GenotypeMatch(i, j, obsVC, dbVC, true));
+				} else if (dbVar.overlapsWith(obsVar)) {
+					result.add(new GenotypeMatch(i, j, obsVC, dbVC, false));
+				}
 				j += 1;
 			}
 
@@ -100,13 +105,23 @@ public AlleleMatcher(String pathFasta) throws JannovarVarDBException {
 	/**
 	 * Convert a {@link VariantContext} to a list of normalized variant descriptions
 	 *
-	 * This will generate one {@link VariantDescription} for each alternative allele in <code>vcf</code>.
+	 * This will generate one {@link VariantDescription} for each alternative allele in
+	 * <code>vcf</code>.
 	 *
 	 * @param vc
 	 *            {@link VariantContext} to convert
-	 * @return A {@link Collection} of {@link VariantDescription} objects corresponding to <code>vc</code>
+	 * @return A {@link Collection} of {@link VariantDescription} objects corresponding to
+	 *         <code>vc</code>
 	 */
 	private Collection<VariantDescription> ctxToVariants(VariantContext vc) {
+		// Short-circuit in the case that we see a "database only" allele, e.g., as created when
+		// using generic TSV annotation without REF/ALT columns. In this case, the position is
+		// enough.
+		if (vc.getReference().toString().equals("N*") && vc.getNAlleles() == 1) {
+			return Lists.newArrayList(
+					new VariantDescription(vc.getContig(), vc.getStart() - 1, "N", "N"));
+		}
+
 		List<VariantDescription> vars = new ArrayList<>();
 		for (int i = 1; i < vc.getNAlleles(); ++i) {
 			VariantDescription vd = new VariantDescription(vc.getContig(), vc.getStart() - 1,
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DBAnnotationOptions.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DBAnnotationOptions.java
index 400495b33c..06c49cd823 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DBAnnotationOptions.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DBAnnotationOptions.java
@@ -24,15 +24,18 @@ public static DBAnnotationOptions createDefaults() {
 
 	/** Whether or not to report overlapping variants at all (default: true) */
 	private boolean reportOverlapping;
-	/** Whether or not to consider overlapping variants as identical (behaviour of other tools, default: false */
+	/**
+	 * Whether or not to consider overlapping variants as identical (behaviour of other tools,
+	 * default: false
+	 */
 	private boolean reportOverlappingAsMatching;
 	/** Prefix for identifiers, e.g. "DBSNP_" */
 	private String identifierPrefix;
 	/** Behaviour on multiple matching annotations */
 	private MultipleMatchBehaviour multiMatchBehaviour;
 
-	public DBAnnotationOptions(boolean reportOverlapping, boolean reportOverlappingAsIdentical, String identifierPrefix,
-			MultipleMatchBehaviour multiMatchBehaviour) {
+	public DBAnnotationOptions(boolean reportOverlapping, boolean reportOverlappingAsIdentical,
+			String identifierPrefix, MultipleMatchBehaviour multiMatchBehaviour) {
 		this.reportOverlapping = reportOverlapping;
 		this.reportOverlappingAsMatching = reportOverlappingAsIdentical;
 		this.identifierPrefix = identifierPrefix;
@@ -80,8 +83,9 @@ public String getIdentifierPrefix() {
 
 	@Override
 	public String toString() {
-		return "DBAnnotationOptions [reportOverlapping=" + reportOverlapping + ", reportOverlappingAsMatching="
-				+ reportOverlappingAsMatching + ", identifierPrefix=" + identifierPrefix + ", multiMatchBehaviour="
+		return "DBAnnotationOptions [reportOverlapping=" + reportOverlapping
+				+ ", reportOverlappingAsMatching=" + reportOverlappingAsMatching
+				+ ", identifierPrefix=" + identifierPrefix + ", multiMatchBehaviour="
 				+ multiMatchBehaviour + "]";
 	}
 
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DatabaseVariantContextProvider.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DatabaseVariantContextProvider.java
new file mode 100755
index 0000000000..0138eebb0b
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/DatabaseVariantContextProvider.java
@@ -0,0 +1,28 @@
+package de.charite.compbio.jannovar.vardbs.base;
+
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.variant.variantcontext.VariantContext;
+
+/**
+ * Allow to query database with contig, (1-based) begin, and end position to produce a
+ * {@link VariantContext} with annotating information.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public interface DatabaseVariantContextProvider {
+
+	/**
+	 * Query for {@link VariantContext}s describing the DB variant annotation between begin and end
+	 * position on the given contig.
+	 * 
+	 * @param contig
+	 *            Name of the contig to perform query on.
+	 * @param beginPos
+	 *            1-based start position
+	 * @param endPos
+	 *            end position
+	 * @return {@link CloseableIterator} of {@link VariantContext} objects for annotation.
+	 */
+	CloseableIterator<VariantContext> query(String contig, int beginPos, int endPos);
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/GenotypeMatch.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/GenotypeMatch.java
index 2d9e877bbf..d5470729ab 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/GenotypeMatch.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/GenotypeMatch.java
@@ -17,12 +17,16 @@
 	final VariantContext obsVC;
 	/** The database VariantContext */
 	final VariantContext dbVC;
+	/** Whether is a match (if false: overlap only). */
+	final boolean isMatch;
 
-	public GenotypeMatch(int observedAllele, int dbAllele, VariantContext obsVC, VariantContext dbVC) {
+	public GenotypeMatch(int observedAllele, int dbAllele, VariantContext obsVC,
+			VariantContext dbVC, boolean isMatch) {
 		this.observedAllele = observedAllele;
 		this.dbAllele = dbAllele;
 		this.obsVC = obsVC;
 		this.dbVC = dbVC;
+		this.isMatch = isMatch;
 	}
 
 	public int getObservedAllele() {
@@ -41,10 +45,14 @@ public VariantContext getDBVC() {
 		return dbVC;
 	}
 
+	public boolean isMatch() {
+		return isMatch;
+	}
+
 	@Override
 	public String toString() {
-		return "GenotypeMatch [observedAllele=" + observedAllele + ", dbAllele=" + dbAllele + ", obsVC=" + obsVC
-				+ ", dbVC=" + dbVC + "]";
+		return "GenotypeMatch [observedAllele=" + observedAllele + ", dbAllele=" + dbAllele
+				+ ", obsVC=" + obsVC + ", dbVC=" + dbVC + ", isMatch=" + isMatch + "]";
 	}
 
 	@Override
@@ -53,6 +61,7 @@ public int hashCode() {
 		int result = 1;
 		result = prime * result + dbAllele;
 		result = prime * result + ((dbVC == null) ? 0 : dbVC.hashCode());
+		result = prime * result + (isMatch ? 1231 : 1237);
 		result = prime * result + ((obsVC == null) ? 0 : obsVC.hashCode());
 		result = prime * result + observedAllele;
 		return result;
@@ -60,27 +69,19 @@ public int hashCode() {
 
 	@Override
 	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (getClass() != obj.getClass())
-			return false;
+		if (this == obj) return true;
+		if (obj == null) return false;
+		if (getClass() != obj.getClass()) return false;
 		GenotypeMatch other = (GenotypeMatch) obj;
-		if (dbAllele != other.dbAllele)
-			return false;
+		if (dbAllele != other.dbAllele) return false;
 		if (dbVC == null) {
-			if (other.dbVC != null)
-				return false;
-		} else if (!dbVC.equals(other.dbVC))
-			return false;
+			if (other.dbVC != null) return false;
+		} else if (!dbVC.equals(other.dbVC)) return false;
+		if (isMatch != other.isMatch) return false;
 		if (obsVC == null) {
-			if (other.obsVC != null)
-				return false;
-		} else if (!obsVC.equals(other.obsVC))
-			return false;
-		if (observedAllele != other.observedAllele)
-			return false;
+			if (other.obsVC != null) return false;
+		} else if (!obsVC.equals(other.obsVC)) return false;
+		if (observedAllele != other.observedAllele) return false;
 		return true;
 	}
 
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFHeaderExtender.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFHeaderExtender.java
index c3e7ece1f6..935f400537 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFHeaderExtender.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFHeaderExtender.java
@@ -35,7 +35,7 @@ public VCFHeaderExtender(DBAnnotationOptions options) {
 	 * Add headers with default prefix
 	 */
 	public void addHeaders(VCFHeader header) {
-		addHeaders(header, getDefaultPrefix());
+		addHeaders(header, options.getVCFIdentifierPrefix());
 	}
 
 }
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFReaderVariantProvider.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFReaderVariantProvider.java
new file mode 100755
index 0000000000..25f7b695ef
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/base/VCFReaderVariantProvider.java
@@ -0,0 +1,31 @@
+package de.charite.compbio.jannovar.vardbs.base;
+
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.vcf.VCFFileReader;
+import java.io.File;
+
+/**
+ * VCF file--backed provider of {@link VariantContext}s.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class VCFReaderVariantProvider implements DatabaseVariantContextProvider {
+
+	/** VCFReader to use for loading the VCF records */
+	private final VCFFileReader vcfReader;
+
+	public VCFReaderVariantProvider(String vcfPath) {
+		this.vcfReader = new VCFFileReader(new File(vcfPath), true);
+	}
+
+	public VCFFileReader getVcfReader() {
+		return vcfReader;
+	}
+
+	@Override
+	public CloseableIterator<VariantContext> query(String contig, int beginPos, int endPos) {
+		return vcfReader.query(contig, beginPos, endPos);
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriver.java
index e49ee35745..681fe84550 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriver.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriver.java
@@ -1,20 +1,19 @@
 package de.charite.compbio.jannovar.vardbs.cosmic;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map.Entry;
-
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
-
 import de.charite.compbio.jannovar.vardbs.base.AbstractDBAnnotationDriver;
 import de.charite.compbio.jannovar.vardbs.base.AnnotatingRecord;
 import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions;
 import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
 import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
 import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import de.charite.compbio.jannovar.vardbs.base.VCFReaderVariantProvider;
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map.Entry;
 
 /**
  * Annotation driver class for annotations using COSMIC data
@@ -25,7 +24,7 @@
 
 	public CosmicAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options)
 			throws JannovarVarDBException {
-		super(vcfPath, fastaPath, options, new CosmicVariantContextToRecordConverter());
+		super(new VCFReaderVariantProvider(vcfPath), fastaPath, options, new CosmicVariantContextToRecordConverter());
 	}
 
 	@Override
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriver.java
index acd5def527..6794aa8c3a 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriver.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriver.java
@@ -13,6 +13,7 @@
 import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
 import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
 import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import de.charite.compbio.jannovar.vardbs.base.VCFReaderVariantProvider;
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
 
@@ -38,9 +39,10 @@
 	 */
 	public DBSNPAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options)
 			throws JannovarVarDBException {
-		super(vcfPath, fastaPath, options, new DBSNPVariantContextToRecordConverter());
+		super(new VCFReaderVariantProvider(vcfPath), fastaPath, options, new DBSNPVariantContextToRecordConverter());
+		VCFReaderVariantProvider vcfProvider = (VCFReaderVariantProvider) this.variantProvider;
 
-		this.dbSNPInfo = new DBSNPInfoFactory().build(vcfReader.getFileHeader());
+		this.dbSNPInfo = new DBSNPInfoFactory().build(vcfProvider.getVcfReader().getFileHeader());
 		if (dbSNPInfo.dbSNPBuildID != 147)
 			throw new JannovarVarDBException(
 					"Unsupported dbSNP build ID " + dbSNPInfo.dbSNPBuildID + " only supported is b174");
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriver.java
index ca35fbcdc7..d224b4ca26 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriver.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriver.java
@@ -12,6 +12,7 @@
 import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
 import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
 import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import de.charite.compbio.jannovar.vardbs.base.VCFReaderVariantProvider;
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
 
@@ -26,7 +27,7 @@
 
 	public ExacAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options)
 			throws JannovarVarDBException {
-		super(vcfPath, fastaPath, options, new ExacVariantContextToRecordConverter());
+		super(new VCFReaderVariantProvider(vcfPath), fastaPath, options, new ExacVariantContextToRecordConverter());
 	}
 
 	@Override
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/facade/DBVariantContextAnnotatorFactory.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/facade/DBVariantContextAnnotatorFactory.java
index afb088f93d..9cca01dbb0 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/facade/DBVariantContextAnnotatorFactory.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/facade/DBVariantContextAnnotatorFactory.java
@@ -6,6 +6,7 @@
 import de.charite.compbio.jannovar.vardbs.cosmic.CosmicAnnotationDriver;
 import de.charite.compbio.jannovar.vardbs.dbsnp.DBSNPAnnotationDriver;
 import de.charite.compbio.jannovar.vardbs.exac.ExacAnnotationDriver;
+import de.charite.compbio.jannovar.vardbs.generic_tsv.GenericTSVAnnotationOptions;
 import de.charite.compbio.jannovar.vardbs.gnomad.GnomadAnnotationDriver;
 import htsjdk.variant.variantcontext.VariantContext;
 
@@ -124,4 +125,42 @@ public DBVariantContextAnnotator constructCosmic(String vcfDBPath, String fastaR
 		return new DBVariantContextAnnotator(new CosmicAnnotationDriver(vcfDBPath, fastaRefPath, options), options);
 	}
 
+	/**
+	 * Construct TSV {@link VariantContext} annotator factory.
+	 *
+	 * @param tsvPath
+	 *            Path to the bgzip-ed TSV annotation file, e.g., dbNSFP or CADD
+	 * @param fastaRefPath
+	 *            Path to reference FASTA file
+	 * @param options
+	 *            Configuration for the variant context annotation
+	 * @return Preconfigured {@link DBVariantContextAnnotator} object
+	 * @throws JannovarVarDBException
+	 *             on problems loading the resources
+	 */
+	public DBVariantContextAnnotator constructGenericTSV(
+			String tsvPath, String fastaRefPath, GenericTSVAnnotationOptions options)
+			throws JannovarVarDBException {
+		return new DBVariantContextAnnotator(new CosmicAnnotationDriver(tsvPath, fastaRefPath, options), options);
+	}
+
+
+	/**
+	 * Construct Generic VCF {@link VariantContext} annotator factory.
+	 *
+	 * @param vcfDBPath
+	 *            Path to gzip-compressed, normalized and tbi-indexed VCF file to use for the annotation
+	 * @param fastaRefPath
+	 *            Path to reference FASTA file
+	 * @param options
+	 *            Configuration for the variant context annotation
+	 * @return Preconfigured {@link DBVariantContextAnnotator} object
+	 * @throws JannovarVarDBException
+	 *             on problems loading the resources
+	 */
+	public DBVariantContextAnnotator constructGenericVCF(String vcfDBPath, String fastaRefPath, DBAnnotationOptions options)
+			throws JannovarVarDBException {
+		return new DBVariantContextAnnotator(new CosmicAnnotationDriver(vcfDBPath, fastaRefPath, options), options);
+	}
+
 }
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAccumulationStrategy.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAccumulationStrategy.java
new file mode 100755
index 0000000000..4351de3589
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAccumulationStrategy.java
@@ -0,0 +1,17 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+/**
+ * Enumeration describing accumulation strategy for annotation with TSV for multiple matches.
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public enum GenericTSVAccumulationStrategy {
+	/** Choose first */
+	CHOOSE_FIRST,
+	/** Use average, only applicable to numbers, fall back to first. */
+	AVERAGE,
+	/** Use largest value, only applicable to numbers, fall back to first. */
+	CHOOSE_MAX,
+	/** Use smallest value, only applicable to numbers, fall back to first. */
+	CHOOSE_MIN;
+}
\ No newline at end of file
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriver.java
new file mode 100755
index 0000000000..6327015fa0
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriver.java
@@ -0,0 +1,399 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import de.charite.compbio.jannovar.vardbs.base.AlleleMatcher;
+import de.charite.compbio.jannovar.vardbs.base.DBAnnotationDriver;
+import de.charite.compbio.jannovar.vardbs.base.DatabaseVariantContextProvider;
+import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.variantcontext.VariantContextBuilder;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Annotation driver class for annotations generic TSV data
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public final class GenericTSVAnnotationDriver implements DBAnnotationDriver {
+
+	/** Path to dbSNP VCF file */
+	private final DatabaseVariantContextProvider variantProvider;
+	/** Helper objects for matching alleles */
+	private final AlleleMatcher matcher;
+	/** Configuration */
+	private final GenericTSVAnnotationOptions options;
+
+	public GenericTSVAnnotationDriver(String fastaPath, GenericTSVAnnotationOptions options)
+			throws JannovarVarDBException {
+		this.variantProvider = new GenericTSVVariantContextProvider(options);
+		this.matcher = new AlleleMatcher(fastaPath);
+		this.options = options;
+	}
+
+	@Override
+	public VCFHeaderExtender constructVCFHeaderExtender() {
+		return new GenericTSVHeaderExtender(options);
+	}
+
+	@Override
+	public VariantContext annotateVariantContext(VariantContext vc) {
+		VariantContextBuilder builder = new VariantContextBuilder(vc);
+
+		// Matching and overlapping records for each allele. For the generic TSV annotation, we
+		// assume that only one allele is given for each database record.
+		Map<Integer, List<VariantContext>> dbRecordsMatch = null;
+		Map<Integer, List<VariantContext>> dbRecordsOverlap = null;
+		if (options.isReportOverlapping() && options.isReportOverlappingAsMatching()) {
+			dbRecordsMatch = pickDBRecords(vc, false);
+		} else {
+			dbRecordsMatch = pickDBRecords(vc, true);
+			dbRecordsOverlap = pickDBRecords(vc, false);
+		}
+		
+		// Annotate with records with genotype matches
+		for (int i = 0; i < options.getValueColumnDescriptions().size(); i++) {
+			final String colName = options.getColumnNames().get(i);
+			final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
+					.get(colName);
+			final String refColName = desc.getRefField();
+			final GenericTSVValueColumnDescription refDesc = options.getValueColumnDescriptions()
+					.get(refColName);
+			annotateWith(vc, "", dbRecordsMatch, desc, refDesc, builder);
+		}
+
+		// Annotate with records with overlapping positions
+		if (options.isReportOverlapping() && !options.isReportOverlappingAsMatching()) {
+			for (int i = 0; i < options.getValueColumnDescriptions().size(); i++) {
+				final String colName = options.getColumnNames().get(i);
+				final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
+						.get(colName);
+				final String refColName = desc.getRefField();
+				final GenericTSVValueColumnDescription refDesc = options
+						.getValueColumnDescriptions().get(refColName);
+				annotateWith(vc, "OVL_", dbRecordsOverlap, desc, refDesc, builder);
+			}
+		}
+
+		return builder.make();
+	}
+
+	/**
+	 * Pick database records for the given {@link VariantContext} <code>vc</code>.
+	 */
+	private Map<Integer, List<VariantContext>> pickDBRecords(VariantContext vc,
+			boolean requireGenotypeMatch) {
+		final Map<Integer, List<VariantContext>> result = new HashMap<>();
+		for (int i = 0; i < vc.getNAlleles(); ++i) {
+			result.put(i, new ArrayList<>());
+		}
+
+		try (CloseableIterator<VariantContext> it = variantProvider.query(vc.getContig(),
+				vc.getStart() - 1, vc.getEnd())) {
+			while (it.hasNext()) {
+				final VariantContext dbVC = it.next();
+				for (int i = 0; i < vc.getNAlleles(); ++i) {
+					final Collection<GenotypeMatch> matches;
+					if (requireGenotypeMatch) {
+						matches = matcher.matchGenotypes(vc, dbVC);
+					} else {
+						matches = matcher.positionOverlaps(vc, dbVC);
+					}
+					for (GenotypeMatch match : matches) {
+						result.get(match.getObservedAllele()).add(dbVC);
+					}
+				}
+			}
+		}
+		return result;
+	}
+
+	/**
+	 * Helper for comparable pairs.
+	 */
+	private static class LabeledValue<Label extends Comparable<Label>, Value>
+			implements Comparable<LabeledValue<Label, Value>> {
+
+		private final Label label;
+		private final Value value;
+
+		public LabeledValue(Label label, Value value) {
+			this.label = label;
+			this.value = value;
+		}
+
+		public Label getLabel() {
+			return label;
+		}
+
+		public Value getValue() {
+			return value;
+		}
+
+		@Override
+		public String toString() {
+			return "LabeledValue [label=" + label + ", value=" + value + "]";
+		}
+
+		@Override
+		public int compareTo(LabeledValue<Label, Value> o) {
+			return label.compareTo(o.getLabel());
+		}
+
+	}
+
+	/**
+	 * Annotate <code>vc</code> with the annotating database records.
+	 * 
+	 * @param refDesc
+	 */
+	private void annotateWith(VariantContext vc, String infix,
+			Map<Integer, List<VariantContext>> dbRecords, GenericTSVValueColumnDescription desc,
+			GenericTSVValueColumnDescription refDesc, VariantContextBuilder builder) {
+		if (dbRecords.values().stream().allMatch(lst -> lst.isEmpty())) {
+			return; // no annotation necessary
+		}
+
+		switch (desc.getValueType()) {
+		case Character:
+			switch (refDesc.getValueType()) {
+			case Character:
+				this.<Character, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Flag:
+				this.<Boolean, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Float:
+				this.<Double, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Double.MIN_VALUE, Double.MAX_VALUE);
+				break;
+			case Integer:
+				this.<Integer, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
+				break;
+			case String:
+			default:
+				this.<String, Character> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			}
+			break;
+		case Flag:
+			switch (refDesc.getValueType()) {
+			case Character:
+				this.<Character, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Flag:
+				this.<Boolean, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Float:
+				this.<Double, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Double.MIN_VALUE, Double.MAX_VALUE);
+				break;
+			case Integer:
+				this.<Integer, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
+				break;
+			case String:
+			default:
+				this.<String, Boolean> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			}
+			break;
+		case Float:
+			switch (refDesc.getValueType()) {
+			case Character:
+				this.<Character, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Flag:
+				this.<Boolean, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Float:
+				this.<Double, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
+						Double.MIN_VALUE, Double.MAX_VALUE);
+				break;
+			case Integer:
+				this.<Integer, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
+				break;
+			case String:
+			default:
+				this.<String, Double> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
+						null, null);
+				break;
+			}
+			break;
+		case Integer:
+			switch (refDesc.getValueType()) {
+			case Character:
+				this.<Character, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Flag:
+				this.<Boolean, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Float:
+				this.<Double, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Double.MIN_VALUE, Double.MAX_VALUE);
+				break;
+			case Integer:
+				this.<Integer, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
+				break;
+			case String:
+			default:
+				this.<String, Integer> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			}
+			break;
+		case String:
+		default:
+			switch (refDesc.getValueType()) {
+			case Character:
+				this.<Character, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Flag:
+				this.<Boolean, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, null, null);
+				break;
+			case Float:
+				this.<Double, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
+						Double.MIN_VALUE, Double.MAX_VALUE);
+				break;
+			case Integer:
+				this.<Integer, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc,
+						builder, Integer.MIN_VALUE, Integer.MAX_VALUE);
+				break;
+			case String:
+			default:
+				this.<String, String> annotateWithImpl(vc, infix, dbRecords, desc, refDesc, builder,
+						null, null);
+				break;
+			}
+			break;
+		}
+	}
+
+	private <Label extends Comparable<Label>, Value> void annotateWithImpl(VariantContext vc,
+			String infix, Map<Integer, List<VariantContext>> dbRecords,
+			GenericTSVValueColumnDescription desc, GenericTSVValueColumnDescription refDesc,
+			VariantContextBuilder builder, Label minValue, Label maxValue) {
+		// Prepare annotation list with one entry for each allele
+		final List<Object> annotations = new ArrayList<>();
+		final Map<Integer, List<LabeledValue<Label, Value>>> labeledValues = new HashMap<>();
+		for (int alleleNo = 0; alleleNo < vc.getNAlleles(); ++alleleNo) {
+			annotations.add(".");
+			labeledValues.put(alleleNo, new ArrayList<>());
+			for (VariantContext dbRecord : dbRecords.get(alleleNo)) {
+				Label label = (Label) dbRecord.getAttribute(refDesc.getFieldName());
+				if (label == null && minValue != null && maxValue != null) {
+					if (refDesc
+							.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MIN) {
+						label = maxValue;
+					} else if (refDesc
+							.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MAX) {
+						label = minValue;
+					}
+				}
+				labeledValues.get(alleleNo).add(new LabeledValue<Label, Value>(label,
+						(Value) dbRecord.getAttribute(desc.getFieldName())));
+			}
+		}
+
+		switch (refDesc.getValueType()) {
+		case Character:
+		case Flag:
+		case String:
+			// Only pick first available
+			for (int j = 0; j < vc.getNAlleles(); ++j) {
+				if (!labeledValues.get(j).isEmpty()) {
+					annotations.set(j, labeledValues.get(j).get(0).getValue());
+				}
+			}
+			break;
+		case Float:
+			for (int j = 0; j < vc.getNAlleles(); ++j) {
+				if (!labeledValues.get(j).isEmpty()) {
+					switch (refDesc.getAccumulationStrategy()) {
+					case AVERAGE:
+						annotations.set(j, labeledValues.get(j).stream()
+								.mapToDouble(x -> (Double) x.getValue()).average().orElse(0.0));
+						break;
+					case CHOOSE_FIRST:
+						annotations.set(j, labeledValues.get(j).get(0).getValue());
+						break;
+					case CHOOSE_MIN:
+						annotations.set(j,
+								labeledValues.get(j).stream()
+										.min(Comparator.<LabeledValue<Label, Value>> naturalOrder())
+										.map(x -> (Object) x.getValue()).orElse("."));
+						break;
+					case CHOOSE_MAX:
+					default:
+						annotations.set(j,
+								labeledValues.get(j).stream()
+										.max(Comparator.<LabeledValue<Label, Value>> naturalOrder())
+										.map(x -> (Object) x.getValue()).orElse("."));
+						break;
+					}
+				}
+			}
+			break;
+		case Integer:
+			for (int j = 0; j < vc.getNAlleles(); ++j) {
+				if (!labeledValues.get(j).isEmpty()) {
+					switch (refDesc.getAccumulationStrategy()) {
+					case AVERAGE:
+						annotations.set(j, labeledValues.get(j).stream()
+								.mapToDouble(x -> (Integer) x.getValue()).average().orElse(0.0));
+						break;
+					case CHOOSE_FIRST:
+						annotations.set(j, labeledValues.get(j).get(0).getValue());
+						break;
+					case CHOOSE_MIN:
+						annotations.set(j,
+								labeledValues.get(j).stream()
+										.min(Comparator.<LabeledValue<Label, Value>> naturalOrder())
+										.map(x -> (Object) x.getValue()).orElse("."));
+						break;
+					case CHOOSE_MAX:
+					default:
+						annotations.set(j,
+								labeledValues.get(j).stream()
+										.max(Comparator.<LabeledValue<Label, Value>> naturalOrder())
+										.map(x -> (Object) x.getValue()).orElse("."));
+						break;
+					}
+				}
+			}
+			break;
+		default:
+			break;
+		}
+
+		if (!options.isRefAlleleAnnotated()) {
+			annotations.remove(0);
+		}
+
+		// Put annotation into variant context builder
+		final String label = options.getVCFIdentifierPrefix() + infix + desc.getFieldName();
+		builder.attribute(label, annotations);
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationOptions.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationOptions.java
new file mode 100755
index 0000000000..1ac1bba406
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationOptions.java
@@ -0,0 +1,218 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions;
+import htsjdk.variant.vcf.VCFHeaderLineType;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Configuration for generic TSV annotation.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationOptions extends DBAnnotationOptions {
+
+	/**
+	 * Construct new TSV annotation configuration from command line option value.
+	 * 
+	 * <p>
+	 * The value must have the format:
+	 * <code>pathToTsvFile:oneBasedOffset:colContig:colStart:colEnd:colRef(or=0):
+	 * colAlt(or=0):colValue:fieldType:fieldName:fieldDescription:accumulationStrategy</code>
+	 * </p>
+	 * 
+	 * @param strValue
+	 *            String to parse from
+	 * @return Constructed {@link BedAnnotationOptions} from the given string value.
+	 */
+	public static GenericTSVAnnotationOptions parseFrom(String strValue) {
+		String tokens[] = strValue.split(":");
+		if (tokens.length != 13) {
+			throw new RuntimeException("Wrong number of tokens tokens in TSV annotation configuration " + strValue
+					+ " expected 13 but was " + tokens.length);
+		}
+
+		final String pathTsvFile = tokens[0];
+		final int oneBasedOffset = Integer.parseInt(tokens[1]);
+		final int colContig = Integer.parseInt(tokens[2]);
+		final int colStart = Integer.parseInt(tokens[3]);
+		final int colEnd = Integer.parseInt(tokens[4]);
+		final int colRef = Integer.parseInt(tokens[5]);
+		final int colAlt = Integer.parseInt(tokens[6]);
+		final boolean refAnnotated = "R".equals(tokens[7]);
+		final int colValue = Integer.parseInt(tokens[8]);
+		final String fieldType = tokens[9];
+		final String fieldName = tokens[10];
+		final String fieldDescription = tokens[11];
+		final String accStrategy = tokens[12];
+
+		final boolean ovlAsIdentical = (colRef == 0) || (colAlt == 0);
+		final GenericTSVAnnotationTarget target = ((colRef == 0) || (colAlt == 0)) ? GenericTSVAnnotationTarget.POSITION
+				: GenericTSVAnnotationTarget.VARIANT;
+
+		return new GenericTSVAnnotationOptions(true, ovlAsIdentical, "", MultipleMatchBehaviour.BEST_ONLY,
+				new File(pathTsvFile), target, (oneBasedOffset != 0), colContig, colStart, colEnd, colRef, colAlt,
+				refAnnotated, ImmutableList.of(fieldName),
+				ImmutableMap.of(fieldName,
+						new GenericTSVValueColumnDescription(colValue, VCFHeaderLineType.valueOf(fieldType), fieldName,
+								fieldDescription, GenericTSVAccumulationStrategy.valueOf(accStrategy))));
+	}
+
+	/** File with TSV annotations. */
+	private File tsvFile;
+
+	/** Configuration of annotation target. */
+	private GenericTSVAnnotationTarget annotationTarget = GenericTSVAnnotationTarget.VARIANT;
+
+	/** Whether or not coordinates are 1-based. */
+	private boolean oneBasedPositions = true;
+
+	/** 1-based index of column with contig name */
+	private int contigColumnIndex = 1;
+
+	/** 1-based index of column with begin position. */
+	private int beginColumnIndex = 2;
+
+	/** 1-based index of column with end position. */
+	private int endColumnIndex = 3;
+
+	/** 1-based index of column with reference allele, 0 for none. */
+	private int refAlleleColumnIndex = 4;
+
+	/** 1-based index of column with variant allele, 0 for none. */
+	private int altAlleleColumnIndex = 5;
+
+	/** Whether or not the ref allele can be annotated. */
+	private boolean refAlleleAnnotated = false;
+
+	/** Column description names as ordered as in file. */
+	private List<String> columnNames = new ArrayList<>();
+
+	/** Description of value columns. */
+	private Map<String, GenericTSVValueColumnDescription> valueColumnDescriptions = new HashMap<>();
+
+	public GenericTSVAnnotationOptions(boolean reportOverlapping, boolean reportOverlappingAsIdentical,
+			String identifierPrefix, MultipleMatchBehaviour multiMatchBehaviour, File tsvFile,
+			GenericTSVAnnotationTarget annotationTarget, boolean oneBasedPositions, int contigColumnIndex,
+			int beginColumnIndex, int endColumnIndex, int refAlleleColumnIndex, int altAlleleColumnIndex,
+			boolean refAlleleAnnotated, List<String> columnNames,
+			Map<String, GenericTSVValueColumnDescription> valueColumnDescriptions) {
+		super(reportOverlapping, reportOverlappingAsIdentical, identifierPrefix, multiMatchBehaviour);
+
+		this.tsvFile = tsvFile;
+		this.annotationTarget = annotationTarget;
+		this.oneBasedPositions = oneBasedPositions;
+		this.contigColumnIndex = contigColumnIndex;
+		this.beginColumnIndex = beginColumnIndex;
+		this.endColumnIndex = endColumnIndex;
+		this.refAlleleColumnIndex = refAlleleColumnIndex;
+		this.altAlleleColumnIndex = altAlleleColumnIndex;
+		this.refAlleleAnnotated = refAlleleAnnotated;
+		this.columnNames = columnNames;
+		this.valueColumnDescriptions = valueColumnDescriptions;
+	}
+
+	public File getTsvFile() {
+		return tsvFile;
+	}
+
+	public void setTsvFile(File tsvFile) {
+		this.tsvFile = tsvFile;
+	}
+
+	public GenericTSVAnnotationTarget getAnnotationTarget() {
+		return annotationTarget;
+	}
+
+	public void setAnnotationTarget(GenericTSVAnnotationTarget annotationTarget) {
+		this.annotationTarget = annotationTarget;
+	}
+
+	public boolean isOneBasedPositions() {
+		return oneBasedPositions;
+	}
+
+	public void setOneBasedPositions(boolean oneBasedPositions) {
+		this.oneBasedPositions = oneBasedPositions;
+	}
+
+	public int getContigColumnIndex() {
+		return contigColumnIndex;
+	}
+
+	public void setContigColumnIndex(int contigColumnIndex) {
+		this.contigColumnIndex = contigColumnIndex;
+	}
+
+	public int getBeginColumnIndex() {
+		return beginColumnIndex;
+	}
+
+	public void setBeginColumnIndex(int beginColumnIndex) {
+		this.beginColumnIndex = beginColumnIndex;
+	}
+
+	public int getEndColumnIndex() {
+		return endColumnIndex;
+	}
+
+	public void setEndColumnIndex(int endColumnIndex) {
+		this.endColumnIndex = endColumnIndex;
+	}
+
+	public int getRefAlleleColumnIndex() {
+		return refAlleleColumnIndex;
+	}
+
+	public void setRefAlleleColumnIndex(int refAlleleColumnIndex) {
+		this.refAlleleColumnIndex = refAlleleColumnIndex;
+	}
+
+	public int getAltAlleleColumnIndex() {
+		return altAlleleColumnIndex;
+	}
+
+	public void setAltAlleleColumnIndex(int altAlleleColumnIndex) {
+		this.altAlleleColumnIndex = altAlleleColumnIndex;
+	}
+
+	public boolean isRefAlleleAnnotated() {
+		return refAlleleAnnotated;
+	}
+
+	public void setRefAlleleAnnotated(boolean refAlleleAnnotated) {
+		this.refAlleleAnnotated = refAlleleAnnotated;
+	}
+
+	public List<String> getColumnNames() {
+		return columnNames;
+	}
+
+	public void setColumnNames(List<String> columnNames) {
+		this.columnNames = columnNames;
+	}
+
+	public Map<String, GenericTSVValueColumnDescription> getValueColumnDescriptions() {
+		return valueColumnDescriptions;
+	}
+
+	public void setValueColumnDescriptions(Map<String, GenericTSVValueColumnDescription> valueColumnDescriptions) {
+		this.valueColumnDescriptions = valueColumnDescriptions;
+	}
+
+	@Override
+	public String toString() {
+		return "GenericTSVAnnotationOptions [tsvFile=" + tsvFile + ", annotationTarget=" + annotationTarget
+				+ ", oneBasedPositions=" + oneBasedPositions + ", contigColumnIndex=" + contigColumnIndex
+				+ ", beginColumnIndex=" + beginColumnIndex + ", endColumnIndex=" + endColumnIndex
+				+ ", refAlleleColumnIndex=" + refAlleleColumnIndex + ", altAlleleColumnIndex=" + altAlleleColumnIndex
+				+ ", refAlleleAnnotated=" + refAlleleAnnotated + ", columnNames=" + columnNames
+				+ ", valueColumnDescriptions=" + valueColumnDescriptions + "]";
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationTarget.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationTarget.java
new file mode 100755
index 0000000000..39339f2223
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationTarget.java
@@ -0,0 +1,14 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+/**
+ * Enumeration for describing annotation target (either position only or variant, e.g.
+ * <code>C&gt;T</code>.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public enum GenericTSVAnnotationTarget {
+	/** TSV file annotates a position. */
+	POSITION,
+	/** TSV file annotates a variant allele. */
+	VARIANT;
+}
\ No newline at end of file
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtender.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtender.java
new file mode 100755
index 0000000000..9e4277a20a
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtender.java
@@ -0,0 +1,71 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import htsjdk.variant.vcf.VCFHeader;
+import htsjdk.variant.vcf.VCFHeaderLineCount;
+import htsjdk.variant.vcf.VCFInfoHeaderLine;
+
+/**
+ * Helper class for extending {@link VCFHeader}s for generic TSV annotations.
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVHeaderExtender extends VCFHeaderExtender {
+
+	private GenericTSVAnnotationOptions tsvOptions;
+
+	public GenericTSVHeaderExtender(GenericTSVAnnotationOptions options) {
+		super(options);
+		this.tsvOptions = options;
+	}
+
+	@Override
+	public String getDefaultPrefix() {
+		return "TSV_";
+	}
+
+	@Override
+	public void addHeaders(VCFHeader header, String prefix) {
+		addHeadersInfixes(header, prefix, "", "");
+
+		// Only add the overlapping annotations if the REF and ALT columns are
+		// configured at all
+		if (tsvOptions.getAltAlleleColumnIndex() > 0 && tsvOptions.getRefAlleleColumnIndex() > 0) {
+			if (options.isReportOverlapping() && !options.isReportOverlappingAsMatching())
+				addHeadersInfixes(header, prefix, "OVL_",
+						" (requiring no genotype match, only position overlap)");
+		}
+	}
+
+	/**
+	 * Add INFO header lines.
+	 * 
+	 * <p>
+	 * In the case of annotating a TSV file with REF and ALT columns, annotate reference and
+	 * alternative alleles. Otherwise, annotate with a list of values.
+	 * </p>
+	 */
+	private void addHeadersInfixes(VCFHeader header, String prefix, String infix, String note) {
+		for (String colName : tsvOptions.getColumnNames()) {
+			final GenericTSVValueColumnDescription desc = tsvOptions.getValueColumnDescriptions()
+					.get(colName);
+			final VCFHeaderLineCount count;
+			if (tsvOptions.getAltAlleleColumnIndex() > 0 && tsvOptions.getRefAlleleColumnIndex() > 0
+					&& options.isReportOverlapping() && !options.isReportOverlappingAsMatching()) {
+				if (tsvOptions.isRefAlleleAnnotated()) {
+					count = VCFHeaderLineCount.R;
+				} else {
+					count = VCFHeaderLineCount.A;
+				}
+			} else {
+				count = VCFHeaderLineCount.UNBOUNDED;
+			}
+
+			final VCFInfoHeaderLine headerLine = new VCFInfoHeaderLine(
+					prefix + infix + desc.getFieldName(), count, desc.getValueType(),
+					desc.getFieldDescription() + note);
+			header.addMetaDataLine(headerLine);
+		}
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVRecord.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVRecord.java
new file mode 100755
index 0000000000..5e09d678c6
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVRecord.java
@@ -0,0 +1,115 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+
+/**
+ * Store entries for one column of a generic TSV file.
+ * 
+ * Here, we currently only have support for one alternative allele. This reflects more dbNSFP or the
+ * CADD score files than VCF files.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVRecord {
+
+	/** Name of the chromosome */
+	final private String contig;
+
+	/** Position of the variant, 0-based */
+	final private int pos;
+
+	/**
+	 * Reference sequence, <code>null</code> if locations are annotated instead of variants.
+	 */
+	final private String ref;
+	/**
+	 * Alternative allele in record, <code>null</code> if locations are annotated instead of
+	 * variants.
+	 */
+	final private String alt;
+
+	/** Values for each value column from configuration. */
+	final private ImmutableList<Object> values;
+
+	public GenericTSVRecord(String contig, int pos, String ref, String alt, List<Object> values) {
+		this.contig = contig;
+		this.pos = pos;
+		this.ref = ref;
+		this.alt = alt;
+		this.values = ImmutableList.copyOf(values);
+	}
+
+	public String getContig() {
+		return contig;
+	}
+
+	public int getPos() {
+		return pos;
+	}
+
+	public String getRef() {
+		return ref;
+	}
+
+	public String getAlt() {
+		return alt;
+	}
+
+	public List<Object> getValues() {
+		return values;
+	}
+
+	@Override
+	public String toString() {
+		return "GenericTSVRecord [chrom=" + contig + ", pos=" + pos + ", ref=" + ref + ", alt=" + alt + ", values="
+				+ values + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((alt == null) ? 0 : alt.hashCode());
+		result = prime * result + ((contig == null) ? 0 : contig.hashCode());
+		result = prime * result + pos;
+		result = prime * result + ((ref == null) ? 0 : ref.hashCode());
+		result = prime * result + ((values == null) ? 0 : values.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		GenericTSVRecord other = (GenericTSVRecord) obj;
+		if (alt == null) {
+			if (other.alt != null)
+				return false;
+		} else if (!alt.equals(other.alt))
+			return false;
+		if (contig == null) {
+			if (other.contig != null)
+				return false;
+		} else if (!contig.equals(other.contig))
+			return false;
+		if (pos != other.pos)
+			return false;
+		if (ref == null) {
+			if (other.ref != null)
+				return false;
+		} else if (!ref.equals(other.ref))
+			return false;
+		if (values == null) {
+			if (other.values != null)
+				return false;
+		} else if (!values.equals(other.values))
+			return false;
+		return true;
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVRecordBuilder.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVRecordBuilder.java
new file mode 100755
index 0000000000..70c8590552
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVRecordBuilder.java
@@ -0,0 +1,123 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Helper for building {@link GenericTSVRecord} objects.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVRecordBuilder {
+
+	private String contig;
+	private int pos;
+	private String ref;
+	private String alt;
+	private ArrayList<Object> values;
+
+	public GenericTSVRecordBuilder() {
+		this.contig = null;
+		this.pos = -1;
+		this.ref = null;
+		this.alt = null;
+		this.values = new ArrayList<>();
+	}
+
+	public GenericTSVRecord build() {
+		return new GenericTSVRecord(contig, pos, ref, alt, values);
+	}
+
+	public String getContig() {
+		return contig;
+	}
+
+	public void setContig(String contig) {
+		this.contig = contig;
+	}
+
+	public int getPos() {
+		return pos;
+	}
+
+	public void setPos(int pos) {
+		this.pos = pos;
+	}
+
+	public String getRef() {
+		return ref;
+	}
+
+	public void setRef(String ref) {
+		this.ref = ref;
+	}
+
+	public String getAlt() {
+		return alt;
+	}
+
+	public void setAlt(String alt) {
+		this.alt = alt;
+	}
+
+	public ArrayList<Object> getValues() {
+		return values;
+	}
+
+	public void setValues(List<Object> values) {
+		this.values = new ArrayList<>(values);
+	}
+
+	@Override
+	public String toString() {
+		return "GenericTSVRecordBuilder [contig=" + contig + ", pos=" + pos
+				+ ", ref=" + ref + ", alt=" + alt + ", values=" + values + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((alt == null) ? 0 : alt.hashCode());
+		result = prime * result + ((contig == null) ? 0 : contig.hashCode());
+		result = prime * result + pos;
+		result = prime * result + ((ref == null) ? 0 : ref.hashCode());
+		result = prime * result + ((values == null) ? 0 : values.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		GenericTSVRecordBuilder other = (GenericTSVRecordBuilder) obj;
+		if (alt == null) {
+			if (other.alt != null)
+				return false;
+		} else if (!alt.equals(other.alt))
+			return false;
+		if (contig == null) {
+			if (other.contig != null)
+				return false;
+		} else if (!contig.equals(other.contig))
+			return false;
+		if (pos != other.pos)
+			return false;
+		if (ref == null) {
+			if (other.ref != null)
+				return false;
+		} else if (!ref.equals(other.ref))
+			return false;
+		if (values == null) {
+			if (other.values != null)
+				return false;
+		} else if (!values.equals(other.values))
+			return false;
+		return true;
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVValueColumnDescription.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVValueColumnDescription.java
new file mode 100755
index 0000000000..997194f5cd
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVValueColumnDescription.java
@@ -0,0 +1,100 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import htsjdk.variant.vcf.VCFHeaderLineType;
+
+/**
+ * Description of a value column.
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVValueColumnDescription {
+
+	private int columnIndex = 6;
+
+	private VCFHeaderLineType valueType = VCFHeaderLineType.String;
+
+	private String fieldName = "VALUE_";
+
+	private String fieldDescription = "";
+
+	private GenericTSVAccumulationStrategy accumulationStrategy = GenericTSVAccumulationStrategy.CHOOSE_FIRST;
+
+	// Name of field to refer to for min/max
+	private String refField;
+
+	public GenericTSVValueColumnDescription() {
+	}
+
+	public GenericTSVValueColumnDescription(int columnIndex, VCFHeaderLineType valueType,
+			String fieldName, String fieldDescription,
+			GenericTSVAccumulationStrategy accumulationStrategy) {
+		this(columnIndex, valueType, fieldName, fieldDescription, accumulationStrategy, fieldName);
+	}
+
+	public GenericTSVValueColumnDescription(int columnIndex, VCFHeaderLineType valueType,
+			String fieldName, String fieldDescription,
+			GenericTSVAccumulationStrategy accumulationStrategy, String refField) {
+		this.columnIndex = columnIndex;
+		this.valueType = valueType;
+		this.fieldName = fieldName;
+		this.fieldDescription = fieldDescription;
+		this.accumulationStrategy = accumulationStrategy;
+		this.refField = refField;
+	}
+
+	public int getColumnIndex() {
+		return columnIndex;
+	}
+
+	public void setColumnIndex(int columnIndex) {
+		this.columnIndex = columnIndex;
+	}
+
+	public VCFHeaderLineType getValueType() {
+		return valueType;
+	}
+
+	public void setValueType(VCFHeaderLineType valueType) {
+		this.valueType = valueType;
+	}
+
+	public String getFieldName() {
+		return fieldName;
+	}
+
+	public void setFieldName(String fieldName) {
+		this.fieldName = fieldName;
+	}
+
+	public String getFieldDescription() {
+		return fieldDescription;
+	}
+
+	public void setFieldDescription(String fieldDescription) {
+		this.fieldDescription = fieldDescription;
+	}
+
+	public GenericTSVAccumulationStrategy getAccumulationStrategy() {
+		return accumulationStrategy;
+	}
+
+	public void setAccumulationStrategy(GenericTSVAccumulationStrategy accumulationStrategy) {
+		this.accumulationStrategy = accumulationStrategy;
+	}
+
+	public String getRefField() {
+		return refField;
+	}
+
+	public void setRefField(String refField) {
+		this.refField = refField;
+	}
+
+	@Override
+	public String toString() {
+		return "GenericTSVValueColumnDescription [columnIndex=" + columnIndex + ", valueType="
+				+ valueType + ", fieldName=" + fieldName + ", fieldDescription=" + fieldDescription
+				+ ", accumulationStrategy=" + accumulationStrategy + ", refField=" + refField + "]";
+	}
+
+}
\ No newline at end of file
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextProvider.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextProvider.java
new file mode 100755
index 0000000000..a4025f5c81
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextProvider.java
@@ -0,0 +1,321 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import com.google.common.collect.ImmutableList;
+import de.charite.compbio.jannovar.vardbs.base.DatabaseVariantContextProvider;
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.tribble.readers.TabixReader;
+import htsjdk.tribble.readers.TabixReader.Iterator;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.variantcontext.VariantContextBuilder;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * Read TSV records as {@link VariantContext} entries.
+ * 
+ * <p>
+ * Note that there cannot be concurrent queries with the same
+ * <code>GenericTSVVariantContextProvider</code> because we currently only shallowly wrap HTSJDK's
+ * TabixReader.
+ * </p>
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVVariantContextProvider implements DatabaseVariantContextProvider {
+
+	private final GenericTSVAnnotationOptions options;
+
+	private final TabixReader tabixReader;
+
+	public GenericTSVVariantContextProvider(GenericTSVAnnotationOptions options) {
+		this.options = options;
+		final String tsvPath = this.options.getTsvFile().toString();
+		try {
+			this.tabixReader = new TabixReader(tsvPath, tsvPath + ".tbi");
+		} catch (IOException e) {
+			throw new RuntimeException("Could not open TABIX file " + tsvPath, e);
+		}
+	}
+
+	@Override
+	public CloseableIterator<VariantContext> query(String contig, int beginPos, int endPos) {
+		return new TabixIteratorWrapper(tabixReader.query(contig, beginPos, endPos));
+	}
+
+	/**
+	 * Wrapper for iterator from {@link TabixReader}.
+	 * 
+	 * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+	 */
+	private class TabixIteratorWrapper implements CloseableIterator<VariantContext> {
+
+		private final Iterator iter;
+
+		private String next;
+
+		public TabixIteratorWrapper(Iterator iter) {
+			this.iter = iter;
+			try {
+				this.next = iter.next();
+			} catch (IOException e) {
+				throw new RuntimeException("Problem reading from " + options.getTsvFile(), e);
+			}
+		}
+
+		@Override
+		public boolean hasNext() {
+			return this.next != null;
+		}
+
+		@Override
+		public VariantContext next() {
+			final String resultLine = next;
+			try {
+				next = iter.next();
+			} catch (IOException e) {
+				throw new RuntimeException("Problem reading from " + options.getTsvFile(), e);
+			}
+			return parseTabixLine(resultLine);
+		}
+
+		private VariantContext parseTabixLine(String resultLine) {
+			final String[] tokens = resultLine.split("\t");
+
+			final VariantContextBuilder builder = new VariantContextBuilder();
+
+			builder.chr(tokens[options.getContigColumnIndex() - 1]);
+
+			final int delta = options.isOneBasedPositions() ? 0 : 1;
+			final int startPos = Integer.parseInt(tokens[options.getBeginColumnIndex() - 1])
+					- delta;
+			builder.start(startPos);
+			builder.stop(startPos);
+
+			if (options.getRefAlleleColumnIndex() > 0 && options.getAltAlleleColumnIndex() > 0) {
+				builder.alleles(tokens[options.getRefAlleleColumnIndex() - 1],
+						tokens[options.getAltAlleleColumnIndex() - 1]);
+			} else {
+				builder.alleles("N");
+			}
+
+			// Collect all required column names (ref column names might not be selected for
+			// printing)
+			Set<String> allColNames = new HashSet<>(options.getColumnNames());
+			for (String colName : options.getColumnNames()) {
+				final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
+						.get(colName);
+				if (desc.getRefField() != null) {
+					allColNames.add(desc.getRefField());
+				}
+			}
+
+			// Collect values from all required columns
+			Map<String, List<Object>> colValues = new HashMap<>();
+			for (String colName : allColNames) {
+				final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
+						.get(colName);
+				final String token = tokens[desc.getColumnIndex() - 1];
+				final String sep = ";";
+				final ImmutableList<String> splitTokens = ImmutableList.copyOf(token.split(sep));
+
+				switch (desc.getValueType()) {
+				case Flag:
+					colValues.put(colName, splitTokens.stream().map(s -> {
+						if (s == null || ".".equals(s)) {
+							return null;
+						} else {
+							return (Object) ImmutableList.of("1", "Y", "y", "T", "t", "yes", "true")
+									.contains(s);
+						}
+					}).collect(Collectors.toList()));
+					break;
+				case Float:
+					colValues.put(colName, splitTokens.stream().map(s -> {
+						if (s == null || ".".equals(s)) {
+							return null;
+						} else {
+							return (Object) Double.parseDouble(s);
+						}
+					}).collect(Collectors.toList()));
+					break;
+				case Integer:
+					colValues.put(colName, splitTokens.stream().map(s -> {
+						if (s == null || ".".equals(s)) {
+							return null;
+						} else {
+							return (Object) Integer.parseInt(s);
+						}
+					}).collect(Collectors.toList()));
+					break;
+				case Character:
+				case String:
+				default:
+					colValues.put(colName, ImmutableList.<Object> copyOf(splitTokens));
+					break;
+				}
+			}
+
+			// For each, now select the best according to strategy.
+			Map<String, Object> values = new HashMap<>();
+
+			for (String colName : options.getColumnNames()) {
+				final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
+						.get(colName);
+				final GenericTSVValueColumnDescription refDesc = options
+						.getValueColumnDescriptions().get(desc.getRefField());
+
+				switch (refDesc.getValueType()) {
+				case Character:
+				case Flag:
+				case String:
+					// Pick first one
+					values.put(colName, colValues.get(colName).get(0));
+					break;
+				case Float:
+					final List<
+							LabeledValue<Double, Object>> doubleLabeledValues = new ArrayList<>();
+					for (int i = 0; i < colValues.get(refDesc.getFieldName()).size(); ++i) {
+						Double value = (Double) colValues.get(refDesc.getFieldName()).get(i);
+						if (value == null && refDesc
+								.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MIN) {
+							value = Double.MAX_VALUE;
+						} else if (value == null && refDesc
+								.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MAX) {
+							value = Double.MIN_VALUE;
+						}
+						doubleLabeledValues.add(new LabeledValue<Double, Object>(value, i));
+					}
+
+					if (doubleLabeledValues.isEmpty()) {
+						values.put(colName, ".");
+					} else {
+						final int key;
+						switch (refDesc.getAccumulationStrategy()) {
+						case CHOOSE_MIN:
+							Collections.sort(doubleLabeledValues);
+							key = (int) doubleLabeledValues.get(0).getValue();
+							break;
+						case CHOOSE_MAX:
+							Collections.sort(doubleLabeledValues);
+							key = (int) doubleLabeledValues.get(doubleLabeledValues.size() - 1)
+									.getValue();
+							break;
+						case CHOOSE_FIRST:
+						case AVERAGE:
+						default:
+							key = 0;
+						}
+
+						if (colValues.get(desc.getFieldName()).size() == 1) {  // might be single value...
+							values.put(colName, colValues.get(desc.getFieldName()).get(0));
+						} else {
+							values.put(colName, colValues.get(desc.getFieldName()).get(key));
+						}
+					}
+					break;
+				case Integer:
+					final List<LabeledValue<Integer, Object>> intLabeledValues = new ArrayList<>();
+					for (int i = 0; i < colValues.get(refDesc.getFieldName()).size(); ++i) {
+						Integer value = (Integer) colValues.get(refDesc.getFieldName()).get(i);
+						if (value == null && refDesc
+								.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MIN) {
+							value = Integer.MAX_VALUE;
+						} else if (value == null && refDesc
+								.getAccumulationStrategy() == GenericTSVAccumulationStrategy.CHOOSE_MAX) {
+							value = Integer.MIN_VALUE;
+						}
+						intLabeledValues.add(new LabeledValue<Integer, Object>(
+								(Integer) colValues.get(refDesc.getFieldName()).get(i), i));
+					}
+
+					if (intLabeledValues.isEmpty()) {
+						values.put(colName, ".");
+					} else {
+						final int key;
+						switch (refDesc.getAccumulationStrategy()) {
+						case CHOOSE_MIN:
+							Collections.sort(intLabeledValues);
+							key = (int) intLabeledValues.get(0).getValue();
+							break;
+						case CHOOSE_MAX:
+							Collections.sort(intLabeledValues);
+							key = (int) intLabeledValues.get(intLabeledValues.size() - 1)
+									.getValue();
+							break;
+						case CHOOSE_FIRST:
+						case AVERAGE:
+						default:
+							key = 0;
+						}
+
+						if (colValues.get(desc.getFieldName()).size() == 1) {  // might be single value...
+							values.put(colName, colValues.get(desc.getFieldName()).get(0));
+						} else {
+							values.put(colName, colValues.get(desc.getFieldName()).get(key));
+						}
+					}
+					break;
+				default:
+					break;
+				}
+			}
+
+			// Finally, write out one value
+			for (String colName : options.getColumnNames()) {
+				final GenericTSVValueColumnDescription desc = options.getValueColumnDescriptions()
+						.get(colName);
+				builder.attribute(desc.getFieldName(), values.get(colName));
+			}
+
+			return builder.make();
+		}
+
+		@Override
+		public void close() {
+			/* nop */
+		}
+
+	}
+
+	/**
+	 * Helper for comparable pairs.
+	 */
+	private static class LabeledValue<Label extends Comparable<Label>, Value>
+			implements Comparable<LabeledValue<Label, Value>> {
+
+		private final Label label;
+		private final Value value;
+
+		public LabeledValue(Label label, Value value) {
+			this.label = label;
+			this.value = value;
+		}
+
+		public Label getLabel() {
+			return label;
+		}
+
+		public Value getValue() {
+			return value;
+		}
+
+		@Override
+		public String toString() {
+			return "LabeledValue [label=" + label + ", value=" + value + "]";
+		}
+
+		@Override
+		public int compareTo(LabeledValue<Label, Value> o) {
+			return label.compareTo(o.getLabel());
+		}
+
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextToRecordConverter.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextToRecordConverter.java
new file mode 100755
index 0000000000..f18fcbd3aa
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextToRecordConverter.java
@@ -0,0 +1,53 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import de.charite.compbio.jannovar.vardbs.base.VariantContextToRecordConverter;
+import htsjdk.variant.variantcontext.VariantContext;
+
+/**
+ * Helper class for converting {@link VariantContext} to {@link GenericTSVRecord}.
+ * 
+ * <p>
+ * It is a bit complex to first generate a {@link VariantContext} from TSV and then use this for
+ * converting back into {@link GenericTSVRecord}. However, this is the easiest way to use the
+ * existing machinery for annotation and allele matching.
+ * </p>
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+final class GenericTSVVariantContextToRecordConverter
+		implements VariantContextToRecordConverter<GenericTSVRecord> {
+
+	private GenericTSVAnnotationOptions tsvOptions;
+
+	public GenericTSVVariantContextToRecordConverter(GenericTSVAnnotationOptions options) {
+		this.tsvOptions = options;
+	}
+
+	@Override
+	public GenericTSVRecord convert(VariantContext vc) {
+		GenericTSVRecordBuilder builder = new GenericTSVRecordBuilder();
+
+		if (vc.getAlternateAlleles().size() > 1) {
+			throw new RuntimeException(
+					"Must have exactly zero or one ALT allele but this == " + this.toString());
+		}
+
+		builder.setContig(vc.getContig());
+		builder.setPos(vc.getStart() - 1);
+		if (vc.getAlternateAlleles().size() == 0) {
+			builder.setRef("N");
+			builder.setAlt("N");
+		} else {
+			builder.setRef(vc.getReference().toString());
+			builder.setAlt(vc.getAlternateAllele(0).toString());
+		}
+		for (String colName : tsvOptions.getColumnNames()) {
+			final GenericTSVValueColumnDescription desc = tsvOptions.getValueColumnDescriptions()
+					.get(colName);
+			builder.getValues().add(vc.getAttribute(desc.getFieldName()));
+		}
+
+		return builder.build();
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFAnnotationDriver.java
new file mode 100755
index 0000000000..c2f33f298a
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFAnnotationDriver.java
@@ -0,0 +1,136 @@
+package de.charite.compbio.jannovar.vardbs.generic_vcf;
+
+import de.charite.compbio.jannovar.vardbs.base.AbstractDBAnnotationDriver;
+import de.charite.compbio.jannovar.vardbs.base.AnnotatingRecord;
+import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import de.charite.compbio.jannovar.vardbs.base.VCFReaderVariantProvider;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.variantcontext.VariantContextBuilder;
+import htsjdk.variant.vcf.VCFHeaderLineCount;
+import htsjdk.variant.vcf.VCFInfoHeaderLine;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map.Entry;
+
+/**
+ * Annotation driver class for annotations using generic VCF data
+ *
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericVCFAnnotationDriver extends AbstractDBAnnotationDriver<VariantContext> {
+
+	private final GenericVCFAnnotationOptions genericVcfOptions;
+	private GenericVCFHeaderExtender genericVcfHeaderExtender;
+
+	public GenericVCFAnnotationDriver(String vcfPath, String fastaPath, GenericVCFAnnotationOptions options)
+			throws JannovarVarDBException {
+		super(new VCFReaderVariantProvider(options.getPathVcfFile()), fastaPath, options,
+				new GenericVCFVariantContextToRecordConverter());
+		this.genericVcfOptions = options;
+	}
+
+	@Override
+	protected HashMap<Integer, AnnotatingRecord<VariantContext>> pickAnnotatingDBRecords(
+			HashMap<Integer, ArrayList<GenotypeMatch>> annotatingRecords,
+			HashMap<GenotypeMatch, AnnotatingRecord<VariantContext>> matchToRecord, boolean isMatch) {
+		// Pick annotation for each alternative allele.
+		//
+		// Note that no smart allele picking has been implemented. Rather, the one from the first
+		// record is returned. In case of {@code !isMatch} (overlaps) and there is a match, this
+		// will be the first and thus used for annotation.
+		//
+		// TODO(holtgrewe): Implement better accumulation strategy? compare to handling TSV
+		HashMap<Integer, AnnotatingRecord<VariantContext>> annotatingRecord = new HashMap<>();
+		for (Entry<Integer, ArrayList<GenotypeMatch>> entry : annotatingRecords.entrySet()) {
+			final int alleleNo = entry.getKey();
+			for (GenotypeMatch m : entry.getValue()) {
+				// Select first or match. 
+				if (!annotatingRecord.containsKey(alleleNo) || m.isMatch()) {
+					annotatingRecord.put(alleleNo, matchToRecord.get(m));
+					if (m.isMatch()) { // stop looking forward in case of match
+						break;
+					}
+				}
+			}
+		}
+		return annotatingRecord;
+	}
+
+	@Override
+	public VCFHeaderExtender constructVCFHeaderExtender() {
+		// TODO(holtgrewe): This side-effect is very unclean, this whole module needs tests and
+		// refactoring
+		genericVcfHeaderExtender = new GenericVCFHeaderExtender(genericVcfOptions);
+		return genericVcfHeaderExtender;
+	}
+
+	@Override
+	protected VariantContext annotateWithDBRecords(VariantContext vc,
+			HashMap<Integer, AnnotatingRecord<VariantContext>> matchRecords,
+			HashMap<Integer, AnnotatingRecord<VariantContext>> overlapRecords) {
+		VariantContextBuilder builder = new VariantContextBuilder(vc);
+
+		// Annotate with records with matching allele
+		for (String fieldName : genericVcfOptions.getFieldNames()) {
+			annotate(vc, "", matchRecords, fieldName, builder);
+		}
+
+		// Annotate with records with overlapping positions
+		if (options.isReportOverlapping() && !options.isReportOverlappingAsMatching()) {
+			for (String fieldName : genericVcfOptions.getFieldNames()) {
+				annotate(vc, "OVL_", overlapRecords, fieldName, builder);
+			}
+		}
+
+		return builder.make();
+	}
+
+	private void annotate(VariantContext vc, String infix, HashMap<Integer, AnnotatingRecord<VariantContext>> records,
+			String fieldName, VariantContextBuilder builder) {
+		final VCFInfoHeaderLine headerLine = genericVcfHeaderExtender.getFileHeader().getInfoHeaderLine(fieldName);
+		final VCFHeaderLineCount countType = headerLine.getCountType();
+
+		// Note that any all cases are already caught in header extension and cause a
+		// RuntimeException.
+		int start = 0;
+		int end = vc.getNAlleles();
+		boolean annotatePos = false;
+		if (countType == VCFHeaderLineCount.R) {
+			/* nop */
+		} else if (countType == VCFHeaderLineCount.A) {
+			start = 1;
+		} else if (countType == VCFHeaderLineCount.INTEGER) {
+			assert headerLine.getCount() == 1;
+			annotatePos = true;
+		}
+
+		final String attrID = options.getVCFIdentifierPrefix() + infix + fieldName;
+
+		if (annotatePos) {
+			for (AnnotatingRecord<VariantContext> record : records.values()) {
+				if (record.getRecord().hasAttribute(fieldName)) {
+					builder.attribute(attrID, record.getRecord().getAttribute(fieldName));
+					return; // done annotating, default is "."
+				}
+			}
+		} else {
+			final ArrayList<Object> valueList = new ArrayList<>();
+			for (int i = start; i < end; ++i) {
+				int offset = (countType == VCFHeaderLineCount.R) ? 0 : 1;
+				if (records.containsKey(i) && records.get(i).getRecord().hasAttribute(fieldName)) {
+					final AnnotatingRecord<VariantContext> annoRecord = records.get(i);
+					valueList.add(annoRecord.getRecord().getAttributeAsList(fieldName).get(
+							annoRecord.getAlleleNo() - offset));
+				} else {
+					valueList.add(".");
+				}
+			}
+			if (!valueList.stream().allMatch(s -> ".".equals(s))) {
+				builder.attribute(attrID, valueList);
+			}
+		}
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFAnnotationOptions.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFAnnotationOptions.java
new file mode 100755
index 0000000000..af02fa2f7e
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFAnnotationOptions.java
@@ -0,0 +1,62 @@
+package de.charite.compbio.jannovar.vardbs.generic_vcf;
+
+import com.google.common.collect.ImmutableList;
+import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions;
+import java.util.List;
+
+/**
+ * Configuration for generic annotation of VCF with options.
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericVCFAnnotationOptions extends DBAnnotationOptions {
+
+	/** Path to VCF file. */
+	private final String pathVcfFile;
+	/** Field names to use for annotation. */
+	private final List<String> fieldNames;
+	// TODO: support different accumulation strategies, similar to TSV
+
+	/**
+	 * Parse configuration from command line string.
+	 * 
+	 * <p>
+	 * The value must be of the format <code>pathToVfFile:prefix:field1,field2,field3</code>.
+	 * </p>
+	 */
+	public static GenericVCFAnnotationOptions parseFrom(String s) {
+		String tokens[] = s.split(":", 3);
+		if (tokens.length != 3) {
+			throw new RuntimeException("Could not parse VCF annotation config from " + s);
+		}
+
+		return new GenericVCFAnnotationOptions(true, false, tokens[1],
+				MultipleMatchBehaviour.BEST_ONLY, tokens[0],
+				ImmutableList.copyOf(tokens[2].split(",")));
+	}
+
+	public GenericVCFAnnotationOptions(boolean reportOverlapping,
+			boolean reportOverlappingAsIdentical, String identifierPrefix,
+			MultipleMatchBehaviour multiMatchBehaviour, String pathVcfFile,
+			List<String> fieldNames) {
+		super(reportOverlapping, reportOverlappingAsIdentical, identifierPrefix,
+				multiMatchBehaviour);
+		this.pathVcfFile = pathVcfFile;
+		this.fieldNames = fieldNames;
+	}
+
+	public List<String> getFieldNames() {
+		return fieldNames;
+	}
+
+	public String getPathVcfFile() {
+		return pathVcfFile;
+	}
+
+	@Override
+	public String toString() {
+		return "GenericVCFAnnotationOptions [fieldNames=" + fieldNames + ", super="
+				+ super.toString() + ", pathVcfFile=" + pathVcfFile + "]";
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFHeaderExtender.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFHeaderExtender.java
new file mode 100755
index 0000000000..ee1eed2f59
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFHeaderExtender.java
@@ -0,0 +1,71 @@
+package de.charite.compbio.jannovar.vardbs.generic_vcf;
+
+import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import htsjdk.variant.vcf.VCFFileReader;
+import htsjdk.variant.vcf.VCFHeader;
+import htsjdk.variant.vcf.VCFHeaderLineCount;
+import htsjdk.variant.vcf.VCFInfoHeaderLine;
+import java.io.File;
+
+/**
+ * Helper class for extending {@link VCFHeader}s for UK10K annotations.
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericVCFHeaderExtender extends VCFHeaderExtender {
+
+	GenericVCFAnnotationOptions genericVcfOptions;
+	VCFHeader fileHeader;
+
+	public GenericVCFHeaderExtender(GenericVCFAnnotationOptions options) {
+		super(options);
+		this.genericVcfOptions = options;
+	}
+
+	@Override
+	public String getDefaultPrefix() {
+		return "";
+	}
+
+	@Override
+	public void addHeaders(VCFHeader header, String prefix) {
+		addHeadersInfixes(header, prefix, "", "");
+		if (options.isReportOverlapping() && !options.isReportOverlappingAsMatching())
+			addHeadersInfixes(header, prefix, "OVL_", " (requiring no genotype match, only position overlap)");
+	}
+
+	public void addHeadersInfixes(VCFHeader header, String prefix, String infix, String note) {
+		try (VCFFileReader reader = new VCFFileReader(new File(genericVcfOptions.getPathVcfFile()), false)) {
+			fileHeader = reader.getFileHeader();
+		}
+
+		for (String fieldName : genericVcfOptions.getFieldNames()) {
+			final VCFInfoHeaderLine headerLine = fileHeader.getInfoHeaderLine(fieldName);
+			final VCFHeaderLineCount countType = headerLine.getCountType();
+			// TODO(holtgrewe): support more counts, could require using "|" for nested lists
+			VCFInfoHeaderLine line;
+			if (countType == VCFHeaderLineCount.R) {
+				line = new VCFInfoHeaderLine(prefix + infix + fieldName, VCFHeaderLineCount.R, headerLine.getType(),
+						"Field " + fieldName + " from file " + genericVcfOptions.getPathVcfFile() + note);
+			} else if (countType == VCFHeaderLineCount.A) {
+				line = new VCFInfoHeaderLine(prefix + infix + fieldName, VCFHeaderLineCount.A, headerLine.getType(),
+						"Field " + fieldName + " from file " + genericVcfOptions.getPathVcfFile() + note);
+			} else if (countType == VCFHeaderLineCount.INTEGER) {
+				if (headerLine.getCount() != 1) {
+					throw new RuntimeException("Unsupported integer count " + headerLine.getCount());
+				}
+				line = new VCFInfoHeaderLine(prefix + infix + fieldName, 1, headerLine.getType(),
+						"Field " + fieldName + " from file " + genericVcfOptions.getPathVcfFile() + note);
+			} else {
+				throw new RuntimeException("Unsupported count type " + countType);
+			}
+
+			header.addMetaDataLine(line);
+		}
+	}
+
+	public VCFHeader getFileHeader() {
+		return fileHeader;
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFVariantContextToRecordConverter.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFVariantContextToRecordConverter.java
new file mode 100755
index 0000000000..9c6e3caeb3
--- /dev/null
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/generic_vcf/GenericVCFVariantContextToRecordConverter.java
@@ -0,0 +1,18 @@
+package de.charite.compbio.jannovar.vardbs.generic_vcf;
+
+import de.charite.compbio.jannovar.vardbs.base.VariantContextToRecordConverter;
+import htsjdk.variant.variantcontext.VariantContext;
+
+/**
+ * Helper class for the conversion of {@link VariantContext} to {@link GenericVCFRecord} objects
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+final class GenericVCFVariantContextToRecordConverter implements VariantContextToRecordConverter<VariantContext> {
+
+	@Override
+	public VariantContext convert(VariantContext vc) {
+		return vc;
+	}
+
+}
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadAnnotationDriver.java
index 4ae4d6e0c1..3049902018 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadAnnotationDriver.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadAnnotationDriver.java
@@ -12,6 +12,7 @@
 import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
 import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
 import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import de.charite.compbio.jannovar.vardbs.base.VCFReaderVariantProvider;
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
 
@@ -26,7 +27,7 @@
 
 	public GnomadAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options)
 			throws JannovarVarDBException {
-		super(vcfPath, fastaPath, options, new GnomadVariantContextToRecordConverter());
+		super(new VCFReaderVariantProvider(vcfPath), fastaPath, options, new GnomadVariantContextToRecordConverter());
 	}
 
 	@Override
diff --git a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriver.java b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriver.java
index 99d564396e..13c7cdd579 100755
--- a/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriver.java
+++ b/jannovar-vardbs/src/main/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriver.java
@@ -10,6 +10,7 @@
 import de.charite.compbio.jannovar.vardbs.base.GenotypeMatch;
 import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
 import de.charite.compbio.jannovar.vardbs.base.VCFHeaderExtender;
+import de.charite.compbio.jannovar.vardbs.base.VCFReaderVariantProvider;
 import htsjdk.variant.variantcontext.VariantContext;
 import htsjdk.variant.variantcontext.VariantContextBuilder;
 
@@ -22,7 +23,7 @@
 
 	public UK10KAnnotationDriver(String vcfPath, String fastaPath, DBAnnotationOptions options)
 			throws JannovarVarDBException {
-		super(vcfPath, fastaPath, options, new UK10KVariantContextToRecordConverter());
+		super(new VCFReaderVariantProvider(vcfPath), fastaPath, options, new UK10KVariantContextToRecordConverter());
 	}
 
 	@Override
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarAnnotationDriverReportNoOverlappingTest.java
index 993228fa05..dd7fe0c25d 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarAnnotationDriverReportNoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
     @Test
     public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("CLINVAR_");
         ClinVarAnnotationDriver driver = new ClinVarAnnotationDriver(dbClinVarVCFPath, fastaPath, options);
 
         VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarVCFHeaderExtenderTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarVCFHeaderExtenderTest.java
index fdcca6cdb7..93c45aedb1 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarVCFHeaderExtenderTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/clinvar/ClinVarVCFHeaderExtenderTest.java
@@ -1,11 +1,9 @@
 package de.charite.compbio.jannovar.vardbs.clinvar;
 
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
 import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions;
 import htsjdk.variant.vcf.VCFHeader;
+import org.junit.Assert;
+import org.junit.Test;
 
 public class ClinVarVCFHeaderExtenderTest {
 
@@ -23,6 +21,7 @@ public void test() {
 		DBAnnotationOptions options = DBAnnotationOptions.createDefaults();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("CLINVAR_");
 
 		new ClinVarVCFHeaderExtender(options).addHeaders(header);
 
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportAlsoOverlappingTest.java
index 66e36f8970..fb0e06f82c 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportAlsoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportAlsoOverlappingTest.java
@@ -26,6 +26,7 @@ public void setUpClass() throws Exception {
 		super.setUpClass();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("COSMIC_");
 	}
 
 	@Test
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportNoOverlappingTest.java
index 9c7e69a24c..57ff893a8c 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportNoOverlappingTest.java
@@ -26,6 +26,7 @@ public void setUpClass() throws Exception {
 		super.setUpClass();
 		options.setReportOverlapping(false);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("COSMIC_");
 	}
 
 	@Test
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportOverlappingAsMatchingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportOverlappingAsMatchingTest.java
index 61b3e2fa8e..c1b4d13248 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportOverlappingAsMatchingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicAnnotationDriverReportOverlappingAsMatchingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("COSMIC_");
 		CosmicAnnotationDriver driver = new CosmicAnnotationDriver(cosmicVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicVCFHeaderExtenderTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicVCFHeaderExtenderTest.java
index 5dc8bda3aa..ed71e3b1d7 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicVCFHeaderExtenderTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/cosmic/CosmicVCFHeaderExtenderTest.java
@@ -28,6 +28,7 @@ public void test() throws JannovarVarDBException {
 		DBAnnotationOptions options = DBAnnotationOptions.createDefaults();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("COSMIC_");
 
 		new CosmicVCFHeaderExtender(options).addHeaders(header);
 
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportAlsoOverlappingTest.java
index 2cc8ae4f98..c6162ca2d5 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportAlsoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportAlsoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("DBSNP_");
 		DBSNPAnnotationDriver driver = new DBSNPAnnotationDriver(dbSNPVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportNoOverlappingTest.java
index 1d03a9f200..d3cff96249 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportNoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("DBSNP_");
 		DBSNPAnnotationDriver driver = new DBSNPAnnotationDriver(dbSNPVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportOverlappingAsMatchingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportOverlappingAsMatchingTest.java
index f71a3cfe23..b24e78be37 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportOverlappingAsMatchingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPAnnotationDriverReportOverlappingAsMatchingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("DBSNP_");
 		DBSNPAnnotationDriver driver = new DBSNPAnnotationDriver(dbSNPVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPVCFHeaderExtenderTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPVCFHeaderExtenderTest.java
index 42ab862aa5..fdf8bd4ad8 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPVCFHeaderExtenderTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/dbsnp/DBSNPVCFHeaderExtenderTest.java
@@ -28,6 +28,7 @@ public void test() throws JannovarVarDBException {
 		DBAnnotationOptions options = DBAnnotationOptions.createDefaults();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("DBSNP_");
 
 		new DBSNPVCFHeaderExtender(options).addHeaders(header);
 
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportAlsoOverlappingTest.java
index 394dbd5c65..51525f5f75 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportAlsoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportAlsoOverlappingTest.java
@@ -30,6 +30,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("EXAC_");
 		ExacAnnotationDriver driver = new ExacAnnotationDriver(dbExacVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportNoOverlappingTest.java
index b41885a437..7e1755a0c9 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportNoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("EXAC_");
 		ExacAnnotationDriver driver = new ExacAnnotationDriver(dbExacVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportOverlappingAsMatchingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportOverlappingAsMatchingTest.java
index edf5062d8c..ab5727c858 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportOverlappingAsMatchingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacAnnotationDriverReportOverlappingAsMatchingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("EXAC_");
 		ExacAnnotationDriver driver = new ExacAnnotationDriver(dbExacVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacVCFHeaderExtenderTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacVCFHeaderExtenderTest.java
index 1bf9eecfeb..0a175f770b 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacVCFHeaderExtenderTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/exac/ExacVCFHeaderExtenderTest.java
@@ -28,6 +28,7 @@ public void test() throws JannovarVarDBException {
 		DBAnnotationOptions options = DBAnnotationOptions.createDefaults();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("EXAC_");
 
 		new ExacVCFHeaderExtender(options).addHeaders(header);
 
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpBaseTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpBaseTest.java
new file mode 100755
index 0000000000..c824487bdb
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpBaseTest.java
@@ -0,0 +1,78 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.io.Files;
+import de.charite.compbio.jannovar.utils.ResourceUtils;
+import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions.MultipleMatchBehaviour;
+import htsjdk.variant.vcf.VCFFileReader;
+import htsjdk.variant.vcf.VCFHeaderLineType;
+import java.io.File;
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+
+/**
+ * Test base for generic TSV annotation, using part of dbNSFP (shifted 69k bases towards the left).
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationDriverWithDbnsfpBaseTest {
+
+	protected String genericTsvPath;
+	protected String fastaPath;
+	protected GenericTSVAnnotationOptions options;
+
+	// File to annotate
+	protected VCFFileReader vcfReader;
+
+	@Before
+	public void setUp() throws Exception {
+		// Setup dbSNP VCF file
+		File tmpDir = Files.createTempDir();
+		genericTsvPath = tmpDir + "/dbNSFP.tsv.gz";
+		ResourceUtils.copyResourceToFile("/dbNSFP3.4a_variant.fake.tsv.gz",
+				new File(genericTsvPath));
+		String tbiPath = tmpDir + "/dbNSFP.tsv.gz.tbi";
+		ResourceUtils.copyResourceToFile("/dbNSFP3.4a_variant.fake.tsv.gz.tbi", new File(tbiPath));
+
+		// Setup reference FASTA file
+		fastaPath = tmpDir + "/chr1.fasta";
+		ResourceUtils.copyResourceToFile("/chr1.fasta", new File(fastaPath));
+		String faiPath = tmpDir + "/chr1.fasta.fai";
+		ResourceUtils.copyResourceToFile("/chr1.fasta.fai", new File(faiPath));
+
+		// Construct options
+		Map<String, GenericTSVValueColumnDescription> descriptions = new HashMap<>();
+		descriptions.put("AAREF",
+				new GenericTSVValueColumnDescription(5, VCFHeaderLineType.Character, "AAREF",
+						"Reference amino acid", GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		descriptions.put("RS_DBSNP147",
+				new GenericTSVValueColumnDescription(7, VCFHeaderLineType.String, "RS_DBSNP147",
+						"ID in dbSNP v147", GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		descriptions.put("HG19POS",
+				new GenericTSVValueColumnDescription(9, VCFHeaderLineType.Integer, "HG19POS",
+						"Position in hg19", GenericTSVAccumulationStrategy.CHOOSE_FIRST));
+		descriptions.put("SIFT_SCORE",
+				new GenericTSVValueColumnDescription(24, VCFHeaderLineType.Float, "SIFT_SCORE",
+						"Sift Score", GenericTSVAccumulationStrategy.CHOOSE_MAX));
+		this.options = new GenericTSVAnnotationOptions(true, false, "DBNSFP_",
+				MultipleMatchBehaviour.BEST_ONLY, new File(genericTsvPath),
+				GenericTSVAnnotationTarget.VARIANT, true, 1, 2, 2, 3, 4, true,
+				ImmutableList.of("AAREF", "RS_DBSNP147", "HG19POS", "SIFT_SCORE"), descriptions);
+		options.setReportOverlapping(true);
+		options.setReportOverlappingAsMatching(false);
+
+		// Write out file to use in the test
+		String vcfHeader = "##fileformat=VCFv4.0\n"
+				+ "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tindividual\n";
+		String testVCFPath = tmpDir + "/test_var_in_dbnsfp_tsv.vcf";
+		PrintWriter writer = new PrintWriter(testVCFPath);
+		writer.write(vcfHeader);
+		writer.write("1\t119\t.\tT\tA,C,G\t.\t.\t.\tGT\t0/1\n");
+		writer.close();
+
+		vcfReader = new VCFFileReader(new File(testVCFPath), false);
+	}
+
+}
\ No newline at end of file
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportAlsoOverlappingTest.java
new file mode 100755
index 0000000000..9f3359d090
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportAlsoOverlappingTest.java
@@ -0,0 +1,101 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.google.common.collect.Lists;
+
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.vcf.VCFHeader;
+
+/**
+ * Test for annotation with dbNSFP with default options
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationDriverWithDbnsfpReportAlsoOverlappingTest
+		extends GenericTSVAnnotationDriverWithDbnsfpBaseTest {
+
+	@Before
+	public void setUp() throws Exception {
+		super.setUp();
+		options.setReportOverlapping(true);
+		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("DBNSFP_");
+	}
+
+	@Test
+	public void testAnnotateExtendHeader() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+
+		VCFHeader header = vcfReader.getFileHeader();
+
+		// Check header before extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(0, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(0, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		driver.constructVCFHeaderExtender().addHeaders(header);
+
+		// Check header after extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(8, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(8, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_AAREF"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_RS_DBSNP147"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_HG19POS"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_SIFT_SCORE"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_OVL_AAREF"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_OVL_RS_DBSNP147"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_OVL_HG19POS"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_OVL_SIFT_SCORE"));
+	}
+
+	@Test
+	public void testAnnotateVariantContext() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+		VariantContext vc = vcfReader.iterator().next();
+
+		Assert.assertEquals(0, vc.getAttributes().size());
+		Assert.assertEquals(".", vc.getID());
+
+		VariantContext annotated = driver.annotateVariantContext(vc);
+
+		Assert.assertEquals(".", annotated.getID());
+
+		Assert.assertEquals(8, annotated.getAttributes().size());
+		ArrayList<String> keys = Lists.newArrayList(annotated.getAttributes().keySet());
+		Collections.sort(keys);
+		Assert.assertEquals("[DBNSFP_AAREF, DBNSFP_HG19POS, DBNSFP_OVL_AAREF, DBNSFP_OVL_HG19POS, "
+				+ "DBNSFP_OVL_RS_DBSNP147, DBNSFP_OVL_SIFT_SCORE, DBNSFP_RS_DBSNP147, "
+				+ "DBNSFP_SIFT_SCORE]", keys.toString());
+
+		Assert.assertEquals("[., L, L, L]", annotated.getAttributeAsString("DBNSFP_AAREF", null));
+		Assert.assertEquals("[., 69119, 69119, 69119]",
+				annotated.getAttributeAsString("DBNSFP_HG19POS", null));
+		Assert.assertEquals("[., ., ., .]",
+				annotated.getAttributeAsString("DBNSFP_RS_DBSNP147", null));
+		Assert.assertEquals("[., 0.0, 0.0, 0.0]",
+				annotated.getAttributeAsString("DBNSFP_SIFT_SCORE", null));
+
+		Assert.assertEquals("[., L, L, L]",
+				annotated.getAttributeAsString("DBNSFP_OVL_AAREF", null));
+		Assert.assertEquals("[., 69119, 69119, 69119]",
+				annotated.getAttributeAsString("DBNSFP_OVL_HG19POS", null));
+		Assert.assertEquals("[., ., ., .]",
+				annotated.getAttributeAsString("DBNSFP_OVL_RS_DBSNP147", null));
+		Assert.assertEquals("[., 0.0, 0.0, 0.0]",
+				annotated.getAttributeAsString("DBNSFP_OVL_SIFT_SCORE", null));
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportNoOverlappingTest.java
new file mode 100755
index 0000000000..04a746498f
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportNoOverlappingTest.java
@@ -0,0 +1,87 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.google.common.collect.Lists;
+
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.vcf.VCFHeader;
+
+/**
+ * Test for annotation with dbNSFP with default options
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationDriverWithDbnsfpReportNoOverlappingTest
+		extends GenericTSVAnnotationDriverWithDbnsfpBaseTest {
+
+	@Before
+	public void setUp() throws Exception {
+		super.setUp();
+		options.setReportOverlapping(false);
+		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("DBNSFP_");
+	}
+
+	@Test
+	public void testAnnotateExtendHeader() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+
+		VCFHeader header = vcfReader.getFileHeader();
+
+		// Check header before extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(0, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(0, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		driver.constructVCFHeaderExtender().addHeaders(header);
+
+		// Check header after extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(4, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(4, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_AAREF"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_RS_DBSNP147"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_HG19POS"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_SIFT_SCORE"));
+	}
+
+	@Test
+	public void testAnnotateVariantContext() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+		VariantContext vc = vcfReader.iterator().next();
+
+		Assert.assertEquals(0, vc.getAttributes().size());
+		Assert.assertEquals(".", vc.getID());
+
+		VariantContext annotated = driver.annotateVariantContext(vc);
+
+		Assert.assertEquals(".", annotated.getID());
+
+		Assert.assertEquals(4, annotated.getAttributes().size());
+		ArrayList<String> keys = Lists.newArrayList(annotated.getAttributes().keySet());
+		Collections.sort(keys);
+		Assert.assertEquals("[DBNSFP_AAREF, DBNSFP_HG19POS, DBNSFP_RS_DBSNP147, DBNSFP_SIFT_SCORE]",
+				keys.toString());
+
+		Assert.assertEquals("[., L, L, L]", annotated.getAttributeAsString("DBNSFP_AAREF", null));
+		Assert.assertEquals("[., 69119, 69119, 69119]",
+				annotated.getAttributeAsString("DBNSFP_HG19POS", null));
+		Assert.assertEquals("[., ., ., .]",
+				annotated.getAttributeAsString("DBNSFP_RS_DBSNP147", null));
+		Assert.assertEquals("[., 0.0, 0.0, 0.0]",
+				annotated.getAttributeAsString("DBNSFP_SIFT_SCORE", null));
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportOnlyOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportOnlyOverlappingTest.java
new file mode 100755
index 0000000000..be098059ed
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithDbnsfpReportOnlyOverlappingTest.java
@@ -0,0 +1,87 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.google.common.collect.Lists;
+
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.vcf.VCFHeader;
+
+/**
+ * Test for annotation with dbNSFP with default options
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationDriverWithDbnsfpReportOnlyOverlappingTest
+		extends GenericTSVAnnotationDriverWithDbnsfpBaseTest {
+
+	@Before
+	public void setUp() throws Exception {
+		super.setUp();
+		options.setReportOverlapping(true);
+		options.setReportOverlappingAsMatching(true);
+		options.setIdentifierPrefix("DBNSFP_");
+	}
+
+	@Test
+	public void testAnnotateExtendHeader() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+
+		VCFHeader header = vcfReader.getFileHeader();
+
+		// Check header before extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(0, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(0, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		driver.constructVCFHeaderExtender().addHeaders(header);
+
+		// Check header after extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(4, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(4, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_AAREF"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_RS_DBSNP147"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_HG19POS"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_SIFT_SCORE"));
+	}
+
+	@Test
+	public void testAnnotateVariantContext() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+		VariantContext vc = vcfReader.iterator().next();
+
+		Assert.assertEquals(0, vc.getAttributes().size());
+		Assert.assertEquals(".", vc.getID());
+
+		VariantContext annotated = driver.annotateVariantContext(vc);
+
+		Assert.assertEquals(".", annotated.getID());
+
+		Assert.assertEquals(4, annotated.getAttributes().size());
+		ArrayList<String> keys = Lists.newArrayList(annotated.getAttributes().keySet());
+		Collections.sort(keys);
+		Assert.assertEquals("[DBNSFP_AAREF, DBNSFP_HG19POS, DBNSFP_RS_DBSNP147, DBNSFP_SIFT_SCORE]",
+				keys.toString());
+
+		Assert.assertEquals("[., L, L, L]", annotated.getAttributeAsString("DBNSFP_AAREF", null));
+		Assert.assertEquals("[., 69119, 69119, 69119]",
+				annotated.getAttributeAsString("DBNSFP_HG19POS", null));
+		Assert.assertEquals("[., ., ., .]",
+				annotated.getAttributeAsString("DBNSFP_RS_DBSNP147", null));
+		Assert.assertEquals("[., 0.0, 0.0, 0.0]",
+				annotated.getAttributeAsString("DBNSFP_SIFT_SCORE", null));
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithRemmBaseTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithRemmBaseTest.java
new file mode 100755
index 0000000000..ec7342afd1
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithRemmBaseTest.java
@@ -0,0 +1,67 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.io.Files;
+import de.charite.compbio.jannovar.utils.ResourceUtils;
+import de.charite.compbio.jannovar.vardbs.base.DBAnnotationOptions.MultipleMatchBehaviour;
+import htsjdk.variant.vcf.VCFFileReader;
+import htsjdk.variant.vcf.VCFHeaderLineType;
+import java.io.File;
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+
+/**
+ * Test base for generic TSV annotation, using the head of ReMM v0.3.1
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationDriverWithRemmBaseTest {
+
+	protected String genericTsvPath;
+	protected String fastaPath;
+	protected GenericTSVAnnotationOptions options;
+
+	// File to annotate
+	protected VCFFileReader vcfReader;
+
+	@Before
+	public void setUp() throws Exception {
+		// Setup dbSNP VCF file
+		File tmpDir = Files.createTempDir();
+		genericTsvPath = tmpDir + "/ReMM.v0.3.1.head.tsv.gz";
+		ResourceUtils.copyResourceToFile("/ReMM.v0.3.1.head.tsv.gz", new File(genericTsvPath));
+		String tbiPath = tmpDir + "/ReMM.v0.3.1.head.tsv.gz.tbi";
+		ResourceUtils.copyResourceToFile("/ReMM.v0.3.1.head.tsv.gz.tbi", new File(tbiPath));
+
+		// Setup reference FASTA file
+		fastaPath = tmpDir + "/chr1.fasta";
+		ResourceUtils.copyResourceToFile("/chr1.fasta", new File(fastaPath));
+		String faiPath = tmpDir + "/chr1.fasta.fai";
+		ResourceUtils.copyResourceToFile("/chr1.fasta.fai", new File(faiPath));
+
+		// Construct options
+		Map<String, GenericTSVValueColumnDescription> descriptions = new HashMap<>();
+		descriptions.put("REMM_SCORE", new GenericTSVValueColumnDescription(3, VCFHeaderLineType.Float, "REMM_SCORE",
+				"ReMM Score", GenericTSVAccumulationStrategy.CHOOSE_MAX));
+		this.options = new GenericTSVAnnotationOptions(true, false, "", MultipleMatchBehaviour.BEST_ONLY,
+				new File(genericTsvPath), GenericTSVAnnotationTarget.VARIANT, true, 1, 2, 2, 0, 0, true,
+				ImmutableList.of("REMM_SCORE"), descriptions);
+		options.setReportOverlapping(true);
+		options.setReportOverlappingAsMatching(true);
+
+		// Write out file to use in the test
+		String vcfHeader = "##fileformat=VCFv4.0\n"
+				+ "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tindividual\n";
+		String testVCFPath = tmpDir + "/test_var_in_dbnsfp_tsv.vcf";
+		PrintWriter writer = new PrintWriter(testVCFPath);
+		writer.write(vcfHeader);
+		writer.write("1\t10026\t.\tT\tA,C,G\t.\t.\t.\tGT\t0/1\n");
+		writer.write("1\t10032\t.\tTA\tT\t.\t.\t.\tGT\t0/1\n"); // 1033 has higher score
+		writer.close();
+
+		vcfReader = new VCFFileReader(new File(testVCFPath), false);
+	}
+
+}
\ No newline at end of file
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithRemmReportOnlyOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithRemmReportOnlyOverlappingTest.java
new file mode 100755
index 0000000000..fa88325d56
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVAnnotationDriverWithRemmReportOnlyOverlappingTest.java
@@ -0,0 +1,97 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.google.common.collect.Lists;
+
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.variant.variantcontext.VariantContext;
+import htsjdk.variant.vcf.VCFHeader;
+
+/**
+ * Test for annotation with dbNSFP with default options
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVAnnotationDriverWithRemmReportOnlyOverlappingTest
+		extends GenericTSVAnnotationDriverWithRemmBaseTest {
+
+	@Before
+	public void setUp() throws Exception {
+		super.setUp();
+	}
+
+	@Test
+	public void testAnnotateExtendHeader() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+
+		VCFHeader header = vcfReader.getFileHeader();
+
+		// Check header before extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(0, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(0, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		driver.constructVCFHeaderExtender().addHeaders(header);
+
+		// Check header after extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(1, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(1, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		Assert.assertNotNull(header.getInfoHeaderLine("REMM_SCORE"));
+	}
+
+	@Test
+	public void testAnnotateVariantContext() throws JannovarVarDBException {
+		GenericTSVAnnotationDriver driver = new GenericTSVAnnotationDriver(fastaPath, options);
+		// Annotation of first variant
+		final CloseableIterator<VariantContext> iter = vcfReader.iterator();
+		VariantContext vcFirst = iter.next();
+		Assert.assertEquals(vcFirst.getStart(), 10026);
+
+		Assert.assertEquals(0, vcFirst.getAttributes().size());
+		Assert.assertEquals(".", vcFirst.getID());
+
+		VariantContext annotatedFirst = driver.annotateVariantContext(vcFirst);
+
+		Assert.assertEquals(".", annotatedFirst.getID());
+
+		Assert.assertEquals(1, annotatedFirst.getAttributes().size());
+		ArrayList<String> keys = Lists.newArrayList(annotatedFirst.getAttributes().keySet());
+		Collections.sort(keys);
+		Assert.assertEquals("[REMM_SCORE]", keys.toString());
+
+		Assert.assertEquals("[., 0.102, 0.102, 0.102]",
+				annotatedFirst.getAttributeAsString("REMM_SCORE", null));
+
+		// Annotation of second variant
+		VariantContext vcSecond = iter.next();
+		Assert.assertEquals(vcSecond.getStart(), 10032);
+
+		Assert.assertEquals(0, vcFirst.getAttributes().size());
+		Assert.assertEquals(".", vcFirst.getID());
+
+		VariantContext annotatedSecond = driver.annotateVariantContext(vcSecond);
+
+		Assert.assertEquals(".", annotatedSecond.getID());
+
+		Assert.assertEquals(1, annotatedSecond.getAttributes().size());
+		ArrayList<String> keysSecond = Lists.newArrayList(annotatedSecond.getAttributes().keySet());
+		Collections.sort(keysSecond);
+		Assert.assertEquals("[REMM_SCORE]", keys.toString());
+
+		Assert.assertEquals("[., 0.104]", annotatedSecond.getAttributeAsString("REMM_SCORE", null));
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtenderDbnsfpTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtenderDbnsfpTest.java
new file mode 100755
index 0000000000..c3c433e706
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtenderDbnsfpTest.java
@@ -0,0 +1,41 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import htsjdk.variant.vcf.VCFHeader;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Test header extension code for generic TSV processing
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVHeaderExtenderDbnsfpTest extends GenericTSVAnnotationDriverWithDbnsfpBaseTest {
+
+	@Test
+	public void test() throws JannovarVarDBException {
+		VCFHeader header = new VCFHeader();
+
+		// Check header before extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(0, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(0, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		new GenericTSVHeaderExtender(options).addHeaders(header);
+
+		// Check header after extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(8, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(8, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_AAREF"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_RS_DBSNP147"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_HG19POS"));
+		Assert.assertNotNull(header.getInfoHeaderLine("DBNSFP_SIFT_SCORE"));
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtenderRemmTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtenderRemmTest.java
new file mode 100755
index 0000000000..f4ae1edccb
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVHeaderExtenderRemmTest.java
@@ -0,0 +1,38 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import de.charite.compbio.jannovar.vardbs.base.JannovarVarDBException;
+import htsjdk.variant.vcf.VCFHeader;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Test header extension code for generic TSV processing
+ * 
+ * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
+ */
+public class GenericTSVHeaderExtenderRemmTest extends GenericTSVAnnotationDriverWithRemmBaseTest {
+
+	@Test
+	public void test() throws JannovarVarDBException {
+		VCFHeader header = new VCFHeader();
+
+		// Check header before extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(0, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(0, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		new GenericTSVHeaderExtender(options).addHeaders(header);
+
+		// Check header after extension
+		Assert.assertEquals(0, header.getFilterLines().size());
+		Assert.assertEquals(1, header.getInfoHeaderLines().size());
+		Assert.assertEquals(0, header.getFormatHeaderLines().size());
+		Assert.assertEquals(1, header.getIDHeaderLines().size());
+		Assert.assertEquals(0, header.getOtherHeaderLines().size());
+
+		Assert.assertNotNull(header.getInfoHeaderLine("REMM_SCORE"));
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextProviderWithDbnsfpTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextProviderWithDbnsfpTest.java
new file mode 100755
index 0000000000..79ea4afa26
--- /dev/null
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/generic_tsv/GenericTSVVariantContextProviderWithDbnsfpTest.java
@@ -0,0 +1,44 @@
+package de.charite.compbio.jannovar.vardbs.generic_tsv;
+
+import htsjdk.samtools.util.CloseableIterator;
+import htsjdk.variant.variantcontext.VariantContext;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class GenericTSVVariantContextProviderWithDbnsfpTest extends GenericTSVAnnotationDriverWithDbnsfpBaseTest {
+
+	@Test
+	public void test() {
+		GenericTSVVariantContextProvider provider = new GenericTSVVariantContextProvider(options);
+
+		List<VariantContext> vcs = new ArrayList<>();
+		try (CloseableIterator<VariantContext> it = provider.query("1", 90, 92)) {
+			while (it.hasNext()) {
+				vcs.add(it.next());
+			}
+		}
+
+		Assert.assertEquals(6, vcs.size());
+		Assert.assertEquals(
+				"[VC null @ 1:91 Q. of type=SNP alleles=[A*, C] attr={AAREF=M, HG19POS=69091, RS_DBSNP147=., SIFT_SCORE=0.13} GT=[]",
+				vcs.get(0).toString());
+		Assert.assertEquals(
+				"[VC null @ 1:91 Q. of type=SNP alleles=[A*, G] attr={AAREF=M, HG19POS=69091, RS_DBSNP147=., SIFT_SCORE=1.0} GT=[]",
+				vcs.get(1).toString());
+		Assert.assertEquals(
+				"[VC null @ 1:91 Q. of type=SNP alleles=[A*, T] attr={AAREF=M, HG19POS=69091, RS_DBSNP147=., SIFT_SCORE=0.13} GT=[]",
+				vcs.get(2).toString());
+		Assert.assertEquals(
+				"[VC null @ 1:92 Q. of type=SNP alleles=[T*, A] attr={AAREF=M, HG19POS=69092, RS_DBSNP147=., SIFT_SCORE=0.0} GT=[]",
+				vcs.get(3).toString());
+		Assert.assertEquals(
+				"[VC null @ 1:92 Q. of type=SNP alleles=[T*, C] attr={AAREF=M, HG19POS=69092, RS_DBSNP147=., SIFT_SCORE=0.001} GT=[]",
+				vcs.get(4).toString());
+		Assert.assertEquals(
+				"[VC null @ 1:92 Q. of type=SNP alleles=[T*, G] attr={AAREF=M, HG19POS=69092, RS_DBSNP147=., SIFT_SCORE=0.0} GT=[]",
+				vcs.get(5).toString());
+	}
+
+}
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportAlsoOverlappingTest.java
index f232493412..2e96d532c6 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportAlsoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportAlsoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("GNOMAD_");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportNoOverlappingTest.java
index bb82e39a20..3c49acc62e 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportNoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("GNOMAD_");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
@@ -103,6 +104,7 @@ public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBExce
 
 	@Test
 	public void testAnnotateVariantContext() throws JannovarVarDBException {
+		options.setIdentifierPrefix("");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 		VariantContext vc = vcfReader.iterator().next();
 
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportOverlappingAsMatchingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportOverlappingAsMatchingTest.java
index b768e015e2..f87fc9c706 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportOverlappingAsMatchingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadExomesAnnotationDriverReportOverlappingAsMatchingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("GNOMAD_");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportAlsoOverlappingTest.java
index 791803c480..06f7b3da93 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportAlsoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportAlsoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("GNOMAD_");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportNoOverlappingTest.java
index 1952170c79..c384c4a872 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportNoOverlappingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("GNOMAD_");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportOverlappingAsMatchingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportOverlappingAsMatchingTest.java
index 5166efc581..c1776f6fe9 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportOverlappingAsMatchingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadGenomesAnnotationDriverReportOverlappingAsMatchingTest.java
@@ -30,6 +30,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("GNOMAD_");
 		GnomadAnnotationDriver driver = new GnomadAnnotationDriver(gnomadVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadVCFHeaderExtenderTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadVCFHeaderExtenderTest.java
index 1ea36d1d9b..c36d72bfab 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadVCFHeaderExtenderTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/gnomad/GnomadVCFHeaderExtenderTest.java
@@ -28,6 +28,7 @@ public void test() throws JannovarVarDBException {
 		DBAnnotationOptions options = DBAnnotationOptions.createDefaults();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("GNOMAD_");
 
 		new GnomadVCFHeaderExtender(options).addHeaders(header);
 
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportAlsoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportAlsoOverlappingTest.java
index 8c826a9faf..2b9b1396c4 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportAlsoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportAlsoOverlappingTest.java
@@ -26,6 +26,7 @@ public void setUpClass() throws Exception {
 		super.setUpClass();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("UK10K_");
 	}
 
 	@Test
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportNoOverlappingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportNoOverlappingTest.java
index 5a60446184..9f1df3c6c2 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportNoOverlappingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportNoOverlappingTest.java
@@ -26,6 +26,7 @@ public void setUpClass() throws Exception {
 		super.setUpClass();
 		options.setReportOverlapping(false);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("UK10K_");
 	}
 
 	@Test
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportOverlappingAsMatchingTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportOverlappingAsMatchingTest.java
index 118f88daac..bc9e98c4db 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportOverlappingAsMatchingTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KAnnotationDriverReportOverlappingAsMatchingTest.java
@@ -29,6 +29,7 @@ public void setUpClass() throws Exception {
 
 	@Test
 	public void testAnnotateExtendHeaderWithDefaultPrefix() throws JannovarVarDBException {
+		options.setIdentifierPrefix("UK10K_");
 		UK10KAnnotationDriver driver = new UK10KAnnotationDriver(dbUK10KVCFPath, fastaPath, options);
 
 		VCFHeader header = vcfReader.getFileHeader();
diff --git a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KVCFHeaderExtenderTest.java b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KVCFHeaderExtenderTest.java
index e85f5a0c43..13b25b9a67 100755
--- a/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KVCFHeaderExtenderTest.java
+++ b/jannovar-vardbs/src/test/java/de/charite/compbio/jannovar/vardbs/uk10k/UK10KVCFHeaderExtenderTest.java
@@ -28,6 +28,7 @@ public void test() throws JannovarVarDBException {
 		DBAnnotationOptions options = DBAnnotationOptions.createDefaults();
 		options.setReportOverlapping(true);
 		options.setReportOverlappingAsMatching(false);
+		options.setIdentifierPrefix("UK10K_");
 
 		new UK10KVCFHeaderExtender(options).addHeaders(header);
 
diff --git a/jannovar-vardbs/src/test/resources/ReMM.v0.3.1.head.tsv.gz b/jannovar-vardbs/src/test/resources/ReMM.v0.3.1.head.tsv.gz
new file mode 100755
index 0000000000..6ecfbdda3e
Binary files /dev/null and b/jannovar-vardbs/src/test/resources/ReMM.v0.3.1.head.tsv.gz differ
diff --git a/jannovar-vardbs/src/test/resources/ReMM.v0.3.1.head.tsv.gz.tbi b/jannovar-vardbs/src/test/resources/ReMM.v0.3.1.head.tsv.gz.tbi
new file mode 100755
index 0000000000..ed46b49b05
Binary files /dev/null and b/jannovar-vardbs/src/test/resources/ReMM.v0.3.1.head.tsv.gz.tbi differ
diff --git a/jannovar-vardbs/src/test/resources/dbNSFP3.4a_variant.fake.tsv.gz b/jannovar-vardbs/src/test/resources/dbNSFP3.4a_variant.fake.tsv.gz
new file mode 100755
index 0000000000..59077f9a2e
Binary files /dev/null and b/jannovar-vardbs/src/test/resources/dbNSFP3.4a_variant.fake.tsv.gz differ
diff --git a/jannovar-vardbs/src/test/resources/dbNSFP3.4a_variant.fake.tsv.gz.tbi b/jannovar-vardbs/src/test/resources/dbNSFP3.4a_variant.fake.tsv.gz.tbi
new file mode 100755
index 0000000000..5b7040dcca
Binary files /dev/null and b/jannovar-vardbs/src/test/resources/dbNSFP3.4a_variant.fake.tsv.gz.tbi differ
diff --git a/manual/authors.rst b/manual/authors.rst
index 0142756b63..edea7e9ed5 100755
--- a/manual/authors.rst
+++ b/manual/authors.rst
@@ -8,3 +8,9 @@ in alphabetical order
 - Marten Jaeger
 - Max Schubach
 - Peter N. Robinson
+
+------------
+Contributors
+------------
+
+- Roland Ewald
diff --git a/pom.xml b/pom.xml
index 23a579fe8a..206c27deca 100755
--- a/pom.xml
+++ b/pom.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <groupId>de.charite.compbio</groupId>
     <artifactId>Jannovar</artifactId>
@@ -10,7 +11,12 @@
     <properties>
         <htsjdk.version>2.8.1</htsjdk.version>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-        <log4j.version>2.5</log4j.version>
+        <log4j.version>2.8.2</log4j.version>
+
+        <junit.version>4.12</junit.version>
+        <slf4j.version>1.7.24</slf4j.version>
+        <guava.version>22.0</guava.version>
+        <antlr.version>4.7</antlr.version>
     </properties>
 
     <modules>
@@ -80,7 +86,7 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.12</version>
+            <version>${slf4j.version}</version>
         </dependency>
         <!-- Logging implementation for test only. -->
         <dependency>
@@ -99,7 +105,7 @@
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
-            <version>4.12</version>
+            <version>${junit.version}</version>
             <scope>test</scope>
         </dependency>
     </dependencies>
@@ -115,7 +121,8 @@
                     <skipTests>false</skipTests>
                     <forkCount>3</forkCount>
                     <reuseForks>true</reuseForks>
-                    <argLine>${argLine} -Xms512m -Xmx1024m -Duser.language=en -Duser.region=US</argLine>
+                    <argLine>${argLine} -Xms512m -Xmx1024m
+                        -Duser.language=en -Duser.region=US</argLine>
                     <systemPropertyVariables>
                         <user.language>en</user.language>
                         <user.region>US</user.region>
