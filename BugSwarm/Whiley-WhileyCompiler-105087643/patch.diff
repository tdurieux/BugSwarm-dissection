diff --git a/modules/wyil/src/wyil/builders/VcGenerator.java b/modules/wyil/src/wyil/builders/VcGenerator.java
index 03cf8e9002..dc78e70862 100755
--- a/modules/wyil/src/wyil/builders/VcGenerator.java
+++ b/modules/wyil/src/wyil/builders/VcGenerator.java
@@ -638,17 +638,17 @@ private void joinAll(ArrayList<VcBranch> branches) {
 	 *            --- The branch the division is on.
 	 * @return
 	 */
-	public Pair<String,Expr>[] divideByZeroCheck(Codes.BinaryOperator binOp, VcBranch branch) {
+	public Pair<String, Expr>[] divideByZeroCheck(Codes.BinaryOperator binOp, VcBranch branch) {
 		Expr rhs = branch.read(binOp.operand(1));
 		Value zero;
-		if (binOp.type() instanceof Type.Int) {
+		if (binOp.type(0) instanceof Type.Int) {
 			zero = Value.Integer(BigInteger.ZERO);
 		} else {
 			zero = Value.Decimal(BigDecimal.ZERO);
 		}
 		Expr.Constant constant = new Expr.Constant(zero, rhs.attributes());
-		return new Pair[] { new Pair("division by zero", new Expr.Binary(
-				Expr.Binary.Op.NEQ, rhs, constant, rhs.attributes())) };
+		return new Pair[] {
+				new Pair("division by zero", new Expr.Binary(Expr.Binary.Op.NEQ, rhs, constant, rhs.attributes())) };
 	}
 
 	/**
@@ -663,7 +663,7 @@ private void joinAll(ArrayList<VcBranch> branches) {
 	 * @return
 	 */
 	public Pair<String,Expr>[] indexOutOfBoundsChecks(Codes.IndexOf code, VcBranch branch) {
-		if (code.type() instanceof Type.EffectiveArray) {
+		if (code.type(0) instanceof Type.EffectiveArray) {
 			Expr src = branch.read(code.operand(0));
 			Expr idx = branch.read(code.operand(1));
 			Expr zero = new Expr.Constant(Value.Integer(BigInteger.ZERO),
@@ -723,26 +723,21 @@ private void joinAll(ArrayList<VcBranch> branches) {
 		// First, check for any potentially constrained types.    
 		//
 		List<wyil.lang.Attribute> attributes = block.attributes(branch.pc());
-		List<Type> code_type_params = code.type().params();		
+		List<Type> code_type_params = code.type(0).params();		
 		int[] code_operands = code.operands();
 		for (int i = 0; i != code_operands.length; ++i) {
 			Type t = code_type_params.get(i);
 			if (containsNominal(t, attributes)) {
 				int operand = code_operands[i];
-				Type rawType = expand(environment[operand],attributes);
-				Expr rawTest = new Expr.Is(branch.read(operand), convert(
-						rawType, attributes));
-				Expr nominalTest = new Expr.Is(branch.read(operand), convert(t,
-						attributes));
-				preconditions.add(new Pair(
-						"type invariant not satisfied (argument " + i + ")",
-						new Expr.Binary(Expr.Binary.Op.IMPLIES, rawTest,
-								nominalTest)));
+				Type rawType = expand(environment[operand], attributes);
+				Expr rawTest = new Expr.Is(branch.read(operand), convert(rawType, attributes));
+				Expr nominalTest = new Expr.Is(branch.read(operand), convert(t, attributes));
+				preconditions.add(new Pair("type invariant not satisfied (argument " + i + ")",
+						new Expr.Binary(Expr.Binary.Op.IMPLIES, rawTest, nominalTest)));
 			}
 		}
 		//
-		List<AttributedCodeBlock> requires = findPrecondition(code.name,
-				code.type(), block, branch);
+		List<AttributedCodeBlock> requires = findPrecondition(code.name, code.type(0), block, branch);
 		//
 		if (requires.size() > 0) {
 			// First, read out the operands from the branch
@@ -754,12 +749,10 @@ private void joinAll(ArrayList<VcBranch> branches) {
 			// simply called the corresponding pre-condition macros.
 			String prefix = code.name.name() + "_requires_";
 
-			Expr argument = operands.length == 1 ? operands[0] : new Expr.Nary(
-					Expr.Nary.Op.TUPLE, operands);
+			Expr argument = operands.length == 1 ? operands[0] : new Expr.Nary(Expr.Nary.Op.TUPLE, operands);
 			for (int i = 0; i != requires.size(); ++i) {
-				Expr precondition = new Expr.Invoke(prefix + i,
-						code.name.module(), Collections.EMPTY_LIST, argument);
-				preconditions.add(new Pair<String,Expr>("precondition not satisfied",precondition));
+				Expr precondition = new Expr.Invoke(prefix + i, code.name.module(), Collections.EMPTY_LIST, argument);
+				preconditions.add(new Pair<String, Expr>("precondition not satisfied", precondition));
 
 			}
 		}
@@ -779,7 +772,7 @@ private void joinAll(ArrayList<VcBranch> branches) {
 	public Pair<String,Expr>[] updateChecks(Codes.Update code, VcBranch branch) {
 		ArrayList<Pair<String,Expr>> preconditions = new ArrayList<Pair<String,Expr>>();
 
-		Expr src = branch.read(code.target());
+		Expr src = branch.read(code.target(0));
 
 		for (Codes.LVal lval : code) {
 			if (lval instanceof Codes.ArrayLVal) {
@@ -1567,11 +1560,9 @@ protected void transform(Code.Unit code, AttributedCodeBlock block,
 			} else if (code instanceof Codes.ArrayGenerator) {
 				transform((Codes.ArrayGenerator) code, block, branch);
 			} else if (code instanceof Codes.NewArray) {
-				transformNary(Expr.Nary.Op.ARRAY, (Codes.NewArray) code, branch,
-						block);
+				transformNary(Expr.Nary.Op.ARRAY, (Codes.NewArray) code, branch, block);
 			} else if (code instanceof Codes.NewRecord) {
-				transformNary(Expr.Nary.Op.TUPLE, (Codes.NewRecord) code,
-						branch, block);
+				transformNary(Expr.Nary.Op.TUPLE, (Codes.NewRecord) code, branch, block);
 			} else if (code instanceof Codes.Convert) {
 				transform((Codes.Convert) code, block, branch);
 			} else if (code instanceof Codes.Const) {
@@ -1622,7 +1613,9 @@ protected void transform(Code.Unit code, AttributedCodeBlock block,
 
 	protected void transform(Codes.Assign code, AttributedCodeBlock block,
 			VcBranch branch) {
-		branch.write(code.target(), branch.read(code.operand(0)));
+		for (int i = 0; i != code.operands().length; ++i) {
+			branch.write(code.target(i), branch.read(code.operand(i)));
+		}
 	}
 
 	/**
@@ -1641,20 +1634,16 @@ protected void transform(Codes.Assign code, AttributedCodeBlock block,
 			null // right shift
 	};
 
-	protected void transform(Codes.Convert code, AttributedCodeBlock block,
-			VcBranch branch) {
-		Collection<Attribute> attributes = toWycsAttributes(block
-				.attributes(branch.pc()));
+	protected void transform(Codes.Convert code, AttributedCodeBlock block, VcBranch branch) {
+		Collection<Attribute> attributes = toWycsAttributes(block.attributes(branch.pc()));
 		Expr result = branch.read(code.operand(0));
 		SyntacticType type = convert(code.result, block.attributes(branch.pc()));
-		branch.write(code.target(), new Expr.Cast(type, result, attributes));
+		branch.write(code.target(0), new Expr.Cast(type, result, attributes));
 	}
 
-	protected void transform(Codes.Const code, AttributedCodeBlock block,
-			VcBranch branch) {
+	protected void transform(Codes.Const code, AttributedCodeBlock block, VcBranch branch) {
 		Value val = convert(code.constant, block, branch);
-		branch.write(code.target(), new Expr.Constant(val,
-				toWycsAttributes(block.attributes(branch.pc()))));
+		branch.write(code.target(), new Expr.Constant(val, toWycsAttributes(block.attributes(branch.pc()))));
 	}
 
 	protected void transform(Codes.Debug code, AttributedCodeBlock block,
@@ -1662,22 +1651,17 @@ protected void transform(Codes.Debug code, AttributedCodeBlock block,
 		// do nout
 	}
 
-	protected void transform(Codes.Dereference code, AttributedCodeBlock block,
-			VcBranch branch) {
-		branch.havoc(code.target());
+	protected void transform(Codes.Dereference code, AttributedCodeBlock block, VcBranch branch) {
+		branch.havoc(code.target(0));
 	}
 
-	protected void transform(Codes.FieldLoad code, AttributedCodeBlock block,
-			VcBranch branch) {
-		ArrayList<String> fields = new ArrayList<String>(code.type().fields()
-				.keySet());
+	protected void transform(Codes.FieldLoad code, AttributedCodeBlock block, VcBranch branch) {
+		ArrayList<String> fields = new ArrayList<String>(code.type(0).fields().keySet());
 		Collections.sort(fields);
 		Expr src = branch.read(code.operand(0));
-		Expr index = new Expr.Constant(Value.Integer(BigInteger.valueOf(fields
-				.indexOf(code.field))));
-		Expr result = new Expr.IndexOf(src, index,
-				toWycsAttributes(block.attributes(branch.pc())));
-		branch.write(code.target(), result);
+		Expr index = new Expr.Constant(Value.Integer(BigInteger.valueOf(fields.indexOf(code.field))));
+		Expr result = new Expr.IndexOf(src, index, toWycsAttributes(block.attributes(branch.pc())));
+		branch.write(code.target(0), result);
 	}
 
 	protected void transform(Codes.IndirectInvoke code,
@@ -1709,18 +1693,17 @@ protected void transform(Codes.Invoke code, AttributedCodeBlock block,
 
 			// This is a potential fix for #488, although it doesn't work
 			// FIXME: needs to updated to handle multiple returns as well
-			if (containsNominal(code.type().returns().get(0), attributes)) {
+			if (containsNominal(code.type(0).returns().get(0), attributes)) {
 				// This is required to handle the implicit constraints implied
 				// by a nominal type. See #488.
 				Expr nominalTest = new Expr.Is(branch.read(code.targets()[0]),
-						convert(code.type().returns().get(0), attributes));
+						convert(code.type(0).returns().get(0), attributes));
 				branch.assume(nominalTest);
 			}
-			
+
 			// Here, we must find the name of the corresponding postcondition so
 			// that we can assume it.
-			List<AttributedCodeBlock> ensures = findPostcondition(code.name,
-					code.type(), block, branch);
+			List<AttributedCodeBlock> ensures = findPostcondition(code.name, code.type(0), block, branch);
 
 			if (ensures.size() > 0) {
 				// To assume the post-condition holds after the method, we
@@ -1741,17 +1724,14 @@ protected void transform(Codes.Invoke code, AttributedCodeBlock block,
 		}
 	}
 
-	protected void transform(Codes.Invert code, AttributedCodeBlock block,
-			VcBranch branch) {
-		branch.havoc(code.target());
+	protected void transform(Codes.Invert code, AttributedCodeBlock block, VcBranch branch) {
+		branch.havoc(code.target(0));
 	}
 
-	protected void transform(Codes.IndexOf code, AttributedCodeBlock block,
-			VcBranch branch) {
+	protected void transform(Codes.IndexOf code, AttributedCodeBlock block, VcBranch branch) {
 		Expr src = branch.read(code.operand(0));
 		Expr idx = branch.read(code.operand(1));
-		branch.write(code.target(), new Expr.IndexOf(src, idx,
-				toWycsAttributes(block.attributes(branch.pc()))));
+		branch.write(code.target(0), new Expr.IndexOf(src, idx, toWycsAttributes(block.attributes(branch.pc()))));
 	}
 
 	protected void transform(Codes.ArrayGenerator code, AttributedCodeBlock block, VcBranch branch) {
@@ -1759,30 +1739,27 @@ protected void transform(Codes.ArrayGenerator code, AttributedCodeBlock block, V
 		Collection<Attribute> attributes = toWycsAttributes(wyilAttributes); 
 		Expr element = branch.read(code.operand(0));
 		Expr count = branch.read(code.operand(1));
-		branch.havoc(code.target());
-		Expr arg = new Expr.Nary(Expr.Nary.Op.TUPLE, new Expr[] { 
-				branch.read(code.target()), element, count },
+		branch.havoc(code.target(0));
+		Expr arg = new Expr.Nary(Expr.Nary.Op.TUPLE, new Expr[] { branch.read(code.target(0)), element, count },
 				attributes);
 		ArrayList<SyntacticType> generics = new ArrayList<SyntacticType>();
-		generics.add(convert(code.type().element(),wyilAttributes));
+		generics.add(convert(code.type(0).element(),wyilAttributes));
 		Expr.Invoke macro = new Expr.Invoke("generate", Trie.fromString("wycs/core/Array"),
 				generics, arg);
 		branch.assume(macro);
 	}
 	
-	protected void transform(Codes.Lambda code, AttributedCodeBlock block,
-			VcBranch branch) {
+	protected void transform(Codes.Lambda code, AttributedCodeBlock block, VcBranch branch) {
 		// TODO: implement lambdas somehow?
-		branch.havoc(code.target());
+		branch.havoc(code.target(0));
 	}
 
 	protected void transform(Codes.Move code, VcBranch branch) {
-		branch.write(code.target(), branch.read(code.operand(0)));
+		branch.write(code.target(0), branch.read(code.operand(0)));
 	}
 
-	protected void transform(Codes.NewObject code, AttributedCodeBlock block,
-			VcBranch branch) {
-		branch.havoc(code.target());
+	protected void transform(Codes.NewObject code, AttributedCodeBlock block, VcBranch branch) {
+		branch.havoc(code.target(0));
 	}
 
 	protected void transform(Codes.Nop code, AttributedCodeBlock block,
@@ -1790,26 +1767,24 @@ protected void transform(Codes.Nop code, AttributedCodeBlock block,
 		// do nout
 	}
 
-	protected void transform(Codes.UnaryOperator code,
-			AttributedCodeBlock block, VcBranch branch) {
+	protected void transform(Codes.UnaryOperator code, AttributedCodeBlock block, VcBranch branch) {
 		switch (code.kind) {
 		case NEG:
 			transformUnary(Expr.Unary.Op.NEG, code, branch, block);
 			break;
 		case NUMERATOR:
 		case DENOMINATOR:
-			branch.havoc(code.target());
+			branch.havoc(code.target(0));
 			break;
 		default:
-			branch.havoc(code.target());
+			branch.havoc(code.target(0));
 		}
 	}
 
-	protected void transform(Codes.Update code, AttributedCodeBlock block,
-			VcBranch branch) {
+	protected void transform(Codes.Update code, AttributedCodeBlock block, VcBranch branch) {
 		Expr result = branch.read(code.result());
-		Expr oldSource = branch.read(code.target());
-		Expr newSource = branch.havoc(code.target());
+		Expr oldSource = branch.read(code.target(0));
+		Expr newSource = branch.havoc(code.target(0));
 		updateHelper(code.iterator(), oldSource, newSource, result, branch, block);
 	}
 
@@ -1888,13 +1863,10 @@ private Expr havoc(Expr source, VcBranch branch, AttributedCodeBlock block) {
 	 * @param branch
 	 *            --- The enclosing branch
 	 */
-	protected void transformUnary(Expr.Unary.Op operator,
-			Code.AbstractUnaryAssignable code, VcBranch branch,
+	protected void transformUnary(Expr.Unary.Op operator, Code.AbstractUnaryAssignable code, VcBranch branch,
 			AttributedCodeBlock block) {
 		Expr lhs = branch.read(code.operand(0));
-
-		branch.write(code.target(), new Expr.Unary(operator, lhs,
-				toWycsAttributes(block.attributes(branch.pc()))));
+		branch.write(code.target(0), new Expr.Unary(operator, lhs, toWycsAttributes(block.attributes(branch.pc()))));
 	}
 
 	/**
@@ -1910,20 +1882,19 @@ protected void transformUnary(Expr.Unary.Op operator,
 	 * @param branch
 	 *            --- The enclosing branch
 	 */
-	protected void transformBinary(Expr.Binary.Op operator,
-			Code.AbstractBinaryAssignable code, VcBranch branch,
+	protected void transformBinary(Expr.Binary.Op operator, Code.AbstractBinaryAssignable code, VcBranch branch,
 			AttributedCodeBlock block) {
 		Expr lhs = branch.read(code.operand(0));
 		Expr rhs = branch.read(code.operand(1));
 
 		if (operator != null) {
-			branch.write(code.target(), new Expr.Binary(operator, lhs, rhs,
-					toWycsAttributes(block.attributes(branch.pc()))));
+			branch.write(code.target(0),
+					new Expr.Binary(operator, lhs, rhs, toWycsAttributes(block.attributes(branch.pc()))));
 		} else {
 			// In this case, we have a binary operator which we don't know how
 			// to translate into WyCS. Therefore, we need to invalidate the
 			// target register to signal this.
-			branch.havoc(code.target());
+			branch.havoc(code.target(0));
 		}
 	}
 
@@ -1940,16 +1911,14 @@ protected void transformBinary(Expr.Binary.Op operator,
 	 * @param branch
 	 *            --- The enclosing branch
 	 */
-	protected void transformNary(Expr.Nary.Op operator,
-			Code.AbstractNaryAssignable code, VcBranch branch,
+	protected void transformNary(Expr.Nary.Op operator, Code.AbstractMultiNaryAssignable code, VcBranch branch,
 			AttributedCodeBlock block) {
 		int[] code_operands = code.operands();
 		Expr[] vals = new Expr[code_operands.length];
 		for (int i = 0; i != vals.length; ++i) {
 			vals[i] = branch.read(code_operands[i]);
 		}
-		branch.write(code.target(), new Expr.Nary(operator, vals,
-				toWycsAttributes(block.attributes(branch.pc()))));
+		branch.write(code.target(0), new Expr.Nary(operator, vals, toWycsAttributes(block.attributes(branch.pc()))));
 	}
 
 	/**
@@ -1968,20 +1937,16 @@ protected void transformNary(Expr.Nary.Op operator,
 	 * @return
 	 * @throws Exception
 	 */
-	protected List<AttributedCodeBlock> findPrecondition(NameID name,
-			Type.FunctionOrMethod fun, AttributedCodeBlock block,
-			VcBranch branch) throws Exception {
-		Path.Entry<WyilFile> e = builder.project().get(name.module(),
-				WyilFile.ContentType);
+	protected List<AttributedCodeBlock> findPrecondition(NameID name, Type.FunctionOrMethod fun,
+			AttributedCodeBlock block, VcBranch branch) throws Exception {
+		Path.Entry<WyilFile> e = builder.project().get(name.module(), WyilFile.ContentType);
 		if (e == null) {
-			syntaxError(
-					errorMessage(ErrorMessages.RESOLUTION_ERROR, name.module()
-							.toString()), filename, block.attributes(branch
-							.pc()));
+			syntaxError(errorMessage(ErrorMessages.RESOLUTION_ERROR, name.module().toString()), filename,
+					block.attributes(branch.pc()));
 		}
 		WyilFile m = e.read();
 		WyilFile.FunctionOrMethod method = m.functionOrMethod(name.name(), fun);
-	
+
 		return method.precondition();
 	}
 
@@ -2001,16 +1966,12 @@ protected void transformNary(Expr.Nary.Op operator,
 	 * @return
 	 * @throws Exception
 	 */
-	protected List<AttributedCodeBlock> findPostcondition(NameID name,
-			Type.FunctionOrMethod fun, AttributedCodeBlock block,
-			VcBranch branch) throws Exception {
-		Path.Entry<WyilFile> e = builder.project().get(name.module(),
-				WyilFile.ContentType);
+	protected List<AttributedCodeBlock> findPostcondition(NameID name, Type.FunctionOrMethod fun,
+			AttributedCodeBlock block, VcBranch branch) throws Exception {
+		Path.Entry<WyilFile> e = builder.project().get(name.module(), WyilFile.ContentType);
 		if (e == null) {
-			syntaxError(
-					errorMessage(ErrorMessages.RESOLUTION_ERROR, name.module()
-							.toString()), filename, block.attributes(branch
-							.pc()));
+			syntaxError(errorMessage(ErrorMessages.RESOLUTION_ERROR, name.module().toString()), filename,
+					block.attributes(branch.pc()));
 		}
 		WyilFile m = e.read();
 		WyilFile.FunctionOrMethod method = m.functionOrMethod(name.name(), fun);
diff --git a/modules/wyil/src/wyil/checks/CoercionCheck.java b/modules/wyil/src/wyil/checks/CoercionCheck.java
index 7b8e2b62a6..5904db6924 100755
--- a/modules/wyil/src/wyil/checks/CoercionCheck.java
+++ b/modules/wyil/src/wyil/checks/CoercionCheck.java
@@ -97,13 +97,10 @@ protected void check(CodeBlock.Index index, CodeBlock block, AttributedCodeBlock
 			Code code = block.get(i);
 			if (code instanceof Codes.Convert) {
 				Codes.Convert conv = (Codes.Convert) code;
-				check(conv.type(), conv.result,
-						new HashSet<Pair<Type, Type>>(), root.attribute(
-								new CodeBlock.Index(index, i),
-								SourceLocation.class));
+				check(conv.type(0), conv.result, new HashSet<Pair<Type, Type>>(),
+						root.attribute(new CodeBlock.Index(index, i), SourceLocation.class));
 			} else if (code instanceof CodeBlock) {
-				check(new CodeBlock.Index(index, i), (CodeBlock) code, root,
-						method);
+				check(new CodeBlock.Index(index, i), (CodeBlock) code, root, method);
 			}
 		}
 	}
diff --git a/modules/wyil/src/wyil/checks/DefiniteAssignmentCheck.java b/modules/wyil/src/wyil/checks/DefiniteAssignmentCheck.java
index dc32bc36ff..e3c289b74c 100755
--- a/modules/wyil/src/wyil/checks/DefiniteAssignmentCheck.java
+++ b/modules/wyil/src/wyil/checks/DefiniteAssignmentCheck.java
@@ -201,30 +201,21 @@ public void checkUses(CodeBlock.Index index, Code code, HashSet<Integer> in) {
 			if (in.contains(a.leftOperand) && in.contains(a.rightOperand)) {
 				return;
 			}
-		} else if(code instanceof Code.AbstractNaryAssignable) {
-			Code.AbstractNaryAssignable a = (Code.AbstractNaryAssignable) code;
+		} else if(code instanceof Code.AbstractMultiNaryAssignable) {
+			Code.AbstractMultiNaryAssignable a = (Code.AbstractMultiNaryAssignable) code;
 			for(int operand : a.operands()) {
 				if(operand != Codes.NULL_REG && !in.contains(operand)) {
 					syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED),
 	                        filename, rootBlock.attribute(index,SourceLocation.class));
 				}
-			}
-			if(code instanceof Codes.Update && !in.contains(a.target())) {
+			}	
+			if(code instanceof Codes.Update && !in.contains(a.target(0))) {
 				// In this case, we are assigning to an index or field.
 				// Therefore, the target register must already be defined.
 				syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED),
                         filename, rootBlock.attribute(index,SourceLocation.class));
 			}
 			return;
-		} else if(code instanceof Code.AbstractMultiNaryAssignable) {
-			Code.AbstractMultiNaryAssignable a = (Code.AbstractMultiNaryAssignable) code;
-			for(int operand : a.operands()) {
-				if(operand != Codes.NULL_REG && !in.contains(operand)) {
-					syntaxError(errorMessage(VARIABLE_POSSIBLY_UNITIALISED),
-	                        filename, rootBlock.attribute(index,SourceLocation.class));
-				}
-			}			
-			return;
 		} else {
 			// includes abstract-assignables and branching bytecodes
 			return;
diff --git a/modules/wyil/src/wyil/checks/ModuleCheck.java b/modules/wyil/src/wyil/checks/ModuleCheck.java
index 064ca74b10..509ae99fce 100755
--- a/modules/wyil/src/wyil/checks/ModuleCheck.java
+++ b/modules/wyil/src/wyil/checks/ModuleCheck.java
@@ -134,10 +134,10 @@ protected void checkFunctionPure(CodeBlock.Index parent, CodeBlock block, Attrib
 		for (int i = 0; i != block.size(); ++i) {
 			Code code = block.get(i);
 			CodeBlock.Index index = new CodeBlock.Index(parent,i);
-			if(code instanceof Codes.Invoke && ((Codes.Invoke)code).type() instanceof Type.Method) {
+			if(code instanceof Codes.Invoke && ((Codes.Invoke)code).type(0) instanceof Type.Method) {
 				// internal message send
 				syntaxError(errorMessage(METHODCALL_NOT_PERMITTED_IN_FUNCTION), filename, root.attribute(index, SourceLocation.class));
-			} else if (code instanceof Codes.IndirectInvoke && ((Codes.IndirectInvoke)code).type() instanceof Type.Method) {
+			} else if (code instanceof Codes.IndirectInvoke && ((Codes.IndirectInvoke)code).type(0) instanceof Type.Method) {
 				syntaxError(errorMessage(METHODCALL_NOT_PERMITTED_IN_FUNCTION), filename, root.attribute(index, SourceLocation.class));
 			} else if(code instanceof Codes.NewObject) {
 				syntaxError(errorMessage(ALLOCATION_NOT_PERMITTED_IN_FUNCTION), filename, root.attribute(index, SourceLocation.class));
diff --git a/modules/wyil/src/wyil/io/WyilFileReader.java b/modules/wyil/src/wyil/io/WyilFileReader.java
index 95795f018a..e6172cd497 100755
--- a/modules/wyil/src/wyil/io/WyilFileReader.java
+++ b/modules/wyil/src/wyil/io/WyilFileReader.java
@@ -591,14 +591,12 @@ private Code readCode(int offset, HashMap<Integer, Codes.Label> labels)
 			return readEmpty(opcode, wideBase, wideRest, offset, labels);
 		case Code.FMT_UNARYOP:
 			return readUnaryOp(opcode, wideBase, wideRest, offset, labels);
-		case Code.FMT_UNARYASSIGN:
-			return readUnaryAssign(opcode, wideBase, wideRest);
 		case Code.FMT_BINARYOP:
 			return readBinaryOp(opcode, wideBase, wideRest, offset, labels);
-		case Code.FMT_BINARYASSIGN:
-			return readBinaryAssign(opcode, wideBase, wideRest);
 		case Code.FMT_NARYOP:
 			return readNaryOp(opcode, wideBase, wideRest, offset, labels);
+		case Code.FMT_UNARYASSIGN:
+		case Code.FMT_BINARYASSIGN:
 		case Code.FMT_NARYASSIGN:
 			return readNaryAssign(opcode, wideBase, wideRest);				
 		case Code.FMT_OTHER:
@@ -677,60 +675,7 @@ private Code readUnaryAssign(int opcode, boolean wideBase, boolean wideRest)
 		int typeIdx = readRest(wideRest);
 		Type type = typePool[typeIdx];
 		switch (opcode) {
-		case Code.OPCODE_convert: {
-			int i = readRest(wideRest);
-			Type t = typePool[i];
-			return Codes.Convert(type, target, operand, t);
-		}
-		case Code.OPCODE_assign:
-			return Codes.Assign(type, target, operand);
-		case Code.OPCODE_dereference: {
-			if (!(type instanceof Type.Reference)) {
-				throw new RuntimeException("expected reference type");
-			}
-			return Codes.Dereference((Type.Reference) type, target, operand);
-		}
-		case Code.OPCODE_fieldload: {
-			if (!(type instanceof Type.EffectiveRecord)) {
-				throw new RuntimeException("expected record type");
-			}
-			int i = readRest(wideRest);
-			String field = stringPool[i];
-			return Codes.FieldLoad((Type.EffectiveRecord) type, target,
-					operand, field);
-		}
-		case Code.OPCODE_invert:
-			return Codes.Invert(type, target, operand);
-		case Code.OPCODE_newobject: {
-			if (!(type instanceof Type.Reference)) {
-				throw new RuntimeException("expected reference type");
-			}
-			return Codes.NewObject((Type.Reference) type, target, operand);
-		}
-		case Code.OPCODE_lengthof: {
-			if (!(type instanceof Type.EffectiveArray)) {
-				throw new RuntimeException("expected collection type");
-			}
-			return Codes.LengthOf((Type.EffectiveArray) type, target,
-					operand);
-		}
-		case Code.OPCODE_move:
-			return Codes.Move(type, target, operand);
-		case Code.OPCODE_neg:
-			return Codes.UnaryOperator(type, target, operand,
-					Codes.UnaryOperatorKind.NEG);
-		case Code.OPCODE_numerator:
-			return Codes.UnaryOperator(type, target, operand,
-					Codes.UnaryOperatorKind.NUMERATOR);
-		case Code.OPCODE_denominator:
-			return Codes.UnaryOperator(type, target, operand,
-					Codes.UnaryOperatorKind.DENOMINATOR);
-		case Code.OPCODE_not: {
-			if (!(type instanceof Type.Bool)) {
-				throw new RuntimeException("expected bool type");
-			}
-			return Codes.Not(target, operand);
-		}
+		
 
 		}
 		throw new RuntimeException("unknown opcode encountered (" + opcode
@@ -765,48 +710,6 @@ private Code readBinaryOp(int opcode, boolean wideBase, boolean wideRest,
 				+ ")");
 	}
 
-	private Code readBinaryAssign(int opcode, boolean wideBase, boolean wideRest)
-			throws IOException {
-		int target = readBase(wideBase);
-		int leftOperand = readBase(wideBase);
-		int rightOperand = readBase(wideBase);
-		int typeIdx = readRest(wideRest);
-		Type type = typePool[typeIdx];
-		switch (opcode) {		
-		case Code.OPCODE_indexof: {
-			if (!(type instanceof Type.EffectiveArray)) {
-				throw new RuntimeException("expecting indexible type");
-			}
-			return Codes.IndexOf((Type.EffectiveArray) type, target,
-					leftOperand, rightOperand);
-		}
-		case Code.OPCODE_listgen: {
-			if (!(type instanceof Type.Array)) {
-				throw new RuntimeException("expecting list type");
-			}
-			return Codes.ArrayGenerator((Type.Array) type, target,
-					leftOperand, rightOperand);
-		}
-		case Code.OPCODE_add:
-		case Code.OPCODE_sub:
-		case Code.OPCODE_mul:
-		case Code.OPCODE_div:
-		case Code.OPCODE_rem:
-		case Code.OPCODE_bitwiseor:
-		case Code.OPCODE_bitwisexor:
-		case Code.OPCODE_bitwiseand:
-		case Code.OPCODE_lshr:
-		case Code.OPCODE_rshr: {
-			Codes.BinaryOperatorKind kind = Codes.BinaryOperatorKind.values()[opcode
-					- Code.OPCODE_add];
-			return Codes.BinaryOperator(type, target, leftOperand,
-					rightOperand, kind);
-		}
-		}
-		throw new RuntimeException("unknown opcode encountered (" + opcode
-				+ ")");
-	}
-
 	private Code readNaryOp(int opcode, boolean wideBase, boolean wideRest,
 			int offset, HashMap<Integer, Codes.Label> labels)
 			throws IOException {
@@ -902,12 +805,89 @@ private Code readNaryAssign(int opcode, boolean wideBase, boolean wideRest)
 		}
 		case Code.OPCODE_newlist: {
 			if (!(types[0] instanceof Type.Array)) {
-				throw new RuntimeException("expected list type");
+				throw new RuntimeException("expected array type");
 			} else if(targets.length != 1) {
 				throw new RuntimeException("expected exactly one target");
 			}
 			return Codes.NewArray((Type.Array) types[0], targets[0], operands);
-		}			
+		}
+		// Unary assignables
+		case Code.OPCODE_convert: {
+			int i = readRest(wideRest);
+			Type t = typePool[i];
+			return Codes.Convert(types[0], targets[0], operands[0], t);
+		}
+		case Code.OPCODE_assign:
+			return Codes.Assign(types[0], targets[0], operands[0]);
+		case Code.OPCODE_dereference: {
+			if (!(types[0] instanceof Type.Reference)) {
+				throw new RuntimeException("expected reference type");
+			}
+			return Codes.Dereference((Type.Reference) types[0], targets[0], operands[0]);
+		}
+		case Code.OPCODE_fieldload: {
+			if (!(types[0] instanceof Type.EffectiveRecord)) {
+				throw new RuntimeException("expected record type");
+			}
+			int i = readRest(wideRest);
+			String field = stringPool[i];
+			return Codes.FieldLoad((Type.EffectiveRecord) types[0], targets[0],
+					operands[0], field);
+		}
+		case Code.OPCODE_invert:
+			return Codes.Invert(types[0], targets[0], operands[0]);
+		case Code.OPCODE_newobject: {
+			if (!(types[0] instanceof Type.Reference)) {
+				throw new RuntimeException("expected reference type");
+			}
+			return Codes.NewObject((Type.Reference) types[0], targets[0], operands[0]);
+		}
+		case Code.OPCODE_lengthof: {
+			if (!(types[0] instanceof Type.EffectiveArray)) {
+				throw new RuntimeException("expected collection type");
+			}
+			return Codes.LengthOf((Type.EffectiveArray) types[0], targets[0], operands[0]);
+		}
+		case Code.OPCODE_move:
+			return Codes.Move(types[0], targets[0], operands[0]);
+		case Code.OPCODE_neg:
+			return Codes.UnaryOperator(types[0], targets[0], operands[0], Codes.UnaryOperatorKind.NEG);
+		case Code.OPCODE_numerator:
+			return Codes.UnaryOperator(types[0], targets[0], operands[0], Codes.UnaryOperatorKind.NUMERATOR);
+		case Code.OPCODE_denominator:
+			return Codes.UnaryOperator(types[0], targets[0], operands[0], Codes.UnaryOperatorKind.DENOMINATOR);
+		case Code.OPCODE_not: {
+			if (!(types[0] instanceof Type.Bool)) {
+				throw new RuntimeException("expected bool type");
+			}
+			return Codes.Not(targets[0], operands[0]);
+		}
+		// Binary Assignables
+		case Code.OPCODE_indexof: {
+			if (!(types[0] instanceof Type.EffectiveArray)) {
+				throw new RuntimeException("expecting indexible type");
+			}
+			return Codes.IndexOf((Type.EffectiveArray) types[0], targets[0], operands[0], operands[1]);
+		}
+		case Code.OPCODE_listgen: {
+			if (!(types[0] instanceof Type.Array)) {
+				throw new RuntimeException("expecting list type");
+			}
+			return Codes.ArrayGenerator((Type.Array) types[0], targets[0], operands[0], operands[1]);
+		}
+		case Code.OPCODE_add:
+		case Code.OPCODE_sub:
+		case Code.OPCODE_mul:
+		case Code.OPCODE_div:
+		case Code.OPCODE_rem:
+		case Code.OPCODE_bitwiseor:
+		case Code.OPCODE_bitwisexor:
+		case Code.OPCODE_bitwiseand:
+		case Code.OPCODE_lshr:
+		case Code.OPCODE_rshr: {
+			Codes.BinaryOperatorKind kind = Codes.BinaryOperatorKind.values()[opcode - Code.OPCODE_add];
+			return Codes.BinaryOperator(types[0], targets[0], operands[0], operands[1], kind);
+		}
 		}
 		throw new RuntimeException("unknown opcode encountered (" + opcode
 				+ ")");
diff --git a/modules/wyil/src/wyil/io/WyilFileWriter.java b/modules/wyil/src/wyil/io/WyilFileWriter.java
index 68594fb156..759c6f1c75 100755
--- a/modules/wyil/src/wyil/io/WyilFileWriter.java
+++ b/modules/wyil/src/wyil/io/WyilFileWriter.java
@@ -532,23 +532,14 @@ private void writeBase(boolean wide, Code code,
 			Code.AbstractBinaryOp<Type> a = (Code.AbstractBinaryOp) code;
 			writeBase(wide,a.leftOperand,output);
 			writeBase(wide,a.rightOperand,output);
-		} else if(code instanceof Code.AbstractUnaryAssignable) {
-			Code.AbstractUnaryAssignable<Type> a = (Code.AbstractUnaryAssignable) code;
-			writeBase(wide,a.target(),output);
-			writeBase(wide,a.operand(0),output);
-		} else if(code instanceof Code.AbstractBinaryAssignable) {
-			Code.AbstractBinaryAssignable<Type> a = (Code.AbstractBinaryAssignable) code;
-			writeBase(wide, a.target(),output);
-			writeBase(wide, a.operand(0),output);
-			writeBase(wide, a.operand(1),output);
-		} else if(code instanceof Code.AbstractNaryAssignable) {
-			Code.AbstractNaryAssignable<Type> a = (Code.AbstractNaryAssignable) code;
-			Type[] types = new Type[]{a.type()};
+		} else if(code instanceof Code.AbstractMultiNaryAssignable) {
+			Code.AbstractMultiNaryAssignable<Type> a = (Code.AbstractMultiNaryAssignable) code;
+			Type[] types = a.types();
 			int[] targets = a.targets();
 			int[] operands = a.operands();
 			if(code instanceof Codes.Lambda) {
-				// This is something of a hack, but the reason is that lambda
-				// operands can be NULL_REG.
+				// FIXME: This is something of a hack, but the reason is that
+				// lambda operands can be NULL_REG.
 				for(int i=0;i!=operands.length;++i) {
 					operands[i] ++;
 				}
@@ -565,23 +556,6 @@ private void writeBase(boolean wide, Code code,
 			for(int i=0;i!=operands.length;++i) {
 				writeBase(wide,operands[i],output);
 			}
-		} else if(code instanceof Code.AbstractMultiNaryAssignable) {
-			Code.AbstractMultiNaryAssignable<Type> a = (Code.AbstractMultiNaryAssignable) code;
-			Type[] types = a.types();
-			int[] targets = a.targets();
-			int[] operands = a.operands();
-			writeBase(wide,types.length,output);
-			writeBase(wide,targets.length,output);
-			writeBase(wide,operands.length,output);
-			for(int i=0;i!=types.length;++i) {
-				writeBase(wide,typeCache.get(types[i]),output);
-			}
-			for(int i=0;i!=targets.length;++i) {
-				writeBase(wide,targets[i],output);
-			}			
-			for(int i=0;i!=operands.length;++i) {
-				writeBase(wide,operands[i],output);
-			}
 		} else if(code instanceof Code.AbstractAssignable) {			
 			Code.AbstractAssignable c = (Code.AbstractAssignable) code;
 			// This is safe because only Codes.Const implements
@@ -653,13 +627,7 @@ private void writeRest(boolean wide, Code code, int offset,
 		} else if(code instanceof Code.AbstractBinaryOp) {
 			Code.AbstractBinaryOp<Type> a = (Code.AbstractBinaryOp) code;
 			writeRest(wide,typeCache.get(a.type),output);
-		} else if(code instanceof Code.AbstractUnaryAssignable) {
-			Code.AbstractUnaryAssignable<Type> a = (Code.AbstractUnaryAssignable) code;
-			writeRest(wide,typeCache.get(a.type()),output);
-		} else if(code instanceof Code.AbstractBinaryAssignable) {
-			Code.AbstractBinaryAssignable<Type> a = (Code.AbstractBinaryAssignable) code;
-			writeRest(wide,typeCache.get(a.type()),output);
-		} 
+		}
 		// now deal with non-uniform instructions
 		// First, deal with special cases
 		if(code instanceof Codes.AssertOrAssume) {
@@ -788,29 +756,6 @@ private int calculateWidth(Code code, int offset, HashMap<String,Integer> labels
 			Code.AbstractBinaryOp<Type> a = (Code.AbstractBinaryOp) code;
 			maxBase = Math.max(a.leftOperand,a.rightOperand);
 			maxRest = typeCache.get(a.type);
-		} else if(code instanceof Code.AbstractUnaryAssignable) {
-			Code.AbstractUnaryAssignable<Type> a = (Code.AbstractUnaryAssignable) code;
-			maxBase = Math.max(a.target(),a.operand(0));
-			maxRest = typeCache.get(a.type());
-		} else if(code instanceof Code.AbstractBinaryAssignable) {
-			Code.AbstractBinaryAssignable<Type> a = (Code.AbstractBinaryAssignable) code;
-			maxBase = Math.max(a.operand(0),a.operand(1));
-			maxBase = Math.max(a.target(),maxBase);
-			maxRest = typeCache.get(a.type());
-		} else if(code instanceof Code.AbstractNaryAssignable) {
-			Code.AbstractNaryAssignable<Type> a = (Code.AbstractNaryAssignable) code;
-			Type[] types = new Type[]{a.type()};
-			int[] targets = a.targets();
-			int[] operands = a.operands();
-			for(int i=0;i!=types.length;++i) {
-				maxBase = Math.max(maxBase,typeCache.get(types[i]));
-			}
-			for(int i=0;i!=targets.length;++i) {
-				maxBase = Math.max(maxBase,targets[i]);
-			}						
-			for(int i=0;i!=operands.length;++i) {
-				maxBase = Math.max(maxBase,operands[i]);
-			}
 		} else if(code instanceof Code.AbstractMultiNaryAssignable) {
 			Code.AbstractMultiNaryAssignable<Type> a = (Code.AbstractMultiNaryAssignable) code;
 			Type[] types = a.types();
@@ -1038,7 +983,6 @@ private void buildPools(Code code) {
 			addNameItem(c.name);
 		} else if(code instanceof Codes.Update) {
 			Codes.Update c = (Codes.Update) code;
-			addTypeItem(c.type());
 			addTypeItem(c.afterType);
 			for(Codes.LVal l : c) {
 				if(l instanceof Codes.RecordLVal) {
@@ -1061,15 +1005,6 @@ private void buildPools(Code code) {
 		} else if(code instanceof Code.AbstractBinaryOp) {
 			Code.AbstractBinaryOp<Type> a = (Code.AbstractBinaryOp) code;
 			addTypeItem(a.type);
-		} else if(code instanceof Code.AbstractUnaryAssignable) {
-			Code.AbstractUnaryAssignable<Type> a = (Code.AbstractUnaryAssignable) code;
-			addTypeItem(a.type());
-		} else if(code instanceof Code.AbstractBinaryAssignable) {
-			Code.AbstractBinaryAssignable<Type> a = (Code.AbstractBinaryAssignable) code;
-			addTypeItem(a.type());
-		} else if(code instanceof Code.AbstractNaryAssignable) {
-			Code.AbstractNaryAssignable<Type> a = (Code.AbstractNaryAssignable) code;
-			addTypeItem(a.type());
 		} else if(code instanceof Code.AbstractMultiNaryAssignable) {
 			Code.AbstractMultiNaryAssignable<Type> a = (Code.AbstractMultiNaryAssignable) code;
 			for(Type type : a.types()) {
diff --git a/modules/wyil/src/wyil/lang/Code.java b/modules/wyil/src/wyil/lang/Code.java
index b008afca36..78598d0cca 100755
--- a/modules/wyil/src/wyil/lang/Code.java
+++ b/modules/wyil/src/wyil/lang/Code.java
@@ -209,13 +209,22 @@ public AbstractAssignable(int... targets) {
 		}
 
 		/**
-		 * Return the target register assigned by this bytecode.
+		 * Return a specific target register assigned by this bytecode.
+		 *
+		 * @return
+		 */
+		public int target(int i) {
+			return targets[0];
+		}
+		
+		/**
+		 * Return the target registers assigned by this bytecode.
 		 *
 		 * @return
 		 */
 		public int[] targets() {
 			return targets;
-		}
+		}		
 	}
 
 	/**
@@ -230,10 +239,16 @@ public AbstractAssignable(int... targets) {
 	 */
 	public static abstract class AbstractMultiNaryAssignable<T> extends
 			AbstractAssignable {
-		protected final T[] types;
+		protected final Type[] types;
 		protected final int[] operands;
 
-		public AbstractMultiNaryAssignable(T[] types, int[] targets, int[] operands) {
+		public AbstractMultiNaryAssignable(Type type, int target, int... operands) {
+			super(target);			
+			this.types = new Type[]{type};
+			this.operands = operands;
+		}
+		
+		public AbstractMultiNaryAssignable(Type[] types, int[] targets, int[] operands) {
 			super(targets);			
 			this.types = types;
 			this.operands = operands;
@@ -245,7 +260,7 @@ public final void registers(java.util.Set<Integer> registers) {
 				registers.add(targets()[i]);
 			}
 			for (int i = 0; i != operands().length; ++i) {
-				registers.add(operands()[i]);
+				registers.add(operands[i]);
 			}
 		}
 
@@ -260,13 +275,15 @@ public final void registers(java.util.Set<Integer> registers) {
 		}
 
 		protected abstract Code.Unit clone(int[] nTargets, int[] nOperands);
-
+		
+		@Override
 		public int hashCode() {
 			return Arrays.hashCode(types) + Arrays.hashCode(targets()) + Arrays.hashCode(operands());
 		}
 
+		@Override
 		public boolean equals(Object o) {
-			if (o instanceof AbstractNaryAssignable) {
+			if (o instanceof AbstractMultiNaryAssignable) {
 				AbstractMultiNaryAssignable bo = (AbstractMultiNaryAssignable) o;
 				return Arrays.equals(targets(), bo.targets()) && Arrays.equals(operands(), bo.operands())
 						&& Arrays.equals(types, bo.types);
@@ -274,12 +291,12 @@ public boolean equals(Object o) {
 			return false;
 		}
 
-		public T[] types() {
+		public Type[] types() {
 			return types;
 		}
 		
 		public T type(int i) {
-			return types[i];
+			return (T) types[i];
 		}
 
 		public int[] operands() {
@@ -295,90 +312,7 @@ public int operand(int i) {
 			return operands[i];
 		}	
 	}
-	
-	/**
-	 * Represents the set of all bytecodes which take an arbitrary number of
-	 * register operands and write a result to the target register.
-	 *
-	 * @author David J. Pearce
-	 *
-	 * @param <T>
-	 *            --- the type associated with this bytecode.
-	 */
-	public static abstract class AbstractNaryAssignable<T> extends
-			AbstractAssignable {
-		protected final T type;
-		protected final int[] operands;
-
-		public AbstractNaryAssignable(T type, int target, int... operands) {
-			super(target);
-			if (type == null) {
-				throw new IllegalArgumentException(
-						"AbstractBinOp type argument cannot be null");
-			}
-			this.type = type;
-			this.operands = operands;
-		}
-
-		@Override
-		public final void registers(java.util.Set<Integer> registers) {
-			if (target() >= 0) {
-				registers.add(target());
-			}
-			for (int i = 0; i != operands().length; ++i) {
-				registers.add(operands()[i]);
-			}
-		}
-
-		@Override
-		public final Code.Unit remap(Map<Integer, Integer> binding) {
-			Integer nTarget = binding.get(target());
-			int[] nOperands = remapOperands(binding, operands());
-			if (nTarget != null || nOperands != operands()) {
-				nTarget = nTarget != null ? nTarget : target();
-				return clone(nTarget, nOperands);
-			}
-			return this;
-		}
-
-		protected abstract Code.Unit clone(int nTarget, int[] nOperands);
-
-		public int hashCode() {
-			return type().hashCode() + target() + Arrays.hashCode(operands());
-		}
-
-		public boolean equals(Object o) {
-			if (o instanceof AbstractNaryAssignable) {
-				AbstractNaryAssignable bo = (AbstractNaryAssignable) o;
-				return target() == bo.target()
-						&& Arrays.equals(operands(), bo.operands())
-						&& type().equals(bo.type());
-			}
-			return false;
-		}
-
-		public int target() {
-			return targets()[0];
-		}
 		
-		public T type() {
-			return type;
-		}
-
-		public int[] operands() {
-			return operands;
-		}
-
-		/**
-		 * Return the ith operand read by this bytecode.
-		 * @param i
-		 * @return
-		 */
-		public int operand(int i) {
-			return operands[i];
-		}
-	}
-
 	/**
 	 * Represents the set of all bytcodes which take a single register operand
 	 * and assign a result to the target register.
@@ -388,10 +322,9 @@ public int operand(int i) {
 	 * @param <T>
 	 *            --- the type associated with this bytecode.
 	 */
-	public static abstract class AbstractUnaryAssignable<T> extends
-			AbstractNaryAssignable<T> {
+	public static abstract class AbstractUnaryAssignable<T> extends AbstractMultiNaryAssignable<T> {
 
-		public AbstractUnaryAssignable(T type, int target, int operand) {
+		public AbstractUnaryAssignable(Type type, int target, int operand) {
 			super(type,target,operand);
 			if (type == null) {
 				throw new IllegalArgumentException(
@@ -460,12 +393,9 @@ public boolean equals(Object o) {
 	 * @param <T>
 	 *            --- the type associated with this bytecode.
 	 */
-	public static abstract class AbstractBinaryAssignable<T> extends
-			AbstractNaryAssignable<T> {
-
-		public AbstractBinaryAssignable(T type, int target, int leftOperand,
-				int rightOperand) {
-			super(type,target,leftOperand,rightOperand);
+	public static abstract class AbstractBinaryAssignable<T> extends AbstractMultiNaryAssignable<T> {
+		public AbstractBinaryAssignable(Type type, int target, int leftOperand, int rightOperand) {
+			super(type, target, leftOperand, rightOperand);
 		}
 	}
 
diff --git a/modules/wyil/src/wyil/lang/Codes.java b/modules/wyil/src/wyil/lang/Codes.java
index 8bda2002b0..b9bf644bfc 100755
--- a/modules/wyil/src/wyil/lang/Codes.java
+++ b/modules/wyil/src/wyil/lang/Codes.java
@@ -542,8 +542,8 @@ public int opcode() {
 		}
 
 		@Override
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return BinaryOperator(type(), nTarget, nOperands[0], nOperands[1],
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return BinaryOperator(type(0), nTargets[0], nOperands[0], nOperands[1],
 					kind);
 		}
 
@@ -560,8 +560,8 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return kind + " %" + target() + " = %" + operand(0) + ", %"
-					+ operand(1) + " : " + type();
+			return kind + " %" + target(0) + " = %" + operand(0) + ", %"
+					+ operand(1) + " : " + type(0);
 		}
 	}
 
@@ -617,8 +617,8 @@ private Convert(Type from, int target, int operand, Type result) {
 			this.result = result;
 		}
 
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return Convert(type(), nTarget, nOperands[0], result);
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Convert(type(0), nTargets[0], nOperands[0], result);
 		}
 
 		public int opcode() {
@@ -638,8 +638,8 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "convert %" + target() + " = %" + operand(0) + " " + result
-					+ " : " + type();
+			return "convert %" + target(0) + " = %" + operand(0) + " " + result
+					+ " : " + type(0);
 		}
 	}
 
@@ -773,8 +773,9 @@ public int opcode() {
 			return OPCODE_assign;
 		}
 
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return Assign(type(), nTarget, nOperands[0]);
+		@Override
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Assign(type(0), nTargets[0], nOperands[0]);
 		}
 
 		public boolean equals(Object o) {
@@ -785,7 +786,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "assign %" + target() + " = %" + operand(0) + " " + " : " + type();
+			return "assign %" + target(0) + " = %" + operand(0) + " " + " : " + type(0);
 		}
 	}
 
@@ -984,13 +985,11 @@ public String toString() {
 	 * @author David J. Pearce
 	 *
 	 */
-	public static final class FieldLoad extends
-			AbstractUnaryAssignable<Type.EffectiveRecord> {
+	public static final class FieldLoad extends AbstractUnaryAssignable<Type.EffectiveRecord> {
 		public final String field;
 
-		private FieldLoad(Type.EffectiveRecord type, int target, int operand,
-				String field) {
-			super(type, target, operand);
+		private FieldLoad(Type.EffectiveRecord type, int target, int operand, String field) {
+			super((Type) type, target, operand);
 			if (field == null) {
 				throw new IllegalArgumentException(
 						"FieldLoad field argument cannot be null");
@@ -999,8 +998,8 @@ private FieldLoad(Type.EffectiveRecord type, int target, int operand,
 		}
 
 		@Override
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return FieldLoad(type(), nTarget, nOperands[0], field);
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return FieldLoad(type(0), nTargets[0], nOperands[0], field);
 		}
 
 		public int opcode() {
@@ -1012,7 +1011,7 @@ public int hashCode() {
 		}
 
 		public Type fieldType() {
-			return type().fields().get(field);
+			return type(0).fields().get(field);
 		}
 
 		public boolean equals(Object o) {
@@ -1024,8 +1023,8 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "fieldload %" + target() + " = %" + operand(0) + " " + field
-					+ " : " + type();
+			return "fieldload %" + target(0) + " = %" + operand(0) + " " + field
+					+ " : " + type(0);
 		}
 	}
 
@@ -1399,10 +1398,6 @@ private IndirectInvoke(Type.FunctionOrMethod type, int[] targets,
 			super(new Type.FunctionOrMethod[]{type}, targets, append(operand,operands));
 		}
 
-		public Type.FunctionOrMethod type() {
-			return types[0];
-		}
-		
 		/**
 		 * Return register holding the indirect function/method reference.
 		 *
@@ -1442,7 +1437,7 @@ public int opcode() {
 
 		@Override
 		public Code.Unit clone(int[] nTargets, int[] nOperands) {
-			return IndirectInvoke(type(), nTargets, nOperands[0],
+			return IndirectInvoke(type(0), nTargets, nOperands[0],
 					Arrays.copyOfRange(nOperands, 1, nOperands.length));
 		}
 
@@ -1452,7 +1447,7 @@ public boolean equals(Object o) {
 
 		public String toString() {			
 			return "indirectinvoke " + arrayToString(targets()) + " = %" + reference() + " "
-					+ arrayToString(parameters()) + " : " + type();			
+					+ arrayToString(parameters()) + " : " + type(0);			
 		}
 	}
 	
@@ -1529,8 +1524,8 @@ public int opcode() {
 		}
 
 		@Override
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return Not(nTarget, nOperands[0]);
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Not(nTargets[0], nOperands[0]);
 		}
 
 		public int hashCode() {
@@ -1546,7 +1541,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "not %" + target() + " = %" + operand(0) + " : " + type();
+			return "not %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 
@@ -1601,24 +1596,20 @@ private Invoke(Type.FunctionOrMethod type, int[] targets, int[] operands,
 		}
 				
 		public int opcode() {
-			if (type() instanceof Type.Function) {
+			if (type(0) instanceof Type.Function) {
 				return OPCODE_invokefn;				
 			} else {
 				return OPCODE_invokemd;			
 			}
 		}
 
-		public Type.FunctionOrMethod type() {
-			return types[0];
-		}
-		
 		public int hashCode() {
 			return name.hashCode() + super.hashCode();
 		}
 
 		@Override
 		public Code.Unit clone(int[] nTargets, int[] nOperands) {
-			return Invoke(type(), nTargets, nOperands, name);
+			return Invoke(type(0), nTargets, nOperands, name);
 		}
 
 		public boolean equals(Object o) {
@@ -1631,12 +1622,12 @@ public boolean equals(Object o) {
 
 		public String toString() {
 			return "invoke " + arrayToString(targets()) + " = " + arrayToString(operands()) + " " + name + " : "
-					+ type();			
+					+ type(0);			
 		}
 	}
 
 	public static final class Lambda extends
-			AbstractNaryAssignable<Type.FunctionOrMethod> {
+			AbstractMultiNaryAssignable<Type.FunctionOrMethod> {
 		public final NameID name;
 
 		private Lambda(Type.FunctionOrMethod type, int target, int[] operands,
@@ -1646,7 +1637,7 @@ private Lambda(Type.FunctionOrMethod type, int target, int[] operands,
 		}
 
 		public int opcode() {
-			if (type() instanceof Type.Function) {
+			if (type(0) instanceof Type.Function) {
 				return OPCODE_lambdafn;
 			} else {
 				return OPCODE_lambdamd;
@@ -1658,8 +1649,8 @@ public int hashCode() {
 		}
 
 		@Override
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return Lambda(type(), nTarget, nOperands, name);
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Lambda(type(0), nTargets[0], nOperands, name);
 		}
 
 		public boolean equals(Object o) {
@@ -1671,8 +1662,8 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "lambda %" + target() + " = " + arrayToString(operands()) + " "
-					+ name + " : " + type();
+			return "lambda %" + target(0) + " = " + arrayToString(operands()) + " "
+					+ name + " : " + type(0);
 		}
 	}
 
@@ -1761,8 +1752,9 @@ public int opcode() {
 			return OPCODE_listgen;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return ArrayGenerator(type(), nTarget, nOperands[0],nOperands[1]);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return ArrayGenerator(type(0), nTargets[0], nOperands[0],nOperands[1]);
 		}
 
 		public boolean equals(Object o) {
@@ -1773,7 +1765,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "listgen %" + target() + " = [" + operand(0) + "; " + operand(1) + "]" + " : " + type();
+			return "arraygen %" + target(0) + " = [" + operand(0) + "; " + operand(1) + "]" + " : " + type(0);
 		}
 	}
 
@@ -1799,18 +1791,19 @@ public String toString() {
 	 * @author David J. Pearce
 	 *
 	 */
-	public static final class LengthOf extends
-			AbstractUnaryAssignable<Type.EffectiveArray> {
+	public static final class LengthOf extends AbstractUnaryAssignable<Type.EffectiveArray> {
+		
 		private LengthOf(Type.EffectiveArray type, int target, int operand) {
-			super(type, target, operand);
+			super((Type) type, target, operand);
 		}
 
 		public int opcode() {
 			return OPCODE_lengthof;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return LengthOf(type(), nTarget, nOperands[0]);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return LengthOf(type(0), nTargets[0], nOperands[0]);
 		}
 
 		public boolean equals(Object o) {
@@ -1821,7 +1814,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "lengthof %" + target() + " = %" + operand(0) + " : " + type();
+			return "lengthof %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 	
@@ -1853,19 +1846,20 @@ public String toString() {
 	 * @author David J. Pearce
 	 *
 	 */
-	public static final class IndexOf extends
-			AbstractBinaryAssignable<Type.EffectiveArray> {
+	public static final class IndexOf extends AbstractBinaryAssignable<Type.EffectiveArray> {
+		
 		private IndexOf(Type.EffectiveArray type, int target,
 				int sourceOperand, int keyOperand) {
-			super(type, target, sourceOperand, keyOperand);
+			super((Type) type, target, sourceOperand, keyOperand);
 		}
 
 		public int opcode() {
 			return OPCODE_indexof;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return IndexOf(type(), nTarget, nOperands[0], nOperands[1]);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return IndexOf(type(0), nTargets[0], nOperands[0], nOperands[1]);
 		}
 
 		public boolean equals(Object o) {
@@ -1876,8 +1870,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "indexof %" + target() + " = %" + operand(0) + ", %"
-					+ operand(1) + " : " + type();
+			return "indexof %" + target(0) + " = %" + operand(0) + ", %" + operand(1) + " : " + type(0);
 		}
 	}
 
@@ -1924,8 +1917,9 @@ public int opcode() {
 			return OPCODE_move;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return Move(type(), nTarget, nOperands[0]);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Move(type(0), nTargets[0], nOperands[0]);
 		}
 
 		public boolean equals(Object o) {
@@ -1936,7 +1930,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "move %" + target() + " = %" + operand(0) + " : " + type();
+			return "move %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 
@@ -2265,7 +2259,7 @@ public void remove() {
 	 * @author David J. Pearce
 	 *
 	 */
-	public static final class Update extends AbstractNaryAssignable<Type>
+	public static final class Update extends AbstractMultiNaryAssignable<Type>
 			implements Iterable<LVal> {
 		public final Type afterType;
 		public final ArrayList<String> fields;
@@ -2347,7 +2341,7 @@ public int key(int index) {
 
 		public int level() {
 			int base = -1; // because last operand is rhs
-			if (type() instanceof Type.Reference) {
+			if (type(0) instanceof Type.Reference) {
 				base++;
 			}
 			return base + fields.size() + operands().length;
@@ -2386,8 +2380,8 @@ public Type rhs() {
 		}
 
 		@Override
-		public final Code.Unit clone(int nTarget, int[] nOperands) {
-			return Update(type(), nTarget,
+		public final Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Update(type(0), nTargets[0],
 					Arrays.copyOf(nOperands, nOperands.length - 1),
 					nOperands[nOperands.length - 1], afterType, fields);
 		}
@@ -2402,7 +2396,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			String r = "%" + target();
+			String r = "%" + target(0);
 			for (LVal lv : this) {
 				if (lv instanceof ArrayLVal) {
 					ArrayLVal l = (ArrayLVal) lv;
@@ -2415,8 +2409,7 @@ public String toString() {
 					r = "(*" + r + ")";
 				}
 			}
-			return "update " + r + " = %" + result() + " : " + type() + " -> "
-					+ afterType;
+			return "update " + r + " = %" + result() + " : " + type(0) + " -> " + afterType;
 		}
 	}
 
@@ -2448,13 +2441,15 @@ public String toString() {
 	 *
 	 */
 	public static final class NewRecord extends
-			AbstractNaryAssignable<Type.Record> {
+			AbstractMultiNaryAssignable<Type.Record> {
+		
 		private NewRecord(Type.Record type, int target, int[] operands) {
 			super(type, target, operands);
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return NewRecord(type(), nTarget, nOperands);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return NewRecord(type(0), nTargets[0], nOperands);
 		}
 
 		public int opcode() {
@@ -2469,8 +2464,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "newrecord %" + target() + " = " + arrayToString(operands())
-					+ " : " + type();
+			return "newrecord %" + target(0) + " = " + arrayToString(operands()) + " : " + type(0);
 		}
 	}
 
@@ -2503,7 +2497,7 @@ public String toString() {
 	 * @author David J. Pearce
 	 *
 	 */
-	public static final class NewArray extends AbstractNaryAssignable<Type.Array> {
+	public static final class NewArray extends AbstractMultiNaryAssignable<Type.Array> {
 
 		private NewArray(Type.Array type, int target, int[] operands) {
 			super(type, target, operands);
@@ -2513,8 +2507,9 @@ public int opcode() {
 			return OPCODE_newlist;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return NewArray(type(), nTarget, nOperands);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return NewArray(type(0), nTargets[0], nOperands);
 		}
 
 		public boolean equals(Object o) {
@@ -2525,8 +2520,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "newlist %" + target() + " = " + arrayToString(operands())
-					+ " : " + type();
+			return "newlist %" + target(0) + " = " + arrayToString(operands()) + " : " + type(0);
 		}
 	}
 
@@ -2767,8 +2761,9 @@ public int opcode() {
 			return OPCODE_invert;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return Invert(type(), nTarget, nOperands[0]);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Invert(type(0), nTargets[0], nOperands[0]);
 		}
 
 		public boolean equals(Object o) {
@@ -2779,7 +2774,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "invert %" + target() + " = %" + operand(0) + " : " + type();
+			return "invert %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 
@@ -2824,8 +2819,8 @@ public int opcode() {
 			return OPCODE_newobject;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return NewObject(type(), nTarget, nOperands[0]);
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return NewObject(type(0), nTargets[0], nOperands[0]);
 		}
 
 		public boolean equals(Object o) {
@@ -2836,7 +2831,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "newobject %" + target() + " = %" + operand(0) + " : " + type();
+			return "newobject %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 
@@ -2859,8 +2854,8 @@ public int opcode() {
 			return OPCODE_dereference;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return Dereference(type(), nTarget, nOperands[0]);
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Dereference(type(0), nTargets[0], nOperands[0]);
 		}
 
 		public boolean equals(Object o) {
@@ -2871,7 +2866,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return "deref %" + target() + " = %" + operand(0) + " : " + type();
+			return "deref %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 
@@ -2943,8 +2938,8 @@ public int opcode() {
 		}
 
 		@Override
-		public Code.Unit clone(int nTarget, int[] nOperands) {
-			return UnaryOperator(type(), nTarget, nOperands[0], kind);
+		public Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return UnaryOperator(type(0), nTargets[0], nOperands[0], kind);
 		}
 
 		public int hashCode() {
@@ -2960,7 +2955,7 @@ public boolean equals(Object o) {
 		}
 
 		public String toString() {
-			return kind + " %" + target() + " = %" + operand(0) + " : " + type();
+			return kind + " %" + target(0) + " = %" + operand(0) + " : " + type(0);
 		}
 	}
 
@@ -2972,7 +2967,7 @@ public String toString() {
 	 * @author David J. Pearce
 	 *
 	 */
-	public static class Void extends AbstractNaryAssignable<Type> {
+	public static class Void extends AbstractMultiNaryAssignable<Type> {
 
 		private Void(Type type, int[] operands) {
 			super(type, Codes.NULL_REG, operands);
@@ -2983,8 +2978,9 @@ public int opcode() {
 			return OPCODE_void;
 		}
 
-		protected Code.Unit clone(int nTarget, int[] nOperands) {
-			return Void(type(), nOperands);
+		@Override
+		protected Code.Unit clone(int[] nTargets, int[] nOperands) {
+			return Void(type(0), nOperands);
 		}
 
 		public boolean equals(Object o) {
diff --git a/modules/wyil/src/wyil/transforms/ConstantPropagation.java b/modules/wyil/src/wyil/transforms/ConstantPropagation.java
index 61c6e65d4d..abd5530ad8 100755
--- a/modules/wyil/src/wyil/transforms/ConstantPropagation.java
+++ b/modules/wyil/src/wyil/transforms/ConstantPropagation.java
@@ -303,7 +303,7 @@ public void infer(CodeBlock.Index index, Codes.BinaryOperator code, Env environm
 			}
 		}
 
-		assign(code.target(), result, environment, index);
+		assign(code.target(0), result, environment, index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.Convert code,
@@ -311,7 +311,7 @@ public void infer(CodeBlock.Index index, Codes.Convert code,
 		// TODO: implement this
 		Constant val = environment.get(code.operand(0));
 
-		invalidate(code.target(),environment);
+		invalidate(code.target(0),environment);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.Const code,
@@ -336,7 +336,7 @@ public void infer(CodeBlock.Index index, Codes.FieldLoad code,
 			result = rec.values.get(code.field);
 		}
 
-		assign(code.target(),result,environment,index);
+		assign(code.target(0),result,environment,index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.IndirectInvoke code,
@@ -358,21 +358,19 @@ public void infer(CodeBlock.Index index, Codes.Invoke code,
 		}		
 	}
 
-	public void infer(CodeBlock.Index index, Codes.Lambda code,
-			Env environment) {
+	public void infer(CodeBlock.Index index, Codes.Lambda code, Env environment) {
 		// For now, don't do anything!
-		assign(code.target(),null,environment,index);
+		assign(code.target(0), null, environment, index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.LengthOf code, Env environment) {
 		Constant val = environment.get(code.operand(0));
 		Constant.Array list = (Constant.Array) val;
 		Constant result = Constant.V_INTEGER(BigInteger.valueOf(list.values.size()));
-		assign(code.target(), result, environment, index);
+		assign(code.target(0), result, environment, index);
 	}
 
-	public void infer(CodeBlock.Index index, Codes.IndexOf code,
-			Env environment) {
+	public void infer(CodeBlock.Index index, Codes.IndexOf code, Env environment) {
 		Constant src = environment.get(code.operand(0));
 		Constant idx = environment.get(code.operand(1));
 		Constant result = null;
@@ -381,36 +379,33 @@ public void infer(CodeBlock.Index index, Codes.IndexOf code,
 			Constant.Array list = (Constant.Array) src;
 			if (num.value.scale() <= 0) {
 				int i = num.value.intValue();
-				if (BigRational.valueOf(i).equals(num.value) && i >= 0
-						&& i < list.values.size()) {
+				if (BigRational.valueOf(i).equals(num.value) && i >= 0 && i < list.values.size()) {
 					result = list.values.get(i);
 				}
 			}
-		} 
+		}
 
-		assign(code.target(),result,environment,index);
+		assign(code.target(0), result, environment, index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.Assign code,
 			Env environment) {
 		Constant result = environment.get(code.operand(0));
-		assign(code.target(),result,environment,index);
+		assign(code.target(0),result,environment,index);
 	}
 
-	public void infer(CodeBlock.Index index, Codes.Update code,
-			Env environment) {
+	public void infer(CodeBlock.Index index, Codes.Update code, Env environment) {
 		// TODO: implement this!
-		invalidate(code.target(),environment);
+		invalidate(code.target(0), environment);
 	}
 
-	public void infer(CodeBlock.Index index, Codes.NewRecord code,
-			Env environment) {
+	public void infer(CodeBlock.Index index, Codes.NewRecord code, Env environment) {
 		HashMap<String, Constant> values = new HashMap<String, Constant>();
-		ArrayList<String> keys = new ArrayList<String>(code.type().keys());
+		ArrayList<String> keys = new ArrayList<String>(code.type(0).keys());
 		Collections.sort(keys);
 		boolean isValue = true;
 		int[] code_operands = code.operands();
-		for (int i=0;i!=code_operands.length;++i) {
+		for (int i = 0; i != code_operands.length; ++i) {
 			Constant val = environment.get(code_operands[i]);
 			if (isRealConstant(val)) {
 				values.put(keys.get(i), val);
@@ -424,11 +419,10 @@ public void infer(CodeBlock.Index index, Codes.NewRecord code,
 			result = Constant.V_RECORD(values);
 		}
 
-		assign(code.target(), result, environment, index);
+		assign(code.target(0), result, environment, index);
 	}
 
-	public void infer(CodeBlock.Index index, Codes.NewArray code,
-			Env environment) {
+	public void infer(CodeBlock.Index index, Codes.NewArray code, Env environment) {
 		ArrayList<Constant> values = new ArrayList<Constant>();
 
 		boolean isValue = true;
@@ -446,7 +440,7 @@ public void infer(CodeBlock.Index index, Codes.NewArray code,
 		if (isValue) {
 			result = Constant.V_ARRAY(values);
 		}
-		assign(code.target(),result,environment,index);
+		assign(code.target(0), result, environment, index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.Return code, Env environment) {
@@ -461,7 +455,7 @@ public void infer(CodeBlock.Index index, Codes.Invert code, Env environment) {
 			result = Constant.V_BYTE((byte) ~num.value);
 		}
 
-		assign(code.target(), result, environment, index);
+		assign(code.target(0), result, environment, index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.UnaryOperator code, Env environment) {
@@ -480,16 +474,16 @@ public void infer(CodeBlock.Index index, Codes.UnaryOperator code, Env environme
 			}
 		}
 
-		assign(code.target(), result, environment, index);
+		assign(code.target(0), result, environment, index);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.NewObject code,
 			Env environment) {
-		invalidate(code.target(), environment);
+		invalidate(code.target(0), environment);
 	}
 
 	public void infer(CodeBlock.Index index, Codes.Dereference code, Env environment) {
-		invalidate(code.target(), environment);
+		invalidate(code.target(0), environment);
 	}
 
 	@Override
diff --git a/modules/wyil/src/wyil/transforms/LiveVariablesAnalysis.java b/modules/wyil/src/wyil/transforms/LiveVariablesAnalysis.java
index 22212977c8..66950457b0 100755
--- a/modules/wyil/src/wyil/transforms/LiveVariablesAnalysis.java
+++ b/modules/wyil/src/wyil/transforms/LiveVariablesAnalysis.java
@@ -194,10 +194,10 @@ public Env propagate(CodeBlock.Index index, Code code, Env environment) {
 				// In the normal case, this bytecode is considered live if the
 				// assigned register is live. However, in the case of an
 				// indirect assignment, then it is always considered live.
-				if(!(cu.type() instanceof Type.Reference)) {
+				if(!(cu.type(0) instanceof Type.Reference)) {
 					// No, this is not an indirect assignment through a
 					// reference
-					isLive = environment.contains(cu.target());
+					isLive = environment.contains(cu.target(0));
 				}
 			} else {
 				for(int target : aa.targets()) {
@@ -216,11 +216,13 @@ public Env propagate(CodeBlock.Index index, Code code, Env environment) {
 			Code.AbstractBinaryOp c = (Code.AbstractBinaryOp) code;
 			environment.add(c.leftOperand);
 			environment.add(c.rightOperand);
-		} else if ((isLive && code instanceof Code.AbstractNaryAssignable)
-				|| (code instanceof Codes.Invoke && ((Codes.Invoke) code).type() instanceof Type.Method)
-				|| (code instanceof Codes.IndirectInvoke && ((Codes.IndirectInvoke) code).type() instanceof Type.Method)) {
-			Code.AbstractNaryAssignable c = (Code.AbstractNaryAssignable) code;
-			for(int operand : c.operands()) {
+		} else if ((isLive && code instanceof Code.AbstractMultiNaryAssignable)
+				|| (code instanceof Codes.Invoke && ((Codes.Invoke) code).type(0) instanceof Type.Method)
+				|| (code instanceof Codes.IndirectInvoke
+						&& ((Codes.IndirectInvoke) code).type(0) instanceof Type.Method)) {
+			// FIXME: this seems to be a problem if there are no assigned variables!
+			Code.AbstractMultiNaryAssignable c = (Code.AbstractMultiNaryAssignable) code;
+			for (int operand : c.operands()) {
 				environment.add(operand);
 			}
 		} else if(!isLive) {
diff --git a/modules/wyil/src/wyil/util/Interpreter.java b/modules/wyil/src/wyil/util/Interpreter.java
index e2ba27be29..e46d97b1c9 100755
--- a/modules/wyil/src/wyil/util/Interpreter.java
+++ b/modules/wyil/src/wyil/util/Interpreter.java
@@ -266,7 +266,10 @@ private Object execute(Codes.AssertOrAssume bytecode, Constant[] frame,
 	 */
 	private Object execute(Codes.Assign bytecode, Constant[] frame,
 			Context context) {
-		frame[bytecode.target()] = frame[bytecode.operand(0)];
+		int[] targets = bytecode.targets();
+		for (int i = 0; i != targets.length; ++i) {
+			frame[bytecode.target(i)] = frame[bytecode.operand(i)];
+		}		
 		return context.pc.next();
 	}
 
@@ -305,7 +308,8 @@ private Object execute(Codes.BinaryOperator bytecode, Constant[] frame,
 		}
 
 		// Write result to target
-		frame[bytecode.target()] = result;
+		frame[bytecode.target(0)] = result;
+		
 		return context.pc.next();
 	}
 
@@ -437,7 +441,7 @@ private Object execute(Codes.Convert bytecode, Constant[] frame,
 		try {
 			Constant operand = frame[bytecode.operand(0)];
 			Type target = expander.getUnderlyingType(bytecode.result);
-			frame[bytecode.target()] = convert(operand, target, context);
+			frame[bytecode.target(0)] = convert(operand, target, context);
 			return context.pc.next();
 		} catch (IOException e) {
 			return error(e.getMessage(), context);
@@ -612,7 +616,7 @@ private Object execute(Codes.Dereference bytecode, Constant[] frame,
 		Constant operand = frame[bytecode.operand(0)];
 		checkType(operand, context, ConstantObject.class);
 		ConstantObject ref = (ConstantObject) operand;
-		frame[bytecode.target()] = ref.read();
+		frame[bytecode.target(0)] = ref.read();
 		return context.pc.next();
 	}
 
@@ -636,7 +640,7 @@ private Object execute(Codes.Fail bytecode, Constant[] frame,
 	private Object execute(Codes.FieldLoad bytecode, Constant[] frame,
 			Context context) {
 		Constant.Record rec = (Constant.Record) frame[bytecode.operand(0)];
-		frame[bytecode.target()] = rec.values.get(bytecode.field);
+		frame[bytecode.target(0)] = rec.values.get(bytecode.field);
 		return context.pc.next();
 	}
 
@@ -899,7 +903,7 @@ private Object execute(Codes.IndexOf bytecode, Constant[] frame,
 			error("index-out-of-bounds", context);
 		}
 		// Ok, get the element at that index
-		frame[bytecode.target()] = list.values.get(index.value.intValue());
+		frame[bytecode.target(0)] = list.values.get(index.value.intValue());
 		// Done		
 		return context.pc.next();
 	}
@@ -944,7 +948,7 @@ private Object execute(Codes.IndirectInvoke bytecode, Constant[] frame,
 		Constant[] results = execute(func.name, func.type(), arguments);		
 		// Check whether a return value was expected or not
 		int[] targets = bytecode.targets();
-		List<Type> returns = bytecode.type().returns();
+		List<Type> returns = bytecode.type(0).returns();
 		for(int i=0;i!=targets.length;++i) {
 			// Coerce the result (may not be actually necessary))
 			frame[targets[i]] = convert(results[i],returns.get(i),context);
@@ -978,7 +982,7 @@ private Object execute(Codes.Invert bytecode, Constant[] frame,
 		checkType(operand, context, Constant.Byte.class);
 		// Write back the inverted value
 		Constant.Byte b = (Constant.Byte) operand;
-		frame[bytecode.target()] = Constant.V_BYTE((byte) ~b.value);
+		frame[bytecode.target(0)] = Constant.V_BYTE((byte) ~b.value);
 		// Done
 		return context.pc.next();
 	}
@@ -1004,9 +1008,8 @@ private Object execute(Codes.Invoke bytecode, Constant[] frame,
 		for (int i = 0; i != arguments.length; ++i) {
 			arguments[i] = frame[operands[i]];
 		}
-		Constant[] results = execute(bytecode.name, bytecode.type(), arguments);
+		Constant[] results = execute(bytecode.name, bytecode.type(0), arguments);
 		int[] targets = bytecode.targets();
-		List<Type> returns = bytecode.type().returns();
 		for(int i=0;i!=targets.length;++i) {
 			frame[targets[i]] = results[i];
 		}		
@@ -1025,8 +1028,7 @@ private Object execute(Codes.Lambda bytecode, Constant[] frame,
 			}
 		}
 		// FIXME: need to do something with the operands here.
-		frame[bytecode.target()] = Constant.V_LAMBDA(bytecode.name,
-				bytecode.type(), arguments);
+		frame[bytecode.target(0)] = Constant.V_LAMBDA(bytecode.name, bytecode.type(0), arguments);
 		//
 		return context.pc.next();
 	}
@@ -1050,7 +1052,7 @@ private Object execute(Codes.LengthOf bytecode, Constant[] frame,
 		checkType(_source, context, Constant.Array.class);
 		Constant.Array list = (Constant.Array) _source;
 		BigInteger length = BigInteger.valueOf(list.values.size());		
-		frame[bytecode.target()] = Constant.V_INTEGER(length);
+		frame[bytecode.target(0)] = Constant.V_INTEGER(length);
 		return context.pc.next();
 	}
 	
@@ -1080,7 +1082,7 @@ private Object execute(Codes.ArrayGenerator bytecode, Constant[] frame,
 		for(int i=0;i!=n;++i) {
 			values.add(element);
 		}
-		frame[bytecode.target()] = Constant.V_ARRAY(values);
+		frame[bytecode.target(0)] = Constant.V_ARRAY(values);
 		return context.pc.next();
 	}
 	
@@ -1112,8 +1114,11 @@ private Object execute(Codes.Loop bytecode, Constant[] frame,
 	 */
 	private Object execute(Codes.Move bytecode, Constant[] frame,
 			Context context) {
-		frame[bytecode.target()] = frame[bytecode.operand(0)];
-		frame[bytecode.operand(0)] = null;
+		int[] operands = bytecode.operands();
+		for(int i=0;i!=operands.length;++i) {
+			frame[bytecode.target(i)] = frame[bytecode.operand(i)];
+			frame[bytecode.operand(i)] = null;
+		}
 		return context.pc.next();
 	}
 
@@ -1135,7 +1140,7 @@ private Object execute(Codes.NewArray bytecode, Constant[] frame,
 		for (int operand : bytecode.operands()) {
 			values.add((Constant) frame[operand]);
 		}
-		frame[bytecode.target()] = Constant.V_ARRAY(values);
+		frame[bytecode.target(0)] = Constant.V_ARRAY(values);
 		return context.pc.next();
 	}
 
@@ -1143,7 +1148,7 @@ private Object execute(Codes.NewObject bytecode, Constant[] frame,
 			Context context) {
 		Constant operand = frame[bytecode.operand(0)];
 		ConstantObject o = new ConstantObject(operand);
-		frame[bytecode.target()] = o;
+		frame[bytecode.target(0)] = o;
 		return context.pc.next();
 	}
 
@@ -1162,14 +1167,13 @@ private Object execute(Codes.NewObject bytecode, Constant[] frame,
 	private Object execute(Codes.NewRecord bytecode, Constant[] frame,
 			Context context) {
 		HashMap<String, Constant> values = new HashMap<String, Constant>();
-		ArrayList<String> fields = new ArrayList<String>(bytecode.type()
-				.fields().keySet());
+		ArrayList<String> fields = new ArrayList<String>(bytecode.type(0).fields().keySet());
 		Collections.sort(fields);
 		int[] operands = bytecode.operands();
 		for (int i = 0; i != operands.length; ++i) {
 			values.put(fields.get(i), (Constant) frame[operands[i]]);
 		}
-		frame[bytecode.target()] = Constant.V_RECORD(values);
+		frame[bytecode.target(0)] = Constant.V_RECORD(values);
 		return context.pc.next();
 	}
 
@@ -1257,7 +1261,7 @@ private Object execute(Codes.UnaryOperator bytecode, Constant[] frame,
 			return deadCode(context);
 		}
 		// Assign result to target register
-		frame[bytecode.target()] = result;
+		frame[bytecode.target(0)] = result;
 		// Fall through to next bytecode
 		return context.pc.next();
 
@@ -1266,9 +1270,8 @@ private Object execute(Codes.UnaryOperator bytecode, Constant[] frame,
 	private Object execute(Codes.Update bytecode, Constant[] frame,
 			Context context) {
 		Constant rhs = frame[bytecode.result()];
-		Constant lhs = frame[bytecode.target()];
-		frame[bytecode.target()] = update(lhs, bytecode.iterator(), rhs, frame,
-				context);
+		Constant lhs = frame[bytecode.target(0)];
+		frame[bytecode.target(0)] = update(lhs, bytecode.iterator(), rhs, frame, context);
 		return context.pc.next();
 	}
 
diff --git a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
index 54b9c64bd8..d88f1e8e0d 100755
--- a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
+++ b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
@@ -707,22 +707,16 @@ private void translate(CodeBlock.Index index, Codes.Const c, int freeSlot,
 		bytecodes.add(new Bytecode.Store(c.target(), jt));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.Convert c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c
-				.type())));
-		addCoercion(c.type(), c.result, freeSlot, constants, bytecodes);
-		bytecodes.add(new Bytecode.Store(c.target(),
-				convertUnderlyingType(c.result)));
+	private void translate(CodeBlock.Index index, Codes.Convert c, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0))));
+		addCoercion(c.type(0), c.result, freeSlot, constants, bytecodes);
+		bytecodes.add(new Bytecode.Store(c.target(0), convertUnderlyingType(c.result)));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.Update code,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		bytecodes.add(new Bytecode.Load(code.target(),
-				convertUnderlyingType(code.type())));
+	private void translate(CodeBlock.Index index, Codes.Update code, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		bytecodes.add(new Bytecode.Load(code.target(0), convertUnderlyingType(code.type(0))));
 		translateUpdate(code.iterator(), code, bytecodes);
-		bytecodes.add(new Bytecode.Store(code.target(),
-				convertUnderlyingType(code.afterType)));
+		bytecodes.add(new Bytecode.Store(code.target(0), convertUnderlyingType(code.afterType)));
 	}
 
 	/**
@@ -867,7 +861,7 @@ private void translate(CodeBlock.Index index, Codes.Return c, int freeSlot,
 		JvmType jt = null;
 		int[] operands = c.operands();
 		 if(operands.length == 1) {
-			jt = convertUnderlyingType(c.type());
+			jt = convertUnderlyingType(c.type(0));
 			bytecodes.add(new Bytecode.Load(operands[0], jt));
 			bytecodes.add(new Bytecode.Return(jt));
 		} else if(operands.length > 1){
@@ -1315,90 +1309,67 @@ private void translate(CodeBlock.Index index, Codes.Debug c, int freeSlot,
 
 	private void translate(CodeBlock.Index index, Codes.Assign c, int freeSlot,
 			ArrayList<Bytecode> bytecodes) {
-		JvmType jt = convertUnderlyingType(c.type());
+		JvmType jt = convertUnderlyingType(c.type(0));
 		bytecodes.add(new Bytecode.Load(c.operand(0), jt));
-		bytecodes.add(new Bytecode.Store(c.target(), jt));
+		bytecodes.add(new Bytecode.Store(c.target(0), jt));
 	}
 
 	private void translate(CodeBlock.Index index, Codes.Move c, int freeSlot,
 			ArrayList<Bytecode> bytecodes) {
-		JvmType jt = convertUnderlyingType(c.type());
+		JvmType jt = convertUnderlyingType(c.type(0));
 		bytecodes.add(new Bytecode.Load(c.operand(0), jt));
-		bytecodes.add(new Bytecode.Store(c.target(), jt));
+		bytecodes.add(new Bytecode.Store(c.target(0), jt));
 	}
 	
-	private void translate(CodeBlock.Index index, Codes.ArrayGenerator c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		
-		JvmType elementType = convertUnderlyingType(c.type().element());
-
+	private void translate(CodeBlock.Index index, Codes.ArrayGenerator c, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		JvmType elementType = convertUnderlyingType(c.type(0).element());
 		bytecodes.add(new Bytecode.Load(c.operand(0), elementType));
-		addWriteConversion(c.type().element(), bytecodes);
+		addWriteConversion(c.type(0).element(), bytecodes);
 		bytecodes.add(new Bytecode.Load(c.operand(1), WHILEYINT));
-		
 		JvmType.Function ftype = new JvmType.Function(WHILEYARRAY, JAVA_LANG_OBJECT, WHILEYINT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "generate", ftype,
-				Bytecode.InvokeMode.STATIC));
-		bytecodes.add(new Bytecode.Store(c.target(), WHILEYARRAY));
+		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "generate", ftype, Bytecode.InvokeMode.STATIC));
+		bytecodes.add(new Bytecode.Store(c.target(0), WHILEYARRAY));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.LengthOf c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		bytecodes.add(new Bytecode.Load(c.operand(0),
-				convertUnderlyingType((Type) c.type())));
+	private void translate(CodeBlock.Index index, Codes.LengthOf c, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType((Type) c.type(0))));
 		JvmType.Clazz ctype = JAVA_LANG_OBJECT;
 		JvmType.Function ftype = new JvmType.Function(WHILEYINT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "length", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Store(c.target(), WHILEYINT));
+		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "length", ftype, Bytecode.InvokeMode.VIRTUAL));
+		bytecodes.add(new Bytecode.Store(c.target(0), WHILEYINT));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.IndexOf c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-
+	private void translate(CodeBlock.Index index, Codes.IndexOf c, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.Load(c.operand(0), WHILEYARRAY));
 		bytecodes.add(new Bytecode.Load(c.operand(1), WHILEYINT));
-		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				WHILEYARRAY, WHILEYINT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "get", ftype,
-				Bytecode.InvokeMode.STATIC));
-		addReadConversion(c.type().element(), bytecodes);
-
-		bytecodes.add(new Bytecode.Store(c.target(), convertUnderlyingType(c
-				.type().element())));
+		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYARRAY, WHILEYINT);
+		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "get", ftype, Bytecode.InvokeMode.STATIC));
+		addReadConversion(c.type(0).element(), bytecodes);
+		bytecodes.add(new Bytecode.Store(c.target(0), convertUnderlyingType(c.type(0).element())));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.Fail c, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	private void translate(CodeBlock.Index index, Codes.Fail c, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.New(JAVA_LANG_RUNTIMEEXCEPTION));
 		bytecodes.add(new Bytecode.Dup(JAVA_LANG_RUNTIMEEXCEPTION));
 		bytecodes.add(new Bytecode.LoadConst("runtime fault encountered"));
 		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_STRING);
-		bytecodes.add(new Bytecode.Invoke(JAVA_LANG_RUNTIMEEXCEPTION, "<init>",
-				ftype, Bytecode.InvokeMode.SPECIAL));
+		bytecodes.add(new Bytecode.Invoke(JAVA_LANG_RUNTIMEEXCEPTION, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 		bytecodes.add(new Bytecode.Throw());
 	}
 
-	private void translate(CodeBlock.Index index, Codes.FieldLoad c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-
+	private void translate(CodeBlock.Index index, Codes.FieldLoad c, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.Load(c.operand(0), WHILEYRECORD));
-
 		bytecodes.add(new Bytecode.LoadConst(c.field));
-		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				WHILEYRECORD, JAVA_LANG_STRING);
-		bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype,
-				Bytecode.InvokeMode.STATIC));
+		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYRECORD, JAVA_LANG_STRING);
+		bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.STATIC));
 		addReadConversion(c.fieldType(), bytecodes);
-
-		bytecodes.add(new Bytecode.Store(c.target(), convertUnderlyingType(c
-				.fieldType())));
+		bytecodes.add(new Bytecode.Store(c.target(0), convertUnderlyingType(c.fieldType())));
 	}
 
 	private void translate(CodeBlock.Index index, Codes.BinaryOperator c,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
 
-		JvmType type = convertUnderlyingType(c.type());
+		JvmType type = convertUnderlyingType(c.type(0));
 		JvmType.Function ftype = new JvmType.Function(type, type);
 
 		// first, load operands
@@ -1473,22 +1444,20 @@ private void translate(CodeBlock.Index index, Codes.BinaryOperator c,
 					rootBlock.attribute(index, SourceLocation.class));
 		}
 
-		bytecodes.add(new Bytecode.Store(c.target(), type));
+		bytecodes.add(new Bytecode.Store(c.target(0), type));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.Invert c, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
-		JvmType type = convertUnderlyingType(c.type());
+	private void translate(CodeBlock.Index index, Codes.Invert c, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		JvmType type = convertUnderlyingType(c.type(0));
 		bytecodes.add(new Bytecode.Load(c.operand(0), type));
 		JvmType.Function ftype = new JvmType.Function(type);
-		bytecodes.add(new Bytecode.Invoke(WHILEYBYTE, "compliment", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Store(c.target(), type));
+		bytecodes.add(new Bytecode.Invoke(WHILEYBYTE, "compliment", ftype, Bytecode.InvokeMode.VIRTUAL));
+		bytecodes.add(new Bytecode.Store(c.target(0), type));
 	}
 
 	private void translate(CodeBlock.Index index, Codes.UnaryOperator c,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		JvmType srcType = convertUnderlyingType(c.type());
+		JvmType srcType = convertUnderlyingType(c.type(0));
 		JvmType targetType = null;
 		String name = null;
 		switch (c.kind) {
@@ -1507,67 +1476,56 @@ private void translate(CodeBlock.Index index, Codes.UnaryOperator c,
 		}
 		JvmType.Function ftype = new JvmType.Function(targetType);
 		bytecodes.add(new Bytecode.Load(c.operand(0), srcType));
-		bytecodes.add(new Bytecode.Invoke((JvmType.Clazz) srcType, name, ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Store(c.target(), targetType));
+		bytecodes.add(new Bytecode.Invoke((JvmType.Clazz) srcType, name, ftype, Bytecode.InvokeMode.VIRTUAL));
+		bytecodes.add(new Bytecode.Store(c.target(0), targetType));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.NewObject c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		JvmType type = convertUnderlyingType(c.type());
+	private void translate(CodeBlock.Index index, Codes.NewObject c, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		JvmType type = convertUnderlyingType(c.type(0));
 		bytecodes.add(new Bytecode.New(WHILEYOBJECT));
 		bytecodes.add(new Bytecode.Dup(WHILEYOBJECT));
-		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c
-				.type().element())));
-		addWriteConversion(c.type().element(), bytecodes);
+		bytecodes.add(new Bytecode.Load(c.operand(0), convertUnderlyingType(c.type(0).element())));
+		addWriteConversion(c.type(0).element(), bytecodes);
 		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "<init>", ftype,
-				Bytecode.InvokeMode.SPECIAL));
-		bytecodes.add(new Bytecode.Store(c.target(), type));
+		bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+		bytecodes.add(new Bytecode.Store(c.target(0), type));
 	}
 
 	private void translate(CodeBlock.Index index, Codes.Dereference c,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		JvmType type = convertUnderlyingType(c.type());
+		JvmType type = convertUnderlyingType(c.type(0));
 		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT);
 		bytecodes.add(new Bytecode.Load(c.operand(0), type));
-		bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "state", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
+		bytecodes.add(new Bytecode.Invoke(WHILEYOBJECT, "state", ftype, Bytecode.InvokeMode.VIRTUAL));
 		// finally, we need to cast the object we got back appropriately.
-		Type.Reference pt = (Type.Reference) c.type();
+		Type.Reference pt = (Type.Reference) c.type(0);
 		addReadConversion(pt.element(), bytecodes);
-		bytecodes.add(new Bytecode.Store(c.target(), convertUnderlyingType(c
-				.type().element())));
+		bytecodes.add(new Bytecode.Store(c.target(0), convertUnderlyingType(c.type(0).element())));
 	}
 
-	protected void translate(CodeBlock.Index index, Codes.NewArray c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
+	protected void translate(CodeBlock.Index index, Codes.NewArray c, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.New(WHILEYARRAY));
 		bytecodes.add(new Bytecode.Dup(WHILEYARRAY));
 		bytecodes.add(new Bytecode.LoadConst(c.operands().length));
 		JvmType.Function ftype = new JvmType.Function(T_VOID, T_INT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype,
-				Bytecode.InvokeMode.SPECIAL));
+		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 
 		ftype = new JvmType.Function(WHILEYARRAY, WHILEYARRAY, JAVA_LANG_OBJECT);
 		for (int i = 0; i != c.operands().length; ++i) {
-			bytecodes.add(new Bytecode.Load(c.operands()[i],
-					convertUnderlyingType(c.type().element())));
-			addWriteConversion(c.type().element(), bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "internal_add",
-					ftype, Bytecode.InvokeMode.STATIC));
+			bytecodes.add(new Bytecode.Load(c.operands()[i], convertUnderlyingType(c.type(0).element())));
+			addWriteConversion(c.type(0).element(), bytecodes);
+			bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "internal_add", ftype, Bytecode.InvokeMode.STATIC));
 		}
 
-		bytecodes.add(new Bytecode.Store(c.target(), WHILEYARRAY));
+		bytecodes.add(new Bytecode.Store(c.target(0), WHILEYARRAY));
 	}
 
 	private void translate(CodeBlock.Index index, Codes.NewRecord code,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
 		construct(WHILEYRECORD, freeSlot, bytecodes);
-		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
 
-		HashMap<String, Type> fields = code.type().fields();
+		HashMap<String, Type> fields = code.type(0).fields();
 		ArrayList<String> keys = new ArrayList<String>(fields.keySet());
 		Collections.sort(keys);
 		for (int i = 0; i != code.operands().length; i++) {
@@ -1576,24 +1534,21 @@ private void translate(CodeBlock.Index index, Codes.NewRecord code,
 			Type fieldType = fields.get(key);
 			bytecodes.add(new Bytecode.Dup(WHILEYRECORD));
 			bytecodes.add(new Bytecode.LoadConst(key));
-			bytecodes.add(new Bytecode.Load(register,
-					convertUnderlyingType(fieldType)));
+			bytecodes.add(new Bytecode.Load(register, convertUnderlyingType(fieldType)));
 			addWriteConversion(fieldType, bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype,
-					Bytecode.InvokeMode.VIRTUAL));
+			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.VIRTUAL));
 			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
 		}
 
-		bytecodes.add(new Bytecode.Store(code.target(), WHILEYRECORD));
+		bytecodes.add(new Bytecode.Store(code.target(0), WHILEYRECORD));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.Lambda c, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	private void translate(CodeBlock.Index index, Codes.Lambda c, int freeSlot, ArrayList<Bytecode> bytecodes) {
 
 		// First, build and register lambda class which calls the given function
 		// or method. This class will extend class wyjc.runtime.WyLambda.
 		int lambda_id = lambdas.size();
-		lambdas.add(buildLambda(c.name, c.type(), lambda_id));
+		lambdas.add(buildLambda(c.name, c.type(0), lambda_id));
 
 		// Second, create and duplicate new lambda object. This will then stay
 		// on the stack (whilst the parameters are constructed) until the
@@ -1629,9 +1584,8 @@ private void translate(CodeBlock.Index index, Codes.Lambda c, int freeSlot,
 				int operand = c.operands()[i];
 
 				if (operand != Codes.NULL_REG) {
-					Type pt = c.type().params().get(i);
-					bytecodes.add(new Bytecode.Load(operand,
-							convertUnderlyingType(pt)));
+					Type pt = c.type(0).params().get(i);
+					bytecodes.add(new Bytecode.Load(operand, convertUnderlyingType(pt)));
 					addWriteConversion(pt, bytecodes);
 				} else {
 					bytecodes.add(new Bytecode.LoadConst(null));
@@ -1644,60 +1598,50 @@ private void translate(CodeBlock.Index index, Codes.Lambda c, int freeSlot,
 		}
 
 		// Fifth, invoke lambda class constructor
-		JvmType.Function ftype = new JvmType.Function(T_VOID,
-				JAVA_LANG_OBJECT_ARRAY);
-		bytecodes.add(new Bytecode.Invoke(lambdaClassType, "<init>", ftype,
-				Bytecode.InvokeMode.SPECIAL));
+		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_OBJECT_ARRAY);
+		bytecodes.add(new Bytecode.Invoke(lambdaClassType, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 
 		// Sixth, assign newly created lambda object to target register
-		JvmType.Clazz clazz = (JvmType.Clazz) convertUnderlyingType(c.type());
-		bytecodes.add(new Bytecode.Store(c.target(), clazz));
+		JvmType.Clazz clazz = (JvmType.Clazz) convertUnderlyingType(c.type(0));
+		bytecodes.add(new Bytecode.Store(c.target(0), clazz));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.Invoke c, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	private void translate(CodeBlock.Index index, Codes.Invoke c, int freeSlot, ArrayList<Bytecode> bytecodes) {
 
 		for (int i = 0; i != c.operands().length; ++i) {
 			int register = c.operands()[i];
-			JvmType parameterType = convertUnderlyingType(c.type().params()
-					.get(i));
+			JvmType parameterType = convertUnderlyingType(c.type(0).params().get(i));
 			bytecodes.add(new Bytecode.Load(register, parameterType));
 		}
 
 		Path.ID mid = c.name.module();
-		String mangled = nameMangle(c.name.name(), c.type());
-		JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString()
-				.replace('/', '.'), mid.last());
-		JvmType.Function type = convertFunType(c.type());
-		bytecodes.add(new Bytecode.Invoke(owner, mangled, type,
-				Bytecode.InvokeMode.STATIC));
+		String mangled = nameMangle(c.name.name(), c.type(0));
+		JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
+		JvmType.Function type = convertFunType(c.type(0));
+		bytecodes.add(new Bytecode.Invoke(owner, mangled, type, Bytecode.InvokeMode.STATIC));
 
 		int[] targets = c.targets();
-		List<Type> returns = c.type().returns();
-		if(targets.length == 0 && !returns.isEmpty()) {
-			bytecodes.add(new Bytecode.Pop(convertUnderlyingType(c.type().returns().get(0))));
-		} else if(targets.length == 1){
+		List<Type> returns = c.type(0).returns();
+		if (targets.length == 0 && !returns.isEmpty()) {
+			bytecodes.add(new Bytecode.Pop(convertUnderlyingType(c.type(0).returns().get(0))));
+		} else if (targets.length == 1) {
 			bytecodes.add(new Bytecode.Store(targets[0], convertUnderlyingType(returns.get(0))));
-		} else if(targets.length > 1){
-			// Multiple return values are provided, and these will have been encoded into an object array.
-			decodeOperandArray(c.type().returns(),targets,bytecodes);
+		} else if (targets.length > 1) {
+			// Multiple return values are provided, and these will have been
+			// encoded into an object array.
+			decodeOperandArray(c.type(0).returns(), targets, bytecodes);
 		}		
 	}
 
-	private void translate(CodeBlock.Index index, Codes.IndirectInvoke c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-
-		Type.FunctionOrMethod ft = c.type();
+	private void translate(CodeBlock.Index index, Codes.IndirectInvoke c, int freeSlot, ArrayList<Bytecode> bytecodes) {
+		Type.FunctionOrMethod ft = c.type(0);
 		JvmType.Clazz owner = (JvmType.Clazz) convertUnderlyingType(ft);
-		bytecodes.add(new Bytecode.Load(c.reference(),
-				convertUnderlyingType(ft)));
-		encodeOperandArray(ft.params(),c.parameters(),bytecodes);
-		
-		JvmType.Function type = new JvmType.Function(JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT_ARRAY);
+		bytecodes.add(new Bytecode.Load(c.reference(), convertUnderlyingType(ft)));
+		encodeOperandArray(ft.params(), c.parameters(), bytecodes);
 
-		bytecodes.add(new Bytecode.Invoke(owner, "call", type,
-				Bytecode.InvokeMode.VIRTUAL));
+		JvmType.Function type = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
+
+		bytecodes.add(new Bytecode.Invoke(owner, "call", type, Bytecode.InvokeMode.VIRTUAL));
 
 		int[] targets = c.targets();
 		List<Type> returns = ft.returns();
@@ -1705,7 +1649,7 @@ private void translate(CodeBlock.Index index, Codes.IndirectInvoke c,
 			// handles the case of an invoke which returns a value that should
 			// be discarded.
 			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
-		} else if(targets.length == 1) {
+		} else if (targets.length == 1) {
 			// Only a single return value, which means it is passed directly as
 			// a return value rather then being encoded into an object array.
 			addReadConversion(returns.get(0), bytecodes);
@@ -1713,13 +1657,12 @@ private void translate(CodeBlock.Index index, Codes.IndirectInvoke c,
 		} else {
 			// Multiple return values, which must be encoded into an object
 			// array.
-			internalFailure("multiple returns not supported", filename, rootBlock.attribute(index, SourceLocation.class));
+			internalFailure("multiple returns not supported", filename,
+					rootBlock.attribute(index, SourceLocation.class));
 		}
 	}
 
-	
-	private void translate(Constant v, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	private void translate(Constant v, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		if (v instanceof Constant.Null) {
 			translate((Constant.Null) v, freeSlot, bytecodes);
 		} else if (v instanceof Constant.Bool) {
@@ -1743,13 +1686,11 @@ private void translate(Constant v, int freeSlot,
 		}
 	}
 
-	protected void translate(Constant.Null e, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	protected void translate(Constant.Null e, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.LoadConst(null));
 	}
 
-	protected void translate(Constant.Bool e, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	protected void translate(Constant.Bool e, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		if (e.value) {
 			bytecodes.add(new Bytecode.LoadConst(1));
 		} else {
@@ -1773,35 +1714,28 @@ protected void translate(Constant.Type e, int freeSlot,
 		}
 
 		bytecodes.add(new Bytecode.LoadConst(jout.toString()));
-		JvmType.Function ftype = new JvmType.Function(WHILEYTYPE,
-				JAVA_LANG_STRING);
-		bytecodes.add(new Bytecode.Invoke(WHILEYTYPE, "valueOf", ftype,
-				Bytecode.InvokeMode.STATIC));
+		JvmType.Function ftype = new JvmType.Function(WHILEYTYPE, JAVA_LANG_STRING);
+		bytecodes.add(new Bytecode.Invoke(WHILEYTYPE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 	}
 
-	protected void translate(Constant.Byte e, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	protected void translate(Constant.Byte e, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.LoadConst(e.value));
 		JvmType.Function ftype = new JvmType.Function(WHILEYBYTE, T_BYTE);
-		bytecodes.add(new Bytecode.Invoke(WHILEYBYTE, "valueOf", ftype,
-				Bytecode.InvokeMode.STATIC));
+		bytecodes.add(new Bytecode.Invoke(WHILEYBYTE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 	}
 
-	protected void translate(Constant.Integer e, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	protected void translate(Constant.Integer e, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		BigInteger num = e.value;
 
 		if (num.bitLength() < 32) {
 			bytecodes.add(new Bytecode.LoadConst(num.intValue()));
 			bytecodes.add(new Bytecode.Conversion(T_INT, T_LONG));
 			JvmType.Function ftype = new JvmType.Function(WHILEYINT, T_LONG);
-			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype,
-					Bytecode.InvokeMode.STATIC));
+			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 		} else if (num.bitLength() < 64) {
 			bytecodes.add(new Bytecode.LoadConst(num.longValue()));
 			JvmType.Function ftype = new JvmType.Function(WHILEYINT, T_LONG);
-			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype,
-					Bytecode.InvokeMode.STATIC));
+			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 		} else {
 			// in this context, we need to use a byte array to construct the
 			// integer object.
@@ -1820,14 +1754,12 @@ protected void translate(Constant.Integer e, int freeSlot,
 			}
 
 			JvmType.Function ftype = new JvmType.Function(T_VOID, bat);
-			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "<init>", ftype,
-					Bytecode.InvokeMode.SPECIAL));
+			bytecodes.add(new Bytecode.Invoke(WHILEYINT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 		}
 
 	}
 
-	protected void translate(Constant.Decimal e, int freeSlot,
-			ArrayList<Bytecode> bytecodes) {
+	protected void translate(Constant.Decimal e, int freeSlot, ArrayList<Bytecode> bytecodes) {
 		BigRational rat = new BigRational(e.value);
 		BigInteger den = rat.denominator();
 		BigInteger num = rat.numerator();
@@ -1836,13 +1768,11 @@ protected void translate(Constant.Decimal e, int freeSlot,
 			if (num.bitLength() < 32) {
 				bytecodes.add(new Bytecode.LoadConst(num.intValue()));
 				JvmType.Function ftype = new JvmType.Function(WHILEYRAT, T_INT);
-				bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype,
-						Bytecode.InvokeMode.STATIC));
+				bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 			} else if (num.bitLength() < 64) {
 				bytecodes.add(new Bytecode.LoadConst(num.longValue()));
 				JvmType.Function ftype = new JvmType.Function(WHILEYRAT, T_LONG);
-				bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype,
-						Bytecode.InvokeMode.STATIC));
+				bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 			} else {
 				// in this context, we need to use a byte array to construct the
 				// integer object.
@@ -1861,23 +1791,18 @@ protected void translate(Constant.Decimal e, int freeSlot,
 				}
 
 				JvmType.Function ftype = new JvmType.Function(T_VOID, bat);
-				bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "<init>", ftype,
-						Bytecode.InvokeMode.SPECIAL));
+				bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 			}
 		} else if (num.bitLength() < 32 && den.bitLength() < 32) {
 			bytecodes.add(new Bytecode.LoadConst(num.intValue()));
 			bytecodes.add(new Bytecode.LoadConst(den.intValue()));
-			JvmType.Function ftype = new JvmType.Function(WHILEYRAT, T_INT,
-					T_INT);
-			bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype,
-					Bytecode.InvokeMode.STATIC));
+			JvmType.Function ftype = new JvmType.Function(WHILEYRAT, T_INT, T_INT);
+			bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 		} else if (num.bitLength() < 64 && den.bitLength() < 64) {
 			bytecodes.add(new Bytecode.LoadConst(num.longValue()));
 			bytecodes.add(new Bytecode.LoadConst(den.longValue()));
-			JvmType.Function ftype = new JvmType.Function(WHILEYRAT, T_LONG,
-					T_LONG);
-			bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype,
-					Bytecode.InvokeMode.STATIC));
+			JvmType.Function ftype = new JvmType.Function(WHILEYRAT, T_LONG, T_LONG);
+			bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
 		} else {
 			// First, do numerator bytes
 			byte[] bytes = num.toByteArray();
@@ -1907,35 +1832,31 @@ protected void translate(Constant.Decimal e, int freeSlot,
 
 			// Finally, construct BigRational object
 			JvmType.Function ftype = new JvmType.Function(T_VOID, bat, bat);
-			bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "<init>", ftype,
-					Bytecode.InvokeMode.SPECIAL));
+			bytecodes.add(new Bytecode.Invoke(WHILEYRAT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 		}
 	}
 
-	protected void translate(Constant.Array lv, int freeSlot,
-			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
+	protected void translate(Constant.Array lv, int freeSlot, ArrayList<ClassFile> lambdas,
+			ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.New(WHILEYARRAY));
 		bytecodes.add(new Bytecode.Dup(WHILEYARRAY));
 		bytecodes.add(new Bytecode.LoadConst(lv.values.size()));
 		JvmType.Function ftype = new JvmType.Function(T_VOID, T_INT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype,
-				Bytecode.InvokeMode.SPECIAL));
+		bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 
 		ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT);
 		for (Constant e : lv.values) {
 			bytecodes.add(new Bytecode.Dup(WHILEYARRAY));
 			translate(e, freeSlot, bytecodes);
 			addWriteConversion(e.type(), bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "add", ftype,
-					Bytecode.InvokeMode.VIRTUAL));
+			bytecodes.add(new Bytecode.Invoke(WHILEYARRAY, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
 			bytecodes.add(new Bytecode.Pop(T_BOOL));
 		}
 	}
 
-	protected void translate(Constant.Record expr, int freeSlot,
-			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
-		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+	protected void translate(Constant.Record expr, int freeSlot, ArrayList<ClassFile> lambdas,
+			ArrayList<Bytecode> bytecodes) {
+		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
 		construct(WHILEYRECORD, freeSlot, bytecodes);
 		for (Map.Entry<String, Constant> e : expr.values.entrySet()) {
 			Type et = e.getValue().type();
@@ -1943,14 +1864,13 @@ protected void translate(Constant.Record expr, int freeSlot,
 			bytecodes.add(new Bytecode.LoadConst(e.getKey()));
 			translate(e.getValue(), freeSlot, bytecodes);
 			addWriteConversion(et, bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype,
-					Bytecode.InvokeMode.VIRTUAL));
+			bytecodes.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.VIRTUAL));
 			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
 		}
 	}
-	
-	protected void translate(Constant.Lambda c, int freeSlot,
-			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
+
+	protected void translate(Constant.Lambda c, int freeSlot, ArrayList<ClassFile> lambdas,
+			ArrayList<Bytecode> bytecodes) {
 
 		// First, build and register lambda class which calls the given function
 		// or method. This class will extend class wyjc.runtime.WyLambda.
@@ -1960,18 +1880,16 @@ protected void translate(Constant.Lambda c, int freeSlot,
 		// Second, create and duplicate new lambda object. This will then stay
 		// on the stack (whilst the parameters are constructed) until the
 		// object's constructor is called.
-		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner
-				.lastComponent().first(), Integer.toString(lambda_id));
+		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner.lastComponent().first(),
+				Integer.toString(lambda_id));
 
 		bytecodes.add(new Bytecode.New(lambdaClassType));
 		bytecodes.add(new Bytecode.Dup(lambdaClassType));
 
 		// Third, invoke lambda class constructor
-		JvmType.Function ftype = new JvmType.Function(T_VOID,
-				JAVA_LANG_OBJECT_ARRAY);
+		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_OBJECT_ARRAY);
 		bytecodes.add(new Bytecode.LoadConst(null));
-		bytecodes.add(new Bytecode.Invoke(lambdaClassType, "<init>", ftype,
-				Bytecode.InvokeMode.SPECIAL));
+		bytecodes.add(new Bytecode.Invoke(lambdaClassType, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
 	}
 
 	/**
@@ -1985,51 +1903,44 @@ protected void translate(Constant.Lambda c, int freeSlot,
 	 *            Type of function or method which this lambda should invoke.
 	 * @return
 	 */
-	protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type,
-			int id) {
+	protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type, int id) {
 		// === (1) Determine the fully qualified type of the lambda class ===
 
 		// start with fully qualified type of this class.
-		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner
-				.lastComponent().first(), Integer.toString(id));
+		JvmType.Clazz lambdaClassType = new JvmType.Clazz(owner.pkg(), owner.lastComponent().first(),
+				Integer.toString(id));
 
 		// === (2) Construct an empty class ===
 		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
 		modifiers.add(Modifier.ACC_PUBLIC);
 		modifiers.add(Modifier.ACC_FINAL);
-		ClassFile cf = new ClassFile(CLASS_VERSION, lambdaClassType,
-				WHILEYLAMBDA, new ArrayList<JvmType.Clazz>(), modifiers);
+		ClassFile cf = new ClassFile(CLASS_VERSION, lambdaClassType, WHILEYLAMBDA, new ArrayList<JvmType.Clazz>(),
+				modifiers);
 
 		// === (3) Add constructor ===
 		modifiers = new ArrayList<Modifier>();
 		modifiers.add(Modifier.ACC_PUBLIC);
-		JvmType.Function constructorType = new JvmType.Function(
-				JvmTypes.T_VOID, JAVA_LANG_OBJECT_ARRAY);
+		JvmType.Function constructorType = new JvmType.Function(JvmTypes.T_VOID, JAVA_LANG_OBJECT_ARRAY);
 		// Create constructor method
-		ClassFile.Method constructor = new ClassFile.Method("<init>",
-				constructorType, modifiers);
+		ClassFile.Method constructor = new ClassFile.Method("<init>", constructorType, modifiers);
 		cf.methods().add(constructor);
 		// Create body of constructor
 		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
 		bytecodes.add(new Bytecode.Load(0, lambdaClassType));
 		bytecodes.add(new Bytecode.Load(1, JAVA_LANG_OBJECT_ARRAY));
-		bytecodes.add(new Bytecode.Invoke(WHILEYLAMBDA, "<init>",
-				constructorType, Bytecode.InvokeMode.SPECIAL));
+		bytecodes.add(new Bytecode.Invoke(WHILEYLAMBDA, "<init>", constructorType, Bytecode.InvokeMode.SPECIAL));
 		bytecodes.add(new Bytecode.Return(null));
 		// Add code attribute to constructor
-		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes,
-				new ArrayList<Handler>(), constructor);
+		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), constructor);
 		constructor.attributes().add(code);
 
 		// === (4) Add implementation of WyLambda.call(Object[]) ===
 		modifiers = new ArrayList<Modifier>();
 		modifiers.add(Modifier.ACC_PUBLIC);
 		modifiers.add(Modifier.ACC_FINAL);
-		JvmType.Function callFnType = new JvmType.Function(
-				JvmTypes.JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
+		JvmType.Function callFnType = new JvmType.Function(JvmTypes.JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
 		// Create constructor method
-		ClassFile.Method callFn = new ClassFile.Method("call", callFnType,
-				modifiers);
+		ClassFile.Method callFn = new ClassFile.Method("call", callFnType, modifiers);
 		cf.methods().add(callFn);
 		// Create body of call method
 		bytecodes = new ArrayList<Bytecode>();
@@ -2037,8 +1948,7 @@ protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type,
 		bytecodes.add(new Bytecode.Load(0, lambdaClassType));
 		bytecodes.add(new Bytecode.Load(1, JAVA_LANG_OBJECT_ARRAY));
 		bytecodes.add(new Bytecode.Invoke(WHILEYLAMBDA, "bindParameters",
-				new JvmType.Function(JAVA_LANG_OBJECT_ARRAY,
-						JAVA_LANG_OBJECT_ARRAY), Bytecode.InvokeMode.VIRTUAL));
+				new JvmType.Function(JAVA_LANG_OBJECT_ARRAY, JAVA_LANG_OBJECT_ARRAY), Bytecode.InvokeMode.VIRTUAL));
 		bytecodes.add(new Bytecode.Store(1, JAVA_LANG_OBJECT_ARRAY));
 		// Load parameters onto stack
 		List<Type> type_params = type.params();
@@ -2051,11 +1961,9 @@ protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type,
 
 		Path.ID mid = name.module();
 		String mangled = nameMangle(name.name(), type);
-		JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString()
-				.replace('/', '.'), mid.last());
+		JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
 		JvmType.Function fnType = convertFunType(type);
-		bytecodes.add(new Bytecode.Invoke(owner, mangled, fnType,
-				Bytecode.InvokeMode.STATIC));
+		bytecodes.add(new Bytecode.Invoke(owner, mangled, fnType, Bytecode.InvokeMode.STATIC));
 		if (type.returns().isEmpty()) {
 			// Called function doesn't return anything, but we have to.
 			// Therefore, push on dummy null value.
@@ -2067,16 +1975,14 @@ protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type,
 		bytecodes.add(new Bytecode.Return(JAVA_LANG_OBJECT));
 
 		// Add code attribute to call method
-		code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(),
-				callFn);
+		code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), callFn);
 		callFn.attributes().add(code);
 
 		// Done
 		return cf;
 	}
 
-	protected void addCoercion(Type from, Type to, int freeSlot,
-			HashMap<JvmConstant, Integer> constants,
+	protected void addCoercion(Type from, Type to, int freeSlot, HashMap<JvmConstant, Integer> constants,
 			ArrayList<Bytecode> bytecodes) {
 
 		// First, deal with coercions which require a change of representation
@@ -2096,10 +2002,8 @@ protected void addCoercion(Type from, Type to, int freeSlot,
 			// ok, it's a harder case so we use an explicit coercion function
 			int id = JvmCoercion.get(from, to, constants);
 			String name = "coercion$" + id;
-			JvmType.Function ft = new JvmType.Function(
-					convertUnderlyingType(to), convertUnderlyingType(from));
-			bytecodes.add(new Bytecode.Invoke(owner, name, ft,
-					Bytecode.InvokeMode.STATIC));
+			JvmType.Function ft = new JvmType.Function(convertUnderlyingType(to), convertUnderlyingType(from));
+			bytecodes.add(new Bytecode.Invoke(owner, name, ft, Bytecode.InvokeMode.STATIC));
 		}
 	}
 
@@ -2389,6 +2293,10 @@ private void translateLoopEnd(ArrayList<Bytecode> bytecodes,
 		bytecodes.add(new Bytecode.Label(labels.third()));
 	}
 
+	private void encodeOperandArray(List<Type> types, int[] operands, ArrayList<Bytecode> bytecodes) {
+		encodeOperandArray(types.toArray(new Type[types.size()]),operands,bytecodes);
+	}
+	
 	/**
 	 * Create an Object[] array from a list of operands. This involves
 	 * appropriately coercing primitives as necessary.
@@ -2397,12 +2305,12 @@ private void translateLoopEnd(ArrayList<Bytecode> bytecodes,
 	 * @param operands
 	 * @param bytecodes
 	 */
-	private void encodeOperandArray(List<Type> types, int[] operands, ArrayList<Bytecode> bytecodes) {
+	private void encodeOperandArray(Type[] types, int[] operands, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.LoadConst(operands.length));
 		bytecodes.add(new Bytecode.New(JAVA_LANG_OBJECT_ARRAY));
 		for (int i = 0; i != operands.length; ++i) {
 			int register = operands[i];
-			Type type = types.get(i);
+			Type type = types[i];
 			JvmType jvmType = convertUnderlyingType(type);
 			bytecodes.add(new Bytecode.Dup(JAVA_LANG_OBJECT_ARRAY));
 			bytecodes.add(new Bytecode.LoadConst(i));
