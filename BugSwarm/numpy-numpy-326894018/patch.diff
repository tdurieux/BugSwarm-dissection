diff --git a/doc/release/1.15.0-notes.rst b/doc/release/1.15.0-notes.rst
index 16a44113cae..d7aba216fbc 100644
--- a/doc/release/1.15.0-notes.rst
+++ b/doc/release/1.15.0-notes.rst
@@ -95,6 +95,13 @@ As a result, ``np.ma.mr_`` now works correctly on the ``masked`` constant.
 This means it takes all the same arguments, making more code written for
 ndarray work for masked array too.
 
+Different C integer types of the same size have unique names
+------------------------------------------------------------
+Depending on platform, two of ``np.intc``, ``np.int_``, and ``np.longlong``
+would previously appear indistinguishable in the ``repr`` of dtypes, despite
+having different ``dtype`` attributes. These now always print with a unique
+name.
+
 Enable AVX2/AVX512 at compile time
 -------------------------------------------------------------
 Change to simd.inc.src to use AVX2 or AVX512 at compile time. Solving the gap
diff --git a/numpy/core/code_generators/generate_umath.py b/numpy/core/code_generators/generate_umath.py
index 9470e882aae..f9bf823c2f6 100644
--- a/numpy/core/code_generators/generate_umath.py
+++ b/numpy/core/code_generators/generate_umath.py
@@ -84,8 +84,9 @@ def TD(types, f=None, astype=None, in_=None, out=None, simd=None):
     if f is not None:
         if isinstance(f, str):
             func_data = build_func_data(types, f)
+        elif len(f) != len(types):
+            raise ValueError("Number of types and f do not match")
         else:
-            assert len(f) == len(types)
             func_data = f
     else:
         func_data = (None,) * len(types)
@@ -93,10 +94,14 @@ def TD(types, f=None, astype=None, in_=None, out=None, simd=None):
         in_ = (in_,) * len(types)
     elif in_ is None:
         in_ = (None,) * len(types)
+    elif len(in_) != len(types):
+        raise ValueError("Number of types and inputs do not match")
     if isinstance(out, str):
         out = (out,) * len(types)
     elif out is None:
         out = (None,) * len(types)
+    elif len(out) != len(types):
+        raise ValueError("Number of types and outputs do not match")
     tds = []
     for t, fd, i, o in zip(types, func_data, in_, out):
         # [(simd-name, list of types)]
diff --git a/numpy/core/numerictypes.py b/numpy/core/numerictypes.py
index aa91ecb4405..4ccc724b7cf 100644
--- a/numpy/core/numerictypes.py
+++ b/numpy/core/numerictypes.py
@@ -297,50 +297,60 @@ def _add_types():
             allTypes[name] = info
 _add_types()
 
+# This is the priority order used to assign the bit-sized NPY_INTxx names, which
+# must match the order in npy_common.h in order for NPY_INTxx and np.intxx to be
+# consistent.
+# If two C types have the same size, then the earliest one in this list is used
+# as the sized name.
+_integer_ctypes = ['LONG', 'LONGLONG', 'INT', 'SHORT', 'BYTE']
+
 def _add_aliases():
     for type_name, info in typeinfo.items():
         if isinstance(info, type):
             continue
+
+        # these are handled by _add_integer_aliases
+        if type_name in _integer_ctypes or type_name[1:] in _integer_ctypes:
+            continue
         name = english_lower(type_name)
 
         # insert bit-width version for this class (if relevant)
         base, bit, char = bitname(info.type)
-        if base[-3:] == 'int' or char[0] in 'ui':
-            continue
-        if base != '':
-            myname = "%s%d" % (base, bit)
-            if (name not in ('longdouble', 'clongdouble') or
-                   myname not in allTypes):
-                base_capitalize = english_capitalize(base)
-                if base == 'complex':
-                    na_name = '%s%d' % (base_capitalize, bit//2)
-                elif base == 'bool':
-                    na_name = base_capitalize
-                else:
-                    na_name = "%s%d" % (base_capitalize, bit)
 
-                allTypes[myname] = info.type
-
-                # add mapping for both the bit name and the numarray name
-                sctypeDict[myname] = info.type
-                sctypeDict[na_name] = info.type
-
-                # add forward, reverse, and string mapping to numarray
-                sctypeNA[na_name] = info.type
-                sctypeNA[info.type] = na_name
-                sctypeNA[info.char] = na_name
-        if char != '':
-            sctypeDict[char] = info.type
-            sctypeNA[char] = na_name
+        # used to be conditional on these, but they seem to always be set anyway
+        assert base != ''
+        assert char != ''
+
+        myname = "%s%d" % (base, bit)
+        if (name not in ('longdouble', 'clongdouble') or
+               myname not in allTypes):
+            base_capitalize = english_capitalize(base)
+            if base == 'complex':
+                na_name = '%s%d' % (base_capitalize, bit//2)
+            elif base == 'bool':
+                na_name = base_capitalize
+            else:
+                na_name = "%s%d" % (base_capitalize, bit)
+
+            allTypes[myname] = info.type
+
+            # add mapping for both the bit name and the numarray name
+            sctypeDict[myname] = info.type
+            sctypeDict[na_name] = info.type
+
+            # add forward, reverse, and string mapping to numarray
+            sctypeNA[na_name] = info.type
+            sctypeNA[info.type] = na_name
+            sctypeNA[info.char] = na_name
+
+        # note: char and info.char are not always the same
+        sctypeDict[char] = info.type
+        sctypeNA[char] = na_name
 _add_aliases()
 
-# Integers are handled so that the int32 and int64 types should agree
-# exactly with NPY_INT32, NPY_INT64. We need to enforce the same checking
-# as is done in arrayobject.h where the order of getting a bit-width match
-# is long, longlong, int, short, char.
 def _add_integer_aliases():
-    _ctypes = ['LONG', 'LONGLONG', 'INT', 'SHORT', 'BYTE']
-    for ctype in _ctypes:
+    # reverse the list so that the first item takes priority
+    for ctype in _integer_ctypes[::-1]:
         i_info = typeinfo[ctype]
         u_info = typeinfo['U'+ctype]
         bits = i_info.bits  # same for both
@@ -348,13 +358,14 @@ def _add_integer_aliases():
         for info, charname, intname, Intname in [
                 (i_info,'i%d' % (bits//8,), 'int%d' % bits, 'Int%d' % bits),
                 (u_info,'u%d' % (bits//8,), 'uint%d' % bits, 'UInt%d' % bits)]:
-            if intname not in allTypes.keys():
-                allTypes[intname] = info.type
-                sctypeDict[intname] = info.type
-                sctypeDict[Intname] = info.type
-                sctypeDict[charname] = info.type
-                sctypeNA[Intname] = info.type
-                sctypeNA[charname] = info.type
+            allTypes[intname] = info.type
+
+            sctypeDict[intname] = info.type
+            sctypeDict[Intname] = info.type
+            sctypeDict[charname] = info.type
+
+            sctypeNA[Intname] = info.type
+            sctypeNA[charname] = info.type
             sctypeNA[info.type] = Intname
             sctypeNA[info.char] = Intname
 _add_integer_aliases()
diff --git a/numpy/core/src/multiarray/scalartypes.c.src b/numpy/core/src/multiarray/scalartypes.c.src
index dca6e3840d9..16ceb008cad 100644
--- a/numpy/core/src/multiarray/scalartypes.c.src
+++ b/numpy/core/src/multiarray/scalartypes.c.src
@@ -4369,6 +4369,28 @@ initialize_numeric_types(void)
 
     PyArrayIter_Type.tp_iter = PyObject_SelfIter;
     PyArrayMapIter_Type.tp_iter = PyObject_SelfIter;
+
+    /*
+    Give types different names when they are the same size (gh-9799). np.intX
+    always refers to the first int of that size in the sequence
+    ['LONG', 'LONGLONG', 'INT', 'SHORT', 'BYTE']
+    */
+#if (NPY_SIZEOF_BYTE == NPY_SIZEOF_SHORT)
+    PyByteArrType_Type.tp_name = "numpy.byte";
+    PyUByteArrType_Type.tp_name = "numpy.ubyte";
+#endif
+#if (NPY_SIZEOF_SHORT == NPY_SIZEOF_INT)
+    PyShortArrType_Type.tp_name = "numpy.short";
+    PyUShortArrType_Type.tp_name = "numpy.ushort";
+#endif
+#if (NPY_SIZEOF_INT == NPY_SIZEOF_LONG)
+    PyIntArrType_Type.tp_name = "numpy.intc";
+    PyUIntArrType_Type.tp_name = "numpy.uintc";
+#endif
+#if (NPY_SIZEOF_LONGLONG == NPY_SIZEOF_LONG)
+    PyLongLongArrType_Type.tp_name = "numpy.longlong";
+    PyULongLongArrType_Type.tp_name = "numpy.ulonglong";
+#endif
 }
 
 typedef struct {
diff --git a/numpy/core/tests/test_numerictypes.py b/numpy/core/tests/test_numerictypes.py
index 8831cd1bb94..b753dba527b 100644
--- a/numpy/core/tests/test_numerictypes.py
+++ b/numpy/core/tests/test_numerictypes.py
@@ -409,5 +409,26 @@ def test_sibling_class(self):
             assert_(not np.issubdtype(w1(np.float32), w2(np.float64)))
             assert_(not np.issubdtype(w1(np.float64), w2(np.float32)))
 
+
+def test_integer_type_names():
+    # gh-9799
+    int_types = [
+        np.byte, np.short, np.intc, np.int_, np.longlong,
+        np.ubyte, np.ushort, np.uintc, np.uint, np.ulonglong
+    ]
+
+    # none of the above may be aliases for each other
+    int_ids = [id(t) for t in int_types]
+    assert_equal(len(set(int_ids)), len(int_ids))
+
+    # names must be unique
+    int_names = [t.__name__ for t in int_types]
+    assert_equal(len(set(int_names)), len(int_names))
+
+    # names should actually correspond to where the type is
+    for t in int_types:
+        assert getattr(np, t.__name__) is t
+
+
 if __name__ == "__main__":
     run_module_suite()
diff --git a/numpy/core/tests/test_scalarmath.py b/numpy/core/tests/test_scalarmath.py
index cb2cd16d4ef..069d592b3c7 100644
--- a/numpy/core/tests/test_scalarmath.py
+++ b/numpy/core/tests/test_scalarmath.py
@@ -135,7 +135,7 @@ def test_integers_to_negative_integer_power(self):
         # 1 ** -1 possible special case
         base = [np.array(1, dt)[()] for dt in 'bhilqBHILQ']
         for i1, i2 in itertools.product(base, exp):
-            if i1.dtype.name != 'uint64':
+            if i1.dtype != np.uint64:
                 assert_raises(ValueError, operator.pow, i1, i2)
             else:
                 res = operator.pow(i1, i2)
@@ -145,7 +145,7 @@ def test_integers_to_negative_integer_power(self):
         # -1 ** -1 possible special case
         base = [np.array(-1, dt)[()] for dt in 'bhilq']
         for i1, i2 in itertools.product(base, exp):
-            if i1.dtype.name != 'uint64':
+            if i1.dtype != np.uint64:
                 assert_raises(ValueError, operator.pow, i1, i2)
             else:
                 res = operator.pow(i1, i2)
@@ -155,7 +155,7 @@ def test_integers_to_negative_integer_power(self):
         # 2 ** -1 perhaps generic
         base = [np.array(2, dt)[()] for dt in 'bhilqBHILQ']
         for i1, i2 in itertools.product(base, exp):
-            if i1.dtype.name != 'uint64':
+            if i1.dtype != np.uint64:
                 assert_raises(ValueError, operator.pow, i1, i2)
             else:
                 res = operator.pow(i1, i2)
diff --git a/numpy/random/mtrand/mtrand.pyx b/numpy/random/mtrand/mtrand.pyx
index 501c1e5b315..0aa3beae1ad 100644
--- a/numpy/random/mtrand/mtrand.pyx
+++ b/numpy/random/mtrand/mtrand.pyx
@@ -573,21 +573,21 @@ def _shape_from_size(size, d):
            shape = tuple(size) + (d,)
     return shape
 
-# Look up table for randint functions keyed by type name. The stored data
-# is a tuple (lbnd, ubnd, func), where lbnd is the smallest value for the
-# type, ubnd is one greater than the largest value, and func is the
+# Look up table for randint functions keyed by dtype.
+# The stored data is a tuple (lbnd, ubnd, func), where lbnd is the smallest
+# value for the type, ubnd is one greater than the largest value, and func is the
 # function to call.
 _randint_type = {
-    'bool': (0, 2, _rand_bool),
-    'int8': (-2**7, 2**7, _rand_int8),
-    'int16': (-2**15, 2**15, _rand_int16),
-    'int32': (-2**31, 2**31, _rand_int32),
-    'int64': (-2**63, 2**63, _rand_int64),
-    'uint8': (0, 2**8, _rand_uint8),
-    'uint16': (0, 2**16, _rand_uint16),
-    'uint32': (0, 2**32, _rand_uint32),
-    'uint64': (0, 2**64, _rand_uint64)
-    }
+    np.dtype(np.bool_): (0, 2, _rand_bool),
+    np.dtype(np.int8): (-2**7, 2**7, _rand_int8),
+    np.dtype(np.int16): (-2**15, 2**15, _rand_int16),
+    np.dtype(np.int32): (-2**31, 2**31, _rand_int32),
+    np.dtype(np.int64): (-2**63, 2**63, _rand_int64),
+    np.dtype(np.uint8): (0, 2**8, _rand_uint8),
+    np.dtype(np.uint16): (0, 2**16, _rand_uint16),
+    np.dtype(np.uint32): (0, 2**32, _rand_uint32),
+    np.dtype(np.uint64): (0, 2**64, _rand_uint64)
+}
 
 
 cdef class RandomState:
@@ -969,13 +969,12 @@ cdef class RandomState:
             high = low
             low = 0
 
-        # '_randint_type' is defined in
-        # 'generate_randint_helpers.py'
-        key = np.dtype(dtype).name
-        if key not in _randint_type:
-            raise TypeError('Unsupported dtype "%s" for randint' % key)
-
-        lowbnd, highbnd, randfunc = _randint_type[key]
+        raw_dtype = dtype
+        dtype = np.dtype(dtype)
+        try:
+            lowbnd, highbnd, randfunc = _randint_type[dtype]
+        except KeyError:
+            raise TypeError('Unsupported dtype "%s" for randint' % dtype)
 
         # TODO: Do not cast these inputs to Python int
         #
@@ -986,20 +985,20 @@ cdef class RandomState:
         ihigh = int(high)
 
         if ilow < lowbnd:
-            raise ValueError("low is out of bounds for %s" % (key,))
+            raise ValueError("low is out of bounds for %s" % dtype)
         if ihigh > highbnd:
-            raise ValueError("high is out of bounds for %s" % (key,))
+            raise ValueError("high is out of bounds for %s" % dtype)
         if ilow >= ihigh:
             raise ValueError("low >= high")
 
         with self.lock:
             ret = randfunc(ilow, ihigh - 1, size, self.state_address)
 
-            if size is None:
-                if dtype in (np.bool, np.int, np.long):
-                    return dtype(ret)
+        # back-compat: keep python scalars when a python type is passed
+        if size is None and raw_dtype in (bool, int, np.long):
+            return raw_dtype(ret)
 
-            return ret
+        return ret
 
     def bytes(self, npy_intp length):
         """
