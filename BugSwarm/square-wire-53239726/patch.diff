diff --git a/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java b/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
index 3118b4b5d8..91c8f40cae 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
@@ -251,6 +251,7 @@ private void emitAll(JavaWriter writer, MessageType messageType, Map<String, ?>
     emitDocumentation(writer, messageType.getDocumentation());
     writer.beginType(name, "class", modifiers,
         compiler.hasExtensions(messageType) ? "ExtendableMessage<" + name + ">" : "Message");
+    writer.emitField("long", "serialVersionUID", EnumSet.of(PRIVATE, STATIC, FINAL), "0L");
 
     emitMessageOptions(writer, optionsMap);
     if (compiler.shouldEmitOptions()) {
diff --git a/wire-runtime/src/main/java/com/squareup/wire/ExtendableMessage.java b/wire-runtime/src/main/java/com/squareup/wire/ExtendableMessage.java
index be0a04d2bb..6c873b21f6 100755
--- a/wire-runtime/src/main/java/com/squareup/wire/ExtendableMessage.java
+++ b/wire-runtime/src/main/java/com/squareup/wire/ExtendableMessage.java
@@ -24,6 +24,7 @@
  * @param <T> the message type being extended.
  */
 public abstract class ExtendableMessage<T extends ExtendableMessage<?>> extends Message {
+  private static final long serialVersionUID = 0L;
 
   @SuppressWarnings("unchecked")
   transient ExtensionMap<T> extensionMap; // Null if empty.
diff --git a/wire-runtime/src/main/java/com/squareup/wire/Message.java b/wire-runtime/src/main/java/com/squareup/wire/Message.java
index db1e898ad8..a429720f2c 100755
--- a/wire-runtime/src/main/java/com/squareup/wire/Message.java
+++ b/wire-runtime/src/main/java/com/squareup/wire/Message.java
@@ -269,7 +269,7 @@ protected boolean equals(List<?> a, List<?> b) {
     return WIRE.messageAdapter((Class<Message>) getClass()).toString(this);
   }
 
-  protected final Object writeReplace() throws ObjectStreamException {
+  private Object writeReplace() throws ObjectStreamException {
     return new MessageSerializedForm(this, getClass());
   }
 
diff --git a/wire-runtime/src/main/java/com/squareup/wire/MessageSerializedForm.java b/wire-runtime/src/main/java/com/squareup/wire/MessageSerializedForm.java
index bd616f34ca..131399a86e 100755
--- a/wire-runtime/src/main/java/com/squareup/wire/MessageSerializedForm.java
+++ b/wire-runtime/src/main/java/com/squareup/wire/MessageSerializedForm.java
@@ -21,6 +21,8 @@
 import java.io.StreamCorruptedException;
 
 final class MessageSerializedForm implements Serializable {
+  private static final long serialVersionUID = 0L;
+
   private final byte[] bytes;
   private final Class<? extends Message> messageClass;
 
diff --git a/wire-runtime/src/test/java/com/google/protobuf/DescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/DescriptorProto.java
new file mode 100755
index 0000000000..203a3953af
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/DescriptorProto.java
@@ -0,0 +1,252 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.INT32;
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * Describes a message type.
+ */
+public final class DescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final String DEFAULT_DOC = "";
+  public static final List<FieldDescriptorProto> DEFAULT_FIELD = Collections.emptyList();
+  public static final List<FieldDescriptorProto> DEFAULT_EXTENSION = Collections.emptyList();
+  public static final List<DescriptorProto> DEFAULT_NESTED_TYPE = Collections.emptyList();
+  public static final List<EnumDescriptorProto> DEFAULT_ENUM_TYPE = Collections.emptyList();
+  public static final List<ExtensionRange> DEFAULT_EXTENSION_RANGE = Collections.emptyList();
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  @ProtoField(tag = 8, type = STRING)
+  public final String doc;
+
+  /**
+   * Doc string for generated code.
+   */
+  @ProtoField(tag = 2, label = REPEATED, messageType = FieldDescriptorProto.class)
+  public final List<FieldDescriptorProto> field;
+
+  @ProtoField(tag = 6, label = REPEATED, messageType = FieldDescriptorProto.class)
+  public final List<FieldDescriptorProto> extension;
+
+  @ProtoField(tag = 3, label = REPEATED, messageType = DescriptorProto.class)
+  public final List<DescriptorProto> nested_type;
+
+  @ProtoField(tag = 4, label = REPEATED, messageType = EnumDescriptorProto.class)
+  public final List<EnumDescriptorProto> enum_type;
+
+  @ProtoField(tag = 5, label = REPEATED, messageType = ExtensionRange.class)
+  public final List<ExtensionRange> extension_range;
+
+  @ProtoField(tag = 7)
+  public final MessageOptions options;
+
+  public DescriptorProto(String name, String doc, List<FieldDescriptorProto> field, List<FieldDescriptorProto> extension, List<DescriptorProto> nested_type, List<EnumDescriptorProto> enum_type, List<ExtensionRange> extension_range, MessageOptions options) {
+    this.name = name;
+    this.doc = doc;
+    this.field = immutableCopyOf(field);
+    this.extension = immutableCopyOf(extension);
+    this.nested_type = immutableCopyOf(nested_type);
+    this.enum_type = immutableCopyOf(enum_type);
+    this.extension_range = immutableCopyOf(extension_range);
+    this.options = options;
+  }
+
+  private DescriptorProto(Builder builder) {
+    this(builder.name, builder.doc, builder.field, builder.extension, builder.nested_type, builder.enum_type, builder.extension_range, builder.options);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof DescriptorProto)) return false;
+    DescriptorProto o = (DescriptorProto) other;
+    return equals(name, o.name)
+        && equals(doc, o.doc)
+        && equals(field, o.field)
+        && equals(extension, o.extension)
+        && equals(nested_type, o.nested_type)
+        && equals(enum_type, o.enum_type)
+        && equals(extension_range, o.extension_range)
+        && equals(options, o.options);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (doc != null ? doc.hashCode() : 0);
+      result = result * 37 + (field != null ? field.hashCode() : 1);
+      result = result * 37 + (extension != null ? extension.hashCode() : 1);
+      result = result * 37 + (nested_type != null ? nested_type.hashCode() : 1);
+      result = result * 37 + (enum_type != null ? enum_type.hashCode() : 1);
+      result = result * 37 + (extension_range != null ? extension_range.hashCode() : 1);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<DescriptorProto> {
+
+    public String name;
+    public String doc;
+    public List<FieldDescriptorProto> field;
+    public List<FieldDescriptorProto> extension;
+    public List<DescriptorProto> nested_type;
+    public List<EnumDescriptorProto> enum_type;
+    public List<ExtensionRange> extension_range;
+    public MessageOptions options;
+
+    public Builder() {
+    }
+
+    public Builder(DescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.doc = message.doc;
+      this.field = copyOf(message.field);
+      this.extension = copyOf(message.extension);
+      this.nested_type = copyOf(message.nested_type);
+      this.enum_type = copyOf(message.enum_type);
+      this.extension_range = copyOf(message.extension_range);
+      this.options = message.options;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder doc(String doc) {
+      this.doc = doc;
+      return this;
+    }
+
+    /**
+     * Doc string for generated code.
+     */
+    public Builder field(List<FieldDescriptorProto> field) {
+      this.field = checkForNulls(field);
+      return this;
+    }
+
+    public Builder extension(List<FieldDescriptorProto> extension) {
+      this.extension = checkForNulls(extension);
+      return this;
+    }
+
+    public Builder nested_type(List<DescriptorProto> nested_type) {
+      this.nested_type = checkForNulls(nested_type);
+      return this;
+    }
+
+    public Builder enum_type(List<EnumDescriptorProto> enum_type) {
+      this.enum_type = checkForNulls(enum_type);
+      return this;
+    }
+
+    public Builder extension_range(List<ExtensionRange> extension_range) {
+      this.extension_range = checkForNulls(extension_range);
+      return this;
+    }
+
+    public Builder options(MessageOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    @Override
+    public DescriptorProto build() {
+      return new DescriptorProto(this);
+    }
+  }
+
+  public static final class ExtensionRange extends Message {
+    private static final long serialVersionUID = 0L;
+
+    public static final Integer DEFAULT_START = 0;
+    public static final Integer DEFAULT_END = 0;
+
+    @ProtoField(tag = 1, type = INT32)
+    public final Integer start;
+
+    @ProtoField(tag = 2, type = INT32)
+    public final Integer end;
+
+    public ExtensionRange(Integer start, Integer end) {
+      this.start = start;
+      this.end = end;
+    }
+
+    private ExtensionRange(Builder builder) {
+      this(builder.start, builder.end);
+      setBuilder(builder);
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      if (other == this) return true;
+      if (!(other instanceof ExtensionRange)) return false;
+      ExtensionRange o = (ExtensionRange) other;
+      return equals(start, o.start)
+          && equals(end, o.end);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = hashCode;
+      if (result == 0) {
+        result = start != null ? start.hashCode() : 0;
+        result = result * 37 + (end != null ? end.hashCode() : 0);
+        hashCode = result;
+      }
+      return result;
+    }
+
+    public static final class Builder extends Message.Builder<ExtensionRange> {
+
+      public Integer start;
+      public Integer end;
+
+      public Builder() {
+      }
+
+      public Builder(ExtensionRange message) {
+        super(message);
+        if (message == null) return;
+        this.start = message.start;
+        this.end = message.end;
+      }
+
+      public Builder start(Integer start) {
+        this.start = start;
+        return this;
+      }
+
+      public Builder end(Integer end) {
+        this.end = end;
+        return this;
+      }
+
+      @Override
+      public ExtensionRange build() {
+        return new ExtensionRange(this);
+      }
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/EnumDescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/EnumDescriptorProto.java
new file mode 100755
index 0000000000..195a9783ef
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/EnumDescriptorProto.java
@@ -0,0 +1,121 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * Describes an enum type.
+ */
+public final class EnumDescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final String DEFAULT_DOC = "";
+  public static final List<EnumValueDescriptorProto> DEFAULT_VALUE = Collections.emptyList();
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  @ProtoField(tag = 4, type = STRING)
+  public final String doc;
+
+  /**
+   * Doc string for generated code.
+   */
+  @ProtoField(tag = 2, label = REPEATED, messageType = EnumValueDescriptorProto.class)
+  public final List<EnumValueDescriptorProto> value;
+
+  @ProtoField(tag = 3)
+  public final EnumOptions options;
+
+  public EnumDescriptorProto(String name, String doc, List<EnumValueDescriptorProto> value, EnumOptions options) {
+    this.name = name;
+    this.doc = doc;
+    this.value = immutableCopyOf(value);
+    this.options = options;
+  }
+
+  private EnumDescriptorProto(Builder builder) {
+    this(builder.name, builder.doc, builder.value, builder.options);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof EnumDescriptorProto)) return false;
+    EnumDescriptorProto o = (EnumDescriptorProto) other;
+    return equals(name, o.name)
+        && equals(doc, o.doc)
+        && equals(value, o.value)
+        && equals(options, o.options);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (doc != null ? doc.hashCode() : 0);
+      result = result * 37 + (value != null ? value.hashCode() : 1);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<EnumDescriptorProto> {
+
+    public String name;
+    public String doc;
+    public List<EnumValueDescriptorProto> value;
+    public EnumOptions options;
+
+    public Builder() {
+    }
+
+    public Builder(EnumDescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.doc = message.doc;
+      this.value = copyOf(message.value);
+      this.options = message.options;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder doc(String doc) {
+      this.doc = doc;
+      return this;
+    }
+
+    /**
+     * Doc string for generated code.
+     */
+    public Builder value(List<EnumValueDescriptorProto> value) {
+      this.value = checkForNulls(value);
+      return this;
+    }
+
+    public Builder options(EnumOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    @Override
+    public EnumDescriptorProto build() {
+      return new EnumDescriptorProto(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/EnumOptions.java b/wire-runtime/src/test/java/com/google/protobuf/EnumOptions.java
index 370bbb564c..c6b6ccde9b 100755
--- a/wire-runtime/src/test/java/com/google/protobuf/EnumOptions.java
+++ b/wire-runtime/src/test/java/com/google/protobuf/EnumOptions.java
@@ -11,13 +11,14 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class EnumOptions extends ExtendableMessage<EnumOptions> {
+  private static final long serialVersionUID = 0L;
 
   public static final List<UninterpretedOption> DEFAULT_UNINTERPRETED_OPTION = Collections.emptyList();
 
   /**
    * The parser stores options it doesn't recognize here. See above.
    */
-  @ProtoField(tag = 999, label = REPEATED)
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
   public final List<UninterpretedOption> uninterpreted_option;
 
   public EnumOptions(List<UninterpretedOption> uninterpreted_option) {
diff --git a/wire-runtime/src/test/java/com/google/protobuf/EnumValueDescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/EnumValueDescriptorProto.java
new file mode 100755
index 0000000000..47f67e3718
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/EnumValueDescriptorProto.java
@@ -0,0 +1,119 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+
+import static com.squareup.wire.Message.Datatype.INT32;
+import static com.squareup.wire.Message.Datatype.STRING;
+
+/**
+ * Describes a value within an enum.
+ */
+public final class EnumValueDescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final String DEFAULT_DOC = "";
+  public static final Integer DEFAULT_NUMBER = 0;
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  @ProtoField(tag = 4, type = STRING)
+  public final String doc;
+
+  /**
+   * Doc string for generated code.
+   */
+  @ProtoField(tag = 2, type = INT32)
+  public final Integer number;
+
+  @ProtoField(tag = 3)
+  public final EnumValueOptions options;
+
+  public EnumValueDescriptorProto(String name, String doc, Integer number, EnumValueOptions options) {
+    this.name = name;
+    this.doc = doc;
+    this.number = number;
+    this.options = options;
+  }
+
+  private EnumValueDescriptorProto(Builder builder) {
+    this(builder.name, builder.doc, builder.number, builder.options);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof EnumValueDescriptorProto)) return false;
+    EnumValueDescriptorProto o = (EnumValueDescriptorProto) other;
+    return equals(name, o.name)
+        && equals(doc, o.doc)
+        && equals(number, o.number)
+        && equals(options, o.options);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (doc != null ? doc.hashCode() : 0);
+      result = result * 37 + (number != null ? number.hashCode() : 0);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<EnumValueDescriptorProto> {
+
+    public String name;
+    public String doc;
+    public Integer number;
+    public EnumValueOptions options;
+
+    public Builder() {
+    }
+
+    public Builder(EnumValueDescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.doc = message.doc;
+      this.number = message.number;
+      this.options = message.options;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder doc(String doc) {
+      this.doc = doc;
+      return this;
+    }
+
+    /**
+     * Doc string for generated code.
+     */
+    public Builder number(Integer number) {
+      this.number = number;
+      return this;
+    }
+
+    public Builder options(EnumValueOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    @Override
+    public EnumValueDescriptorProto build() {
+      return new EnumValueDescriptorProto(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/EnumValueOptions.java b/wire-runtime/src/test/java/com/google/protobuf/EnumValueOptions.java
index 54e66bb308..47454b615a 100755
--- a/wire-runtime/src/test/java/com/google/protobuf/EnumValueOptions.java
+++ b/wire-runtime/src/test/java/com/google/protobuf/EnumValueOptions.java
@@ -11,13 +11,14 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class EnumValueOptions extends ExtendableMessage<EnumValueOptions> {
+  private static final long serialVersionUID = 0L;
 
   public static final List<UninterpretedOption> DEFAULT_UNINTERPRETED_OPTION = Collections.emptyList();
 
   /**
    * The parser stores options it doesn't recognize here. See above.
    */
-  @ProtoField(tag = 999, label = REPEATED)
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
   public final List<UninterpretedOption> uninterpreted_option;
 
   public EnumValueOptions(List<UninterpretedOption> uninterpreted_option) {
diff --git a/wire-runtime/src/test/java/com/google/protobuf/FieldDescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/FieldDescriptorProto.java
new file mode 100755
index 0000000000..3a2fb1fe88
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/FieldDescriptorProto.java
@@ -0,0 +1,313 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoEnum;
+import com.squareup.wire.ProtoField;
+
+import static com.squareup.wire.Message.Datatype.ENUM;
+import static com.squareup.wire.Message.Datatype.INT32;
+import static com.squareup.wire.Message.Datatype.STRING;
+
+/**
+ * Describes a field within a message.
+ */
+public final class FieldDescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final String DEFAULT_DOC = "";
+  public static final Integer DEFAULT_NUMBER = 0;
+  public static final Label DEFAULT_LABEL = Label.LABEL_OPTIONAL;
+  public static final Type DEFAULT_TYPE = Type.TYPE_DOUBLE;
+  public static final String DEFAULT_TYPE_NAME = "";
+  public static final String DEFAULT_EXTENDEE = "";
+  public static final String DEFAULT_DEFAULT_VALUE = "";
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  @ProtoField(tag = 9, type = STRING)
+  public final String doc;
+
+  /**
+   * Doc string for generated code.
+   */
+  @ProtoField(tag = 3, type = INT32)
+  public final Integer number;
+
+  @ProtoField(tag = 4, type = ENUM)
+  public final Label label;
+
+  /**
+   * If type_name is set, this need not be set.  If both this and type_name
+   * are set, this must be either TYPE_ENUM or TYPE_MESSAGE.
+   */
+  @ProtoField(tag = 5, type = ENUM)
+  public final Type type;
+
+  /**
+   * For message and enum types, this is the name of the type.  If the name
+   * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
+   * rules are used to find the type (i.e. first the nested types within this
+   * message are searched, then within the parent, on up to the root
+   * namespace).
+   */
+  @ProtoField(tag = 6, type = STRING)
+  public final String type_name;
+
+  /**
+   * For extensions, this is the name of the type being extended.  It is
+   * resolved in the same manner as type_name.
+   */
+  @ProtoField(tag = 2, type = STRING)
+  public final String extendee;
+
+  /**
+   * For numeric types, contains the original text representation of the value.
+   * For booleans, "true" or "false".
+   * For strings, contains the default text contents (not escaped in any way).
+   * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
+   * TODO(kenton):  Base-64 encode?
+   */
+  @ProtoField(tag = 7, type = STRING)
+  public final String default_value;
+
+  @ProtoField(tag = 8)
+  public final FieldOptions options;
+
+  public FieldDescriptorProto(String name, String doc, Integer number, Label label, Type type, String type_name, String extendee, String default_value, FieldOptions options) {
+    this.name = name;
+    this.doc = doc;
+    this.number = number;
+    this.label = label;
+    this.type = type;
+    this.type_name = type_name;
+    this.extendee = extendee;
+    this.default_value = default_value;
+    this.options = options;
+  }
+
+  private FieldDescriptorProto(Builder builder) {
+    this(builder.name, builder.doc, builder.number, builder.label, builder.type, builder.type_name, builder.extendee, builder.default_value, builder.options);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof FieldDescriptorProto)) return false;
+    FieldDescriptorProto o = (FieldDescriptorProto) other;
+    return equals(name, o.name)
+        && equals(doc, o.doc)
+        && equals(number, o.number)
+        && equals(label, o.label)
+        && equals(type, o.type)
+        && equals(type_name, o.type_name)
+        && equals(extendee, o.extendee)
+        && equals(default_value, o.default_value)
+        && equals(options, o.options);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (doc != null ? doc.hashCode() : 0);
+      result = result * 37 + (number != null ? number.hashCode() : 0);
+      result = result * 37 + (label != null ? label.hashCode() : 0);
+      result = result * 37 + (type != null ? type.hashCode() : 0);
+      result = result * 37 + (type_name != null ? type_name.hashCode() : 0);
+      result = result * 37 + (extendee != null ? extendee.hashCode() : 0);
+      result = result * 37 + (default_value != null ? default_value.hashCode() : 0);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<FieldDescriptorProto> {
+
+    public String name;
+    public String doc;
+    public Integer number;
+    public Label label;
+    public Type type;
+    public String type_name;
+    public String extendee;
+    public String default_value;
+    public FieldOptions options;
+
+    public Builder() {
+    }
+
+    public Builder(FieldDescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.doc = message.doc;
+      this.number = message.number;
+      this.label = message.label;
+      this.type = message.type;
+      this.type_name = message.type_name;
+      this.extendee = message.extendee;
+      this.default_value = message.default_value;
+      this.options = message.options;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder doc(String doc) {
+      this.doc = doc;
+      return this;
+    }
+
+    /**
+     * Doc string for generated code.
+     */
+    public Builder number(Integer number) {
+      this.number = number;
+      return this;
+    }
+
+    public Builder label(Label label) {
+      this.label = label;
+      return this;
+    }
+
+    /**
+     * If type_name is set, this need not be set.  If both this and type_name
+     * are set, this must be either TYPE_ENUM or TYPE_MESSAGE.
+     */
+    public Builder type(Type type) {
+      this.type = type;
+      return this;
+    }
+
+    /**
+     * For message and enum types, this is the name of the type.  If the name
+     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
+     * rules are used to find the type (i.e. first the nested types within this
+     * message are searched, then within the parent, on up to the root
+     * namespace).
+     */
+    public Builder type_name(String type_name) {
+      this.type_name = type_name;
+      return this;
+    }
+
+    /**
+     * For extensions, this is the name of the type being extended.  It is
+     * resolved in the same manner as type_name.
+     */
+    public Builder extendee(String extendee) {
+      this.extendee = extendee;
+      return this;
+    }
+
+    /**
+     * For numeric types, contains the original text representation of the value.
+     * For booleans, "true" or "false".
+     * For strings, contains the default text contents (not escaped in any way).
+     * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
+     * TODO(kenton):  Base-64 encode?
+     */
+    public Builder default_value(String default_value) {
+      this.default_value = default_value;
+      return this;
+    }
+
+    public Builder options(FieldOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    @Override
+    public FieldDescriptorProto build() {
+      return new FieldDescriptorProto(this);
+    }
+  }
+
+  public enum Type
+      implements ProtoEnum {
+    /**
+     * 0 is reserved for errors.
+     * Order is weird for historical reasons.
+     */
+    TYPE_DOUBLE(1),
+    TYPE_FLOAT(2),
+    TYPE_INT64(3),
+    /**
+     * Not ZigZag encoded.  Negative numbers
+     * take 10 bytes.  Use TYPE_SINT64 if negative
+     * values are likely.
+     */
+    TYPE_UINT64(4),
+    TYPE_INT32(5),
+    /**
+     * Not ZigZag encoded.  Negative numbers
+     * take 10 bytes.  Use TYPE_SINT32 if negative
+     * values are likely.
+     */
+    TYPE_FIXED64(6),
+    TYPE_FIXED32(7),
+    TYPE_BOOL(8),
+    TYPE_STRING(9),
+    TYPE_GROUP(10),
+    /**
+     * Tag-delimited aggregate.
+     */
+    TYPE_MESSAGE(11),
+    /**
+     * Length-delimited aggregate.
+     * New in version 2.
+     */
+    TYPE_BYTES(12),
+    TYPE_UINT32(13),
+    TYPE_ENUM(14),
+    TYPE_SFIXED32(15),
+    TYPE_SFIXED64(16),
+    TYPE_SINT32(17),
+    /**
+     * Uses ZigZag encoding.
+     */
+    TYPE_SINT64(18);
+
+    private final int value;
+
+    private Type(int value) {
+      this.value = value;
+    }
+
+    @Override
+    public int getValue() {
+      return value;
+    }
+  }
+
+  public enum Label
+      implements ProtoEnum {
+    /**
+     * 0 is reserved for errors
+     */
+    LABEL_OPTIONAL(1),
+    LABEL_REQUIRED(2),
+    LABEL_REPEATED(3);
+
+    private final int value;
+
+    private Label(int value) {
+      this.value = value;
+    }
+
+    @Override
+    public int getValue() {
+      return value;
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/FieldOptions.java b/wire-runtime/src/test/java/com/google/protobuf/FieldOptions.java
index a72d205c82..2746343246 100755
--- a/wire-runtime/src/test/java/com/google/protobuf/FieldOptions.java
+++ b/wire-runtime/src/test/java/com/google/protobuf/FieldOptions.java
@@ -15,6 +15,7 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class FieldOptions extends ExtendableMessage<FieldOptions> {
+  private static final long serialVersionUID = 0L;
 
   public static final CType DEFAULT_CTYPE = CType.STRING;
   public static final Boolean DEFAULT_PACKED = false;
@@ -69,7 +70,7 @@
   /**
    * The parser stores options it doesn't recognize here. See above.
    */
-  @ProtoField(tag = 999, label = REPEATED)
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
   public final List<UninterpretedOption> uninterpreted_option;
 
   public FieldOptions(CType ctype, Boolean packed, Boolean deprecated, String experimental_map_key, List<UninterpretedOption> uninterpreted_option) {
diff --git a/wire-runtime/src/test/java/com/google/protobuf/FileDescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/FileDescriptorProto.java
new file mode 100755
index 0000000000..4a492efda2
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/FileDescriptorProto.java
@@ -0,0 +1,216 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * Describes a complete .proto file.
+ */
+public final class FileDescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final String DEFAULT_PACKAGE = "";
+  public static final List<String> DEFAULT_DEPENDENCY = Collections.emptyList();
+  public static final List<DescriptorProto> DEFAULT_MESSAGE_TYPE = Collections.emptyList();
+  public static final List<EnumDescriptorProto> DEFAULT_ENUM_TYPE = Collections.emptyList();
+  public static final List<ServiceDescriptorProto> DEFAULT_SERVICE = Collections.emptyList();
+  public static final List<FieldDescriptorProto> DEFAULT_EXTENSION = Collections.emptyList();
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  /**
+   * file name, relative to root of source tree
+   */
+  @ProtoField(tag = 2, type = STRING)
+  public final String _package;
+
+  /**
+   * e.g. "foo", "foo.bar", etc.
+   * Names of files imported by this file.
+   */
+  @ProtoField(tag = 3, type = STRING, label = REPEATED)
+  public final List<String> dependency;
+
+  /**
+   * All top-level definitions in this file.
+   */
+  @ProtoField(tag = 4, label = REPEATED, messageType = DescriptorProto.class)
+  public final List<DescriptorProto> message_type;
+
+  @ProtoField(tag = 5, label = REPEATED, messageType = EnumDescriptorProto.class)
+  public final List<EnumDescriptorProto> enum_type;
+
+  @ProtoField(tag = 6, label = REPEATED, messageType = ServiceDescriptorProto.class)
+  public final List<ServiceDescriptorProto> service;
+
+  @ProtoField(tag = 7, label = REPEATED, messageType = FieldDescriptorProto.class)
+  public final List<FieldDescriptorProto> extension;
+
+  @ProtoField(tag = 8)
+  public final FileOptions options;
+
+  /**
+   * This field contains optional information about the original source code.
+   * You may safely remove this entire field without harming runtime
+   * functionality of the descriptors -- the information is needed only by
+   * development tools.
+   */
+  @ProtoField(tag = 9)
+  public final SourceCodeInfo source_code_info;
+
+  public FileDescriptorProto(String name, String _package, List<String> dependency, List<DescriptorProto> message_type, List<EnumDescriptorProto> enum_type, List<ServiceDescriptorProto> service, List<FieldDescriptorProto> extension, FileOptions options, SourceCodeInfo source_code_info) {
+    this.name = name;
+    this._package = _package;
+    this.dependency = immutableCopyOf(dependency);
+    this.message_type = immutableCopyOf(message_type);
+    this.enum_type = immutableCopyOf(enum_type);
+    this.service = immutableCopyOf(service);
+    this.extension = immutableCopyOf(extension);
+    this.options = options;
+    this.source_code_info = source_code_info;
+  }
+
+  private FileDescriptorProto(Builder builder) {
+    this(builder.name, builder._package, builder.dependency, builder.message_type, builder.enum_type, builder.service, builder.extension, builder.options, builder.source_code_info);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof FileDescriptorProto)) return false;
+    FileDescriptorProto o = (FileDescriptorProto) other;
+    return equals(name, o.name)
+        && equals(_package, o._package)
+        && equals(dependency, o.dependency)
+        && equals(message_type, o.message_type)
+        && equals(enum_type, o.enum_type)
+        && equals(service, o.service)
+        && equals(extension, o.extension)
+        && equals(options, o.options)
+        && equals(source_code_info, o.source_code_info);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (_package != null ? _package.hashCode() : 0);
+      result = result * 37 + (dependency != null ? dependency.hashCode() : 1);
+      result = result * 37 + (message_type != null ? message_type.hashCode() : 1);
+      result = result * 37 + (enum_type != null ? enum_type.hashCode() : 1);
+      result = result * 37 + (service != null ? service.hashCode() : 1);
+      result = result * 37 + (extension != null ? extension.hashCode() : 1);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      result = result * 37 + (source_code_info != null ? source_code_info.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<FileDescriptorProto> {
+
+    public String name;
+    public String _package;
+    public List<String> dependency;
+    public List<DescriptorProto> message_type;
+    public List<EnumDescriptorProto> enum_type;
+    public List<ServiceDescriptorProto> service;
+    public List<FieldDescriptorProto> extension;
+    public FileOptions options;
+    public SourceCodeInfo source_code_info;
+
+    public Builder() {
+    }
+
+    public Builder(FileDescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this._package = message._package;
+      this.dependency = copyOf(message.dependency);
+      this.message_type = copyOf(message.message_type);
+      this.enum_type = copyOf(message.enum_type);
+      this.service = copyOf(message.service);
+      this.extension = copyOf(message.extension);
+      this.options = message.options;
+      this.source_code_info = message.source_code_info;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    /**
+     * file name, relative to root of source tree
+     */
+    public Builder _package(String _package) {
+      this._package = _package;
+      return this;
+    }
+
+    /**
+     * e.g. "foo", "foo.bar", etc.
+     * Names of files imported by this file.
+     */
+    public Builder dependency(List<String> dependency) {
+      this.dependency = checkForNulls(dependency);
+      return this;
+    }
+
+    /**
+     * All top-level definitions in this file.
+     */
+    public Builder message_type(List<DescriptorProto> message_type) {
+      this.message_type = checkForNulls(message_type);
+      return this;
+    }
+
+    public Builder enum_type(List<EnumDescriptorProto> enum_type) {
+      this.enum_type = checkForNulls(enum_type);
+      return this;
+    }
+
+    public Builder service(List<ServiceDescriptorProto> service) {
+      this.service = checkForNulls(service);
+      return this;
+    }
+
+    public Builder extension(List<FieldDescriptorProto> extension) {
+      this.extension = checkForNulls(extension);
+      return this;
+    }
+
+    public Builder options(FileOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    /**
+     * This field contains optional information about the original source code.
+     * You may safely remove this entire field without harming runtime
+     * functionality of the descriptors -- the information is needed only by
+     * development tools.
+     */
+    public Builder source_code_info(SourceCodeInfo source_code_info) {
+      this.source_code_info = source_code_info;
+      return this;
+    }
+
+    @Override
+    public FileDescriptorProto build() {
+      return new FileDescriptorProto(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/FileDescriptorSet.java b/wire-runtime/src/test/java/com/google/protobuf/FileDescriptorSet.java
new file mode 100755
index 0000000000..847a4a8881
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/FileDescriptorSet.java
@@ -0,0 +1,69 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * The protocol compiler can output a FileDescriptorSet containing the .proto
+ * files it parses.
+ */
+public final class FileDescriptorSet extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final List<FileDescriptorProto> DEFAULT_FILE = Collections.emptyList();
+
+  @ProtoField(tag = 1, label = REPEATED, messageType = FileDescriptorProto.class)
+  public final List<FileDescriptorProto> file;
+
+  public FileDescriptorSet(List<FileDescriptorProto> file) {
+    this.file = immutableCopyOf(file);
+  }
+
+  private FileDescriptorSet(Builder builder) {
+    this(builder.file);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof FileDescriptorSet)) return false;
+    return equals(file, ((FileDescriptorSet) other).file);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    return result != 0 ? result : (hashCode = file != null ? file.hashCode() : 1);
+  }
+
+  public static final class Builder extends Message.Builder<FileDescriptorSet> {
+
+    public List<FileDescriptorProto> file;
+
+    public Builder() {
+    }
+
+    public Builder(FileDescriptorSet message) {
+      super(message);
+      if (message == null) return;
+      this.file = copyOf(message.file);
+    }
+
+    public Builder file(List<FileDescriptorProto> file) {
+      this.file = checkForNulls(file);
+      return this;
+    }
+
+    @Override
+    public FileDescriptorSet build() {
+      return new FileDescriptorSet(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/FileOptions.java b/wire-runtime/src/test/java/com/google/protobuf/FileOptions.java
new file mode 100755
index 0000000000..207794aa18
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/FileOptions.java
@@ -0,0 +1,331 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.ExtendableMessage;
+import com.squareup.wire.Extension;
+import com.squareup.wire.ProtoEnum;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.BOOL;
+import static com.squareup.wire.Message.Datatype.ENUM;
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * ===================================================================
+ * Options
+ * Each of the definitions above may have "options" attached.  These are
+ * just annotations which may cause code to be generated slightly differently
+ * or may contain hints for code that manipulates protocol messages.
+ *
+ * Clients may define custom options as extensions of the *Options messages.
+ * These extensions may not yet be known at parsing time, so the parser cannot
+ * store the values in them.  Instead it stores them in a field in the *Options
+ * message called uninterpreted_option. This field must have the same name
+ * across all *Options messages. We then use this field to populate the
+ * extensions when we build a descriptor, at which point all protos have been
+ * parsed and so all extensions are known.
+ *
+ * Extension numbers for custom options may be chosen as follows:
+ * * For options which will only be used within a single application or
+ *   organization, or for experimental options, use field numbers 50000
+ *   through 99999.  It is up to you to ensure that you do not use the
+ *   same number for multiple options.
+ * * For options which will be published and used publicly by multiple
+ *   independent entities, e-mail kenton@google.com to reserve extension
+ *   numbers.  Simply tell me how many you need and I'll send you back a
+ *   set of numbers to use -- there's no need to explain how you intend to
+ *   use them.  If this turns out to be popular, a web service will be set up
+ *   to automatically assign option numbers.
+ */
+public final class FileOptions extends ExtendableMessage<FileOptions> {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_JAVA_PACKAGE = "";
+  public static final String DEFAULT_JAVA_OUTER_CLASSNAME = "";
+  public static final Boolean DEFAULT_JAVA_MULTIPLE_FILES = false;
+  public static final Boolean DEFAULT_JAVA_GENERATE_EQUALS_AND_HASH = false;
+  public static final OptimizeMode DEFAULT_OPTIMIZE_FOR = OptimizeMode.SPEED;
+  public static final Boolean DEFAULT_CC_GENERIC_SERVICES = false;
+  public static final Boolean DEFAULT_JAVA_GENERIC_SERVICES = false;
+  public static final Boolean DEFAULT_PY_GENERIC_SERVICES = false;
+  public static final List<UninterpretedOption> DEFAULT_UNINTERPRETED_OPTION = Collections.emptyList();
+
+  /**
+   * Sets the Java package where classes generated from this .proto will be
+   * placed.  By default, the proto package is used, but this is often
+   * inappropriate because proto packages do not normally start with backwards
+   * domain names.
+   */
+  @ProtoField(tag = 1, type = STRING)
+  public final String java_package;
+
+  /**
+   * If set, all the classes from the .proto file are wrapped in a single
+   * outer class with the given name.  This applies to both Proto1
+   * (equivalent to the old "--one_java_file" option) and Proto2 (where
+   * a .proto always translates to a single class, but you may want to
+   * explicitly choose the class name).
+   */
+  @ProtoField(tag = 8, type = STRING)
+  public final String java_outer_classname;
+
+  /**
+   * If set true, then the Java code generator will generate a separate .java
+   * file for each top-level message, enum, and service defined in the .proto
+   * file.  Thus, these types will *not* be nested inside the outer class
+   * named by java_outer_classname.  However, the outer class will still be
+   * generated to contain the file's getDescriptor() method as well as any
+   * top-level extensions defined in the file.
+   */
+  @ProtoField(tag = 10, type = BOOL)
+  public final Boolean java_multiple_files;
+
+  /**
+   * If set true, then the Java code generator will generate equals() and
+   * hashCode() methods for all messages defined in the .proto file. This is
+   * purely a speed optimization, as the AbstractMessage base class includes
+   * reflection-based implementations of these methods.
+   */
+  @ProtoField(tag = 20, type = BOOL)
+  public final Boolean java_generate_equals_and_hash;
+
+  @ProtoField(tag = 9, type = ENUM)
+  public final OptimizeMode optimize_for;
+
+  /**
+   * Should generic services be generated in each language?  "Generic" services
+   * are not specific to any particular RPC system.  They are generated by the
+   * main code generators in each language (without additional plugins).
+   * Generic services were the only kind of service generation supported by
+   * early versions of proto2.
+   *
+   * Generic services are now considered deprecated in favor of using plugins
+   * that generate code specific to your particular RPC system.  Therefore,
+   * these default to false.  Old code which depends on generic services should
+   * explicitly set them to true.
+   */
+  @ProtoField(tag = 16, type = BOOL)
+  public final Boolean cc_generic_services;
+
+  @ProtoField(tag = 17, type = BOOL)
+  public final Boolean java_generic_services;
+
+  @ProtoField(tag = 18, type = BOOL)
+  public final Boolean py_generic_services;
+
+  /**
+   * The parser stores options it doesn't recognize here. See above.
+   */
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
+  public final List<UninterpretedOption> uninterpreted_option;
+
+  public FileOptions(String java_package, String java_outer_classname, Boolean java_multiple_files, Boolean java_generate_equals_and_hash, OptimizeMode optimize_for, Boolean cc_generic_services, Boolean java_generic_services, Boolean py_generic_services, List<UninterpretedOption> uninterpreted_option) {
+    this.java_package = java_package;
+    this.java_outer_classname = java_outer_classname;
+    this.java_multiple_files = java_multiple_files;
+    this.java_generate_equals_and_hash = java_generate_equals_and_hash;
+    this.optimize_for = optimize_for;
+    this.cc_generic_services = cc_generic_services;
+    this.java_generic_services = java_generic_services;
+    this.py_generic_services = py_generic_services;
+    this.uninterpreted_option = immutableCopyOf(uninterpreted_option);
+  }
+
+  private FileOptions(Builder builder) {
+    this(builder.java_package, builder.java_outer_classname, builder.java_multiple_files, builder.java_generate_equals_and_hash, builder.optimize_for, builder.cc_generic_services, builder.java_generic_services, builder.py_generic_services, builder.uninterpreted_option);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof FileOptions)) return false;
+    FileOptions o = (FileOptions) other;
+    if (!extensionsEqual(o)) return false;
+    return equals(java_package, o.java_package)
+        && equals(java_outer_classname, o.java_outer_classname)
+        && equals(java_multiple_files, o.java_multiple_files)
+        && equals(java_generate_equals_and_hash, o.java_generate_equals_and_hash)
+        && equals(optimize_for, o.optimize_for)
+        && equals(cc_generic_services, o.cc_generic_services)
+        && equals(java_generic_services, o.java_generic_services)
+        && equals(py_generic_services, o.py_generic_services)
+        && equals(uninterpreted_option, o.uninterpreted_option);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = extensionsHashCode();
+      result = result * 37 + (java_package != null ? java_package.hashCode() : 0);
+      result = result * 37 + (java_outer_classname != null ? java_outer_classname.hashCode() : 0);
+      result = result * 37 + (java_multiple_files != null ? java_multiple_files.hashCode() : 0);
+      result = result * 37 + (java_generate_equals_and_hash != null ? java_generate_equals_and_hash.hashCode() : 0);
+      result = result * 37 + (optimize_for != null ? optimize_for.hashCode() : 0);
+      result = result * 37 + (cc_generic_services != null ? cc_generic_services.hashCode() : 0);
+      result = result * 37 + (java_generic_services != null ? java_generic_services.hashCode() : 0);
+      result = result * 37 + (py_generic_services != null ? py_generic_services.hashCode() : 0);
+      result = result * 37 + (uninterpreted_option != null ? uninterpreted_option.hashCode() : 1);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends ExtendableBuilder<FileOptions> {
+
+    public String java_package;
+    public String java_outer_classname;
+    public Boolean java_multiple_files;
+    public Boolean java_generate_equals_and_hash;
+    public OptimizeMode optimize_for;
+    public Boolean cc_generic_services;
+    public Boolean java_generic_services;
+    public Boolean py_generic_services;
+    public List<UninterpretedOption> uninterpreted_option;
+
+    public Builder() {
+    }
+
+    public Builder(FileOptions message) {
+      super(message);
+      if (message == null) return;
+      this.java_package = message.java_package;
+      this.java_outer_classname = message.java_outer_classname;
+      this.java_multiple_files = message.java_multiple_files;
+      this.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
+      this.optimize_for = message.optimize_for;
+      this.cc_generic_services = message.cc_generic_services;
+      this.java_generic_services = message.java_generic_services;
+      this.py_generic_services = message.py_generic_services;
+      this.uninterpreted_option = copyOf(message.uninterpreted_option);
+    }
+
+    /**
+     * Sets the Java package where classes generated from this .proto will be
+     * placed.  By default, the proto package is used, but this is often
+     * inappropriate because proto packages do not normally start with backwards
+     * domain names.
+     */
+    public Builder java_package(String java_package) {
+      this.java_package = java_package;
+      return this;
+    }
+
+    /**
+     * If set, all the classes from the .proto file are wrapped in a single
+     * outer class with the given name.  This applies to both Proto1
+     * (equivalent to the old "--one_java_file" option) and Proto2 (where
+     * a .proto always translates to a single class, but you may want to
+     * explicitly choose the class name).
+     */
+    public Builder java_outer_classname(String java_outer_classname) {
+      this.java_outer_classname = java_outer_classname;
+      return this;
+    }
+
+    /**
+     * If set true, then the Java code generator will generate a separate .java
+     * file for each top-level message, enum, and service defined in the .proto
+     * file.  Thus, these types will *not* be nested inside the outer class
+     * named by java_outer_classname.  However, the outer class will still be
+     * generated to contain the file's getDescriptor() method as well as any
+     * top-level extensions defined in the file.
+     */
+    public Builder java_multiple_files(Boolean java_multiple_files) {
+      this.java_multiple_files = java_multiple_files;
+      return this;
+    }
+
+    /**
+     * If set true, then the Java code generator will generate equals() and
+     * hashCode() methods for all messages defined in the .proto file. This is
+     * purely a speed optimization, as the AbstractMessage base class includes
+     * reflection-based implementations of these methods.
+     */
+    public Builder java_generate_equals_and_hash(Boolean java_generate_equals_and_hash) {
+      this.java_generate_equals_and_hash = java_generate_equals_and_hash;
+      return this;
+    }
+
+    public Builder optimize_for(OptimizeMode optimize_for) {
+      this.optimize_for = optimize_for;
+      return this;
+    }
+
+    /**
+     * Should generic services be generated in each language?  "Generic" services
+     * are not specific to any particular RPC system.  They are generated by the
+     * main code generators in each language (without additional plugins).
+     * Generic services were the only kind of service generation supported by
+     * early versions of proto2.
+     *
+     * Generic services are now considered deprecated in favor of using plugins
+     * that generate code specific to your particular RPC system.  Therefore,
+     * these default to false.  Old code which depends on generic services should
+     * explicitly set them to true.
+     */
+    public Builder cc_generic_services(Boolean cc_generic_services) {
+      this.cc_generic_services = cc_generic_services;
+      return this;
+    }
+
+    public Builder java_generic_services(Boolean java_generic_services) {
+      this.java_generic_services = java_generic_services;
+      return this;
+    }
+
+    public Builder py_generic_services(Boolean py_generic_services) {
+      this.py_generic_services = py_generic_services;
+      return this;
+    }
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+      this.uninterpreted_option = checkForNulls(uninterpreted_option);
+      return this;
+    }
+
+    @Override
+    public <E> Builder setExtension(Extension<FileOptions, E> extension, E value) {
+      super.setExtension(extension, value);
+      return this;
+    }
+
+    @Override
+    public FileOptions build() {
+      return new FileOptions(this);
+    }
+  }
+
+  public enum OptimizeMode
+      implements ProtoEnum {
+    SPEED(1),
+    /**
+     * Generate complete code for parsing, serialization,
+     * etc.
+     */
+    CODE_SIZE(2),
+    /**
+     * Use ReflectionOps to implement these methods.
+     */
+    LITE_RUNTIME(3);
+
+    private final int value;
+
+    private OptimizeMode(int value) {
+      this.value = value;
+    }
+
+    @Override
+    public int getValue() {
+      return value;
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/MessageOptions.java b/wire-runtime/src/test/java/com/google/protobuf/MessageOptions.java
index 3ab7e9b79a..f8c5aeb757 100755
--- a/wire-runtime/src/test/java/com/google/protobuf/MessageOptions.java
+++ b/wire-runtime/src/test/java/com/google/protobuf/MessageOptions.java
@@ -12,6 +12,7 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class MessageOptions extends ExtendableMessage<MessageOptions> {
+  private static final long serialVersionUID = 0L;
 
   public static final Boolean DEFAULT_MESSAGE_SET_WIRE_FORMAT = false;
   public static final Boolean DEFAULT_NO_STANDARD_DESCRIPTOR_ACCESSOR = false;
@@ -51,7 +52,7 @@
   /**
    * The parser stores options it doesn't recognize here. See above.
    */
-  @ProtoField(tag = 999, label = REPEATED)
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
   public final List<UninterpretedOption> uninterpreted_option;
 
   public MessageOptions(Boolean message_set_wire_format, Boolean no_standard_descriptor_accessor, List<UninterpretedOption> uninterpreted_option) {
diff --git a/wire-runtime/src/test/java/com/google/protobuf/MethodDescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/MethodDescriptorProto.java
new file mode 100755
index 0000000000..10f38dbd10
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/MethodDescriptorProto.java
@@ -0,0 +1,136 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+
+import static com.squareup.wire.Message.Datatype.STRING;
+
+/**
+ * Describes a method of a service.
+ */
+public final class MethodDescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final String DEFAULT_DOC = "";
+  public static final String DEFAULT_INPUT_TYPE = "";
+  public static final String DEFAULT_OUTPUT_TYPE = "";
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  @ProtoField(tag = 5, type = STRING)
+  public final String doc;
+
+  /**
+   * Doc string for generated code.
+   * Input and output type names.  These are resolved in the same way as
+   * FieldDescriptorProto.type_name, but must refer to a message type.
+   */
+  @ProtoField(tag = 2, type = STRING)
+  public final String input_type;
+
+  @ProtoField(tag = 3, type = STRING)
+  public final String output_type;
+
+  @ProtoField(tag = 4)
+  public final MethodOptions options;
+
+  public MethodDescriptorProto(String name, String doc, String input_type, String output_type, MethodOptions options) {
+    this.name = name;
+    this.doc = doc;
+    this.input_type = input_type;
+    this.output_type = output_type;
+    this.options = options;
+  }
+
+  private MethodDescriptorProto(Builder builder) {
+    this(builder.name, builder.doc, builder.input_type, builder.output_type, builder.options);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof MethodDescriptorProto)) return false;
+    MethodDescriptorProto o = (MethodDescriptorProto) other;
+    return equals(name, o.name)
+        && equals(doc, o.doc)
+        && equals(input_type, o.input_type)
+        && equals(output_type, o.output_type)
+        && equals(options, o.options);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (doc != null ? doc.hashCode() : 0);
+      result = result * 37 + (input_type != null ? input_type.hashCode() : 0);
+      result = result * 37 + (output_type != null ? output_type.hashCode() : 0);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<MethodDescriptorProto> {
+
+    public String name;
+    public String doc;
+    public String input_type;
+    public String output_type;
+    public MethodOptions options;
+
+    public Builder() {
+    }
+
+    public Builder(MethodDescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.doc = message.doc;
+      this.input_type = message.input_type;
+      this.output_type = message.output_type;
+      this.options = message.options;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder doc(String doc) {
+      this.doc = doc;
+      return this;
+    }
+
+    /**
+     * Doc string for generated code.
+     * Input and output type names.  These are resolved in the same way as
+     * FieldDescriptorProto.type_name, but must refer to a message type.
+     */
+    public Builder input_type(String input_type) {
+      this.input_type = input_type;
+      return this;
+    }
+
+    public Builder output_type(String output_type) {
+      this.output_type = output_type;
+      return this;
+    }
+
+    public Builder options(MethodOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    @Override
+    public MethodDescriptorProto build() {
+      return new MethodDescriptorProto(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/MethodOptions.java b/wire-runtime/src/test/java/com/google/protobuf/MethodOptions.java
new file mode 100755
index 0000000000..f44e4aa854
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/MethodOptions.java
@@ -0,0 +1,93 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.ExtendableMessage;
+import com.squareup.wire.Extension;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Label.REPEATED;
+
+public final class MethodOptions extends ExtendableMessage<MethodOptions> {
+  private static final long serialVersionUID = 0L;
+
+  public static final List<UninterpretedOption> DEFAULT_UNINTERPRETED_OPTION = Collections.emptyList();
+
+  /**
+   * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+   *   framework.  We apologize for hoarding these numbers to ourselves, but
+   *   we were already using them long before we decided to release Protocol
+   *   Buffers.
+   * The parser stores options it doesn't recognize here. See above.
+   */
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
+  public final List<UninterpretedOption> uninterpreted_option;
+
+  public MethodOptions(List<UninterpretedOption> uninterpreted_option) {
+    this.uninterpreted_option = immutableCopyOf(uninterpreted_option);
+  }
+
+  private MethodOptions(Builder builder) {
+    this(builder.uninterpreted_option);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof MethodOptions)) return false;
+    MethodOptions o = (MethodOptions) other;
+    if (!extensionsEqual(o)) return false;
+    return equals(uninterpreted_option, o.uninterpreted_option);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = extensionsHashCode();
+      result = result * 37 + (uninterpreted_option != null ? uninterpreted_option.hashCode() : 1);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends ExtendableBuilder<MethodOptions> {
+
+    public List<UninterpretedOption> uninterpreted_option;
+
+    public Builder() {
+    }
+
+    public Builder(MethodOptions message) {
+      super(message);
+      if (message == null) return;
+      this.uninterpreted_option = copyOf(message.uninterpreted_option);
+    }
+
+    /**
+     * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+     *   framework.  We apologize for hoarding these numbers to ourselves, but
+     *   we were already using them long before we decided to release Protocol
+     *   Buffers.
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+      this.uninterpreted_option = checkForNulls(uninterpreted_option);
+      return this;
+    }
+
+    @Override
+    public <E> Builder setExtension(Extension<MethodOptions, E> extension, E value) {
+      super.setExtension(extension, value);
+      return this;
+    }
+
+    @Override
+    public MethodOptions build() {
+      return new MethodOptions(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/ServiceDescriptorProto.java b/wire-runtime/src/test/java/com/google/protobuf/ServiceDescriptorProto.java
new file mode 100755
index 0000000000..d7ad9918bc
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/ServiceDescriptorProto.java
@@ -0,0 +1,121 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * Describes a service.
+ */
+public final class ServiceDescriptorProto extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final String DEFAULT_NAME = "";
+  public static final List<MethodDescriptorProto> DEFAULT_METHOD = Collections.emptyList();
+  public static final String DEFAULT_DOC = "";
+
+  @ProtoField(tag = 1, type = STRING)
+  public final String name;
+
+  @ProtoField(tag = 2, label = REPEATED, messageType = MethodDescriptorProto.class)
+  public final List<MethodDescriptorProto> method;
+
+  @ProtoField(tag = 4, type = STRING)
+  public final String doc;
+
+  /**
+   * Doc string for generated code.
+   */
+  @ProtoField(tag = 3)
+  public final ServiceOptions options;
+
+  public ServiceDescriptorProto(String name, List<MethodDescriptorProto> method, String doc, ServiceOptions options) {
+    this.name = name;
+    this.method = immutableCopyOf(method);
+    this.doc = doc;
+    this.options = options;
+  }
+
+  private ServiceDescriptorProto(Builder builder) {
+    this(builder.name, builder.method, builder.doc, builder.options);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof ServiceDescriptorProto)) return false;
+    ServiceDescriptorProto o = (ServiceDescriptorProto) other;
+    return equals(name, o.name)
+        && equals(method, o.method)
+        && equals(doc, o.doc)
+        && equals(options, o.options);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (method != null ? method.hashCode() : 1);
+      result = result * 37 + (doc != null ? doc.hashCode() : 0);
+      result = result * 37 + (options != null ? options.hashCode() : 0);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<ServiceDescriptorProto> {
+
+    public String name;
+    public List<MethodDescriptorProto> method;
+    public String doc;
+    public ServiceOptions options;
+
+    public Builder() {
+    }
+
+    public Builder(ServiceDescriptorProto message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.method = copyOf(message.method);
+      this.doc = message.doc;
+      this.options = message.options;
+    }
+
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder method(List<MethodDescriptorProto> method) {
+      this.method = checkForNulls(method);
+      return this;
+    }
+
+    public Builder doc(String doc) {
+      this.doc = doc;
+      return this;
+    }
+
+    /**
+     * Doc string for generated code.
+     */
+    public Builder options(ServiceOptions options) {
+      this.options = options;
+      return this;
+    }
+
+    @Override
+    public ServiceDescriptorProto build() {
+      return new ServiceDescriptorProto(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/ServiceOptions.java b/wire-runtime/src/test/java/com/google/protobuf/ServiceOptions.java
new file mode 100755
index 0000000000..4c18c1e58d
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/ServiceOptions.java
@@ -0,0 +1,93 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.ExtendableMessage;
+import com.squareup.wire.Extension;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Label.REPEATED;
+
+public final class ServiceOptions extends ExtendableMessage<ServiceOptions> {
+  private static final long serialVersionUID = 0L;
+
+  public static final List<UninterpretedOption> DEFAULT_UNINTERPRETED_OPTION = Collections.emptyList();
+
+  /**
+   * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+   *   framework.  We apologize for hoarding these numbers to ourselves, but
+   *   we were already using them long before we decided to release Protocol
+   *   Buffers.
+   * The parser stores options it doesn't recognize here. See above.
+   */
+  @ProtoField(tag = 999, label = REPEATED, messageType = UninterpretedOption.class)
+  public final List<UninterpretedOption> uninterpreted_option;
+
+  public ServiceOptions(List<UninterpretedOption> uninterpreted_option) {
+    this.uninterpreted_option = immutableCopyOf(uninterpreted_option);
+  }
+
+  private ServiceOptions(Builder builder) {
+    this(builder.uninterpreted_option);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof ServiceOptions)) return false;
+    ServiceOptions o = (ServiceOptions) other;
+    if (!extensionsEqual(o)) return false;
+    return equals(uninterpreted_option, o.uninterpreted_option);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = extensionsHashCode();
+      result = result * 37 + (uninterpreted_option != null ? uninterpreted_option.hashCode() : 1);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends ExtendableBuilder<ServiceOptions> {
+
+    public List<UninterpretedOption> uninterpreted_option;
+
+    public Builder() {
+    }
+
+    public Builder(ServiceOptions message) {
+      super(message);
+      if (message == null) return;
+      this.uninterpreted_option = copyOf(message.uninterpreted_option);
+    }
+
+    /**
+     * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+     *   framework.  We apologize for hoarding these numbers to ourselves, but
+     *   we were already using them long before we decided to release Protocol
+     *   Buffers.
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+      this.uninterpreted_option = checkForNulls(uninterpreted_option);
+      return this;
+    }
+
+    @Override
+    public <E> Builder setExtension(Extension<ServiceOptions, E> extension, E value) {
+      super.setExtension(extension, value);
+      return this;
+    }
+
+    @Override
+    public ServiceOptions build() {
+      return new ServiceOptions(this);
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/SourceCodeInfo.java b/wire-runtime/src/test/java/com/google/protobuf/SourceCodeInfo.java
new file mode 100755
index 0000000000..7a76c4c452
--- /dev/null
+++ b/wire-runtime/src/test/java/com/google/protobuf/SourceCodeInfo.java
@@ -0,0 +1,301 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.INT32;
+import static com.squareup.wire.Message.Label.PACKED;
+import static com.squareup.wire.Message.Label.REPEATED;
+
+/**
+ * ===================================================================
+ * Optional source code info
+ * Encapsulates information about the original source file from which a
+ * FileDescriptorProto was generated.
+ */
+public final class SourceCodeInfo extends Message {
+  private static final long serialVersionUID = 0L;
+
+  public static final List<Location> DEFAULT_LOCATION = Collections.emptyList();
+
+  /**
+   * A Location identifies a piece of source code in a .proto file which
+   * corresponds to a particular definition.  This information is intended
+   * to be useful to IDEs, code indexers, documentation generators, and similar
+   * tools.
+   *
+   * For example, say we have a file like:
+   *   message Foo {
+   *     optional string foo = 1;
+   *   }
+   * Let's look at just the field definition:
+   *   optional string foo = 1;
+   *   ^       ^^     ^^  ^  ^^^
+   *   a       bc     de  f  ghi
+   * We have the following locations:
+   *   span   path               represents
+   *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
+   *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
+   *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
+   *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
+   *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
+   *
+   * Notes:
+   * - A location may refer to a repeated field itself (i.e. not to any
+   *   particular index within it).  This is used whenever a set of elements are
+   *   logically enclosed in a single code segment.  For example, an entire
+   *   extend block (possibly containing multiple extension definitions) will
+   *   have an outer location whose path refers to the "extensions" repeated
+   *   field without an index.
+   * - Multiple locations may have the same path.  This happens when a single
+   *   logical declaration is spread out across multiple places.  The most
+   *   obvious example is the "extend" block again -- there may be multiple
+   *   extend blocks in the same scope, each of which will have the same path.
+   * - A location's span is not always a subset of its parent's span.  For
+   *   example, the "extendee" of an extension declaration appears at the
+   *   beginning of the "extend" block and is shared by all extensions within
+   *   the block.
+   * - Just because a location's span is a subset of some other location's span
+   *   does not mean that it is a descendent.  For example, a "group" defines
+   *   both a type and a field in a single declaration.  Thus, the locations
+   *   corresponding to the type and field and their components will overlap.
+   * - Code which tries to interpret locations should probably be designed to
+   *   ignore those that it doesn't understand, as more types of locations could
+   *   be recorded in the future.
+   */
+  @ProtoField(tag = 1, label = REPEATED, messageType = Location.class)
+  public final List<Location> location;
+
+  public SourceCodeInfo(List<Location> location) {
+    this.location = immutableCopyOf(location);
+  }
+
+  private SourceCodeInfo(Builder builder) {
+    this(builder.location);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof SourceCodeInfo)) return false;
+    return equals(location, ((SourceCodeInfo) other).location);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    return result != 0 ? result : (hashCode = location != null ? location.hashCode() : 1);
+  }
+
+  public static final class Builder extends Message.Builder<SourceCodeInfo> {
+
+    public List<Location> location;
+
+    public Builder() {
+    }
+
+    public Builder(SourceCodeInfo message) {
+      super(message);
+      if (message == null) return;
+      this.location = copyOf(message.location);
+    }
+
+    /**
+     * A Location identifies a piece of source code in a .proto file which
+     * corresponds to a particular definition.  This information is intended
+     * to be useful to IDEs, code indexers, documentation generators, and similar
+     * tools.
+     *
+     * For example, say we have a file like:
+     *   message Foo {
+     *     optional string foo = 1;
+     *   }
+     * Let's look at just the field definition:
+     *   optional string foo = 1;
+     *   ^       ^^     ^^  ^  ^^^
+     *   a       bc     de  f  ghi
+     * We have the following locations:
+     *   span   path               represents
+     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
+     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
+     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
+     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
+     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
+     *
+     * Notes:
+     * - A location may refer to a repeated field itself (i.e. not to any
+     *   particular index within it).  This is used whenever a set of elements are
+     *   logically enclosed in a single code segment.  For example, an entire
+     *   extend block (possibly containing multiple extension definitions) will
+     *   have an outer location whose path refers to the "extensions" repeated
+     *   field without an index.
+     * - Multiple locations may have the same path.  This happens when a single
+     *   logical declaration is spread out across multiple places.  The most
+     *   obvious example is the "extend" block again -- there may be multiple
+     *   extend blocks in the same scope, each of which will have the same path.
+     * - A location's span is not always a subset of its parent's span.  For
+     *   example, the "extendee" of an extension declaration appears at the
+     *   beginning of the "extend" block and is shared by all extensions within
+     *   the block.
+     * - Just because a location's span is a subset of some other location's span
+     *   does not mean that it is a descendent.  For example, a "group" defines
+     *   both a type and a field in a single declaration.  Thus, the locations
+     *   corresponding to the type and field and their components will overlap.
+     * - Code which tries to interpret locations should probably be designed to
+     *   ignore those that it doesn't understand, as more types of locations could
+     *   be recorded in the future.
+     */
+    public Builder location(List<Location> location) {
+      this.location = checkForNulls(location);
+      return this;
+    }
+
+    @Override
+    public SourceCodeInfo build() {
+      return new SourceCodeInfo(this);
+    }
+  }
+
+  public static final class Location extends Message {
+    private static final long serialVersionUID = 0L;
+
+    public static final List<Integer> DEFAULT_PATH = Collections.emptyList();
+    public static final List<Integer> DEFAULT_SPAN = Collections.emptyList();
+
+    /**
+     * Identifies which part of the FileDescriptorProto was defined at this
+     * location.
+     *
+     * Each element is a field number or an index.  They form a path from
+     * the root FileDescriptorProto to the place where the definition.  For
+     * example, this path:
+     *   [ 4, 3, 2, 7, 1 ]
+     * refers to:
+     *   file.message_type(3)  // 4, 3
+     *       .field(7)         // 2, 7
+     *       .name()           // 1
+     * This is because FileDescriptorProto.message_type has field number 4:
+     *   repeated DescriptorProto message_type = 4;
+     * and DescriptorProto.field has field number 2:
+     *   repeated FieldDescriptorProto field = 2;
+     * and FieldDescriptorProto.name has field number 1:
+     *   optional string name = 1;
+     *
+     * Thus, the above path gives the location of a field name.  If we removed
+     * the last element:
+     *   [ 4, 3, 2, 7 ]
+     * this path refers to the whole field declaration (from the beginning
+     * of the label to the terminating semicolon).
+     */
+    @ProtoField(tag = 1, type = INT32, label = PACKED)
+    public final List<Integer> path;
+
+    /**
+     * Always has exactly three or four elements: start line, start column,
+     * end line (optional, otherwise assumed same as start line), end column.
+     * These are packed into a single field for efficiency.  Note that line
+     * and column numbers are zero-based -- typically you will want to add
+     * 1 to each before displaying to a user.
+     */
+    @ProtoField(tag = 2, type = INT32, label = PACKED)
+    public final List<Integer> span;
+
+    public Location(List<Integer> path, List<Integer> span) {
+      this.path = immutableCopyOf(path);
+      this.span = immutableCopyOf(span);
+    }
+
+    private Location(Builder builder) {
+      this(builder.path, builder.span);
+      setBuilder(builder);
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      if (other == this) return true;
+      if (!(other instanceof Location)) return false;
+      Location o = (Location) other;
+      return equals(path, o.path)
+          && equals(span, o.span);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = hashCode;
+      if (result == 0) {
+        result = path != null ? path.hashCode() : 1;
+        result = result * 37 + (span != null ? span.hashCode() : 1);
+        hashCode = result;
+      }
+      return result;
+    }
+
+    public static final class Builder extends Message.Builder<Location> {
+
+      public List<Integer> path;
+      public List<Integer> span;
+
+      public Builder() {
+      }
+
+      public Builder(Location message) {
+        super(message);
+        if (message == null) return;
+        this.path = copyOf(message.path);
+        this.span = copyOf(message.span);
+      }
+
+      /**
+       * Identifies which part of the FileDescriptorProto was defined at this
+       * location.
+       *
+       * Each element is a field number or an index.  They form a path from
+       * the root FileDescriptorProto to the place where the definition.  For
+       * example, this path:
+       *   [ 4, 3, 2, 7, 1 ]
+       * refers to:
+       *   file.message_type(3)  // 4, 3
+       *       .field(7)         // 2, 7
+       *       .name()           // 1
+       * This is because FileDescriptorProto.message_type has field number 4:
+       *   repeated DescriptorProto message_type = 4;
+       * and DescriptorProto.field has field number 2:
+       *   repeated FieldDescriptorProto field = 2;
+       * and FieldDescriptorProto.name has field number 1:
+       *   optional string name = 1;
+       *
+       * Thus, the above path gives the location of a field name.  If we removed
+       * the last element:
+       *   [ 4, 3, 2, 7 ]
+       * this path refers to the whole field declaration (from the beginning
+       * of the label to the terminating semicolon).
+       */
+      public Builder path(List<Integer> path) {
+        this.path = checkForNulls(path);
+        return this;
+      }
+
+      /**
+       * Always has exactly three or four elements: start line, start column,
+       * end line (optional, otherwise assumed same as start line), end column.
+       * These are packed into a single field for efficiency.  Note that line
+       * and column numbers are zero-based -- typically you will want to add
+       * 1 to each before displaying to a user.
+       */
+      public Builder span(List<Integer> span) {
+        this.span = checkForNulls(span);
+        return this;
+      }
+
+      @Override
+      public Location build() {
+        return new Location(this);
+      }
+    }
+  }
+}
diff --git a/wire-runtime/src/test/java/com/google/protobuf/UninterpretedOption.java b/wire-runtime/src/test/java/com/google/protobuf/UninterpretedOption.java
index 91b1deccc7..6125992376 100755
--- a/wire-runtime/src/test/java/com/google/protobuf/UninterpretedOption.java
+++ b/wire-runtime/src/test/java/com/google/protobuf/UninterpretedOption.java
@@ -26,6 +26,7 @@
  * in them.
  */
 public final class UninterpretedOption extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final List<NamePart> DEFAULT_NAME = Collections.emptyList();
   public static final String DEFAULT_IDENTIFIER_VALUE = "";
@@ -35,7 +36,7 @@
   public static final ByteString DEFAULT_STRING_VALUE = ByteString.EMPTY;
   public static final String DEFAULT_AGGREGATE_VALUE = "";
 
-  @ProtoField(tag = 2, label = REPEATED)
+  @ProtoField(tag = 2, label = REPEATED, messageType = NamePart.class)
   public final List<NamePart> name;
 
   /**
@@ -183,6 +184,7 @@ public UninterpretedOption build() {
    * "foo.(bar.baz).qux".
    */
   public static final class NamePart extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final String DEFAULT_NAME_PART = "";
     public static final Boolean DEFAULT_IS_EXTENSION = false;
diff --git a/wire-runtime/src/test/java/com/squareup/foobar/protos/bar/Bar.java b/wire-runtime/src/test/java/com/squareup/foobar/protos/bar/Bar.java
index f0e86b2c6b..d37f68c05f 100755
--- a/wire-runtime/src/test/java/com/squareup/foobar/protos/bar/Bar.java
+++ b/wire-runtime/src/test/java/com/squareup/foobar/protos/bar/Bar.java
@@ -7,6 +7,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class Bar extends Message {
+  private static final long serialVersionUID = 0L;
 
   public Bar() {
   }
@@ -41,6 +42,7 @@ public Bar build() {
   }
 
   public static final class Baz extends Message {
+    private static final long serialVersionUID = 0L;
 
     public Baz() {
     }
@@ -75,6 +77,7 @@ public Baz build() {
     }
 
     public static final class Moo extends Message {
+      private static final long serialVersionUID = 0L;
 
       public static final String DEFAULT_BOO = "";
 
diff --git a/wire-runtime/src/test/java/com/squareup/foobar/protos/foo/Foo.java b/wire-runtime/src/test/java/com/squareup/foobar/protos/foo/Foo.java
index 7aee61ab69..204a621ded 100755
--- a/wire-runtime/src/test/java/com/squareup/foobar/protos/foo/Foo.java
+++ b/wire-runtime/src/test/java/com/squareup/foobar/protos/foo/Foo.java
@@ -7,6 +7,7 @@
 import com.squareup.wire.ProtoField;
 
 public final class Foo extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1)
   public final Bar.Baz.Moo moo;
diff --git a/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataRequest.java b/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataRequest.java
index 030b4c0201..06bb65d965 100755
--- a/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataRequest.java
+++ b/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataRequest.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class HeresAllTheDataRequest extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_DATA = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataResponse.java b/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataResponse.java
index 37d8bb9067..94ffeb4726 100755
--- a/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataResponse.java
+++ b/wire-runtime/src/test/java/com/squareup/services/HeresAllTheDataResponse.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class HeresAllTheDataResponse extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_DATA = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/services/LetsDataRequest.java b/wire-runtime/src/test/java/com/squareup/services/LetsDataRequest.java
index 152422b123..e35e8e8baa 100755
--- a/wire-runtime/src/test/java/com/squareup/services/LetsDataRequest.java
+++ b/wire-runtime/src/test/java/com/squareup/services/LetsDataRequest.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class LetsDataRequest extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_DATA = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/services/LetsDataResponse.java b/wire-runtime/src/test/java/com/squareup/services/LetsDataResponse.java
index 855fd64019..12df0f148e 100755
--- a/wire-runtime/src/test/java/com/squareup/services/LetsDataResponse.java
+++ b/wire-runtime/src/test/java/com/squareup/services/LetsDataResponse.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class LetsDataResponse extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_DATA = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataRequest.java b/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataRequest.java
index 615561f204..5f0cde6f41 100755
--- a/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataRequest.java
+++ b/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataRequest.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class SendDataRequest extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_DATA = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataResponse.java b/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataResponse.java
index fc72b8c381..d9a9c5708b 100755
--- a/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataResponse.java
+++ b/wire-runtime/src/test/java/com/squareup/services/anotherpackage/SendDataResponse.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class SendDataResponse extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_DATA = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/SerializableTest.java b/wire-runtime/src/test/java/com/squareup/wire/SerializableTest.java
index 91da926d7c..0cb741b4c9 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/SerializableTest.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/SerializableTest.java
@@ -58,9 +58,9 @@
         .result("tacos")
         .build();
     ByteString goldenSerialized = ByteString.decodeBase64("rO0ABXNyACdjb20uc3F1YXJldXAud2lyZS5NZXNz"
-        + "YWdlU2VyaWFsaXplZEZvcm23LJyGlF0W+QIAAlsABWJ5dGVzdAACW0JMAAxtZXNzYWdlQ2xhc3N0ABFMamF2YS9s"
+        + "YWdlU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAlsABWJ5dGVzdAACW0JMAAxtZXNzYWdlQ2xhc3N0ABFMamF2YS9s"
         + "YW5nL0NsYXNzO3hwdXIAAltCrPMX+AYIVOACAAB4cAAAAAkoY1IFdGFjb3N2cgAtY29tLnNxdWFyZXVwLndpcmUu"
-        + "cHJvdG9zLnNpbXBsZS5TaW1wbGVNZXNzYWdlEFlfVMiFFIECAAxMAAhfcGFja2FnZXQAEkxqYXZhL2xhbmcvU3Ry"
+        + "cHJvdG9zLnNpbXBsZS5TaW1wbGVNZXNzYWdlAAAAAAAAAAACAAxMAAhfcGFja2FnZXQAEkxqYXZhL2xhbmcvU3Ry"
         + "aW5nO0wAFGRlZmF1bHRfZm9yZWlnbl9lbnVtdAAuTGNvbS9zcXVhcmV1cC93aXJlL3Byb3Rvcy9mb3JlaWduL0Zv"
         + "cmVpZ25FbnVtO0wAE2RlZmF1bHRfbmVzdGVkX2VudW10ADpMY29tL3NxdWFyZXVwL3dpcmUvcHJvdG9zL3NpbXBs"
         + "ZS9TaW1wbGVNZXNzYWdlJE5lc3RlZEVudW07TAAXbm9fZGVmYXVsdF9mb3JlaWduX2VudW1xAH4ACEwAAW9xAH4A"
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/ChildPackage.java b/wire-runtime/src/test/java/com/squareup/wire/protos/ChildPackage.java
index 21e2b9f3ae..9f86d3066a 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/ChildPackage.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/ChildPackage.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.ENUM;
 
 public final class ChildPackage extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ForeignEnum DEFAULT_INNER_FOREIGN_ENUM = ForeignEnum.BAV;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/alltypes/AllTypes.java b/wire-runtime/src/test/java/com/squareup/wire/protos/alltypes/AllTypes.java
index c0e699792e..f3e64a4b14 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/alltypes/AllTypes.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/alltypes/AllTypes.java
@@ -32,6 +32,7 @@
 import static com.squareup.wire.Message.Label.REQUIRED;
 
 public final class AllTypes extends ExtendableMessage<AllTypes> {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_OPT_INT32 = 0;
   public static final Integer DEFAULT_OPT_UINT32 = 0;
@@ -1243,6 +1244,7 @@ public int getValue() {
   }
 
   public static final class NestedMessage extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final Integer DEFAULT_A = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java
index d3a921e5e5..e8f8825bcc 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java
@@ -21,6 +21,7 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class FooBar extends ExtendableMessage<FooBar> {
+  private static final long serialVersionUID = 0L;
 
   public static final FieldOptions FIELD_OPTIONS_FOO = new FieldOptions.Builder()
       .setExtension(Ext_custom_options.my_field_option_one, 17)
@@ -210,6 +211,7 @@ public FooBar build() {
   }
 
   public static final class Nested extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final FooBarBazEnum DEFAULT_VALUE = FooBarBazEnum.FOO;
 
@@ -264,6 +266,7 @@ public Nested build() {
   }
 
   public static final class More extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final List<Integer> DEFAULT_SERIAL = Collections.emptyList();
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java.noOptions b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java.noOptions
index 9b2d149bdc..5910ea4276 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java.noOptions
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/FooBar.java.noOptions
@@ -19,6 +19,7 @@ import static com.squareup.wire.Message.Datatype.UINT64;
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class FooBar extends ExtendableMessage<FooBar> {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_FOO = 0;
   public static final String DEFAULT_BAR = "";
@@ -168,6 +169,7 @@ public final class FooBar extends ExtendableMessage<FooBar> {
   }
 
   public static final class Nested extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final FooBarBazEnum DEFAULT_VALUE = FooBarBazEnum.FOO;
 
@@ -222,6 +224,7 @@ public final class FooBar extends ExtendableMessage<FooBar> {
   }
 
   public static final class More extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final List<Integer> DEFAULT_SERIAL = Collections.emptyList();
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java
index 299d0e259f..5bb0ad1e3a 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java
@@ -8,6 +8,7 @@
 import com.squareup.wire.protos.foreign.ForeignMessage;
 
 public final class MessageWithOptions extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final MessageOptions MESSAGE_OPTIONS = new MessageOptions.Builder()
       .setExtension(Ext_custom_options.my_message_option_one, new FooBar.Builder()
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java.noOptions b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java.noOptions
index 1307e1ac00..56f793fef5 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java.noOptions
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/custom_options/MessageWithOptions.java.noOptions
@@ -5,6 +5,7 @@ package com.squareup.wire.protos.custom_options;
 import com.squareup.wire.Message;
 
 public final class MessageWithOptions extends Message {
+  private static final long serialVersionUID = 0L;
 
   public MessageWithOptions() {
   }
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/NoFields.java b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/NoFields.java
index 642fbac0df..bb344439fc 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/NoFields.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/NoFields.java
@@ -5,6 +5,7 @@
 import com.squareup.wire.Message;
 
 public final class NoFields extends Message {
+  private static final long serialVersionUID = 0L;
 
   public NoFields() {
   }
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneBytesField.java b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneBytesField.java
index b69d7a2c63..7c0dc38af9 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneBytesField.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneBytesField.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.BYTES;
 
 public final class OneBytesField extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final ByteString DEFAULT_OPT_BYTES = ByteString.EMPTY;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneField.java b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneField.java
index 2345cb5083..a14324695e 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneField.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/OneField.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class OneField extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_OPT_INT32 = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/Recursive.java b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/Recursive.java
index 14aeb6baa1..c2b12929a4 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/Recursive.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/edgecases/Recursive.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class Recursive extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_VALUE = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/foreign/ForeignMessage.java b/wire-runtime/src/test/java/com/squareup/wire/protos/foreign/ForeignMessage.java
index 0cd55fc228..b76406ad4c 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/foreign/ForeignMessage.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/foreign/ForeignMessage.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class ForeignMessage extends ExtendableMessage<ForeignMessage> {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/Foo.java b/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/Foo.java
index 691d374604..615badceca 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/Foo.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/Foo.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class Foo extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_BAR = "";
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/OneExtension.java b/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/OneExtension.java
index 45e0b6186d..75fef87d29 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/OneExtension.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/one_extension/OneExtension.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class OneExtension extends ExtendableMessage<OneExtension> {
+  private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_ID = "";
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/person/Person.java b/wire-runtime/src/test/java/com/squareup/wire/protos/person/Person.java
index 89b3d6bc63..57f7e2b2cb 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/person/Person.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/person/Person.java
@@ -15,6 +15,7 @@
 import static com.squareup.wire.Message.Label.REQUIRED;
 
 public final class Person extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_NAME = "";
   public static final Integer DEFAULT_ID = 0;
@@ -161,6 +162,7 @@ public int getValue() {
   }
 
   public static final class PhoneNumber extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final String DEFAULT_NUMBER = "";
     public static final PhoneType DEFAULT_TYPE = PhoneType.HOME;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/NotRedacted.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/NotRedacted.java
index 45294689f3..a532a12dee 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/NotRedacted.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/NotRedacted.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class NotRedacted extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_A = "";
   public static final String DEFAULT_B = "";
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/Redacted.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/Redacted.java
index 5cfd426430..97013fc25d 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/Redacted.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/Redacted.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class Redacted extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final FieldOptions FIELD_OPTIONS_A = new FieldOptions.Builder()
       .setExtension(Ext_redacted_test.redacted, true)
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedChild.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedChild.java
index f47acccf00..2bf7e90486 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedChild.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedChild.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class RedactedChild extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_A = "";
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleA.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleA.java
index f087e87132..161b289ec5 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleA.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleA.java
@@ -6,6 +6,7 @@
 import com.squareup.wire.ProtoField;
 
 public final class RedactedCycleA extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1)
   public final RedactedCycleB b;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleB.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleB.java
index cd64112aca..3d5edc0ffa 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleB.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedCycleB.java
@@ -6,6 +6,7 @@
 import com.squareup.wire.ProtoField;
 
 public final class RedactedCycleB extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1)
   public final RedactedCycleA a;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRepeated.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRepeated.java
index 33fe16228d..3757c80314 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRepeated.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRepeated.java
@@ -12,6 +12,7 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class RedactedRepeated extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final FieldOptions FIELD_OPTIONS_A = new FieldOptions.Builder()
       .setExtension(Ext_redacted_test.redacted, true)
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRequired.java b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRequired.java
index 2bec4b8295..93eb0be67d 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRequired.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/redacted/RedactedRequired.java
@@ -10,6 +10,7 @@
 import static com.squareup.wire.Message.Label.REQUIRED;
 
 public final class RedactedRequired extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final FieldOptions FIELD_OPTIONS_A = new FieldOptions.Builder()
       .setExtension(Ext_redacted_test.redacted, true)
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/A.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/A.java
index 0d101631d1..b000df27b5 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/A.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/A.java
@@ -21,6 +21,7 @@
  * I -> nothing
  */
 public final class A extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1)
   public final B c;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/B.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/B.java
index 8ff47026ae..7538d627db 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/B.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/B.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Label.REQUIRED;
 
 public final class B extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1, label = REQUIRED)
   public final C c;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/C.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/C.java
index fc2ec70cc1..469f2cfd21 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/C.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/C.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class C extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/D.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/D.java
index fee4249fed..ac04fe85f7 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/D.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/D.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class D extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/E.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/E.java
index d966125219..09b9a81343 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/E.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/E.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class E extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final G DEFAULT_G = G.FOO;
 
@@ -80,6 +81,7 @@ public E build() {
   }
 
   public static final class F extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/H.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/H.java
index d304a443d7..96a516a940 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/H.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/H.java
@@ -6,6 +6,7 @@
 import com.squareup.wire.ProtoField;
 
 public final class H extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1)
   public final E.F ef;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/I.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/I.java
index 8115546fb0..095bed0f3b 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/I.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/I.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class I extends ExtendableMessage<I> {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/J.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/J.java
index e92f91ed91..f087cd88c2 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/J.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/J.java
@@ -6,6 +6,7 @@
 import com.squareup.wire.ProtoField;
 
 public final class J extends Message {
+  private static final long serialVersionUID = 0L;
 
   @ProtoField(tag = 1)
   public final K k;
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/K.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/K.java
index a2e18bd39b..a35d442adc 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/K.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/K.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class K extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheRequest.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheRequest.java
index fe8d382019..6b47007ac3 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheRequest.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheRequest.java
@@ -5,6 +5,7 @@
 import com.squareup.wire.Message;
 
 public final class TheRequest extends Message {
+  private static final long serialVersionUID = 0L;
 
   public TheRequest() {
   }
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheResponse.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheResponse.java
index c9849aa099..8a569af1e8 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheResponse.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/TheResponse.java
@@ -5,6 +5,7 @@
 import com.squareup.wire.Message;
 
 public final class TheResponse extends Message {
+  private static final long serialVersionUID = 0L;
 
   public TheResponse() {
   }
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/UnnecessaryResponse.java b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/UnnecessaryResponse.java
index dd25ab546f..2785c2f7b3 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/roots/UnnecessaryResponse.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/roots/UnnecessaryResponse.java
@@ -5,6 +5,7 @@
 import com.squareup.wire.Message;
 
 public final class UnnecessaryResponse extends Message {
+  private static final long serialVersionUID = 0L;
 
   public UnnecessaryResponse() {
   }
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/simple/ExternalMessage.java b/wire-runtime/src/test/java/com/squareup/wire/protos/simple/ExternalMessage.java
index e33faa6766..a234859752 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/simple/ExternalMessage.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/simple/ExternalMessage.java
@@ -9,6 +9,7 @@
 import static com.squareup.wire.Message.Datatype.FLOAT;
 
 public final class ExternalMessage extends ExtendableMessage<ExternalMessage> {
+  private static final long serialVersionUID = 0L;
 
   public static final Float DEFAULT_F = 20F;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/simple/SimpleMessage.java b/wire-runtime/src/test/java/com/squareup/wire/protos/simple/SimpleMessage.java
index cd72d54e1b..fcb1a757be 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/simple/SimpleMessage.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/simple/SimpleMessage.java
@@ -20,6 +20,7 @@
  * A message for testing.
  */
 public final class SimpleMessage extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_OPTIONAL_INT32 = 123;
   public static final NestedEnum DEFAULT_DEFAULT_NESTED_ENUM = NestedEnum.BAZ;
@@ -306,6 +307,7 @@ public SimpleMessage build() {
   }
 
   public static final class NestedMessage extends Message {
+    private static final long serialVersionUID = 0L;
 
     public static final Integer DEFAULT_BB = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bar.java b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bar.java
index 2ef6b8e6d5..0b101f9c69 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bar.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bar.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class Bar extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_BAZ = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bars.java b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bars.java
index 8d471305e7..e7196703d5 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bars.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Bars.java
@@ -10,6 +10,7 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class Bars extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final List<Bar> DEFAULT_BARS = Collections.emptyList();
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foo.java b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foo.java
index 72216aa267..428f4d97fd 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foo.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foo.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class Foo extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_BAR = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foos.java b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foos.java
index c35627e377..6097b5613e 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foos.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/single_level/Foos.java
@@ -10,6 +10,7 @@
 import static com.squareup.wire.Message.Label.REPEATED;
 
 public final class Foos extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final List<Foo> DEFAULT_FOOS = Collections.emptyList();
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionOne.java b/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionOne.java
index ce6566cb28..e534d4bf88 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionOne.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionOne.java
@@ -8,6 +8,7 @@
 import static com.squareup.wire.Message.Datatype.INT32;
 
 public final class VersionOne extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
 
diff --git a/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionTwo.java b/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionTwo.java
index f3900e596f..de17c5ad86 100755
--- a/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionTwo.java
+++ b/wire-runtime/src/test/java/com/squareup/wire/protos/unknownfields/VersionTwo.java
@@ -11,6 +11,7 @@
 import static com.squareup.wire.Message.Datatype.STRING;
 
 public final class VersionTwo extends Message {
+  private static final long serialVersionUID = 0L;
 
   public static final Integer DEFAULT_I = 0;
   public static final Integer DEFAULT_V2_I = 0;
