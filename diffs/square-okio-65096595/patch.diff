diff --git a/okio/src/main/java/okio/ByteString.java b/okio/src/main/java/okio/ByteString.java
index 81be905a..b2e17fa4 100644
--- a/okio/src/main/java/okio/ByteString.java
+++ b/okio/src/main/java/okio/ByteString.java
@@ -33,15 +33,17 @@
 /**
  * An immutable sequence of bytes.
  *
- * <p><strong>Full disclosure:</strong> this class provides untrusted input and
- * output streams with raw access to the underlying byte array. A hostile
- * stream implementation could keep a reference to the mutable byte string,
- * violating the immutable guarantee of this class. For this reason a byte
- * string's immutability guarantee cannot be relied upon for security in applets
- * and other environments that run both trusted and untrusted code in the same
- * process.
+ * <p>Byte strings compare lexicographically as a sequence of <strong>unsigned</strong> bytes. That
+ * is, the byte string {@code ff} sorts after {@code 00}. This is counter to the sort order of the
+ * corresponding bytes, where {@code -1} sorts before {@code 0}.
+ *
+ * <p><strong>Full disclosure:</strong> this class provides untrusted input and output streams with
+ * raw access to the underlying byte array. A hostile stream implementation could keep a reference
+ * to the mutable byte string, violating the immutable guarantee of this class. For this reason a
+ * byte string's immutability guarantee cannot be relied upon for security in applets and other
+ * environments that run both trusted and untrusted code in the same process.
  */
-public class ByteString implements Serializable {
+public class ByteString implements Serializable, Comparable<ByteString> {
   static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
   private static final long serialVersionUID = 1L;
@@ -331,6 +333,19 @@ public boolean rangeEquals(int offset, byte[] other, int otherOffset, int byteCo
     return result != 0 ? result : (hashCode = Arrays.hashCode(data));
   }
 
+  @Override public int compareTo(ByteString byteString) {
+    int sizeA = size();
+    int sizeB = byteString.size();
+    for (int i = 0, size = Math.min(sizeA, sizeB); i < size; i++) {
+      int byteA = getByte(i) & 0xff;
+      int byteB = byteString.getByte(i) & 0xff;
+      if (byteA == byteB) continue;
+      return byteA < byteB ? -1 : 1;
+    }
+    if (sizeA == sizeB) return 0;
+    return sizeA < sizeB ? -1 : 1;
+  }
+
   @Override public String toString() {
     if (data.length == 0) {
       return "ByteString[size=0]";
diff --git a/okio/src/test/java/okio/ByteStringTest.java b/okio/src/test/java/okio/ByteStringTest.java
index 2835edbf..68a29746 100644
--- a/okio/src/test/java/okio/ByteStringTest.java
+++ b/okio/src/test/java/okio/ByteStringTest.java
@@ -18,6 +18,11 @@
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
 import org.junit.Test;
 
 import static okio.TestUtil.assertByteArraysEquals;
@@ -29,7 +34,6 @@
 import static org.junit.Assert.fail;
 
 public class ByteStringTest {
-
   @Test public void ofCopyRange() {
     byte[] bytes = "Hello, World!".getBytes(Util.UTF_8);
     ByteString byteString = ByteString.of(bytes, 2, 9);
@@ -269,4 +273,58 @@
     ByteString byteString = ByteString.of();
     assertEquivalent(byteString, TestUtil.reserialize(byteString));
   }
+
+  @Test public void compareToSingleBytes() throws Exception {
+    List<ByteString> originalByteStrings = Arrays.asList(
+        ByteString.decodeHex("00"),
+        ByteString.decodeHex("01"),
+        ByteString.decodeHex("7e"),
+        ByteString.decodeHex("7f"),
+        ByteString.decodeHex("80"),
+        ByteString.decodeHex("81"),
+        ByteString.decodeHex("fe"),
+        ByteString.decodeHex("ff"));
+
+    List<ByteString> sortedByteStrings = new ArrayList<>(originalByteStrings);
+    Collections.shuffle(sortedByteStrings, new Random(0));
+    Collections.sort(sortedByteStrings);
+
+    assertEquals(originalByteStrings, sortedByteStrings);
+  }
+
+  @Test public void compareToMultipleBytes() throws Exception {
+    List<ByteString> originalByteStrings = Arrays.asList(
+        ByteString.decodeHex(""),
+        ByteString.decodeHex("00"),
+        ByteString.decodeHex("0000"),
+        ByteString.decodeHex("000000"),
+        ByteString.decodeHex("00000000"),
+        ByteString.decodeHex("0000000000"),
+        ByteString.decodeHex("0000000001"),
+        ByteString.decodeHex("000001"),
+        ByteString.decodeHex("00007f"),
+        ByteString.decodeHex("0000ff"),
+        ByteString.decodeHex("000100"),
+        ByteString.decodeHex("000101"),
+        ByteString.decodeHex("007f00"),
+        ByteString.decodeHex("00ff00"),
+        ByteString.decodeHex("010000"),
+        ByteString.decodeHex("010001"),
+        ByteString.decodeHex("01007f"),
+        ByteString.decodeHex("0100ff"),
+        ByteString.decodeHex("010100"),
+        ByteString.decodeHex("01010000"),
+        ByteString.decodeHex("0101000000"),
+        ByteString.decodeHex("0101000001"),
+        ByteString.decodeHex("010101"),
+        ByteString.decodeHex("7f0000"),
+        ByteString.decodeHex("7f0000ffff"),
+        ByteString.decodeHex("ffffff"));
+
+    List<ByteString> sortedByteStrings = new ArrayList<>(originalByteStrings);
+    Collections.shuffle(sortedByteStrings, new Random(0));
+    Collections.sort(sortedByteStrings);
+
+    assertEquals(originalByteStrings, sortedByteStrings);
+  }
 }
