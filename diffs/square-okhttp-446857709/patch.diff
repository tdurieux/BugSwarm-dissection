diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/DuplexResponseBody.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/DuplexResponseBody.java
new file mode 100644
index 000000000..b64ed5c5b
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/DuplexResponseBody.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+import java.io.IOException;
+import okhttp3.HttpSink;
+import okhttp3.internal.http2.Header;
+import okio.BufferedSource;
+
+public interface DuplexResponseBody {
+  Header.Listener onRequest(
+      RecordedRequest request,
+      BufferedSource requestBodySource,
+      HttpSink responseBodySink) throws IOException;
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 36457229e..49931b3df 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -49,6 +49,7 @@
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
   private WebSocketListener webSocketListener;
+  private DuplexResponseBody duplexResponseBody;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
@@ -155,6 +156,14 @@ public MockResponse removeHeader(String name) {
     return this;
   }
 
+  public boolean isDuplex() {
+    return duplexResponseBody != null;
+  }
+
+  public DuplexResponseBody getDuplexResponseBody() {
+    return duplexResponseBody;
+  }
+
   /** Returns a copy of the raw HTTP payload. */
   public Buffer getBody() {
     return body != null ? body.clone() : null;
@@ -171,6 +180,11 @@ public MockResponse setBody(String body) {
     return setBody(new Buffer().writeUtf8(body));
   }
 
+  public MockResponse setBody(DuplexResponseBody duplexResponseBody) {
+    this.duplexResponseBody = duplexResponseBody;
+    return this;
+  }
+
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index d2a532dd6..a1257c73e 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -52,6 +52,7 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Headers;
+import okhttp3.HttpSink;
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -924,7 +925,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
         socket.close();
         return;
       }
-      writeResponse(stream, response);
+      writeResponse(stream, request, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
             + " and responded: " + response + " protocol is " + protocol.toString());
@@ -962,7 +963,9 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       Headers headers = httpHeaders.build();
 
       MockResponse peek = dispatcher.peek();
-      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
+      if (peek.isDuplex()) {
+        readBody = false;
+      } else if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
         stream.writeHeaders(Collections.singletonList(
             new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
         stream.getConnection().flush();
@@ -984,7 +987,8 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
+    private void writeResponse(final Http2Stream stream,
+        final RecordedRequest request, final MockResponse response) throws IOException {
       Settings settings = response.getSettings();
       if (settings != null) {
         stream.getConnection().setSettings(settings);
@@ -1008,20 +1012,46 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
       sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
 
       Buffer body = response.getBody();
-      boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.writeHeaders(http2Headers, closeStreamAfterHeaders);
-      pushPromises(stream, response.getPushPromises());
+      boolean hasResponseBody = body != null
+          || !response.getPushPromises().isEmpty()
+          || response.isDuplex();
+      stream.writeHeaders(http2Headers, hasResponseBody);
+      pushPromises(stream, request, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
         sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
         throttledTransfer(response, socket, body, sink, body.size(), false);
         sink.close();
-      } else if (closeStreamAfterHeaders) {
+      } else if (response.isDuplex()) {
+        final BufferedSink sink = Okio.buffer(stream.getSink());
+        final BufferedSource source = Okio.buffer(stream.getSource());
+        final DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
+        Header.Listener headersListener =
+            duplexResponseBody.onRequest(request, source, new HttpSink() {
+              @Override public BufferedSink sink() {
+                return sink;
+              }
+
+              @Override public void headers(Headers headers) throws IOException {
+                List<Header> headerList = new ArrayList<>(headers.size() / 2);
+                for (int i = 0, size = headers.size(); i < size; i++) {
+                  headerList.add(new Header(headers.name(i), headers.value(i)));
+                }
+                stream.writeHeaders(headerList, true);
+              }
+
+              @Override public void close() throws IOException {
+                sink.close();
+              }
+            });
+        stream.setHeadersListener(headersListener);
+      } else if (hasResponseBody) {
         stream.close(ErrorCode.NO_ERROR);
       }
     }
 
-    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(Http2Stream stream, RecordedRequest request,
+        List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
@@ -1038,7 +1068,7 @@ private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws
         boolean hasBody = pushPromise.response().getBody() != null;
         Http2Stream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, pushPromise.response());
+        writeResponse(pushedStream, request, pushPromise.response());
       }
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
new file mode 100644
index 000000000..69fcf4047
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.internal.RecordingHeadersListener;
+import okhttp3.internal.http2.Header;
+import okhttp3.mockwebserver.DuplexResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
+import okio.BufferedSource;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static junit.framework.TestCase.assertTrue;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertEquals;
+
+public final class DuplexTest {
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = defaultClient();
+
+  @Test public void clientReadsHeadersDataHeadersData() throws IOException {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setBody(new DuplexResponseBody() {
+          @Override public Header.Listener onRequest(RecordedRequest request,
+              BufferedSource requestBodySource, HttpSink responseBodySink) throws IOException {
+            responseBodySink.sink().writeUtf8("staten");
+            responseBodySink.sink().flush();
+
+            responseBodySink.headers(Headers.of("brooklyn", "zoo"));
+            responseBodySink.sink().writeUtf8(" island");
+            responseBodySink.sink().flush();
+
+            responseBodySink.headers(Headers.of("toronto", "aquarium"));
+            responseBodySink.sink().close();
+
+            return null;
+          }
+        }));
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .duplex("POST")
+        .build());
+
+    Response response = call.execute();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+    response.headersListener(headersListener);
+
+    BufferedSource source = response.body().source();
+    assertEquals("staten island", source.readUtf8());
+
+    assertEquals(Headers.of("h1", "v1", "h2", "v2"), response.headers());
+
+    assertEquals(Arrays.asList(Headers.of("brooklyn", "zoo"), Headers.of("toronto", "aquarium")),
+        headersListener.takeAll());
+    assertTrue(source.exhausted());
+  }
+
+  @Test public void serverReadsHeadersDataHeadersData() throws IOException {
+    final RecordingHeadersListener serverHeadersListener = new RecordingHeadersListener();
+    final AtomicReference<BufferedSource> requestBodySourceRef = new AtomicReference<>();
+
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setBody(new DuplexResponseBody() {
+          @Override public Header.Listener onRequest(RecordedRequest request,
+              BufferedSource requestBodySource, HttpSink responseBodySink) throws IOException {
+            responseBodySink.sink().close();
+
+            requestBodySourceRef.set(requestBodySource);
+            return serverHeadersListener;
+          }
+        }));
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .duplex("POST")
+        .build());
+
+    Response response = call.execute();
+    HttpSink httpSink = response.httpSink();
+    httpSink.sink().writeUtf8("hey\n");
+    httpSink.headers(Headers.of("a", "android"));
+    httpSink.sink().writeUtf8("whats going on\n");
+    httpSink.headers(Headers.of("b", "blackberry"));
+    httpSink.sink().close();
+
+    // check what the server received
+    BufferedSource requestBodySource = requestBodySourceRef.get();
+    assertEquals("hey", requestBodySource.readUtf8Line());
+    assertEquals("whats going on", requestBodySource.readUtf8Line());
+    assertTrue(requestBodySource.exhausted());
+    assertEquals(Arrays.asList(Headers.of("a", "android"), Headers.of("b", "blackberry")),
+        serverHeadersListener.takeAll());
+  }
+
+  // TODO(oldergod) write tests for headers discarded with 100 Continue
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingHeadersListener.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingHeadersListener.java
new file mode 100644
index 000000000..ee25208ca
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingHeadersListener.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.Headers;
+import okhttp3.internal.http2.Header;
+
+public final class RecordingHeadersListener implements Header.Listener {
+  final ArrayDeque<Headers> receivedHeaders = new ArrayDeque<>();
+
+  @Override public void onHeaders(Headers headers) {
+    receivedHeaders.add(headers);
+  }
+
+  public List<Headers> takeAll() {
+    List<Headers> result = new ArrayList<>();
+    for (Headers headers; (headers = receivedHeaders.poll()) != null; ) {
+      result.add(headers);
+    }
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index ea5b8ed60..4b7b585cc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.Socket;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -26,6 +25,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import okhttp3.Headers;
+import okhttp3.internal.RecordingHeadersListener;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.MockHttp2Peer.InFrame;
 import okio.AsyncTimeout;
@@ -542,22 +542,6 @@
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
-  static final class RecordingHeadersListener implements Header.Listener {
-    final ArrayDeque<Headers> receivedHeaders = new ArrayDeque<>();
-
-    @Override public void onHeaders(Headers headers) {
-      receivedHeaders.add(headers);
-    }
-
-    public List<Headers> takeAll() {
-      List<Headers> result = new ArrayList<>();
-      for (Headers headers; (headers = receivedHeaders.poll()) != null; ) {
-        result.add(headers);
-      }
-      return result;
-    }
-  }
-
   @Test public void clientReadsHeadersDataHeadersData() throws Exception {
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
diff --git a/okhttp/src/main/java/okhttp3/HttpSink.java b/okhttp/src/main/java/okhttp3/HttpSink.java
new file mode 100644
index 000000000..c08d90b05
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HttpSink.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.Closeable;
+import java.io.IOException;
+import okio.BufferedSink;
+
+public interface HttpSink extends Closeable {
+  BufferedSink sink();
+  void headers(Headers headers) throws IOException;
+}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 9272828aa..d7a40ecf0 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -37,11 +37,12 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.platform.Platform;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
@@ -190,6 +191,10 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return RealCall.newRealCall(client, originalRequest, true);
       }
+
+      @Override public void setHttp2Codec(Response.Builder builder, Http2Codec http2Codec) {
+        builder.http2Codec(http2Codec);
+      }
     };
   }
 
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index df0bebd02..1da4fb4a3 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -33,6 +33,7 @@
   final String method;
   final Headers headers;
   final @Nullable RequestBody body;
+  final boolean duplex;
   final Map<Class<?>, Object> tags;
 
   private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
@@ -42,6 +43,7 @@
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
+    this.duplex = builder.duplex;
     this.tags = Util.immutableMap(builder.tags);
   }
 
@@ -69,6 +71,10 @@ public Headers headers() {
     return body;
   }
 
+  public boolean isDuplex() {
+    return duplex;
+  }
+
   /**
    * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
    * that key.
@@ -121,6 +127,7 @@ public boolean isHttps() {
     String method;
     Headers.Builder headers;
     @Nullable RequestBody body;
+    boolean duplex;
 
     /** A mutable map of tags, or an immutable empty map if we don't have any. */
     Map<Class<?>, Object> tags = Collections.emptyMap();
@@ -134,6 +141,7 @@ public Builder() {
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
+      this.duplex = request.duplex;
       this.tags = request.tags.isEmpty()
           ? Collections.<Class<?>, Object>emptyMap()
           : new LinkedHashMap<>(request.tags);
@@ -259,6 +267,19 @@ public Builder method(String method, @Nullable RequestBody body) {
       }
       this.method = method;
       this.body = body;
+      this.duplex = false;
+      return this;
+    }
+
+    public Builder duplex(String method) {
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
+      if (!HttpMethod.permitsRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
+      this.method = method;
+      this.body = null;
+      this.duplex = true;
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 9c4951e6a..8235b5fd1 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -21,6 +21,8 @@
 import java.util.List;
 import javax.annotation.Nullable;
 import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Codec;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -46,13 +48,15 @@
   final int code;
   final String message;
   final @Nullable Handshake handshake;
-  final Headers headers;
+  @Nullable Headers headers;
   final @Nullable ResponseBody body;
   final @Nullable Response networkResponse;
   final @Nullable Response cacheResponse;
   final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
+  final HttpSink httpSink;
+  final @Nullable Http2Codec http2Codec;
 
   private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
@@ -69,6 +73,8 @@
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
+    this.httpSink = builder.httpSink;
+    this.http2Codec = builder.http2Codec;
   }
 
   /**
@@ -136,6 +142,14 @@ public Headers headers() {
     return headers;
   }
 
+  /**
+   * Should work for any trailers actually right?
+   */
+  public synchronized void headersListener(Header.Listener listener) {
+    if (http2Codec == null) throw new IllegalStateException("http2Codec == null");
+    http2Codec.setHeadersListener(listener);
+  }
+
   /**
    * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
    * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
@@ -301,11 +315,15 @@ public long receivedResponseAtMillis() {
         + '}';
   }
 
+  public HttpSink httpSink() {
+    return httpSink;
+  }
+
   public static class Builder {
     @Nullable Request request;
     @Nullable Protocol protocol;
     int code = -1;
-    String message;
+    @Nullable String message;
     @Nullable Handshake handshake;
     Headers.Builder headers;
     @Nullable ResponseBody body;
@@ -314,6 +332,8 @@ public long receivedResponseAtMillis() {
     @Nullable Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
+    @Nullable HttpSink httpSink;
+    @Nullable Http2Codec http2Codec;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -332,6 +352,8 @@ public Builder() {
       this.priorResponse = response.priorResponse;
       this.sentRequestAtMillis = response.sentRequestAtMillis;
       this.receivedResponseAtMillis = response.receivedResponseAtMillis;
+      this.httpSink = response.httpSink;
+      this.http2Codec = response.http2Codec;
     }
 
     public Builder request(Request request) {
@@ -439,6 +461,16 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
+    public Builder httpSink(@Nullable HttpSink httpSink) {
+      this.httpSink = httpSink;
+      return this;
+    }
+
+    Builder http2Codec(@Nullable Http2Codec http2Codec) {
+      this.http2Codec = http2Codec;
+      return this;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 4bb228275..bf40d969d 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -30,6 +30,7 @@
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.Http2Codec;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -74,4 +75,6 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
   public abstract StreamAllocation streamAllocation(Call call);
 
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
+
+  public abstract void setHttp2Codec(Response.Builder builder, Http2Codec http2Codec);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 62531aa51..5bac7207b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,12 +17,19 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.Headers;
+import okhttp3.HttpSink;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Codec;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -38,8 +45,8 @@ public CallServerInterceptor(boolean forWebSocket) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    HttpCodec httpCodec = realChain.httpStream();
+    final RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    final HttpCodec httpCodec = realChain.httpStream();
     StreamAllocation streamAllocation = realChain.streamAllocation();
     RealConnection connection = (RealConnection) realChain.connection();
     Request request = realChain.request();
@@ -50,8 +57,10 @@ public CallServerInterceptor(boolean forWebSocket) {
     httpCodec.writeRequestHeaders(request);
     realChain.eventListener().requestHeadersEnd(realChain.call(), request);
 
+    HttpSink httpSink = null;
     Response.Builder responseBuilder = null;
-    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+    if (HttpMethod.permitsRequestBody(request.method())
+        && (request.body() != null || request.isDuplex())) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
       // Continue" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
@@ -62,17 +71,43 @@ public CallServerInterceptor(boolean forWebSocket) {
       }
 
       if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
-        realChain.eventListener().requestBodyStart(realChain.call());
-        long contentLength = request.body().contentLength();
-        CountingSink requestBodyOut =
-            new CountingSink(httpCodec.createRequestBody(request, contentLength));
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-        realChain.eventListener()
-            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+        if (request.isDuplex()) {
+          // Prepare a duplex body so that the application can send a request body later.
+          final CountingSink requestBodyOut =
+              new CountingSink(httpCodec.createRequestBody(request, -1L));
+          final BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+          httpSink = new HttpSink() {
+            @Override public BufferedSink sink() {
+              return bufferedRequestBody;
+            }
+
+            @Override public void headers(Headers headers) throws IOException {
+              List<Header> headerBlock = new ArrayList<>(headers.size() / 2);
+              for (int i = 0, size = headers.size(); i < size; i++) {
+                headerBlock.add(new Header(headers.name(i), headers.value(i)));
+              }
+              ((Http2Codec) httpCodec).writeRequestHeaders(headerBlock);
+            }
+
+            @Override public void close() throws IOException {
+              bufferedRequestBody.close();
+              realChain.eventListener()
+                  .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+            }
+          };
+        } else {
+          // Write the request body if the "Expect: 100-continue" expectation was met.
+          realChain.eventListener().requestBodyStart(realChain.call());
+          long contentLength = request.body().contentLength();
+          CountingSink requestBodyOut =
+              new CountingSink(httpCodec.createRequestBody(request, contentLength));
+          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+          request.body().writeTo(bufferedRequestBody);
+          bufferedRequestBody.close();
+          realChain.eventListener()
+              .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+        }
       } else if (!connection.isMultiplexed()) {
         // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
         // from being reused. Otherwise we're still obligated to transmit the request body to
@@ -81,7 +116,11 @@ public CallServerInterceptor(boolean forWebSocket) {
       }
     }
 
-    httpCodec.finishRequest();
+    if (request.isDuplex()) {
+      httpCodec.flushRequest();
+    } else {
+      httpCodec.finishRequest();
+    }
 
     if (responseBuilder == null) {
       realChain.eventListener().responseHeadersStart(realChain.call());
@@ -93,6 +132,7 @@ public CallServerInterceptor(boolean forWebSocket) {
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
+        .httpSink(httpSink)
         .build();
 
     int code = response.code();
@@ -102,15 +142,22 @@ public CallServerInterceptor(boolean forWebSocket) {
       responseBuilder = httpCodec.readResponseHeaders(false);
 
       response = responseBuilder
-              .request(request)
-              .handshake(streamAllocation.connection().handshake())
-              .sentRequestAtMillis(sentRequestMillis)
-              .receivedResponseAtMillis(System.currentTimeMillis())
-              .build();
+          .request(request)
+          .handshake(streamAllocation.connection().handshake())
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .httpSink(httpSink)
+          .build();
 
       code = response.code();
     }
 
+    if (request.isDuplex()) {
+      Response.Builder builder = response.newBuilder();
+      Internal.instance.setHttp2Codec(builder, (Http2Codec) httpCodec);
+      response = builder.build();
+    }
+
     realChain.eventListener()
             .responseHeadersEnd(realChain.call(), response);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 52f988089..16d5e63ea 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -162,6 +162,11 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
           "interceptor " + interceptor + " returned a response with no body");
     }
 
+    if (request.isDuplex() && response.httpSink() == null) {
+      throw new IllegalStateException(
+          "interceptor " + interceptor + " returned a response with no httpSink");
+    }
+
     return response;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 362570a2b..37b699a18 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -79,7 +79,7 @@ public Header(ByteString name, ByteString value) {
   }
 
   // TODO(jwilson): move this to Headers?
-  interface Listener {
+  public interface Listener {
     void onHeaders(Headers headers);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 9a81d536f..15b78043a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -112,13 +112,24 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   @Override public void writeRequestHeaders(Request request) throws IOException {
     if (stream != null) return;
 
-    boolean hasRequestBody = request.body() != null;
+    boolean hasRequestBody = request.body() != null || request.isDuplex();
     List<Header> requestHeaders = http2HeadersList(request);
     stream = connection.newStream(requestHeaders, hasRequestBody);
     stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
 
+  /** Write more headers for the request. */
+  public void writeRequestHeaders(List<Header> headers) throws IOException {
+    if (stream == null) throw new IllegalStateException("stream == null");
+    stream.writeHeaders(headers, true);
+  }
+
+  public void setHeadersListener(Header.Listener headersListener) {
+    if (stream == null) throw new IllegalStateException("stream == null");
+    stream.setHeadersListener(headersListener);
+  }
+
   @Override public void flushRequest() throws IOException {
     connection.flush();
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index c391b3895..bcb5d4444 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -316,9 +316,6 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
 
   public synchronized void setHeadersListener(Header.Listener headersListener) {
     this.headersListener = headersListener;
-    if (!headersQueue.isEmpty() && headersListener != null) {
-      notifyAll(); // We now have somewhere to deliver headers!
-    }
   }
 
   /**
