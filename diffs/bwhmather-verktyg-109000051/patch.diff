diff --git a/verktyg/accept.py b/verktyg/accept/__init__.py
similarity index 95%
rename from verktyg/accept.py
rename to verktyg/accept/__init__.py
index b65662e..57287c2 100644
--- a/verktyg/accept.py
+++ b/verktyg/accept/__init__.py
@@ -11,11 +11,16 @@
 """
 import functools
 
-from verktyg.http import (
-    parse_content_type_header, parse_language_header, parse_charset_header,
-    parse_accept_header, parse_accept_language_header,
-    parse_accept_charset_header,
+from verktyg.accept.content_type import (
+    parse_content_type_header, parse_accept_header
 )
+from verktyg.accept.language import (
+    parse_language_header, parse_accept_language_header,
+)
+from verktyg.accept.charset import (
+    parse_charset_header, parse_accept_charset_header,
+)
+
 from verktyg.exceptions import NotAcceptable
 
 
diff --git a/verktyg/accept/_base.py b/verktyg/accept/_base.py
new file mode 100644
index 0000000..6c0a57c
--- /dev/null
+++ b/verktyg/accept/_base.py
@@ -0,0 +1,246 @@
+"""
+    verktyg.accept._base
+    ~~~~~~~~~~~~~~~~~~~~
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+import re
+import functools
+
+from verktyg.datastructures import ImmutableDict
+from verktyg.exceptions import NotAcceptable
+
+
+_token_re_str = r'''
+    (?:
+        [a-zA-Z0-9]+
+        (?:
+            - [a-zA-Z0-9]+
+        )*
+    )
+'''
+
+# TODO
+_value_re = re.compile(
+    r'''
+        ^
+        {token} | \*
+        $
+    '''.format(token=_token_re_str), re.VERBOSE
+)
+
+# TODO
+_content_type_value_re = re.compile(
+    r'''
+        ^
+        (?: {token} | \*)
+        /
+        (?:
+            (?:
+                (?:{token} \.)?
+                {token}
+                (?: \+ {token})?
+            ) | \*
+        )
+    '''.format(token=_token_re_str), re.VERBOSE
+)
+
+
+# TODO better name
+class Value(object):
+    """Base class for a value that the server to be proposed during content
+    negotiation.
+    """
+    match_type = None
+
+    def __init__(self, value, *, qs=None):
+        self.value = value
+        self.qs = qs
+
+    def _acceptability_for_option(self, option):
+        if option.value == '*':
+            exact_match = False
+        elif self.value == option.value:
+            exact_match = True
+        else:
+            raise NotAcceptable()
+
+        return self.match_type(
+            self, exact_match=exact_match,
+            q=option.q, qs=self.qs
+        )
+
+    def acceptability(self, accept):
+        best_match = None
+
+        for option in accept:
+            try:
+                match = self._acceptability_for_option(option)
+            except NotAcceptable:
+                pass
+            else:
+                if best_match is None or match > best_match:
+                    best_match = match
+
+        if best_match is None:
+            raise NotAcceptable()
+
+        return best_match
+
+    def __str__(self):
+        return self.to_header()
+
+    def to_header(self):
+        """Returns a string suitable for use in the corresponding header
+        """
+        return self.value
+
+
+class Range(object):
+    def __init__(self, value, q=1.0, params=None):
+        self._validate_value(value)
+        self.value = value
+
+        self.q = max(min(float(q), 1.0), 0.0)
+
+        if params is None:
+            params = {}
+        for param in params.items():
+            self._validate_param(*param)
+        self.params = ImmutableDict(params)
+
+    def _validate_value(self, value):
+        if _value_re.match(value) is None:
+            raise ValueError("Invalid value: %r" % value)
+
+    def _validate_param(self, key, value):
+        return
+
+    def __repr__(self):
+        return '{name}(value={value!r}, q={q!r}, params={params!r})'.format(
+            name=self.__class__.__name__,
+            value=self.value,
+            q=self.q,
+            params=self.params,
+        )
+
+    def __str__(self):
+        return self.to_header()
+
+    def to_header(self):
+        header = self.value
+
+        if self.q != 1:
+            header += ';q=%s' % self.q
+
+        for param in self.params.items():
+            # TODO escaping?
+            header += ';%s=%s' % param
+
+        return header
+
+
+class Accept(object):
+    range_type = None
+
+    def __init__(self, options):
+        self._options = []
+        for option in options:
+            if isinstance(option, str):
+                option = (option,)
+
+            self._options.append(self.range_type(*option))
+
+    def __iter__(self):
+        return iter(self._options)
+
+    def __contains__(self, value):
+        try:
+            value.acceptability(self)
+        except NotAcceptable:
+            return False
+        else:
+            return True
+
+    def __getitem__(self, value):
+        try:
+            return value.acceptability(self)
+        except NotAcceptable as e:
+            raise KeyError() from e
+
+    def __repr__(self):
+        raise NotImplementedError()
+
+    def __str__(self):
+        return self.to_header()
+
+    def to_header(self):
+        """Return an equivalent string suitable for use as an `Accept` header.
+        """
+        return ','.join(option.to_header() for option in self)
+
+
+@functools.total_ordering
+class Acceptability(object):
+    def __init__(self, value, *, match_quality, q, qs=None):
+        self._value = value
+        self._match_quality = match_quality
+        self._q = q
+        self._qs = qs
+
+    @property
+    def exact_match(self):
+        return bool(self._match_quality)
+
+    @property
+    def quality(self):
+        if self._qs is not None:
+            return self._q * self._qs
+        return self._q
+
+    def __eq__(self, other):
+        if other is None:
+            return False
+
+        if self._match_quality != other._match_quality:
+            return False
+
+        if self.quality != other.quality:
+            return False
+
+        return True
+
+    def __gt__(self, other):
+        if other is None:
+            return True
+
+        if self._match_quality > other._match_quality:
+            return True
+
+        if self.quality > other.quality:
+            return True
+
+        return False
+
+
+def split_accept_string(string):
+    for accept_range in string.split(','):
+        accept, *str_params = accept_range.split(';')
+
+        params = {}
+        for param in str_params:
+            try:
+                key, value = param.split('=', 1)
+            except ValueError as e:
+                raise ValueError("invalid parameter: %r" % param) from e
+
+            key, value = key.strip(), value.strip()
+
+            params[key] = value
+
+        q = params.pop('q', '1.0')
+
+        yield accept.strip(), q, params
diff --git a/verktyg/accept/charset.py b/verktyg/accept/charset.py
new file mode 100644
index 0000000..d77abd4
--- /dev/null
+++ b/verktyg/accept/charset.py
@@ -0,0 +1,46 @@
+"""
+    verktyg.accept.charset
+    ~~~~~~~~~~~~~~~~~~~~~~
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+from verktyg.accept import _base
+
+
+class _CharsetRange(_base.Range):
+    def _validate_param(self, key, value):
+        raise ValueError("Accept-Charset header does not take parameters")
+
+
+class CharsetAccept(_base.Accept):
+    range_type = _CharsetRange
+
+
+class CharsetAcceptability(_base.Acceptability):
+    def __init__(self, value, *, exact_match, q, qs=None):
+        super(CharsetAcceptability, self).__init__(
+            value, match_quality=exact_match, q=q, qs=qs
+        )
+
+    @property
+    def charset(self):
+        return self._value
+
+    @property
+    def exact_match(self):
+        return self._match_quality
+
+
+class Charset(_base.Value):
+    match_type = CharsetAcceptability
+
+
+def parse_accept_charset_header(string):
+    return CharsetAccept(_base.split_accept_string(string))
+
+
+def parse_charset_header(string):
+    return Charset(string)
diff --git a/verktyg/accept/content_type.py b/verktyg/accept/content_type.py
new file mode 100644
index 0000000..e0c5cba
--- /dev/null
+++ b/verktyg/accept/content_type.py
@@ -0,0 +1,149 @@
+"""
+    verktyg.accept.content_type
+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+import re
+
+from verktyg.exceptions import NotAcceptable
+from verktyg.accept import _base
+
+
+_token_re_str = r'''
+    (?:
+        [a-zA-Z0-9]+
+        (?:
+            - [a-zA-Z0-9]+
+        )*
+    )
+'''
+
+# TODO
+_value_re = re.compile(
+    r'''
+        ^
+        {token} | \*
+        $
+    '''.format(token=_token_re_str), re.VERBOSE
+)
+
+# TODO
+_content_type_value_re = re.compile(
+    r'''
+        ^
+        (?: {token} | \*)
+        /
+        (?:
+            (?:
+                (?:{token} \.)?
+                {token}
+                (?: \+ {token})?
+            ) | \*
+        )
+    '''.format(token=_token_re_str), re.VERBOSE
+)
+
+
+class _ContentTypeRange(_base.Range):
+    def _validate_value(self, value):
+        if _content_type_value_re.match(value) is None:
+            raise ValueError("Invalid value: %r" % value)
+
+    @property
+    def type(self):
+        type, _ = self.value.split('/')
+        return type
+
+    @property
+    def subtype(self):
+        _, subtype = self.value.split('/')
+        return subtype
+
+
+class ContentTypeAccept(_base.Accept):
+    range_type = _ContentTypeRange
+
+
+class ContentTypeAcceptability(_base.Acceptability):
+    def __init__(
+                self, content_type, *,
+                type_matches, subtype_matches,
+                q, qs=None
+            ):
+        super(ContentTypeAcceptability, self).__init__(
+            content_type, match_quality=(
+                type_matches, subtype_matches
+            ),
+            q=q, qs=qs
+        )
+
+    @property
+    def content_type(self):
+        return self._value
+
+    @property
+    def type_matches(self):
+        return self._match_quality[0]
+
+    @property
+    def subtype_matches(self):
+        return self._match_quality[1]
+
+    @property
+    def exact_match(self):
+        return self._match_quality[0] and self._match_quality[1]
+
+
+class ContentType(_base.Value):
+    match_type = ContentTypeAcceptability
+
+    @property
+    def type(self):
+        type, _ = self.value.split('/')
+        return type
+
+    @property
+    def subtype(self):
+        _, subtype = self.value.split('/')
+        return subtype
+
+    def _acceptability_for_option(self, option):
+        if option.type == self.type:
+            type_matches = True
+        elif option.type == '*':
+            type_matches = False
+        else:
+            raise NotAcceptable()
+
+        if option.subtype == self.subtype:
+            subtype_matches = True
+        elif option.subtype == '*':
+            subtype_matches = False
+        else:
+            raise NotAcceptable()
+
+        return self.match_type(
+            self, type_matches=type_matches, subtype_matches=subtype_matches,
+            qs=self.qs, q=option.q
+        )
+
+    def to_header(self):
+        """Returns a string suitable for use as a `Content-Type` header.
+        """
+        return "%s/%s" % (self.type, self.subtype)
+
+
+def parse_accept_header(string):
+    """Creates a new `ContentTypeAccept` object from an `Accept` header string.
+    """
+    return ContentTypeAccept(_base.split_accept_string(string))
+
+
+def parse_content_type_header(string, qs=None):
+    """Creates a new `ContentType` object from a mime type string.
+    """
+    return ContentType(string, qs=qs)
diff --git a/verktyg/accept/language.py b/verktyg/accept/language.py
new file mode 100644
index 0000000..583e764
--- /dev/null
+++ b/verktyg/accept/language.py
@@ -0,0 +1,78 @@
+"""
+    verktyg.accept.language
+    ~~~~~~~~~~~~~~~~~~~~~~~
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+from verktyg.exceptions import NotAcceptable
+
+from verktyg.accept import _base
+
+
+class _LanguageRange(_base.Range):
+    def _validate_param(self, key, value):
+        raise ValueError("Accept-Language header does not take parameters")
+
+
+class LanguageAccept(_base.Accept):
+    range_type = _LanguageRange
+
+
+class LanguageAcceptability(_base.Acceptability):
+    def __init__(
+                self, content_type, *,
+                specificity, tail,
+                q, qs=None
+            ):
+        super(LanguageAcceptability, self).__init__(
+            content_type, match_quality=(-tail, specificity), q=q, qs=qs
+        )
+
+    @property
+    def language(self):
+        return self._value
+
+    @property
+    def specificity(self):
+        return self._match_quality[1]
+
+    @property
+    def tail(self):
+        return -self._match_quality[0]
+
+    @property
+    def exact_match(self):
+        return not self.tail
+
+
+class Language(_base.Value):
+    match_type = LanguageAcceptability
+
+    def _acceptability_for_option(self, option):
+        if self.value == option.value:
+            specificity = len(list(option.value.split('-')))
+            tail = 0
+        elif self.value.startswith('%s-' % option.value):
+            specificity = len(list(option.value.split('-')))
+            tail = len(list(self.value.split('-'))) - specificity
+        elif option.value == '*':
+            specificity = 0
+            tail = len(list(self.value.split('-')))
+        else:
+            raise NotAcceptable()
+
+        return self.match_type(
+            self, specificity=specificity, tail=tail,
+            qs=self.qs, q=option.q
+        )
+
+
+def parse_accept_language_header(string):
+    return LanguageAccept(_base.split_accept_string(string))
+
+
+def parse_language_header(string):
+    return Language(string)
diff --git a/verktyg/http/__init__.py b/verktyg/http/__init__.py
index 488664e..282930a 100644
--- a/verktyg/http/__init__.py
+++ b/verktyg/http/__init__.py
@@ -31,14 +31,6 @@
     is_hop_by_hop_header,
     is_byte_range_valid,
 )
-from verktyg.http.accept import (
-    ContentType, ContentTypeAccept,
-    parse_content_type_header, parse_accept_header,
-    Language, LanguageAccept,
-    parse_language_header, parse_accept_language_header,
-    Charset, CharsetAccept,
-    parse_charset_header, parse_accept_charset_header,
-)
 from verktyg.http.cache_control import (
     IfRange,
     Range,
diff --git a/verktyg/http/accept.py b/verktyg/http/accept.py
deleted file mode 100644
index 3fd71aa..0000000
--- a/verktyg/http/accept.py
+++ /dev/null
@@ -1,448 +0,0 @@
-"""
-    verktyg.http.accept
-    ~~~~~~~~~~~~~~~~~~~
-
-    :copyright:
-        (c) 2015 Ben Mather
-    :license:
-        BSD, see LICENSE for more details.
-"""
-import re
-import functools
-
-from verktyg.datastructures import ImmutableDict
-from verktyg.exceptions import NotAcceptable
-
-
-_token_re_str = r'''
-    (?:
-        [a-zA-Z0-9]+
-        (?:
-            - [a-zA-Z0-9]+
-        )*
-    )
-'''
-
-# TODO
-_value_re = re.compile(
-    r'''
-        ^
-        {token} | \*
-        $
-    '''.format(token=_token_re_str), re.VERBOSE
-)
-
-# TODO
-_content_type_value_re = re.compile(
-    r'''
-        ^
-        (?: {token} | \*)
-        /
-        (?:
-            (?:
-                (?:{token} \.)?
-                {token}
-                (?: \+ {token})?
-            ) | \*
-        )
-    '''.format(token=_token_re_str), re.VERBOSE
-)
-
-
-# TODO better name
-class _Value(object):
-    """Base class for a value that the server to be proposed during content
-    negotiation.
-    """
-    match_type = None
-
-    def __init__(self, value, *, qs=None):
-        self.value = value
-        self.qs = qs
-
-    def _acceptability_for_option(self, option):
-        if option.value == '*':
-            exact_match = False
-        elif self.value == option.value:
-            exact_match = True
-        else:
-            raise NotAcceptable()
-
-        return self.match_type(
-            self, exact_match=exact_match,
-            q=option.q, qs=self.qs
-        )
-
-    def acceptability(self, accept):
-        best_match = None
-
-        for option in accept:
-            try:
-                match = self._acceptability_for_option(option)
-            except NotAcceptable:
-                pass
-            else:
-                if best_match is None or match > best_match:
-                    best_match = match
-
-        if best_match is None:
-            raise NotAcceptable()
-
-        return best_match
-
-    def __str__(self):
-        return self.to_header()
-
-    def to_header(self):
-        """Returns a string suitable for use in the corresponding header
-        """
-        return self.value
-
-
-class _Range(object):
-    def __init__(self, value, q=1.0, params=None):
-        self._validate_value(value)
-        self.value = value
-
-        self.q = max(min(float(q), 1.0), 0.0)
-
-        if params is None:
-            params = {}
-        for param in params.items():
-            self._validate_param(*param)
-        self.params = ImmutableDict(params)
-
-    def _validate_value(self, value):
-        if _value_re.match(value) is None:
-            raise ValueError("Invalid value: %r" % value)
-
-    def _validate_param(self, key, value):
-        return
-
-    def to_header(self):
-        header = self.value
-
-        if self.q != 1:
-            header += ';q=%s' % self.q
-
-        for param in self.params.items():
-            # TODO escaping?
-            header += ';%s=%s' % param
-
-        return header
-
-
-class _Accept(object):
-    range_type = None
-
-    def __init__(self, options):
-        self._options = []
-        for option in options:
-            if isinstance(option, str):
-                option = (option,)
-
-            self._options.append(self.range_type(*option))
-
-    def __iter__(self):
-        return iter(self._options)
-
-    def __contains__(self, value):
-        try:
-            value.acceptability(self)
-        except NotAcceptable:
-            return False
-        else:
-            return True
-
-    def __getitem__(self, value):
-        try:
-            return value.acceptability(self)
-        except NotAcceptable as e:
-            raise KeyError() from e
-
-    def __repr__(self):
-        raise NotImplementedError()
-
-    def __str__(self):
-        return self.to_header()
-
-    def to_header(self):
-        """Return an equivalent string suitable for use as an `Accept` header.
-        """
-        return ','.join(option.to_header() for option in self)
-
-
-@functools.total_ordering
-class _Acceptability(object):
-    def __init__(self, value, *, match_quality, q, qs=None):
-        self._value = value
-        self._match_quality = match_quality
-        self._q = q
-        self._qs = qs
-
-    @property
-    def exact_match(self):
-        return bool(self._match_quality)
-
-    @property
-    def quality(self):
-        if self._qs is not None:
-            return self._q * self._qs
-        return self._q
-
-    def __eq__(self, other):
-        if other is None:
-            return False
-
-        if self._match_quality != other._match_quality:
-            return False
-
-        if self.quality != other.quality:
-            return False
-
-        return True
-
-    def __gt__(self, other):
-        if other is None:
-            return True
-
-        if self._match_quality > other._match_quality:
-            return True
-
-        if self.quality > other.quality:
-            return True
-
-        return False
-
-
-class _ContentTypeRange(_Range):
-    def _validate_value(self, value):
-        if _content_type_value_re.match(value) is None:
-            raise ValueError("Invalid value: %r" % value)
-
-    @property
-    def type(self):
-        type, _ = self.value.split('/')
-        return type
-
-    @property
-    def subtype(self):
-        _, subtype = self.value.split('/')
-        return subtype
-
-
-class ContentTypeAccept(_Accept):
-    range_type = _ContentTypeRange
-
-
-class ContentTypeAcceptability(_Acceptability):
-    def __init__(
-                self, content_type, *,
-                type_matches, subtype_matches,
-                q, qs=None
-            ):
-        super(ContentTypeAcceptability, self).__init__(
-            content_type, match_quality=(
-                type_matches, subtype_matches
-            ),
-            q=q, qs=qs
-        )
-
-    @property
-    def content_type(self):
-        return self._value
-
-    @property
-    def type_matches(self):
-        return self._match_quality[0]
-
-    @property
-    def subtype_matches(self):
-        return self._match_quality[1]
-
-    @property
-    def exact_match(self):
-        return self._match_quality[0] and self._match_quality[1]
-
-
-class ContentType(_Value):
-    match_type = ContentTypeAcceptability
-
-    @property
-    def type(self):
-        type, _ = self.value.split('/')
-        return type
-
-    @property
-    def subtype(self):
-        _, subtype = self.value.split('/')
-        return subtype
-
-    def _acceptability_for_option(self, option):
-        if option.type == self.type:
-            type_matches = True
-        elif option.type == '*':
-            type_matches = False
-        else:
-            raise NotAcceptable()
-
-        if option.subtype == self.subtype:
-            subtype_matches = True
-        elif option.subtype == '*':
-            subtype_matches = False
-        else:
-            raise NotAcceptable()
-
-        return self.match_type(
-            self, type_matches=type_matches, subtype_matches=subtype_matches,
-            qs=self.qs, q=option.q
-        )
-
-    def to_header(self):
-        """Returns a string suitable for use as a `Content-Type` header.
-        """
-        return "%s/%s" % (self.type, self.subtype)
-
-
-def _split_accept_string(string):
-    for accept_range in string.split(','):
-        accept, *str_params = accept_range.split(';')
-
-        params = {}
-        for param in str_params:
-            try:
-                key, value = param.split('=', 1)
-            except ValueError as e:
-                raise ValueError("invalid parameter: %r" % param) from e
-
-            key, value = key.strip(), value.strip()
-
-            params[key] = value
-
-        q = params.pop('q', '1.0')
-
-        yield accept.strip(), q, params
-
-
-def parse_accept_header(string):
-    """Creates a new `ContentTypeAccept` object from an `Accept` header string.
-    """
-    return ContentTypeAccept(_split_accept_string(string))
-
-
-def parse_content_type_header(string, qs=None):
-    """Creates a new `ContentType` object from a mime type string.
-    """
-    return ContentType(string, qs=qs)
-
-
-class _LanguageRange(_Range):
-    def _validate_param(self, key, value):
-        raise ValueError("Accept-Language header does not take parameters")
-
-
-class LanguageAccept(_Accept):
-    range_type = _LanguageRange
-
-
-class LanguageAcceptability(_Acceptability):
-    def __init__(
-                self, content_type, *,
-                specificity, tail,
-                q, qs=None
-            ):
-        super(LanguageAcceptability, self).__init__(
-            content_type, match_quality=(-tail, specificity), q=q, qs=qs
-        )
-
-    @property
-    def language(self):
-        return self._value
-
-    @property
-    def specificity(self):
-        return self._match_quality[1]
-
-    @property
-    def tail(self):
-        return -self._match_quality[0]
-
-    @property
-    def exact_match(self):
-        return not self.tail
-
-
-class Language(_Value):
-    match_type = LanguageAcceptability
-
-    def _acceptability_for_option(self, option):
-        if self.value == option.value:
-            specificity = len(list(option.value.split('-')))
-            tail = 0
-        elif self.value.startswith('%s-' % option.value):
-            specificity = len(list(option.value.split('-')))
-            tail = len(list(self.value.split('-'))) - specificity
-        elif option.value == '*':
-            specificity = 0
-            tail = len(list(self.value.split('-')))
-        else:
-            raise NotAcceptable()
-
-        return self.match_type(
-            self, specificity=specificity, tail=tail,
-            qs=self.qs, q=option.q
-        )
-
-
-def parse_accept_language_header(string):
-    return LanguageAccept(_split_accept_string(string))
-
-
-def parse_language_header(string):
-    return Language(string)
-
-
-class _CharsetRange(_Range):
-    def _validate_param(self, key, value):
-        raise ValueError("Accept-Charset header does not take parameters")
-
-
-class CharsetAccept(_Accept):
-    range_type = _CharsetRange
-
-
-class CharsetAcceptability(_Acceptability):
-    def __init__(self, value, *, exact_match, q, qs=None):
-        super(CharsetAcceptability, self).__init__(
-            value, match_quality=exact_match, q=q, qs=qs
-        )
-
-    @property
-    def charset(self):
-        return self._value
-
-    @property
-    def exact_match(self):
-        return self._match_quality
-
-
-class Charset(_Value):
-    match_type = CharsetAcceptability
-
-
-def parse_accept_charset_header(string):
-    return CharsetAccept(_split_accept_string(string))
-
-
-def parse_charset_header(string):
-    return Charset(string)
-
-
-__all__ = [
-    'ContentType', 'ContentTypeAccept',
-    'parse_content_type_header', 'parse_accept_header',
-    'Language', 'LanguageAccept',
-    'parse_language_header', 'parse_accept_language_header',
-    'Charset', 'CharsetAccept',
-    'parse_charset_header', 'parse_accept_charset_header',
-]
diff --git a/verktyg/testsuite/__init__.py b/verktyg/testsuite/__init__.py
index bc3984a..68d5810 100644
--- a/verktyg/testsuite/__init__.py
+++ b/verktyg/testsuite/__init__.py
@@ -12,8 +12,9 @@
 
 from verktyg.testsuite import (
     test_utils, test_datastructures, test_exceptions, test_http,
-    test_http_accept, test_wsgi, test_requests, test_responses, test_routing,
-    test_dispatch, test_accept, test_views, test_application,
+    test_accept_content_type, test_accept_language, test_accept_charset,
+    test_accept, test_wsgi, test_requests, test_responses, test_routing,
+    test_dispatch,  test_views, test_application,
 )
 
 
@@ -23,12 +24,14 @@
     loader.loadTestsFromModule(test_datastructures),
     loader.loadTestsFromModule(test_exceptions),
     loader.loadTestsFromModule(test_http),
-    loader.loadTestsFromModule(test_http_accept),
     loader.loadTestsFromModule(test_wsgi),
     loader.loadTestsFromModule(test_requests),
     loader.loadTestsFromModule(test_responses),
     loader.loadTestsFromModule(test_routing),
     loader.loadTestsFromModule(test_dispatch),
+    loader.loadTestsFromModule(test_accept_content_type),
+    loader.loadTestsFromModule(test_accept_language),
+    loader.loadTestsFromModule(test_accept_charset),
     loader.loadTestsFromModule(test_accept),
     loader.loadTestsFromModule(test_views),
     loader.loadTestsFromModule(test_application),
diff --git a/verktyg/testsuite/test_accept.py b/verktyg/testsuite/test_accept.py
index b224558..0938815 100644
--- a/verktyg/testsuite/test_accept.py
+++ b/verktyg/testsuite/test_accept.py
@@ -9,14 +9,15 @@
 """
 import unittest
 
-from verktyg import http
 from verktyg.exceptions import NotAcceptable
-from verktyg.accept import Representation, select_representation
+from verktyg.accept import (
+    Representation, select_representation, parse_accept_header,
+)
 
 
 class RepresentationTestCase(unittest.TestCase):
     def test_content_type_dispatch(self):
-        accept = http.parse_accept_header(
+        accept = parse_accept_header(
             'text/xml,'
             'application/xml,'
             'application/xhtml+xml,'
@@ -79,7 +80,7 @@ def test_not_acceptable(self):
         self.assertRaises(
             NotAcceptable,
             pdf_repr.acceptability,
-            accept=http.parse_accept_header('text/html')
+            accept=parse_accept_header('text/html')
         )
 
         self.assertRaises(
diff --git a/verktyg/testsuite/test_accept_charset.py b/verktyg/testsuite/test_accept_charset.py
new file mode 100644
index 0000000..f4c723a
--- /dev/null
+++ b/verktyg/testsuite/test_accept_charset.py
@@ -0,0 +1,141 @@
+"""
+    verktyg.testsuite.test_accept_charset
+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    Tests for HTTP accept header parsing utilities.
+
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+import unittest
+
+from verktyg.accept.charset import (
+    parse_charset_header, parse_accept_charset_header,
+    Charset, CharsetAccept,
+)
+from verktyg.exceptions import NotAcceptable
+
+
+class CharsetTestCase(unittest.TestCase):
+    def test_parse_accept_basic(self):
+        accept = parse_accept_charset_header(
+            'iso-8859-5'
+        )
+
+        range_ = next(iter(accept))
+        self.assertEqual('iso-8859-5', range_.value)
+        self.assertEqual(1, range_.q)
+
+    def test_parse_accept_q(self):
+        accept = parse_accept_charset_header(
+            'ascii;q=0.5',
+        )
+
+        range_ = next(iter(accept))
+        self.assertEqual('ascii', range_.value)
+        self.assertEqual(0.5, range_.q)
+
+    def test_parse_accept_params(self):
+        with self.assertRaises(ValueError):
+            parse_accept_charset_header(
+                'utf-8;orange=black'
+            )
+
+    def test_parse_accept_multiple(self):
+        accept = parse_accept_charset_header(
+            'utf-8,'
+            'ascii;q=0.5,'
+            '*;q=0.1'
+        )
+
+        self.assertEqual(3, len(list(accept)))
+
+    def test_parse(self):
+        charset = parse_charset_header('utf-8')
+        self.assertEqual('utf-8', charset.value)
+
+    def test_serialize(self):
+        charset = Charset('iso-8859-1', qs=0.5)
+        self.assertEqual('iso-8859-1', charset.to_header())
+
+    def test_serialize_accept(self):
+        accept = CharsetAccept(['ascii'])
+        self.assertEqual(accept.to_header(), 'ascii')
+
+    def test_serialize_accept_with_q(self):
+        accept = CharsetAccept([('utf-8', '0.5')])
+        self.assertEqual(accept.to_header(), 'utf-8;q=0.5')
+
+    def test_serialize_accept_redundant_q(self):
+        accept = CharsetAccept([('utf-8', '1')])
+        self.assertEqual(accept.to_header(), 'utf-8')
+
+    def test_serialize_accept_multiple(self):
+        accept = CharsetAccept([
+            'utf-8',
+            ('ascii', 0.5),
+            ('*', 0.1),
+        ])
+        self.assertEqual(
+            accept.to_header(),
+            (
+                'utf-8,'
+                'ascii;q=0.5,'
+                '*;q=0.1'
+            )
+        )
+
+    def test_match_basic(self):
+        accept = CharsetAccept(['utf-8'])
+
+        acceptable = Charset('utf-8')
+        unacceptable = Charset('latin-1')
+
+        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
+
+        match = acceptable.acceptability(accept)
+        self.assertEqual(acceptable, match.charset)
+        self.assertTrue(match.exact_match)
+
+    def test_match_wildcard(self):
+        accept = CharsetAccept(['*'])
+
+        charset = Charset('iso-8859-8')
+
+        match = charset.acceptability(accept)
+        self.assertEqual(charset, match.charset)
+        self.assertFalse(match.exact_match)
+
+    def test_match_quality(self):
+        accept = CharsetAccept([('utf-8', '0.5')])
+
+        no_qs = Charset('utf-8')
+        qs = Charset('utf-8', qs=0.5)
+
+        self.assertEqual(0.5, no_qs.acceptability(accept).quality)
+        self.assertEqual(0.25, qs.acceptability(accept).quality)
+
+    def test_match(self):
+        accept = CharsetAccept([
+            'utf-8',
+            ('ascii', 0.5),
+            ('*', 0.1),
+        ])
+
+        charset = Charset('utf-8')
+        match = charset.acceptability(accept)
+        self.assertEqual(1.0, match.quality)
+        self.assertTrue(match.exact_match)
+
+        charset = Charset('ascii')
+        match = charset.acceptability(accept)
+        self.assertEqual(0.5, match.quality)
+        self.assertTrue(match.exact_match)
+
+        charset = Charset('latin-1')
+        match = charset.acceptability(accept)
+        self.assertEqual(0.1, match.quality)
+        self.assertFalse(match.exact_match)
diff --git a/verktyg/testsuite/test_accept_content_type.py b/verktyg/testsuite/test_accept_content_type.py
new file mode 100644
index 0000000..f7ad90e
--- /dev/null
+++ b/verktyg/testsuite/test_accept_content_type.py
@@ -0,0 +1,200 @@
+"""
+    verktyg.testsuite.test_accept_content_type
+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    Tests for HTTP accept header parsing utilities.
+
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+import unittest
+
+from verktyg.accept.content_type import (
+    parse_content_type_header, parse_accept_header,
+    ContentType, ContentTypeAccept,
+)
+from verktyg.exceptions import NotAcceptable
+
+
+class ContentTypeTestCase(unittest.TestCase):
+    def test_parse_accept_basic(self):
+        accept = parse_accept_header(
+            'text/xml'
+        )
+
+        range_ = next(iter(accept))
+        self.assertEqual('text', range_.type)
+        self.assertEqual('xml', range_.subtype)
+        self.assertEqual(1, range_.q)
+        self.assertEqual(0, len(range_.params))
+        with self.assertRaises(KeyError):
+            range_.params['q']
+
+    def test_parse_accept_params(self):
+        accept = parse_accept_header(
+            'application/foo;quiet=no; bar=baz;q=0.6'
+        )
+        range_ = next(iter(accept))
+        self.assertEqual('application', range_.type)
+        self.assertEqual('foo', range_.subtype)
+        self.assertEqual(0.6, range_.q)
+
+        self.assertEqual(2, len(range_.params))
+        self.assertEqual('no', range_.params['quiet'])
+        self.assertEqual('baz', range_.params['bar'])
+        with self.assertRaises(KeyError):
+            range_.params['no-such-param']
+        with self.assertRaises(KeyError):
+            range_.params['q']
+
+    def test_parse_accept_invalid_params(self):
+        # TODO
+        pass
+
+    def test_parse_accept_case(self):
+        # TODO
+        pass
+
+    def test_parse_accept_multiple(self):
+        accept = parse_accept_header(
+            'text/xml,'
+            'application/xml,'
+            'application/xhtml+xml,'
+            'application/foo;quiet=no; bar=baz;q=0.6,'
+            'text/html;q=0.9,'
+            'text/plain;q=0.8,'
+            'image/png,'
+            '*/*;q=0.5'
+        )
+
+        self.assertEqual(len(list(accept)), 8)
+
+    def test_parse(self):
+        content_type = parse_content_type_header('text/html')
+
+        self.assertEqual(content_type.type, 'text')
+        self.assertEqual(content_type.subtype, 'html')
+
+    def test_serialize(self):
+        content_type = ContentType('text/html', qs=0.5)
+
+        self.assertEqual('text/html', content_type.to_header())
+
+    def test_serialize_accept(self):
+        accept = ContentTypeAccept(['text/html'])
+
+        self.assertEqual(accept.to_header(), 'text/html')
+
+    def test_serialize_accept_q_before_params(self):
+        accept = ContentTypeAccept([
+            ('application/json', '0.5', {'speed': 'maximum'}),
+        ])
+
+        self.assertEqual(
+            accept.to_header(), 'application/json;q=0.5;speed=maximum'
+        )
+
+    def test_serialize_accept_redundant_q(self):
+        accept = ContentTypeAccept([('image/png', '1')])
+        self.assertEqual(accept.to_header(), 'image/png')
+
+    def test_serialize_accept_multiple(self):
+        accept = ContentTypeAccept([
+            'application/xhtml+xml',
+            ('text/plain', '0.8'),
+            'image/png',
+            ('*/*', '0.5'),
+        ])
+        self.assertEqual(
+            accept.to_header(),
+            (
+                'application/xhtml+xml,'
+                'text/plain;q=0.8,'
+                'image/png,'
+                '*/*;q=0.5'
+            )
+        )
+
+    def test_match_basic(self):
+        accept = ContentTypeAccept(['text/xml'])
+
+        acceptable = ContentType('text/xml')
+        unacceptable_type = ContentType('application/xml')
+        unacceptable_subtype = ContentType('text/html')
+
+        self.assertRaises(
+            NotAcceptable, unacceptable_type.acceptability, accept
+        )
+        self.assertRaises(
+            NotAcceptable, unacceptable_subtype.acceptability, accept
+        )
+
+        match = acceptable.acceptability(accept)
+        self.assertEqual(acceptable, match.content_type)
+        self.assertTrue(match.type_matches)
+        self.assertTrue(match.subtype_matches)
+        self.assertTrue(match.exact_match)
+
+    def test_match_wildcard(self):
+        accept = ContentTypeAccept(['*/*'])
+
+        content_type = ContentType('text/html')
+
+        match = content_type.acceptability(accept)
+        self.assertEqual(content_type, match.content_type)
+        self.assertFalse(match.type_matches)
+        self.assertFalse(match.subtype_matches)
+        self.assertFalse(match.exact_match)
+
+    def test_match_subtype_wildcard(self):
+        accept = ContentTypeAccept(['text/*'])
+
+        unacceptable = ContentType('image/jpeg')
+        acceptable = ContentType('text/html')
+
+        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
+
+        match = acceptable.acceptability(accept)
+        self.assertEqual(acceptable, match.content_type)
+        self.assertTrue(match.type_matches)
+        self.assertFalse(match.subtype_matches)
+        self.assertFalse(match.exact_match)
+
+    def test_match_quality(self):
+        accept = ContentTypeAccept([('text/html', '0.5')])
+
+        no_qs = ContentType('text/html')
+        qs = ContentType('text/html', qs=0.5)
+
+        self.assertEqual(0.5, no_qs.acceptability(accept).quality)
+        self.assertEqual(0.25, qs.acceptability(accept).quality)
+
+    def test_match(self):
+        accept = ContentTypeAccept([
+            'text/xml',
+            'application/xml',
+            'application/xhtml+xml',
+            ('application/foo', '0.6', {'quiet': 'no', 'bar': 'baz'}),
+            ('text/html', '0.9'),
+            ('text/plain', '0.8'),
+            'image/png',
+            ('*/*', '0.5'),
+        ])
+
+        content_type = ContentType('image/png')
+        match = content_type.acceptability(accept)
+        self.assertEqual(match.quality, 1.0)
+        self.assertTrue(match.exact_match)
+
+        content_type = ContentType('text/plain')
+        match = content_type.acceptability(accept)
+        self.assertEqual(match.quality, 0.8)
+        self.assertTrue(match.exact_match)
+
+        content_type = ContentType('application/json')
+        match = content_type.acceptability(accept)
+        self.assertEqual(match.quality, 0.5)
+        self.assertFalse(match.exact_match)
diff --git a/verktyg/testsuite/test_accept_language.py b/verktyg/testsuite/test_accept_language.py
new file mode 100644
index 0000000..dec3589
--- /dev/null
+++ b/verktyg/testsuite/test_accept_language.py
@@ -0,0 +1,154 @@
+"""
+    verktyg.testsuite.test_accept_language
+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    Tests for HTTP accept header parsing utilities.
+
+
+    :copyright:
+        (c) 2016 Ben Mather
+    :license:
+        BSD, see LICENSE for more details.
+"""
+import unittest
+
+from verktyg.accept.language import (
+    parse_language_header, parse_accept_language_header,
+    Language, LanguageAccept,
+)
+
+from verktyg.exceptions import NotAcceptable
+
+
+class LanguageTestCase(unittest.TestCase):
+    def test_parse_accept_basic(self):
+        accept = parse_accept_language_header('en-gb')
+
+        range_ = next(iter(accept))
+        self.assertEqual('en-gb', range_.value)
+        self.assertEqual(1, range_.q)
+
+    def test_parse_accept_params(self):
+        self.assertRaises(
+            ValueError, parse_accept_language_header, 'en;param=invalid'
+        )
+
+    def test_parse_accept_q(self):
+        accept = parse_accept_language_header('en; q=0.8')
+        range_ = next(iter(accept))
+
+        self.assertEqual(0.8, range_.q)
+
+    def test_parse_accept_multiple(self):
+        accept = parse_accept_language_header(
+            'da,en-gb;q=0.8,en;q=0.7,*;q=0.1'
+        )
+
+        self.assertEqual(len(list(accept)), 4)
+
+    def test_parse(self):
+        language = parse_language_header('en-gb')
+
+        self.assertEqual(language.value, 'en-gb')
+
+    def test_serialize(self):
+        language = Language('en-us', qs=0.5)
+
+        self.assertEqual('en-us', language.to_header())
+
+    def test_serialize_accept_redundant_q(self):
+        accept = LanguageAccept([('jp', '1')])
+        self.assertEqual(accept.to_header(), 'jp')
+
+    def test_serialize_accept_multiple(self):
+        accept = LanguageAccept([
+            'da', ('en-gb', 0.8), ('en', 0.7), ('*', 0.1)
+        ])
+
+        self.assertEqual(accept.to_header(), 'da,en-gb;q=0.8,en;q=0.7,*;q=0.1')
+
+    def test_match_basic(self):
+        accept = LanguageAccept(['en-gb'])
+
+        acceptable = Language('en-gb')
+        unacceptable = Language('fr')
+
+        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
+
+        match = acceptable.acceptability(accept)
+        self.assertEqual(match.language, acceptable)
+        self.assertEqual(match.specificity, 2)
+        self.assertEqual(match.tail, 0)
+        self.assertTrue(match.exact_match)
+
+    def test_match_partial(self):
+        accept = LanguageAccept(['one-two'])
+
+        unacceptable = Language('one')
+        acceptable = Language('one-two-three')
+
+        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
+
+        match = acceptable.acceptability(accept)
+        self.assertEqual(acceptable, match.language)
+        self.assertEqual(match.specificity, 2)
+        self.assertEqual(match.tail, 1)
+        self.assertFalse(match.exact_match)
+
+    def test_match_wildcard(self):
+        accept = LanguageAccept(['*'])
+
+        language = Language('en')
+
+        match = language.acceptability(accept)
+        self.assertEqual(match.language, language)
+        self.assertEqual(match.specificity, 0)
+        self.assertEqual(match.tail, 1)
+        self.assertFalse(match.exact_match)
+
+    def test_match_quality(self):
+        accept = LanguageAccept([('en', '0.5')])
+
+        no_qs = Language('en')
+        qs = Language('en', qs=0.5)
+
+        self.assertEqual(0.5, no_qs.acceptability(accept).quality)
+        self.assertEqual(0.25, qs.acceptability(accept).quality)
+
+    def test_match(self):
+        accept = LanguageAccept([
+            'fr', 'fr-be', ('en-gb', 0.8), ('en', 0.7), ('*', 0.1)
+        ])
+
+        fr = Language('fr')
+        fr_match = fr.acceptability(accept)
+        self.assertEqual(fr_match.quality, 1.0)
+        self.assertTrue(fr_match.exact_match)
+
+        fr_be = Language('fr-be')
+        fr_be_match = fr_be.acceptability(accept)
+        self.assertEqual(fr_be_match.quality, 1.0)
+        self.assertTrue(fr_be_match.exact_match)
+
+        # more specific first
+        self.assertGreater(fr_be_match, fr_match)
+
+        en_gb = Language('en-gb')
+        en_gb_match = en_gb.acceptability(accept)
+        self.assertEqual(en_gb_match.quality, 0.8)
+        self.assertTrue(en_gb_match.exact_match)
+
+        en_us = Language('en-us')
+        en_us_match = en_us.acceptability(accept)
+        self.assertEqual(en_us_match.quality, 0.7)
+        self.assertFalse(en_us_match.exact_match)
+
+        en = Language('en')
+        en_match = en.acceptability(accept)
+        self.assertEqual(en_match.quality, 0.7)
+        self.assertTrue(en_match.exact_match)
+
+        zu = Language('zu')
+        zu_match = zu.acceptability(accept)
+        self.assertEqual(zu_match.quality, 0.1)
+        self.assertFalse(zu_match.exact_match)
diff --git a/verktyg/testsuite/test_http_accept.py b/verktyg/testsuite/test_http_accept.py
deleted file mode 100644
index a0e3e5f..0000000
--- a/verktyg/testsuite/test_http_accept.py
+++ /dev/null
@@ -1,453 +0,0 @@
-"""
-    verktyg.testsuite.test_http_accept
-    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-    Tests for HTTP accept header parsing utilities.
-
-
-    :copyright:
-        (c) 2015 Ben Mather, based on Werkzeug, see AUTHORS for more details.
-    :license:
-        BSD, see LICENSE for more details.
-"""
-import unittest
-
-from verktyg import http
-from verktyg.exceptions import NotAcceptable
-
-
-class ContentTypeTestCase(unittest.TestCase):
-    def test_parse_accept_basic(self):
-        accept = http.parse_accept_header(
-            'text/xml'
-        )
-
-        range_ = next(iter(accept))
-        self.assertEqual('text', range_.type)
-        self.assertEqual('xml', range_.subtype)
-        self.assertEqual(1, range_.q)
-        self.assertEqual(0, len(range_.params))
-        with self.assertRaises(KeyError):
-            range_.params['q']
-
-    def test_parse_accept_params(self):
-        accept = http.parse_accept_header(
-            'application/foo;quiet=no; bar=baz;q=0.6'
-        )
-        range_ = next(iter(accept))
-        self.assertEqual('application', range_.type)
-        self.assertEqual('foo', range_.subtype)
-        self.assertEqual(0.6, range_.q)
-
-        self.assertEqual(2, len(range_.params))
-        self.assertEqual('no', range_.params['quiet'])
-        self.assertEqual('baz', range_.params['bar'])
-        with self.assertRaises(KeyError):
-            range_.params['no-such-param']
-        with self.assertRaises(KeyError):
-            range_.params['q']
-
-    def test_parse_accept_invalid_params(self):
-        # TODO
-        pass
-
-    def test_parse_accept_case(self):
-        # TODO
-        pass
-
-    def test_parse_accept_multiple(self):
-        accept = http.parse_accept_header(
-            'text/xml,'
-            'application/xml,'
-            'application/xhtml+xml,'
-            'application/foo;quiet=no; bar=baz;q=0.6,'
-            'text/html;q=0.9,'
-            'text/plain;q=0.8,'
-            'image/png,'
-            '*/*;q=0.5'
-        )
-
-        self.assertEqual(len(list(accept)), 8)
-
-    def test_parse(self):
-        content_type = http.parse_content_type_header('text/html')
-
-        self.assertEqual(content_type.type, 'text')
-        self.assertEqual(content_type.subtype, 'html')
-
-    def test_serialize(self):
-        content_type = http.ContentType('text/html', qs=0.5)
-
-        self.assertEqual('text/html', content_type.to_header())
-
-    def test_serialize_accept(self):
-        accept = http.ContentTypeAccept(['text/html'])
-
-        self.assertEqual(accept.to_header(), 'text/html')
-
-    def test_serialize_accept_q_before_params(self):
-        accept = http.ContentTypeAccept([
-            ('application/json', '0.5', {'speed': 'maximum'}),
-        ])
-
-        self.assertEqual(
-            accept.to_header(), 'application/json;q=0.5;speed=maximum'
-        )
-
-    def test_serialize_accept_redundant_q(self):
-        accept = http.ContentTypeAccept([('image/png', '1')])
-        self.assertEqual(accept.to_header(), 'image/png')
-
-    def test_serialize_accept_multiple(self):
-        accept = http.ContentTypeAccept([
-            'application/xhtml+xml',
-            ('text/plain', '0.8'),
-            'image/png',
-            ('*/*', '0.5'),
-        ])
-        self.assertEqual(
-            accept.to_header(),
-            (
-                'application/xhtml+xml,'
-                'text/plain;q=0.8,'
-                'image/png,'
-                '*/*;q=0.5'
-            )
-        )
-
-    def test_match_basic(self):
-        accept = http.ContentTypeAccept(['text/xml'])
-
-        acceptable = http.ContentType('text/xml')
-        unacceptable_type = http.ContentType('application/xml')
-        unacceptable_subtype = http.ContentType('text/html')
-
-        self.assertRaises(
-            NotAcceptable, unacceptable_type.acceptability, accept
-        )
-        self.assertRaises(
-            NotAcceptable, unacceptable_subtype.acceptability, accept
-        )
-
-        match = acceptable.acceptability(accept)
-        self.assertEqual(acceptable, match.content_type)
-        self.assertTrue(match.type_matches)
-        self.assertTrue(match.subtype_matches)
-        self.assertTrue(match.exact_match)
-
-    def test_match_wildcard(self):
-        accept = http.ContentTypeAccept(['*/*'])
-
-        content_type = http.ContentType('text/html')
-
-        match = content_type.acceptability(accept)
-        self.assertEqual(content_type, match.content_type)
-        self.assertFalse(match.type_matches)
-        self.assertFalse(match.subtype_matches)
-        self.assertFalse(match.exact_match)
-
-    def test_match_subtype_wildcard(self):
-        accept = http.ContentTypeAccept(['text/*'])
-
-        unacceptable = http.ContentType('image/jpeg')
-        acceptable = http.ContentType('text/html')
-
-        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
-
-        match = acceptable.acceptability(accept)
-        self.assertEqual(acceptable, match.content_type)
-        self.assertTrue(match.type_matches)
-        self.assertFalse(match.subtype_matches)
-        self.assertFalse(match.exact_match)
-
-    def test_match_quality(self):
-        accept = http.ContentTypeAccept([('text/html', '0.5')])
-
-        no_qs = http.ContentType('text/html')
-        qs = http.ContentType('text/html', qs=0.5)
-
-        self.assertEqual(0.5, no_qs.acceptability(accept).quality)
-        self.assertEqual(0.25, qs.acceptability(accept).quality)
-
-    def test_match(self):
-        accept = http.ContentTypeAccept([
-            'text/xml',
-            'application/xml',
-            'application/xhtml+xml',
-            ('application/foo', '0.6', {'quiet': 'no', 'bar': 'baz'}),
-            ('text/html', '0.9'),
-            ('text/plain', '0.8'),
-            'image/png',
-            ('*/*', '0.5'),
-        ])
-
-        content_type = http.ContentType('image/png')
-        match = content_type.acceptability(accept)
-        self.assertEqual(match.quality, 1.0)
-        self.assertTrue(match.exact_match)
-
-        content_type = http.ContentType('text/plain')
-        match = content_type.acceptability(accept)
-        self.assertEqual(match.quality, 0.8)
-        self.assertTrue(match.exact_match)
-
-        content_type = http.ContentType('application/json')
-        match = content_type.acceptability(accept)
-        self.assertEqual(match.quality, 0.5)
-        self.assertFalse(match.exact_match)
-
-
-class LanguageTestCase(unittest.TestCase):
-    def test_parse_accept_basic(self):
-        accept = http.parse_accept_language_header('en-gb')
-
-        range_ = next(iter(accept))
-        self.assertEqual('en-gb', range_.value)
-        self.assertEqual(1, range_.q)
-
-    def test_parse_accept_params(self):
-        self.assertRaises(
-            ValueError, http.parse_accept_language_header, 'en;param=invalid'
-        )
-
-    def test_parse_accept_q(self):
-        accept = http.parse_accept_language_header('en; q=0.8')
-        range_ = next(iter(accept))
-
-        self.assertEqual(0.8, range_.q)
-
-    def test_parse_accept_multiple(self):
-        accept = http.parse_accept_language_header(
-            'da,en-gb;q=0.8,en;q=0.7,*;q=0.1'
-        )
-
-        self.assertEqual(len(list(accept)), 4)
-
-    def test_parse(self):
-        language = http.parse_language_header('en-gb')
-
-        self.assertEqual(language.value, 'en-gb')
-
-    def test_serialize(self):
-        language = http.Language('en-us', qs=0.5)
-
-        self.assertEqual('en-us', language.to_header())
-
-    def test_serialize_accept_redundant_q(self):
-        accept = http.LanguageAccept([('jp', '1')])
-        self.assertEqual(accept.to_header(), 'jp')
-
-    def test_serialize_accept_multiple(self):
-        accept = http.LanguageAccept([
-            'da', ('en-gb', 0.8), ('en', 0.7), ('*', 0.1)
-        ])
-
-        self.assertEqual(accept.to_header(), 'da,en-gb;q=0.8,en;q=0.7,*;q=0.1')
-
-    def test_match_basic(self):
-        accept = http.LanguageAccept(['en-gb'])
-
-        acceptable = http.Language('en-gb')
-        unacceptable = http.Language('fr')
-
-        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
-
-        match = acceptable.acceptability(accept)
-        self.assertEqual(match.language, acceptable)
-        self.assertEqual(match.specificity, 2)
-        self.assertEqual(match.tail, 0)
-        self.assertTrue(match.exact_match)
-
-    def test_match_partial(self):
-        accept = http.LanguageAccept(['one-two'])
-
-        unacceptable = http.Language('one')
-        acceptable = http.Language('one-two-three')
-
-        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
-
-        match = acceptable.acceptability(accept)
-        self.assertEqual(acceptable, match.language)
-        self.assertEqual(match.specificity, 2)
-        self.assertEqual(match.tail, 1)
-        self.assertFalse(match.exact_match)
-
-    def test_match_wildcard(self):
-        accept = http.LanguageAccept(['*'])
-
-        language = http.Language('en')
-
-        match = language.acceptability(accept)
-        self.assertEqual(match.language, language)
-        self.assertEqual(match.specificity, 0)
-        self.assertEqual(match.tail, 1)
-        self.assertFalse(match.exact_match)
-
-    def test_match_quality(self):
-        accept = http.LanguageAccept([('en', '0.5')])
-
-        no_qs = http.Language('en')
-        qs = http.Language('en', qs=0.5)
-
-        self.assertEqual(0.5, no_qs.acceptability(accept).quality)
-        self.assertEqual(0.25, qs.acceptability(accept).quality)
-
-    def test_match(self):
-        accept = http.LanguageAccept([
-            'fr', 'fr-be', ('en-gb', 0.8), ('en', 0.7), ('*', 0.1)
-        ])
-
-        fr = http.Language('fr')
-        fr_match = fr.acceptability(accept)
-        self.assertEqual(fr_match.quality, 1.0)
-        self.assertTrue(fr_match.exact_match)
-
-        fr_be = http.Language('fr-be')
-        fr_be_match = fr_be.acceptability(accept)
-        self.assertEqual(fr_be_match.quality, 1.0)
-        self.assertTrue(fr_be_match.exact_match)
-
-        # more specific first
-        self.assertGreater(fr_be_match, fr_match)
-
-        en_gb = http.Language('en-gb')
-        en_gb_match = en_gb.acceptability(accept)
-        self.assertEqual(en_gb_match.quality, 0.8)
-        self.assertTrue(en_gb_match.exact_match)
-
-        en_us = http.Language('en-us')
-        en_us_match = en_us.acceptability(accept)
-        self.assertEqual(en_us_match.quality, 0.7)
-        self.assertFalse(en_us_match.exact_match)
-
-        en = http.Language('en')
-        en_match = en.acceptability(accept)
-        self.assertEqual(en_match.quality, 0.7)
-        self.assertTrue(en_match.exact_match)
-
-        zu = http.Language('zu')
-        zu_match = zu.acceptability(accept)
-        self.assertEqual(zu_match.quality, 0.1)
-        self.assertFalse(zu_match.exact_match)
-
-
-class CharsetTestCase(unittest.TestCase):
-    def test_parse_accept_basic(self):
-        accept = http.parse_accept_charset_header(
-            'iso-8859-5'
-        )
-
-        range_ = next(iter(accept))
-        self.assertEqual('iso-8859-5', range_.value)
-        self.assertEqual(1, range_.q)
-
-    def test_parse_accept_q(self):
-        accept = http.parse_accept_charset_header(
-            'ascii;q=0.5',
-        )
-
-        range_ = next(iter(accept))
-        self.assertEqual('ascii', range_.value)
-        self.assertEqual(0.5, range_.q)
-
-    def test_parse_accept_params(self):
-        with self.assertRaises(ValueError):
-            http.parse_accept_charset_header(
-                'utf-8;orange=black'
-            )
-
-    def test_parse_accept_multiple(self):
-        accept = http.parse_accept_charset_header(
-            'utf-8,'
-            'ascii;q=0.5,'
-            '*;q=0.1'
-        )
-
-        self.assertEqual(3, len(list(accept)))
-
-    def test_parse(self):
-        charset = http.parse_charset_header('utf-8')
-        self.assertEqual('utf-8', charset.value)
-
-    def test_serialize(self):
-        charset = http.Charset('iso-8859-1', qs=0.5)
-        self.assertEqual('iso-8859-1', charset.to_header())
-
-    def test_serialize_accept(self):
-        accept = http.CharsetAccept(['ascii'])
-        self.assertEqual(accept.to_header(), 'ascii')
-
-    def test_serialize_accept_with_q(self):
-        accept = http.CharsetAccept([('utf-8', '0.5')])
-        self.assertEqual(accept.to_header(), 'utf-8;q=0.5')
-
-    def test_serialize_accept_redundant_q(self):
-        accept = http.CharsetAccept([('utf-8', '1')])
-        self.assertEqual(accept.to_header(), 'utf-8')
-
-    def test_serialize_accept_multiple(self):
-        accept = http.CharsetAccept([
-            'utf-8',
-            ('ascii', 0.5),
-            ('*', 0.1),
-        ])
-        self.assertEqual(
-            accept.to_header(),
-            (
-                'utf-8,'
-                'ascii;q=0.5,'
-                '*;q=0.1'
-            )
-        )
-
-    def test_match_basic(self):
-        accept = http.CharsetAccept(['utf-8'])
-
-        acceptable = http.Charset('utf-8')
-        unacceptable = http.Charset('latin-1')
-
-        self.assertRaises(NotAcceptable, unacceptable.acceptability, accept)
-
-        match = acceptable.acceptability(accept)
-        self.assertEqual(acceptable, match.charset)
-        self.assertTrue(match.exact_match)
-
-    def test_match_wildcard(self):
-        accept = http.CharsetAccept(['*'])
-
-        charset = http.Charset('iso-8859-8')
-
-        match = charset.acceptability(accept)
-        self.assertEqual(charset, match.charset)
-        self.assertFalse(match.exact_match)
-
-    def test_match_quality(self):
-        accept = http.CharsetAccept([('utf-8', '0.5')])
-
-        no_qs = http.Charset('utf-8')
-        qs = http.Charset('utf-8', qs=0.5)
-
-        self.assertEqual(0.5, no_qs.acceptability(accept).quality)
-        self.assertEqual(0.25, qs.acceptability(accept).quality)
-
-    def test_match(self):
-        accept = http.CharsetAccept([
-            'utf-8',
-            ('ascii', 0.5),
-            ('*', 0.1),
-        ])
-
-        charset = http.Charset('utf-8')
-        match = charset.acceptability(accept)
-        self.assertEqual(1.0, match.quality)
-        self.assertTrue(match.exact_match)
-
-        charset = http.Charset('ascii')
-        match = charset.acceptability(accept)
-        self.assertEqual(0.5, match.quality)
-        self.assertTrue(match.exact_match)
-
-        charset = http.Charset('latin-1')
-        match = charset.acceptability(accept)
-        self.assertEqual(0.1, match.quality)
-        self.assertFalse(match.exact_match)
