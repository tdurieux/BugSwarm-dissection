diff --git a/okhttp-tests/src/test/java/okhttp3/internal/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/PublicSuffixDatabaseTest.java
new file mode 100644
index 000000000..5ade19897
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/PublicSuffixDatabaseTest.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static okhttp3.internal.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public final class PublicSuffixDatabaseTest {
+  private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
+
+  @Test public void longestMatchWins() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("com\n")
+        .writeUtf8("my.square.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
+    assertEquals("bar.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+  }
+
+  @Test public void wildcardMatch() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.square.com\n")
+        .writeUtf8("com\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("foo.*.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+    assertEquals("my.foo.bar.com", publicSuffixDatabase.getEffectiveTldPlusOne("my.foo.bar.com"));
+  }
+
+  @Test public void boundarySearches() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("bbb\n")
+        .writeUtf8("ddd\n")
+        .writeUtf8("fff\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+  }
+
+  @Test public void exhaustWildcardPermutations() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.*.*.com\n")
+        .writeUtf8("*.*.jp\n")
+        .writeUtf8("bar.*.foo.ca\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("one.foo.bar.jp", publicSuffixDatabase.getEffectiveTldPlusOne("one.foo.bar.jp"));
+    assertEquals("one.foo.bar.fun.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("one.foo.bar.fun.com"));
+    assertEquals("one.bar.fun.foo.ca",
+        publicSuffixDatabase.getEffectiveTldPlusOne("one.bar.fun.foo.ca"));
+  }
+
+  @Test public void exceptionRule() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
+  }
+
+  @Test public void noEffectiveTldPlusOne() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+  }
+
+  @Test public void allPublicSuffixes() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class.getClassLoader()
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String publicSuffix = buffer.readUtf8LineStrict();
+      if (publicSuffix.contains("*")) {
+        // A wildcard rule, let's replace the wildcard with a value.
+        publicSuffix = publicSuffix.replaceAll("\\*", "square");
+      }
+      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+
+      String test = "foobar." + publicSuffix;
+      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void publicSuffixExceptions() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class.getClassLoader()
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    source.skip(length);
+
+    length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String exception = buffer.readUtf8LineStrict();
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+
+      String test = "foobar." + exception;
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  /**
+   * These tests are provided by <a href="https://publicsuffix.org/list/">publicsuffix.com</a>.
+   */
+  @Test public void publicSuffixDotOrgTestCases() {
+    // Any copyright is dedicated to the Public Domain.
+    // https://creativecommons.org/publicdomain/zero/1.0/
+
+    // null input.
+    checkPublicSuffix(null, null);
+    // Mixed case.
+    checkPublicSuffix("COM", null);
+    checkPublicSuffix("example.COM", "example.com");
+    checkPublicSuffix("WwW.example.COM", "example.com");
+    // Leading dot.
+    checkPublicSuffix(".com", null);
+    checkPublicSuffix(".example", null);
+    checkPublicSuffix(".example.com", null);
+    checkPublicSuffix(".example.example", null);
+    // Unlisted TLD.
+    checkPublicSuffix("example", null);
+    checkPublicSuffix("example.example", "example.example");
+    checkPublicSuffix("b.example.example", "example.example");
+    checkPublicSuffix("a.b.example.example", "example.example");
+    // Listed, but non-Internet, TLD.
+    //checkPublicSuffix('local', null);
+    //checkPublicSuffix('example.local', null);
+    //checkPublicSuffix('b.example.local', null);
+    //checkPublicSuffix('a.b.example.local', null);
+    // TLD with only 1 rule.
+    checkPublicSuffix("biz", null);
+    checkPublicSuffix("domain.biz", "domain.biz");
+    checkPublicSuffix("b.domain.biz", "domain.biz");
+    checkPublicSuffix("a.b.domain.biz", "domain.biz");
+    // TLD with some 2-level rules.
+    checkPublicSuffix("com", null);
+    checkPublicSuffix("example.com", "example.com");
+    checkPublicSuffix("b.example.com", "example.com");
+    checkPublicSuffix("a.b.example.com", "example.com");
+    checkPublicSuffix("uk.com", null);
+    checkPublicSuffix("example.uk.com", "example.uk.com");
+    checkPublicSuffix("b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("a.b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("test.ac", "test.ac");
+    // TLD with only 1 (wildcard) rule.
+    checkPublicSuffix("mm", null);
+    checkPublicSuffix("c.mm", null);
+    checkPublicSuffix("b.c.mm", "b.c.mm");
+    checkPublicSuffix("a.b.c.mm", "b.c.mm");
+    // More complex TLD.
+    checkPublicSuffix("jp", null);
+    checkPublicSuffix("test.jp", "test.jp");
+    checkPublicSuffix("www.test.jp", "test.jp");
+    checkPublicSuffix("ac.jp", null);
+    checkPublicSuffix("test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("www.test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("kyoto.jp", null);
+    checkPublicSuffix("test.kyoto.jp", "test.kyoto.jp");
+    checkPublicSuffix("ide.kyoto.jp", null);
+    checkPublicSuffix("b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("a.b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("c.kobe.jp", null);
+    checkPublicSuffix("b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("a.b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("city.kobe.jp", "city.kobe.jp");
+    checkPublicSuffix("www.city.kobe.jp", "city.kobe.jp");
+    // TLD with a wildcard rule and exceptions.
+    checkPublicSuffix("ck", null);
+    checkPublicSuffix("test.ck", null);
+    checkPublicSuffix("b.test.ck", "b.test.ck");
+    checkPublicSuffix("a.b.test.ck", "b.test.ck");
+    checkPublicSuffix("www.ck", "www.ck");
+    checkPublicSuffix("www.www.ck", "www.ck");
+    // US K12.
+    checkPublicSuffix("us", null);
+    checkPublicSuffix("test.us", "test.us");
+    checkPublicSuffix("www.test.us", "test.us");
+    checkPublicSuffix("ak.us", null);
+    checkPublicSuffix("test.ak.us", "test.ak.us");
+    checkPublicSuffix("www.test.ak.us", "test.ak.us");
+    checkPublicSuffix("k12.ak.us", null);
+    checkPublicSuffix("test.k12.ak.us", "test.k12.ak.us");
+    checkPublicSuffix("www.test.k12.ak.us", "test.k12.ak.us");
+    // IDN labels.
+    checkPublicSuffix("食狮.com.cn", "食狮.com.cn");
+    checkPublicSuffix("食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("www.食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("shishi.公司.cn", "shishi.公司.cn");
+    checkPublicSuffix("公司.cn", null);
+    checkPublicSuffix("食狮.中国", "食狮.中国");
+    checkPublicSuffix("www.食狮.中国", "食狮.中国");
+    checkPublicSuffix("shishi.中国", "shishi.中国");
+    checkPublicSuffix("中国", null);
+    // Same as above, but punycoded.
+    checkPublicSuffix("xn--85x722f.com.cn", "xn--85x722f.com.cn");
+    checkPublicSuffix("xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("www.xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("shishi.xn--55qx5d.cn", "shishi.xn--55qx5d.cn");
+    checkPublicSuffix("xn--55qx5d.cn", null);
+    checkPublicSuffix("xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("www.xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("shishi.xn--fiqs8s", "shishi.xn--fiqs8s");
+    checkPublicSuffix("xn--fiqs8s", null);
+  }
+
+  private void checkPublicSuffix(String domain, String registrablePart) {
+    String result = publicSuffixDatabase.getEffectiveTldPlusOne(domain);
+    assertEquals(registrablePart, result);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/PublicSuffixDatabase.java
new file mode 100644
index 000000000..907d3d1b1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/PublicSuffixDatabase.java
@@ -0,0 +1,346 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.IDN;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import okio.Source;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * A database of public suffixes provided by
+ * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
+ */
+public final class PublicSuffixDatabase {
+  public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
+
+  private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
+  private static final String[] EMPTY_RULE = new String[0];
+
+  private static final byte EXCEPTION_MARKER = '!';
+
+  /** True after we've attempted to read the list for the first time. */
+  final AtomicBoolean listRead = new AtomicBoolean(false);
+
+  /** Used for concurrent threads reading the list for the first time. */
+  final CountDownLatch readCompleteLatch = new CountDownLatch(1);
+
+  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
+  // that will likely never be used. Each rule is separated by '\n'. Please see the
+  // PublicSuffixListGenerator class for how these lists are generated.
+  // Guarded by this.
+  private byte[] publicSuffixListBytes;
+  private byte[] publicSuffixExceptionListBytes;
+
+  /**
+   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
+   *
+   * <p>Here are some examples: <pre>{@code
+   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
+   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
+   * assertNull(getEffectiveTldPlusOne("com"));
+   * }</pre>
+   */
+  public String getEffectiveTldPlusOne(String domain) {
+    if (domain == null) return null;
+
+    // Confirm we're dealing with a valid domain.
+    // TODO: Domains that start with '.' will be null on JDK8, but not on JDK7.
+    String canonicalDomain = Util.domainToAscii(domain);
+    if (canonicalDomain == null || canonicalDomain.startsWith(".")) return null;
+
+    // Convert it back to Unicode because the list uses Unicode, not punycode form.
+    String unicodeDomain = IDN.toUnicode(canonicalDomain);
+
+    // Preserve the passed in domain format (Unicode vs. punycode), but canonicalize it. This
+    // satisfies the publicsuffix.org test cases, but it's unclear if this should be done generally.
+    String domainToReturn = canonicalDomain.equalsIgnoreCase(domain)
+        ? canonicalDomain // We were passed a punycode domain.
+        : unicodeDomain; // We were passed a Unicode domain.
+
+    String[] domainLabels = unicodeDomain.split("\\.");
+    String[] ruleLabels = findMatchingRule(domainLabels);
+    if (ruleLabels == null) {
+      // If no rules match, the prevailing rule is '*'.
+      ruleLabels = new String[]{" "};
+    }
+
+    if (domainLabels.length == ruleLabels.length && ruleLabels[0].charAt(0) != EXCEPTION_MARKER) {
+      // The domain is a public suffix.
+      return null;
+    }
+
+    int labelsToInclude;
+    if (ruleLabels[0].charAt(0) == EXCEPTION_MARKER) {
+      // Exception rules hold the effective TLD plus one.
+      labelsToInclude = domainLabels.length - ruleLabels.length;
+    } else {
+      // Otherwise the rule is for a public suffix, so we must take one more label.
+      labelsToInclude = domainLabels.length - (ruleLabels.length + 1);
+    }
+
+    String[] domainToReturnLabels = domainToReturn.split("\\.");
+    StringBuilder effectiveTldPlusOne = new StringBuilder();
+    for (int i = labelsToInclude; i < domainToReturnLabels.length; i++) {
+      effectiveTldPlusOne.append(domainToReturnLabels[i]).append('.');
+    }
+    effectiveTldPlusOne.deleteCharAt(effectiveTldPlusOne.length() - 1);
+
+    return effectiveTldPlusOne.toString();
+  }
+
+  private String[] findMatchingRule(String[] domainLabels) {
+    if (!listRead.get() && listRead.compareAndSet(false, true)) {
+      readTheList();
+    } else {
+      try {
+        readCompleteLatch.await();
+      } catch (InterruptedException ignored) {
+      }
+    }
+
+    synchronized (this) {
+      if (publicSuffixListBytes == null) {
+        // We failed to read the public suffix list. This scenario should never happen, but in case
+        // it does, we'll let act as though this is a no-op.
+        return null;
+      }
+    }
+
+    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+    byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
+    for (int i = 0; i < domainLabels.length; i++) {
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+    }
+
+    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+    String exactMatch = null;
+    for (int i = 0; i < domainLabelsUtf8Bytes.length; i++) {
+      String match = binarySearchBytes(publicSuffixListBytes, domainLabelsUtf8Bytes, i);
+      if (match != null) {
+        exactMatch = match;
+        break;
+      }
+    }
+
+    // Wildcard rules throw a wrench into the mix. They are not restricted to appear in the leftmost
+    // position. An example is: *.*.foo. Therefore, we must exhaust the permutations,
+    // substituting a wildcard in the various label positions. For example, on the domain
+    // foo.bar.com, we'll try: [*, com], [foo, *, com], [*, bar, com], [*, *, com].
+    // Note: since we've already tried an exact match, we leave out those permutations.
+    String wildcardMatch = null;
+    if (domainLabelsUtf8Bytes.length > 1) {
+      // It seems highly unlikely (impossible?) the rightmost label will ever be a wildcard.
+      byte[][] labelsWithWildcard = new byte[domainLabelsUtf8Bytes.length][];
+      labelsWithWildcard[domainLabelsUtf8Bytes.length - 1] =
+          domainLabelsUtf8Bytes[domainLabelsUtf8Bytes.length - 1];
+
+      int firstLevel = domainLabelsUtf8Bytes.length - 1;
+      outer: for (int currentLevel = 0; currentLevel < firstLevel; currentLevel++) {
+        int numberOfWildcards = firstLevel - currentLevel;
+        int permutations = 1 << numberOfWildcards;
+        for (int i = 1; i < permutations; i++) {
+          for (int labelPos = firstLevel - 1; labelPos >= currentLevel; labelPos--) {
+            // Use the bit positions to indicate whether we should place a wildcard there. For
+            // example with foo.bar.com: 01, 10, 11. The second level is position 1, third is
+            // position 2, etc.
+            int labelBitPos = 1 << firstLevel - 1 - labelPos;
+            int useWildcard = labelBitPos & i;
+
+            labelsWithWildcard[labelPos] = useWildcard > 0
+                ? WILDCARD_LABEL
+                : domainLabelsUtf8Bytes[labelPos];
+          }
+          String match = binarySearchBytes(publicSuffixListBytes, labelsWithWildcard, currentLevel);
+          if (match != null) {
+            wildcardMatch = match;
+            break outer;
+          }
+        }
+      }
+    }
+
+    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+    String exception = null;
+    if (wildcardMatch != null) {
+      for (int i = 0; i < domainLabelsUtf8Bytes.length - 1; i++) {
+        String rule = binarySearchBytes(publicSuffixExceptionListBytes, domainLabelsUtf8Bytes, i);
+        if (rule != null) {
+          exception = rule;
+          break;
+        }
+      }
+    }
+
+    if (exception != null) {
+      // Signal we've identified an exception rule.
+      exception = "!" + exception;
+      return exception.split("\\.");
+    }
+
+    if (exactMatch == null && wildcardMatch == null) return null;
+
+    String[] exactRuleLabels = exactMatch != null
+        ? exactMatch.split("\\.")
+        : EMPTY_RULE;
+
+    String[] wildcardRuleLabels = wildcardMatch != null
+        ? wildcardMatch.split("\\.")
+        : EMPTY_RULE;
+
+    return exactRuleLabels.length > wildcardRuleLabels.length
+        ? exactRuleLabels
+        : wildcardRuleLabels;
+  }
+
+  private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, int labelIndex) {
+    int low = 0;
+    int high = bytesToSearch.length;
+    String match = null;
+    while (low < high) {
+      int mid = (low + high) / 2;
+      // Search for a '\n' that marks the start of a value. Don't go back past the start of the
+      // array.
+      while (mid > -1 && bytesToSearch[mid] != '\n') {
+        mid--;
+      }
+      mid++;
+
+      // Now look for the ending '\n'.
+      int end = 1;
+      while (bytesToSearch[mid + end] != '\n') {
+        end++;
+      }
+      int publicSuffixLength = (mid + end) - mid;
+
+      // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+      // unsigned bytes.
+      int compareResult;
+      int currentLabelIndex = labelIndex;
+      int currentLabelByteIndex = 0;
+      int publicSuffixByteIndex = 0;
+
+      boolean expectDot = false;
+      while (true) {
+        int byte0;
+        if (expectDot) {
+          byte0 = '.';
+          expectDot = false;
+        } else {
+          byte0 = labels[currentLabelIndex][currentLabelByteIndex] & 0xff;
+        }
+
+        int byte1 = bytesToSearch[mid + publicSuffixByteIndex] & 0xff;
+
+        compareResult = byte0 - byte1;
+        if (compareResult != 0) break;
+
+        publicSuffixByteIndex++;
+        currentLabelByteIndex++;
+        if (publicSuffixByteIndex == publicSuffixLength) break;
+
+        if (labels[currentLabelIndex].length == currentLabelByteIndex) {
+          // We've exhausted our current label. Either there are more labels to compare, in which
+          // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+          if (currentLabelIndex == labels.length - 1) {
+            break;
+          } else {
+            currentLabelIndex++;
+            currentLabelByteIndex = -1;
+            expectDot = true;
+          }
+        }
+      }
+
+      if (compareResult < 0) {
+        high = mid - 1;
+      } else if (compareResult > 0) {
+        low = mid + end + 1;
+      } else {
+        // We found a match, but are the lengths equal?
+        int publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex;
+        int labelBytesLeft = labels[currentLabelIndex].length - currentLabelByteIndex;
+        for (int i = currentLabelIndex + 1; i < labels.length; i++) {
+          labelBytesLeft += labels[i].length;
+        }
+
+        if (labelBytesLeft < publicSuffixBytesLeft) {
+          high = mid - 1;
+        } else if (labelBytesLeft > publicSuffixBytesLeft) {
+          low = mid + end + 1;
+        } else {
+          // Found a match.
+          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          break;
+        }
+      }
+    }
+    return match;
+  }
+
+  private void readTheList() {
+    byte[] publicSuffixListBytes = null;
+    byte[] publicSuffixExceptionListBytes = null;
+
+    InputStream is = PublicSuffixDatabase.class.getClassLoader().getResourceAsStream(
+        PUBLIC_SUFFIX_RESOURCE);
+
+    if (is != null) {
+      Source source = new GzipSource(Okio.source(is));
+      BufferedSource bufferedSource = null;
+      try {
+        bufferedSource = Okio.buffer(source);
+        int totalBytes = bufferedSource.readInt();
+        publicSuffixListBytes = new byte[totalBytes];
+        bufferedSource.readFully(publicSuffixListBytes);
+
+        int totalExceptionBytes = bufferedSource.readInt();
+        publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
+        bufferedSource.readFully(publicSuffixExceptionListBytes);
+      } catch (IOException e) {
+        Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
+        publicSuffixListBytes = null;
+        publicSuffixExceptionListBytes = null;
+      } finally {
+        closeQuietly(bufferedSource);
+      }
+    }
+
+    synchronized (this) {
+      this.publicSuffixListBytes = publicSuffixListBytes;
+      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    }
+
+    readCompleteLatch.countDown();
+  }
+
+  /** Visible for testing. */
+  void setListBytes(byte[] publicSuffixListBytes, byte[] publicSuffixExceptionListBytes) {
+    this.publicSuffixListBytes = publicSuffixListBytes;
+    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    listRead.set(true);
+    readCompleteLatch.countDown();
+  }
+}
diff --git a/okhttp/src/main/resources/publicsuffixes.gz b/okhttp/src/main/resources/publicsuffixes.gz
new file mode 100644
index 000000000..13c62fa88
Binary files /dev/null and b/okhttp/src/main/resources/publicsuffixes.gz differ
diff --git a/okhttp/src/test/java/okhttp3/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/PublicSuffixListGenerator.java
new file mode 100644
index 000000000..674ea90f9
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/PublicSuffixListGenerator.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import okhttp3.internal.PublicSuffixDatabase;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+
+/**
+ * Downloads the public suffix list from https://publicsuffix.org/list/public_suffix_list.dat and
+ * transforms the file into an efficient format used by OkHttp.
+ *
+ * <p>The intent is to use this class to update the list periodically by manually running the main
+ * method. This should be run from the top-level okhttp directory.
+ *
+ * <p>The resulting file is used by {@link PublicSuffixDatabase}.
+ */
+public final class PublicSuffixListGenerator {
+  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
+      + File.separator + "main" + File.separator + "resources";
+
+  private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
+
+  public static void main(String... args) throws IOException {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    Request request = new Request.Builder()
+        .url("https://publicsuffix.org/list/public_suffix_list.dat")
+        .build();
+    Response response = client.newCall(request).execute();
+
+    SortedSet<ByteString> sortedRules = new TreeSet<>();
+    SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
+    BufferedSource source = response.body().source();
+    int totalRuleBytes = 0;
+    int totalExceptionRuleBytes = 0;
+    while (!source.exhausted()) {
+      String line = source.readUtf8LineStrict();
+      if (line.trim().isEmpty() || line.startsWith("//")) continue;
+
+      ByteString rule = ByteString.encodeUtf8(line);
+      if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
+        rule = rule.substring(1);
+        // We use '\n' for end of value.
+        totalExceptionRuleBytes += rule.size() + 1;
+        sortedExceptionRules.add(rule);
+      } else {
+        totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
+        sortedRules.add(rule);
+      }
+    }
+
+    File resources = new File(OKHTTP_RESOURCE_DIR);
+    if (!resources.mkdirs() && !resources.exists()) {
+      throw new RuntimeException("Unable to create resource directory!");
+    }
+
+    Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+    try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
+      sink.writeInt(totalRuleBytes);
+      for (ByteString domain : sortedRules) {
+        sink.write(domain).writeByte('\n');
+      }
+
+      sink.writeInt(totalExceptionRuleBytes);
+      for (ByteString domain : sortedExceptionRules) {
+        sink.write(domain).writeByte('\n');
+      }
+    }
+  }
+}
