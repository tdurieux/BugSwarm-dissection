diff --git a/modules/wyc/src/wyc/builder/CodeGenerator.java b/modules/wyc/src/wyc/builder/CodeGenerator.java
index 058f235b8..241a90901 100644
--- a/modules/wyc/src/wyc/builder/CodeGenerator.java
+++ b/modules/wyc/src/wyc/builder/CodeGenerator.java
@@ -226,7 +226,7 @@ public WyilFile generate(WhileyFile wf) {
 		Environment environment = new Environment();		
 		ArrayList<VariableDeclarations.Declaration> declarations = new ArrayList<VariableDeclarations.Declaration>(); 				
 		addDeclaredParameters(fd.parameters,fd.resolvedType().params(), environment, declarations);
-		addDeclaredParameter(fd.returnType,fd.resolvedType().ret(), environment, declarations);		
+		addDeclaredParameters(fd.returns,fd.resolvedType().returns(), environment, declarations);		
 		// Allocate all declared variables now. This ensures that all declared
 		// variables occur before any temporary variables.
 		buildVariableDeclarations(fd.statements, declarations, environment, fd);
@@ -728,13 +728,14 @@ private void generate(Stmt.Assume s, Environment environment,
 	 * @return
 	 */
 	private void generate(Stmt.Return s, Environment environment, AttributedCodeBlock codes, Context context) {
-		if (s.expr != null) {
-			int operand = generate(s.expr, environment, codes, context);
+		if (!s.returns.isEmpty()) {
+			// FIXME: this is clearly broken!
+			int operand = generate(s.returns.get(0), environment, codes, context);
 			// Here, we don't put the type propagated for the return expression.
 			// Instead, we use the declared return type of this function. This
 			// has the effect of forcing an implicit coercion between the
 			// actual value being returned and its required type.
-			Type ret = ((WhileyFile.FunctionOrMethod) context).resolvedType().raw().ret();
+			Type ret = ((WhileyFile.FunctionOrMethod) context).resolvedType().raw().returns().get(0);
 
 			codes.add(Codes.Return(ret, operand), attributes(s));
 		} else {
@@ -1816,12 +1817,12 @@ private int generate(Expr.Lambda expr, Environment environment,
 
 		// Generate body based on current environment
 		AttributedCodeBlock body = new AttributedCodeBlock(
-				new SourceLocationMap());
-		if (tfm.ret() != Type.T_VOID) {
-			int target = generate(expr.body, benv, body, context);
-			body.add(Codes.Return(tfm.ret(), target), attributes(expr));
-		} else {
+				new SourceLocationMap());		
+		if (tfm.returns().isEmpty()) {
 			body.add(Codes.Return(), attributes(expr));
+		} else {
+			int target = generate(expr.body, benv, body, context);
+			body.add(Codes.Return(tfm.returns().get(0), target), attributes(expr));
 		}
 
 		// Add type information for all temporary registers allocated
@@ -1835,9 +1836,9 @@ private int generate(Expr.Lambda expr, Environment environment,
 		// Create concrete type for private lambda function
 		Type.FunctionOrMethod cfm;
 		if (tfm instanceof Type.Function) {
-			cfm = Type.Function(tfm.ret(), paramTypes);
+			cfm = Type.Function(tfm.returns(), paramTypes);
 		} else {
-			cfm = Type.Method(tfm.ret(), paramTypes);
+			cfm = Type.Method(tfm.returns(), paramTypes);
 		}
 
 		// Construct private lambda function using generated body
diff --git a/modules/wyc/src/wyc/builder/FlowTypeChecker.java b/modules/wyc/src/wyc/builder/FlowTypeChecker.java
index eb5839ac3..0eca2706d 100644
--- a/modules/wyc/src/wyc/builder/FlowTypeChecker.java
+++ b/modules/wyc/src/wyc/builder/FlowTypeChecker.java
@@ -178,8 +178,7 @@ public void propagate(WhileyFile wf) {
 					propagate((WhileyFile.Constant) decl);
 				}
 			} catch (ResolveError e) {
-				syntaxError(errorMessage(RESOLUTION_ERROR, e.getMessage()),
-						filename, decl, e);
+				syntaxError(errorMessage(RESOLUTION_ERROR, e.getMessage()), filename, decl, e);
 			} catch (SyntaxError e) {
 				throw e;
 			} catch (Throwable t) {
@@ -209,7 +208,7 @@ public void propagate(WhileyFile.Type td) throws IOException {
 
 		if (Type.isSubtype(Type.T_VOID, td.resolvedType.raw())) {
 			// A non-contractive type is one which cannot accept a finite
-			// values.  For example, the following is a contractive type:
+			// values. For example, the following is a contractive type:
 			//
 			// type NonContractive is { NonContractive x }
 			syntaxError("empty type encountered", filename, td);
@@ -218,7 +217,7 @@ public void propagate(WhileyFile.Type td) throws IOException {
 			// that.
 			Environment environment = addDeclaredParameter(td.parameter, new Environment(), td);
 			// Propagate type information through the constraint
-			for(int i=0;i!=td.invariant.size();++i) {
+			for (int i = 0; i != td.invariant.size(); ++i) {
 				Expr invariant = propagate(td.invariant.get(i), environment, td);
 				td.invariant.set(i, invariant);
 			}
@@ -232,8 +231,7 @@ public void propagate(WhileyFile.Type td) throws IOException {
 	 *            Constant declaration to check.
 	 * @throws IOException
 	 */
-	public void propagate(WhileyFile.Constant cd) throws IOException,
-			ResolveError {
+	public void propagate(WhileyFile.Constant cd) throws IOException, ResolveError {
 		NameID nid = new NameID(cd.file().module, cd.name());
 		cd.resolvedValue = resolveAsConstant(nid).first();
 	}
@@ -247,13 +245,13 @@ public void propagate(WhileyFile.Constant cd) throws IOException,
 	 */
 	public void propagate(WhileyFile.FunctionOrMethod d) throws IOException {
 		this.current = d; // ugly
-		
+
 		// Resolve the types of all parameters and construct an appropriate
 		// environment for use in the flow-sensitive type propagation.
-		Environment environment = addDeclaredParameters(d.parameters,new Environment(),d);
-		environment = addDeclaredParameter(d.returnType, environment.clone(), d);
+		Environment environment = addDeclaredParameters(d.parameters, new Environment(), d);
+		environment = addDeclaredParameters(d.returns, environment, d);
 		// Resolve types for any preconditions (i.e. requires clauses) provided.
-		propagateConditions(d.requires, environment, d);		
+		propagateConditions(d.requires, environment, d);
 		// Resolve types for any postconditions (i.e. ensures clauses) provided.
 		propagateConditions(d.ensures, environment, d);
 
@@ -265,12 +263,12 @@ public void propagate(WhileyFile.FunctionOrMethod d) throws IOException {
 			WhileyFile.Method m = (WhileyFile.Method) d;
 			m.resolvedType = resolveAsType(m.unresolvedType(), d);
 		}
-		
+
 		// Finally, propagate type information throughout all statements in the
 		// function / method body.
 		Environment last = propagate(d.statements, environment);
 		//
-		checkReturnValue(d,last);		
+		checkReturnValue(d, last);
 	}
 
 	/**
@@ -284,7 +282,7 @@ public void propagate(WhileyFile.FunctionOrMethod d) throws IOException {
 	 */
 	private void checkReturnValue(WhileyFile.FunctionOrMethod d, Environment last) {
 		if (!d.hasModifier(Modifier.NATIVE) && last != BOTTOM
-				&& !(current.resolvedType().ret().raw() instanceof Type.Void)) {
+				&& !current.resolvedType().returns().isEmpty()) {
 			// In this case, code reaches the end of the function or method and,
 			// furthermore, that this requires a return value. To get here means
 			// that there was no explicit return statement given on at least one
@@ -292,7 +290,7 @@ private void checkReturnValue(WhileyFile.FunctionOrMethod d, Environment last) {
 			syntaxError("missing return statement", filename, d);
 		}
 	}
-	
+
 	/**
 	 * Propagate type information through a list of conditions, updating each
 	 * one in place. The environment is cloned so as to ensure no interference.
@@ -308,7 +306,7 @@ private void propagateConditions(List<Expr> conditions, Environment environment,
 			conditions.set(i, condition);
 		}
 	}
-	
+
 	// =========================================================================
 	// Blocks & Statements
 	// =========================================================================
@@ -329,8 +327,7 @@ private Environment propagate(ArrayList<Stmt> block, Environment environment) {
 		for (int i = 0; i != block.size(); ++i) {
 			Stmt stmt = block.get(i);
 			if (stmt instanceof Expr) {
-				block.set(i,
-						(Stmt) propagate((Expr) stmt, environment, current));
+				block.set(i, (Stmt) propagate((Expr) stmt, environment, current));
 			} else {
 				environment = propagate(stmt, environment);
 			}
@@ -381,13 +378,11 @@ private Environment propagate(Stmt stmt, Environment environment) {
 			} else if (stmt instanceof Stmt.Skip) {
 				return propagate((Stmt.Skip) stmt, environment);
 			} else {
-				internalFailure("unknown statement: "
-						+ stmt.getClass().getName(), filename, stmt);
+				internalFailure("unknown statement: " + stmt.getClass().getName(), filename, stmt);
 				return null; // deadcode
 			}
 		} catch (ResolveError e) {
-			syntaxError(errorMessage(RESOLUTION_ERROR, e.getMessage()),
-					filename, stmt, e);
+			syntaxError(errorMessage(RESOLUTION_ERROR, e.getMessage()), filename, stmt, e);
 			return null; // dead code
 		} catch (SyntaxError e) {
 			throw e;
@@ -447,8 +442,8 @@ private Environment propagate(Stmt.Assume stmt, Environment environment) {
 	 *            this block
 	 * @return
 	 */
-	private Environment propagate(Stmt.VariableDeclaration stmt,
-			Environment environment) throws IOException, ResolveError {
+	private Environment propagate(Stmt.VariableDeclaration stmt, Environment environment)
+			throws IOException, ResolveError {
 		// First, resolve declared type
 		stmt.type = resolveAsType(stmt.parameter.type, current);
 
@@ -486,8 +481,7 @@ private Environment propagate(Stmt.VariableDeclaration stmt,
 	 *            this block
 	 * @return
 	 */
-	private Environment propagate(Stmt.Assign stmt, Environment environment)
-			throws IOException, ResolveError {
+	private Environment propagate(Stmt.Assign stmt, Environment environment) throws IOException, ResolveError {
 
 		Expr.LVal lhs = propagate(stmt.lhs, environment);
 		Expr rhs = propagate(stmt.rhs, environment, current);
@@ -495,21 +489,17 @@ private Environment propagate(Stmt.Assign stmt, Environment environment)
 		if (lhs instanceof Expr.RationalLVal) {
 			// represents a destructuring assignment
 			Expr.RationalLVal tv = (Expr.RationalLVal) lhs;
-			Pair<Expr.AssignedVariable, Expr.AssignedVariable> avs = inferAfterType(
-					tv, rhs);
+			Pair<Expr.AssignedVariable, Expr.AssignedVariable> avs = inferAfterType(tv, rhs);
 			String numVar = avs.first().var;
 			String denVar = avs.second().var;
-			checkIsSubtype(environment.getDeclaredType(numVar),
-					avs.first().afterType, avs.first());
-			checkIsSubtype(environment.getDeclaredType(denVar),
-					avs.second().afterType, avs.second());
+			checkIsSubtype(environment.getDeclaredType(numVar), avs.first().afterType, avs.first());
+			checkIsSubtype(environment.getDeclaredType(denVar), avs.second().afterType, avs.second());
 			environment = environment.update(numVar, avs.first().afterType);
 			environment = environment.update(denVar, avs.second().afterType);
 		} else {
 			// represents element or field update
 			Expr.AssignedVariable av = inferAfterType(lhs, rhs.result());
-			checkIsSubtype(environment.getDeclaredType(av.var), av.afterType,
-					av);
+			checkIsSubtype(environment.getDeclaredType(av.var), av.afterType, av);
 			environment = environment.update(av.var, av.afterType);
 		}
 
@@ -519,24 +509,22 @@ private Environment propagate(Stmt.Assign stmt, Environment environment)
 		return environment;
 	}
 
-	private Pair<Expr.AssignedVariable, Expr.AssignedVariable> inferAfterType(
-			Expr.RationalLVal tv, Expr rhs) throws IOException {
+	private Pair<Expr.AssignedVariable, Expr.AssignedVariable> inferAfterType(Expr.RationalLVal tv, Expr rhs)
+			throws IOException {
 		Nominal afterType = rhs.result();
 
 		if (!Type.isSubtype(Type.T_REAL, afterType.raw())) {
 			syntaxError("real value expected, got " + afterType, filename, rhs);
 		}
 
-		if (tv.numerator instanceof Expr.AssignedVariable
-				&& tv.denominator instanceof Expr.AssignedVariable) {
+		if (tv.numerator instanceof Expr.AssignedVariable && tv.denominator instanceof Expr.AssignedVariable) {
 			Expr.AssignedVariable lv = (Expr.AssignedVariable) tv.numerator;
 			Expr.AssignedVariable rv = (Expr.AssignedVariable) tv.denominator;
 			lv.type = Nominal.T_VOID;
 			rv.type = Nominal.T_VOID;
 			lv.afterType = Nominal.T_INT;
 			rv.afterType = Nominal.T_INT;
-			return new Pair<Expr.AssignedVariable, Expr.AssignedVariable>(lv,
-					rv);
+			return new Pair<Expr.AssignedVariable, Expr.AssignedVariable>(lv, rv);
 		} else {
 			syntaxError(errorMessage(INVALID_TUPLE_LVAL), filename, tv);
 			return null; // dead code
@@ -567,8 +555,7 @@ private Environment propagate(Stmt.Assign stmt, Environment environment)
 			afterType = (Nominal) srcType.update(la.name, afterType);
 			return inferAfterType((Expr.LVal) la.src, afterType);
 		} else {
-			internalFailure("unknown lval: " + lv.getClass().getName(),
-					filename, lv);
+			internalFailure("unknown lval: " + lv.getClass().getName(), filename, lv);
 			return null; // deadcode
 		}
 	}
@@ -603,7 +590,7 @@ private Environment propagate(Stmt.Break stmt, Environment environment) {
 	 */
 	private Environment propagate(Stmt.Debug stmt, Environment environment) {
 		stmt.expr = propagate(stmt.expr, environment, current);
-		checkIsSubtype(Type.Array(Type.T_INT,false), stmt.expr);
+		checkIsSubtype(Type.Array(Type.T_INT, false), stmt.expr);
 		return environment;
 	}
 
@@ -620,8 +607,7 @@ private Environment propagate(Stmt.Debug stmt, Environment environment) {
 	private Environment propagate(Stmt.DoWhile stmt, Environment environment) {
 
 		// Iterate to a fixed point
-		environment = computeFixedPoint(environment, stmt.body, stmt.condition,
-				true, stmt);
+		environment = computeFixedPoint(environment, stmt.body, stmt.condition, true, stmt);
 
 		// Type invariants
 		List<Expr> stmt_invariants = stmt.invariants;
@@ -635,8 +621,7 @@ private Environment propagate(Stmt.DoWhile stmt, Environment environment) {
 		// Type condition assuming its false to represent the terminated loop.
 		// This is important if the condition contains a type test, as we'll
 		// know that doesn't hold here.
-		Pair<Expr, Environment> p = propagateCondition(stmt.condition, false,
-				environment, current);
+		Pair<Expr, Environment> p = propagateCondition(stmt.condition, false, environment, current);
 		stmt.condition = p.first();
 		environment = p.second();
 
@@ -688,10 +673,8 @@ private Environment propagate(Stmt.IfElse stmt, Environment environment) {
 		// First, check condition and apply variable retypings.
 		Pair<Expr, Environment> p1, p2;
 
-		p1 = propagateCondition(stmt.condition, true, environment.clone(),
-				current);
-		p2 = propagateCondition(stmt.condition, false, environment.clone(),
-				current);
+		p1 = propagateCondition(stmt.condition, true, environment.clone(), current);
+		p2 = propagateCondition(stmt.condition, false, environment.clone(), current);
 		stmt.condition = p1.first();
 
 		Environment trueEnvironment = p1.second();
@@ -726,19 +709,30 @@ private Environment propagate(Stmt.IfElse stmt, Environment environment) {
 	 *            this block
 	 * @return
 	 */
-	private Environment propagate(Stmt.Return stmt, Environment environment)
-			throws IOException {
+	private Environment propagate(Stmt.Return stmt, Environment environment) throws IOException {
+		List<Expr> stmt_returns = stmt.returns;
+		List<Nominal> current_returns = current.resolvedType().returns();
 
-		if (stmt.expr != null) {
-			stmt.expr = propagate(stmt.expr, environment, current);
-			Nominal rhs = stmt.expr.result();
-			checkIsSubtype(current.resolvedType().ret(), rhs, stmt.expr);
-		} else if (!(current.resolvedType().ret().raw() instanceof Type.Void)) {
-			// In this case, we have an unusual situation. A return statement
-			// was provided without a return value, but the enclosing method or
-			// function requires a return value.
-			syntaxError("missing return value", filename, stmt);
-		}
+		if (stmt_returns.size() < current_returns.size()) {
+			// In this case, a return statement was provided with too few return
+			// values compared with the number declared for the enclosing
+			// method.
+			syntaxError("not enough return values provided", filename, stmt);
+		} else if (stmt_returns.size() > current_returns.size()) {
+			// In this case, a return statement was provided with too many return
+			// values compared with the number declared for the enclosing
+			// method.
+			syntaxError("too many return values provided", filename, stmt);
+		} 
+		
+		// Number of return values match number declared for enclosing
+		// function/method. Now, check they have appropriate types.
+		for(int i=0;i!=current_returns.size();++i) {
+			Nominal t = current_returns.get(i);
+			Expr e = propagate(stmt_returns.get(i), environment, current);
+			checkIsSubtype(t, e.result(), e);
+			stmt_returns.set(i, e);
+		}		
 
 		environment.free();
 		return BOTTOM;
@@ -807,8 +801,7 @@ private Environment propagate(Stmt.Skip stmt, Environment environment) {
 	 *            this block
 	 * @return
 	 */
-	private Environment propagate(Stmt.Switch stmt, Environment environment)
-			throws IOException {
+	private Environment propagate(Stmt.Switch stmt, Environment environment) throws IOException {
 
 		stmt.expr = propagate(stmt.expr, environment, current);
 
@@ -868,8 +861,7 @@ private Environment propagate(Stmt.Switch stmt, Environment environment)
 	private Environment propagate(Stmt.While stmt, Environment environment) {
 
 		// Determine typing at beginning of loop
-		environment = computeFixedPoint(environment, stmt.body, stmt.condition,
-				false, stmt);
+		environment = computeFixedPoint(environment, stmt.body, stmt.condition, false, stmt);
 
 		// Type loop invariant(s)
 		List<Expr> stmt_invariants = stmt.invariants;
@@ -883,8 +875,7 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 		// Type condition assuming its false to represent the terminated loop.
 		// This is important if the condition contains a type test, as we'll
 		// know that doesn't hold here.
-		Pair<Expr, Environment> p = propagateCondition(stmt.condition, false,
-				environment, current);
+		Pair<Expr, Environment> p = propagateCondition(stmt.condition, false, environment, current);
 		stmt.condition = p.first();
 		environment = p.second();
 
@@ -903,8 +894,7 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 				if (p == null) {
 					syntaxError(errorMessage(UNKNOWN_VARIABLE), filename, lval);
 				}
-				Expr.AssignedVariable lv = new Expr.AssignedVariable(av.var,
-						av.attributes());
+				Expr.AssignedVariable lv = new Expr.AssignedVariable(av.var, av.attributes());
 				lv.type = p;
 				return lv;
 			} else if (lval instanceof Expr.RationalLVal) {
@@ -927,8 +917,7 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 				ai.index = index;
 				Nominal.Array srcType = expandAsEffectiveList(src.result());
 				if (srcType == null) {
-					syntaxError(errorMessage(INVALID_LVAL_EXPRESSION),
-							filename, lval);
+					syntaxError(errorMessage(INVALID_LVAL_EXPRESSION), filename, lval);
 				}
 				ai.srcType = srcType;
 				return ai;
@@ -936,28 +925,23 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 				// this indicates a record update
 				Expr.FieldAccess ad = (Expr.FieldAccess) lval;
 				Expr.LVal src = propagate((Expr.LVal) ad.src, environment);
-				Expr.FieldAccess ra = new Expr.FieldAccess(src, ad.name,
-						ad.attributes());
-				Nominal.Record srcType = expandAsEffectiveRecord(src
-						.result());
+				Expr.FieldAccess ra = new Expr.FieldAccess(src, ad.name, ad.attributes());
+				Nominal.Record srcType = expandAsEffectiveRecord(src.result());
 				if (srcType == null) {
-					syntaxError(errorMessage(INVALID_LVAL_EXPRESSION),
-							filename, lval);
+					syntaxError(errorMessage(INVALID_LVAL_EXPRESSION), filename, lval);
 				} else if (srcType.field(ra.name) == null) {
-					syntaxError(errorMessage(RECORD_MISSING_FIELD, ra.name),
-							filename, lval);
+					syntaxError(errorMessage(RECORD_MISSING_FIELD, ra.name), filename, lval);
 				}
 				ra.srcType = srcType;
 				return ra;
-			} 
+			}
 		} catch (SyntaxError e) {
 			throw e;
 		} catch (Throwable e) {
 			internalFailure(e.getMessage(), filename, lval, e);
 			return null; // dead code
 		}
-		internalFailure("unknown lval: " + lval.getClass().getName(), filename,
-				lval);
+		internalFailure("unknown lval: " + lval.getClass().getName(), filename, lval);
 		return null; // dead code
 	}
 
@@ -1007,17 +991,15 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 	 *            function declaration, etc)
 	 * @return
 	 */
-	public Pair<Expr, Environment> propagateCondition(Expr expr, boolean sign,
-			Environment environment, Context context) {
+	public Pair<Expr, Environment> propagateCondition(Expr expr, boolean sign, Environment environment,
+			Context context) {
 
 		// Split up into the compound and non-compound forms.
 
 		if (expr instanceof Expr.UnOp) {
-			return propagateCondition((Expr.UnOp) expr, sign, environment,
-					context);
+			return propagateCondition((Expr.UnOp) expr, sign, environment, context);
 		} else if (expr instanceof Expr.BinOp) {
-			return propagateCondition((Expr.BinOp) expr, sign, environment,
-					context);
+			return propagateCondition((Expr.BinOp) expr, sign, environment, context);
 		} else {
 			// For non-compound forms, can just default back to the base rules
 			// for general expressions.
@@ -1047,15 +1029,14 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 	 *            function declaration, etc)
 	 * @return
 	 */
-	private Pair<Expr, Environment> propagateCondition(Expr.UnOp expr,
-			boolean sign, Environment environment, Context context) {
+	private Pair<Expr, Environment> propagateCondition(Expr.UnOp expr, boolean sign, Environment environment,
+			Context context) {
 		Expr.UnOp uop = (Expr.UnOp) expr;
 
 		// Check whether we have logical not
 
 		if (uop.op == Expr.UOp.NOT) {
-			Pair<Expr, Environment> p = propagateCondition(uop.mhs, !sign,
-					environment, context);
+			Pair<Expr, Environment> p = propagateCondition(uop.mhs, !sign, environment, context);
 			uop.mhs = p.first();
 			checkIsSubtype(Type.T_BOOL, uop.mhs, context);
 			uop.type = Nominal.T_BOOL;
@@ -1088,8 +1069,8 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 	 *            function declaration, etc)
 	 * @return
 	 */
-	private Pair<Expr, Environment> propagateCondition(Expr.BinOp bop,
-			boolean sign, Environment environment, Context context) {
+	private Pair<Expr, Environment> propagateCondition(Expr.BinOp bop, boolean sign, Environment environment,
+			Context context) {
 		Expr.BOp op = bop.op;
 
 		// Split into the two broard cases: logical connectives and primitives.
@@ -1133,12 +1114,11 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 	 *            function declaration, etc)
 	 * @return
 	 */
-	private Pair<Expr, Environment> resolveNonLeafCondition(Expr.BinOp bop,
-			boolean sign, Environment environment, Context context) {
+	private Pair<Expr, Environment> resolveNonLeafCondition(Expr.BinOp bop, boolean sign, Environment environment,
+			Context context) {
 		Expr.BOp op = bop.op;
 		Pair<Expr, Environment> p;
-		boolean followOn = (sign && op == Expr.BOp.AND)
-				|| (!sign && op == Expr.BOp.OR);
+		boolean followOn = (sign && op == Expr.BOp.AND) || (!sign && op == Expr.BOp.OR);
 
 		if (followOn) {
 			// In this case, the environment feeds directly from the result of
@@ -1204,8 +1184,8 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 	 *            function declaration, etc)
 	 * @return
 	 */
-	private Pair<Expr, Environment> resolveLeafCondition(Expr.BinOp bop,
-			boolean sign, Environment environment, Context context) {
+	private Pair<Expr, Environment> resolveLeafCondition(Expr.BinOp bop, boolean sign, Environment environment,
+			Context context) {
 		Expr.BOp op = bop.op;
 
 		Expr lhs = propagate(bop.lhs, environment, context);
@@ -1226,8 +1206,7 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 			if (rhs instanceof Expr.TypeVal) {
 				// yes, right-hand side is a constant
 				Expr.TypeVal tv = (Expr.TypeVal) rhs;
-				Nominal unconstrainedTestType = resolveAsUnconstrainedType(
-						tv.unresolvedType, context);
+				Nominal unconstrainedTestType = resolveAsUnconstrainedType(tv.unresolvedType, context);
 
 				/**
 				 * Determine the types guaranteed to hold on the true and false
@@ -1250,19 +1229,15 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 				 * The unconstrained type of listnat is [int], since nat is a
 				 * constrained type.
 				 */
-				Nominal glbForFalseBranch = Nominal.intersect(lhs.result(),
-						Nominal.Negation(unconstrainedTestType));
-				Nominal glbForTrueBranch = Nominal.intersect(lhs.result(),
-						tv.type);
+				Nominal glbForFalseBranch = Nominal.intersect(lhs.result(), Nominal.Negation(unconstrainedTestType));
+				Nominal glbForTrueBranch = Nominal.intersect(lhs.result(), tv.type);
 
 				if (glbForFalseBranch.raw() == Type.T_VOID) {
 					// DEFINITE TRUE CASE
 					syntaxError(errorMessage(BRANCH_ALWAYS_TAKEN), context, bop);
 				} else if (glbForTrueBranch.raw() == Type.T_VOID) {
 					// DEFINITE FALSE CASE
-					syntaxError(
-							errorMessage(INCOMPARABLE_OPERANDS, lhsRawType,
-									tv.type.raw()), context, bop);
+					syntaxError(errorMessage(INCOMPARABLE_OPERANDS, lhsRawType, tv.type.raw()), context, bop);
 				}
 
 				// Finally, if the lhs is local variable then update its
@@ -1295,9 +1270,7 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 			checkSuptypes(rhs, context, Nominal.T_INT, Nominal.T_REAL);
 			//
 			if (!lhsRawType.equals(rhsRawType)) {
-				syntaxError(
-						errorMessage(INCOMPARABLE_OPERANDS, lhsRawType,
-								rhsRawType), filename, bop);
+				syntaxError(errorMessage(INCOMPARABLE_OPERANDS, lhsRawType, rhsRawType), filename, bop);
 				return null;
 			} else {
 				bop.srcType = lhs.result();
@@ -1311,23 +1284,19 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 			// first, check for special case of e.g. x != null. This is then
 			// treated the same as !(x is null)
 
-			if (lhs instanceof Expr.LocalVariable
-					&& rhs instanceof Expr.Constant
+			if (lhs instanceof Expr.LocalVariable && rhs instanceof Expr.Constant
 					&& ((Expr.Constant) rhs).value == Constant.V_NULL) {
 				// bingo, special case
 				Expr.LocalVariable lv = (Expr.LocalVariable) lhs;
 				Nominal newType;
 				Nominal glb = Nominal.intersect(lhs.result(), Nominal.T_NULL);
 				if (glb.raw() == Type.T_VOID) {
-					syntaxError(
-							errorMessage(INCOMPARABLE_OPERANDS, lhs.result()
-									.raw(), Type.T_NULL), context, bop);
+					syntaxError(errorMessage(INCOMPARABLE_OPERANDS, lhs.result().raw(), Type.T_NULL), context, bop);
 					return null;
 				} else if (sign) {
 					newType = glb;
 				} else {
-					newType = Nominal
-							.intersect(lhs.result(), Nominal.T_NOTNULL);
+					newType = Nominal.intersect(lhs.result(), Nominal.T_NOTNULL);
 				}
 				bop.srcType = lhs.result();
 				environment = environment.update(lv.var, newType);
@@ -1338,9 +1307,7 @@ private Environment propagate(Stmt.While stmt, Environment environment) {
 				} else if (Type.isSubtype(rhsRawType, lhsRawType)) {
 					bop.srcType = rhs.result();
 				} else {
-					syntaxError(
-							errorMessage(INCOMPARABLE_OPERANDS, lhsRawType,
-									rhsRawType), context, bop);
+					syntaxError(errorMessage(INCOMPARABLE_OPERANDS, lhsRawType, rhsRawType), context, bop);
 					return null; // dead code
 				}
 			}
@@ -1382,19 +1349,15 @@ public Expr propagate(Expr expr, Environment environment, Context context) {
 			} else if (expr instanceof Expr.Cast) {
 				return propagate((Expr.Cast) expr, environment, context);
 			} else if (expr instanceof Expr.ConstantAccess) {
-				return propagate((Expr.ConstantAccess) expr, environment,
-						context);
+				return propagate((Expr.ConstantAccess) expr, environment, context);
 			} else if (expr instanceof Expr.FieldAccess) {
 				return propagate((Expr.FieldAccess) expr, environment, context);
 			} else if (expr instanceof Expr.AbstractFunctionOrMethod) {
-				return propagate((Expr.AbstractFunctionOrMethod) expr,
-						environment, context);
+				return propagate((Expr.AbstractFunctionOrMethod) expr, environment, context);
 			} else if (expr instanceof Expr.AbstractInvoke) {
-				return propagate((Expr.AbstractInvoke) expr, environment,
-						context);
+				return propagate((Expr.AbstractInvoke) expr, environment, context);
 			} else if (expr instanceof Expr.AbstractIndirectInvoke) {
-				return propagate((Expr.AbstractIndirectInvoke) expr,
-						environment, context);
+				return propagate((Expr.AbstractIndirectInvoke) expr, environment, context);
 			} else if (expr instanceof Expr.IndexOf) {
 				return propagate((Expr.IndexOf) expr, environment, context);
 			} else if (expr instanceof Expr.Lambda) {
@@ -1402,8 +1365,7 @@ public Expr propagate(Expr expr, Environment environment, Context context) {
 			} else if (expr instanceof Expr.LengthOf) {
 				return propagate((Expr.LengthOf) expr, environment, context);
 			} else if (expr instanceof Expr.LocalVariable) {
-				return propagate((Expr.LocalVariable) expr, environment,
-						context);
+				return propagate((Expr.LocalVariable) expr, environment, context);
 			} else if (expr instanceof Expr.ArrayInitialiser) {
 				return propagate((Expr.ArrayInitialiser) expr, environment, context);
 			} else if (expr instanceof Expr.ArrayGenerator) {
@@ -1418,21 +1380,18 @@ public Expr propagate(Expr expr, Environment environment, Context context) {
 				return propagate((Expr.TypeVal) expr, environment, context);
 			}
 		} catch (ResolveError e) {
-			syntaxError(errorMessage(RESOLUTION_ERROR, e.getMessage()),
-					context, expr, e);
+			syntaxError(errorMessage(RESOLUTION_ERROR, e.getMessage()), context, expr, e);
 		} catch (SyntaxError e) {
 			throw e;
 		} catch (Throwable e) {
 			internalFailure(e.getMessage(), context, expr, e);
 			return null; // dead code
 		}
-		internalFailure("unknown expression: " + expr.getClass().getName(),
-				context, expr);
+		internalFailure("unknown expression: " + expr.getClass().getName(), context, expr);
 		return null; // dead code
 	}
 
-	private Expr propagate(Expr.BinOp expr, Environment environment,
-			Context context) throws IOException {
+	private Expr propagate(Expr.BinOp expr, Environment environment, Context context) throws IOException {
 
 		// TODO: split binop into arithmetic and conditional operators. This
 		// would avoid the following case analysis since conditional binary
@@ -1467,8 +1426,7 @@ private Expr propagate(Expr.BinOp expr, Environment environment,
 		case AND:
 		case OR:
 		case XOR:
-			return propagateCondition(expr, true, environment, context)
-					.first();
+			return propagateCondition(expr, true, environment, context).first();
 		case BITWISEAND:
 		case BITWISEOR:
 		case BITWISEXOR:
@@ -1498,14 +1456,12 @@ private Expr propagate(Expr.BinOp expr, Environment environment,
 			checkSuptypes(rhs, context, Nominal.T_INT, Nominal.T_REAL);
 			//
 			if (!lhsRawType.equals(rhsRawType)) {
-				syntaxError(
-						errorMessage(INCOMPARABLE_OPERANDS, lhsRawType,
-								rhsRawType), filename, expr);
+				syntaxError(errorMessage(INCOMPARABLE_OPERANDS, lhsRawType, rhsRawType), filename, expr);
 				return null;
 			} else {
 				srcType = lhsRawType;
 			}
-		}		
+		}
 
 		// FIXME: loss of nominal information
 		expr.srcType = Nominal.construct(srcType, srcType);
@@ -1513,8 +1469,7 @@ private Expr propagate(Expr.BinOp expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.UnOp expr, Environment environment,
-			Context context) throws IOException {
+	private Expr propagate(Expr.UnOp expr, Environment environment, Context context) throws IOException {
 
 		if (expr.op == Expr.UOp.NOT) {
 			// hand off to special method for conditions
@@ -1533,9 +1488,7 @@ private Expr propagate(Expr.UnOp expr, Environment environment,
 			break;
 
 		default:
-			internalFailure(
-					"unknown operator: " + expr.op.getClass().getName(),
-					context, expr);
+			internalFailure("unknown operator: " + expr.op.getClass().getName(), context, expr);
 		}
 
 		expr.type = src.result();
@@ -1543,8 +1496,8 @@ private Expr propagate(Expr.UnOp expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.Quantifier expr, Environment environment,
-			Context context) throws IOException, ResolveError {
+	private Expr propagate(Expr.Quantifier expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 
 		ArrayList<Triple<String, Expr, Expr>> sources = expr.sources;
 		Environment local = environment.clone();
@@ -1552,8 +1505,7 @@ private Expr propagate(Expr.Quantifier expr, Environment environment,
 			Triple<String, Expr, Expr> p = sources.get(i);
 			Expr start = propagate(p.second(), local, context);
 			Expr end = propagate(p.third(), local, context);
-			sources.set(i,
-					new Triple<String, Expr, Expr>(p.first(), start, end));
+			sources.set(i, new Triple<String, Expr, Expr>(p.first(), start, end));
 			checkIsSubtype(Type.T_INT, start, context);
 			local = local.declare(p.first(), Nominal.T_INT, Nominal.T_INT);
 		}
@@ -1569,13 +1521,11 @@ private Expr propagate(Expr.Quantifier expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.Constant expr, Environment environment,
-			Context context) {
+	private Expr propagate(Expr.Constant expr, Environment environment, Context context) {
 		return expr;
 	}
 
-	private Expr propagate(Expr.Cast c, Environment environment, Context context)
-			throws IOException {
+	private Expr propagate(Expr.Cast c, Environment environment, Context context) throws IOException {
 		c.expr = propagate(c.expr, environment, context);
 		c.type = resolveAsType(c.unresolvedType, context);
 		Type from = c.expr.result().raw();
@@ -1586,9 +1536,8 @@ private Expr propagate(Expr.Cast c, Environment environment, Context context)
 		return c;
 	}
 
-	private Expr propagate(Expr.AbstractFunctionOrMethod expr,
-			Environment environment, Context context) throws IOException,
-			ResolveError {
+	private Expr propagate(Expr.AbstractFunctionOrMethod expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 
 		if (expr instanceof Expr.FunctionOrMethod) {
 			return expr;
@@ -1602,58 +1551,57 @@ private Expr propagate(Expr.AbstractFunctionOrMethod expr,
 				paramTypes.add(resolveAsType(t, context));
 			}
 			// FIXME: clearly a bug here in the case of message reference
-			p = (Pair<NameID, Nominal.FunctionOrMethod>) resolveAsFunctionOrMethod(
-					expr.name, paramTypes, context);
+			p = (Pair<NameID, Nominal.FunctionOrMethod>) resolveAsFunctionOrMethod(expr.name, paramTypes, context);
 		} else {
 			p = resolveAsFunctionOrMethod(expr.name, context);
 		}
 
-		expr = new Expr.FunctionOrMethod(p.first(), expr.paramTypes,
-				expr.attributes());
+		expr = new Expr.FunctionOrMethod(p.first(), expr.paramTypes, expr.attributes());
 		expr.type = p.second();
 		return expr;
 	}
 
-	private Expr propagate(Expr.Lambda expr, Environment environment,
-			Context context) throws IOException {
-
-		ArrayList<Type> rawTypes = new ArrayList<Type>();
-		ArrayList<Type> nomTypes = new ArrayList<Type>();
-
+	private Expr propagate(Expr.Lambda expr, Environment environment, Context context) throws IOException {
+		Type.FunctionOrMethod rawResultType;
+		Type.FunctionOrMethod nomResultType;
+		ArrayList<Type> rawParameterTypes = new ArrayList<Type>();
+		ArrayList<Type> nomParameterTypes = new ArrayList<Type>();
+		ArrayList<Type> rawReturnTypes = new ArrayList<Type>();
+		ArrayList<Type> nomReturnTypes = new ArrayList<Type>();
+		
 		for (WhileyFile.Parameter p : expr.parameters) {
 			Nominal n = resolveAsType(p.type, context);
-			rawTypes.add(n.raw());
-			nomTypes.add(n.nominal());
+			rawParameterTypes.add(n.raw());
+			nomParameterTypes.add(n.nominal());
 			// Now, update the environment to include those declared variables
 			String var = p.name();
 			if (environment.containsKey(var)) {
-				syntaxError(errorMessage(VARIABLE_ALREADY_DEFINED, var),
-						context, p);
+				syntaxError(errorMessage(VARIABLE_ALREADY_DEFINED, var), context, p);
 			}
 			environment = environment.declare(var, n, n);
 		}
 
 		expr.body = propagate(expr.body, environment, context);
-
-		Type.FunctionOrMethod rawType;
-		Type.FunctionOrMethod nomType;
+		Nominal result = expr.body.result();
+		if(result != null) {
+			rawReturnTypes.add(result.raw());
+			nomReturnTypes.add(result.nominal());
+		}
 
 		if (Exprs.isPure(expr.body, context)) {
-			rawType = Type.Function(expr.body.result().raw(), rawTypes);
-			nomType = Type.Function(expr.body.result().nominal(), nomTypes);
+			rawResultType = Type.Function(rawReturnTypes, rawParameterTypes);
+			nomResultType = Type.Function(nomReturnTypes, nomParameterTypes);
 		} else {
-			rawType = Type.Method(expr.body.result().raw(), rawTypes);
-			nomType = Type.Method(expr.body.result().nominal(), nomTypes);
+			rawResultType = Type.Method(rawReturnTypes, rawParameterTypes);
+			nomResultType = Type.Method(nomReturnTypes, nomParameterTypes);
 		}
 
-		expr.type = (Nominal.FunctionOrMethod) Nominal.construct(nomType,
-				rawType);
+		expr.type = (Nominal.FunctionOrMethod) Nominal.construct(nomResultType, rawResultType);
 		return expr;
 	}
 
-	private Expr propagate(Expr.AbstractIndirectInvoke expr,
-			Environment environment, Context context) throws IOException,
-			ResolveError {
+	private Expr propagate(Expr.AbstractIndirectInvoke expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 
 		expr.src = propagate(expr.src, environment, context);
 		Nominal.FunctionOrMethod funType = expandAsFunctionOrMethod(expr.src.result());
@@ -1665,9 +1613,7 @@ private Expr propagate(Expr.AbstractIndirectInvoke expr,
 		ArrayList<Expr> exprArgs = expr.arguments;
 
 		if (paramTypes.size() != exprArgs.size()) {
-			syntaxError(
-					"insufficient arguments for function or method invocation",
-					context, expr.src);
+			syntaxError("insufficient arguments for function or method invocation", context, expr.src);
 		}
 
 		for (int i = 0; i != exprArgs.size(); ++i) {
@@ -1679,21 +1625,19 @@ private Expr propagate(Expr.AbstractIndirectInvoke expr,
 		}
 
 		if (funType instanceof Nominal.Function) {
-			Expr.IndirectFunctionCall ifc = new Expr.IndirectFunctionCall(
-					expr.src, exprArgs, expr.attributes());
+			Expr.IndirectFunctionCall ifc = new Expr.IndirectFunctionCall(expr.src, exprArgs, expr.attributes());
 			ifc.functionType = (Nominal.Function) funType;
 			return ifc;
 		} else {
-			Expr.IndirectMethodCall imc = new Expr.IndirectMethodCall(expr.src,
-					exprArgs, expr.attributes());
+			Expr.IndirectMethodCall imc = new Expr.IndirectMethodCall(expr.src, exprArgs, expr.attributes());
 			imc.methodType = (Nominal.Method) funType;
 			return imc;
 		}
 
 	}
 
-	private Expr propagate(Expr.AbstractInvoke expr, Environment environment,
-			Context context) throws IOException, ResolveError {
+	private Expr propagate(Expr.AbstractInvoke expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 
 		// first, resolve through receiver and parameters.
 
@@ -1719,31 +1663,26 @@ private Expr propagate(Expr.AbstractInvoke expr, Environment environment,
 
 		// third, lookup the appropriate function or method based on the name
 		// and given parameter types.
-		Nominal.FunctionOrMethod funType = resolveAsFunctionOrMethod(name,
-				paramTypes, context);
+		Nominal.FunctionOrMethod funType = resolveAsFunctionOrMethod(name, paramTypes, context);
 		if (funType instanceof Nominal.Function) {
-			Expr.FunctionCall r = new Expr.FunctionCall(name, qualification,
-					exprArgs, expr.attributes());
+			Expr.FunctionCall r = new Expr.FunctionCall(name, qualification, exprArgs, expr.attributes());
 			r.functionType = (Nominal.Function) funType;
 			return r;
 		} else {
-			Expr.MethodCall r = new Expr.MethodCall(name, qualification,
-					exprArgs, expr.attributes());
+			Expr.MethodCall r = new Expr.MethodCall(name, qualification, exprArgs, expr.attributes());
 			r.methodType = (Nominal.Method) funType;
 			return r;
 		}
 	}
 
-	private Expr propagate(Expr.IndexOf expr, Environment environment,
-			Context context) throws IOException, ResolveError {
+	private Expr propagate(Expr.IndexOf expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 		expr.src = propagate(expr.src, environment, context);
 		expr.index = propagate(expr.index, environment, context);
-		Nominal.Array srcType = expandAsEffectiveList(expr.src
-				.result());
+		Nominal.Array srcType = expandAsEffectiveList(expr.src.result());
 
 		if (srcType == null) {
-			syntaxError(errorMessage(INVALID_ARRAY_EXPRESSION), context,
-					expr.src);
+			syntaxError(errorMessage(INVALID_ARRAY_EXPRESSION), context, expr.src);
 		} else {
 			expr.srcType = srcType;
 		}
@@ -1753,16 +1692,14 @@ private Expr propagate(Expr.IndexOf expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.LengthOf expr, Environment environment,
-			Context context) throws IOException, ResolveError {
+	private Expr propagate(Expr.LengthOf expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 		expr.src = propagate(expr.src, environment, context);
 
-		Nominal.Array srcType = expandAsEffectiveList(expr.src
-				.result());
+		Nominal.Array srcType = expandAsEffectiveList(expr.src.result());
 
 		if (srcType == null) {
-			syntaxError("found " + expr.src.result().nominal()
-					+ ", expected string, set, list or dictionary.", context,
+			syntaxError("found " + expr.src.result().nominal() + ", expected string, set, list or dictionary.", context,
 					expr.src);
 		} else {
 			expr.srcType = srcType;
@@ -1771,15 +1708,13 @@ private Expr propagate(Expr.LengthOf expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.LocalVariable expr, Environment environment,
-			Context context) throws IOException {
+	private Expr propagate(Expr.LocalVariable expr, Environment environment, Context context) throws IOException {
 		Nominal type = environment.getCurrentType(expr.var);
 		expr.type = type;
 		return expr;
 	}
 
-	private Expr propagate(Expr.ArrayInitialiser expr, Environment environment,
-			Context context) {
+	private Expr propagate(Expr.ArrayInitialiser expr, Environment environment, Context context) {
 		Nominal element = Nominal.T_VOID;
 
 		ArrayList<Expr> exprs = expr.arguments;
@@ -1794,17 +1729,15 @@ private Expr propagate(Expr.ArrayInitialiser expr, Environment environment,
 
 		return expr;
 	}
-	
-	private Expr propagate(Expr.ArrayGenerator expr, Environment environment,
-			Context context) {
+
+	private Expr propagate(Expr.ArrayGenerator expr, Environment environment, Context context) {
 		expr.element = propagate(expr.element, environment, context);
 		expr.count = propagate(expr.count, environment, context);
 		expr.type = Nominal.Array(expr.element.result(), true);
 		return expr;
 	}
-	
-	private Expr propagate(Expr.Record expr, Environment environment,
-			Context context) {
+
+	private Expr propagate(Expr.Record expr, Environment environment, Context context) {
 
 		HashMap<String, Expr> exprFields = expr.fields;
 		HashMap<String, Nominal> fieldTypes = new HashMap<String, Nominal>();
@@ -1822,26 +1755,23 @@ private Expr propagate(Expr.Record expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.FieldAccess ra, Environment environment,
-			Context context) throws IOException, ResolveError {
+	private Expr propagate(Expr.FieldAccess ra, Environment environment, Context context)
+			throws IOException, ResolveError {
 		ra.src = propagate(ra.src, environment, context);
 		Nominal srcType = ra.src.result();
 		Nominal.Record recType = expandAsEffectiveRecord(srcType);
 		if (recType == null) {
-			syntaxError(errorMessage(RECORD_TYPE_REQUIRED, srcType.raw()),
-					context, ra);
+			syntaxError(errorMessage(RECORD_TYPE_REQUIRED, srcType.raw()), context, ra);
 		}
 		Nominal fieldType = recType.field(ra.name);
 		if (fieldType == null) {
-			syntaxError(errorMessage(RECORD_MISSING_FIELD, ra.name), context,
-					ra);
+			syntaxError(errorMessage(RECORD_MISSING_FIELD, ra.name), context, ra);
 		}
 		ra.srcType = recType;
 		return ra;
 	}
 
-	private Expr propagate(Expr.ConstantAccess expr, Environment environment,
-			Context context) throws IOException {
+	private Expr propagate(Expr.ConstantAccess expr, Environment environment, Context context) throws IOException {
 		// First, determine the fully qualified name of this function based on
 		// the given function name and any supplied qualifications.
 		ArrayList<String> qualifications = new ArrayList<String>();
@@ -1854,7 +1784,7 @@ private Expr propagate(Expr.ConstantAccess expr, Environment environment,
 		try {
 			NameID name = resolveAsName(qualifications, context);
 			// Second, determine the value of the constant.
-			Pair<Constant,Nominal> ct = resolveAsConstant(name);
+			Pair<Constant, Nominal> ct = resolveAsConstant(name);
 			expr.value = ct.first();
 			expr.type = ct.second();
 			return expr;
@@ -1864,8 +1794,8 @@ private Expr propagate(Expr.ConstantAccess expr, Environment environment,
 		}
 	}
 
-	private Expr propagate(Expr.Dereference expr, Environment environment,
-			Context context) throws IOException, ResolveError {
+	private Expr propagate(Expr.Dereference expr, Environment environment, Context context)
+			throws IOException, ResolveError {
 		Expr src = propagate(expr.src, environment, context);
 		expr.src = src;
 		Nominal.Reference srcType = expandAsReference(src.result());
@@ -1876,16 +1806,14 @@ private Expr propagate(Expr.Dereference expr, Environment environment,
 		return expr;
 	}
 
-	private Expr propagate(Expr.New expr, Environment environment,
-			Context context) {
+	private Expr propagate(Expr.New expr, Environment environment, Context context) {
 		expr.expr = propagate(expr.expr, environment, context);
 		expr.type = Nominal.Reference(expr.expr.result());
 		return expr;
 	}
 
-	private Expr propagate(Expr.TypeVal expr, Environment environment,
-			Context context) throws IOException {
-		expr.type = resolveAsType(expr.unresolvedType, context);		
+	private Expr propagate(Expr.TypeVal expr, Environment environment, Context context) throws IOException {
+		expr.type = resolveAsType(expr.unresolvedType, context);
 		return expr;
 	}
 
@@ -1941,9 +1869,8 @@ private Expr propagate(Expr.TypeVal expr, Environment environment,
 	 *            first iteration.
 	 * @return
 	 */
-	private Environment computeFixedPoint(Environment environment,
-			ArrayList<Stmt> body, Expr condition, boolean doWhile,
-			SyntacticElement element) {
+	private Environment computeFixedPoint(Environment environment, ArrayList<Stmt> body, Expr condition,
+			boolean doWhile, SyntacticElement element) {
 		// The count is used simply to guarantee termination.
 		int count = 0;
 		// The original environment is an exact copy of the initial environment.
@@ -1967,8 +1894,7 @@ private Environment computeFixedPoint(Environment environment,
 			// Second, propagate through condition (if applicable). This may
 			// update the environment if one or more type tests are used.
 			if (condition != null && !doWhile) {
-				tmp = propagateCondition(condition, true, old.clone(), current)
-						.second();
+				tmp = propagateCondition(condition, true, old.clone(), current).second();
 			} else {
 				tmp = old;
 				doWhile = false;
@@ -2000,9 +1926,8 @@ private Environment computeFixedPoint(Environment environment,
 	 * @return
 	 * @throws IOException
 	 */
-	public Nominal.FunctionOrMethod resolveAsFunctionOrMethod(NameID nid,
-			List<Nominal> parameters, Context context) throws IOException,
-			ResolveError {
+	public Nominal.FunctionOrMethod resolveAsFunctionOrMethod(NameID nid, List<Nominal> parameters, Context context)
+			throws IOException, ResolveError {
 
 		// Thet set of candidate names and types for this function or method.
 		HashSet<Pair<NameID, Nominal.FunctionOrMethod>> candidates = new HashSet<Pair<NameID, Nominal.FunctionOrMethod>>();
@@ -2013,8 +1938,7 @@ private Environment computeFixedPoint(Environment environment,
 
 		// Second, add to narrow down the list of candidates to a single choice.
 		// If this is impossible, then we have an ambiguity error.
-		return selectCandidateFunctionOrMethod(nid.name(), parameters,
-				candidates, context).second();
+		return selectCandidateFunctionOrMethod(nid.name(), parameters, candidates, context).second();
 	}
 
 	/**
@@ -2030,8 +1954,8 @@ private Environment computeFixedPoint(Environment environment,
 	 * @return
 	 * @throws IOException
 	 */
-	public Pair<NameID, Nominal.FunctionOrMethod> resolveAsFunctionOrMethod(
-			String name, Context context) throws IOException, ResolveError {
+	public Pair<NameID, Nominal.FunctionOrMethod> resolveAsFunctionOrMethod(String name, Context context)
+			throws IOException, ResolveError {
 		return resolveAsFunctionOrMethod(name, null, context);
 	}
 
@@ -2049,9 +1973,8 @@ private Environment computeFixedPoint(Environment environment,
 	 * @return
 	 * @throws IOException
 	 */
-	public Pair<NameID, Nominal.FunctionOrMethod> resolveAsFunctionOrMethod(
-			String name, List<Nominal> parameters, Context context)
-			throws IOException, ResolveError {
+	public Pair<NameID, Nominal.FunctionOrMethod> resolveAsFunctionOrMethod(String name, List<Nominal> parameters,
+			Context context) throws IOException, ResolveError {
 
 		HashSet<Pair<NameID, Nominal.FunctionOrMethod>> candidates = new HashSet<Pair<NameID, Nominal.FunctionOrMethod>>();
 		// first, try to find the matching message
@@ -2067,18 +1990,15 @@ private Environment computeFixedPoint(Environment environment,
 				}
 				for (Path.ID mid : builder.imports(filter)) {
 					NameID nid = new NameID(mid, name);
-					addCandidateFunctionsAndMethods(nid, parameters,
-							candidates, context);
+					addCandidateFunctionsAndMethods(nid, parameters, candidates, context);
 				}
 			}
 		}
 
-		return selectCandidateFunctionOrMethod(name, parameters, candidates,
-				context);
+		return selectCandidateFunctionOrMethod(name, parameters, candidates, context);
 	}
 
-	private boolean paramSubtypes(Type.FunctionOrMethod f1,
-			Type.FunctionOrMethod f2) {
+	private boolean paramSubtypes(Type.FunctionOrMethod f1, Type.FunctionOrMethod f2) {
 		List<Type> f1_params = f1.params();
 		List<Type> f2_params = f2.params();
 		if (f1_params.size() == f2_params.size()) {
@@ -2095,8 +2015,7 @@ private boolean paramSubtypes(Type.FunctionOrMethod f1,
 		return false;
 	}
 
-	private boolean paramStrictSubtypes(Type.FunctionOrMethod f1,
-			Type.FunctionOrMethod f2) {
+	private boolean paramStrictSubtypes(Type.FunctionOrMethod f1, Type.FunctionOrMethod f2) {
 		List<Type> f1_params = f1.params();
 		List<Type> f2_params = f2.params();
 		if (f1_params.size() == f2_params.size()) {
@@ -2135,17 +2054,20 @@ private String parameterString(List<Nominal> paramTypes) {
 		return paramStr + ")";
 	}
 
-	private Pair<NameID, Nominal.FunctionOrMethod> selectCandidateFunctionOrMethod(
-			String name, List<Nominal> parameters,
-			Collection<Pair<NameID, Nominal.FunctionOrMethod>> candidates,
-			Context context) throws IOException, ResolveError {
+	private Pair<NameID, Nominal.FunctionOrMethod> selectCandidateFunctionOrMethod(String name,
+			List<Nominal> parameters, Collection<Pair<NameID, Nominal.FunctionOrMethod>> candidates, Context context)
+					throws IOException, ResolveError {
 
 		List<Type> rawParameters;
 		Type.Function target;
 
 		if (parameters != null) {
-			rawParameters = stripNominal(parameters);
-			target = (Type.Function) Type.Function(Type.T_ANY,rawParameters);
+			// FIXME: this seems to be fundamentally broken in that the number
+			// of expected return values is completely unknown.
+			ArrayList<Type> rawReturns = new ArrayList<Type>();
+			rawReturns.add(Type.T_ANY);
+			rawParameters = stripNominal(parameters);			
+			target = (Type.Function) Type.Function(rawReturns, rawParameters);
 		} else {
 			rawParameters = null;
 			target = null;
@@ -2158,19 +2080,15 @@ private String parameterString(List<Nominal> paramTypes) {
 			Type.FunctionOrMethod ft = nft.raw();
 			if (parameters == null || paramSubtypes(ft, target)) {
 				// this is now a genuine candidate
-				if (candidateType == null
-						|| paramStrictSubtypes(candidateType.raw(), ft)) {
+				if (candidateType == null || paramStrictSubtypes(candidateType.raw(), ft)) {
 					candidateType = nft;
 					candidateID = p.first();
 				} else if (!paramStrictSubtypes(ft, candidateType.raw())) {
 					// this is an ambiguous error
-					String msg = name + parameterString(parameters)
-							+ " is ambiguous";
+					String msg = name + parameterString(parameters) + " is ambiguous";
 					// FIXME: should report all ambiguous matches here
-					msg += "\n\tfound: " + candidateID + " : "
-							+ candidateType.nominal();
-					msg += "\n\tfound: " + p.first() + " : "
-							+ p.second().nominal();
+					msg += "\n\tfound: " + candidateID + " : " + candidateType.nominal();
+					msg += "\n\tfound: " + p.first() + " : " + p.second().nominal();
 					throw new ResolveError(msg);
 				}
 			}
@@ -2190,13 +2108,11 @@ private String parameterString(List<Nominal> paramTypes) {
 			WhileyFile wf = builder.getSourceFile(candidateID.module());
 			if (wf != null) {
 				if (wf != context.file()) {
-					for (WhileyFile.FunctionOrMethod d : wf.declarations(
-							WhileyFile.FunctionOrMethod.class,
+					for (WhileyFile.FunctionOrMethod d : wf.declarations(WhileyFile.FunctionOrMethod.class,
 							candidateID.name())) {
 						if (d.parameters.equals(candidateType.params())) {
 							if (!d.hasModifier(Modifier.PUBLIC)) {
-								String msg = candidateID.module() + "." + name
-										+ parameterString(parameters)
+								String msg = candidateID.module() + "." + name + parameterString(parameters)
 										+ " is not visible";
 								throw new ResolveError(msg);
 							}
@@ -2205,18 +2121,15 @@ private String parameterString(List<Nominal> paramTypes) {
 				}
 			} else {
 				WyilFile m = builder.getModule(candidateID.module());
-				WyilFile.FunctionOrMethod d = m.functionOrMethod(
-						candidateID.name(), candidateType.nominal());
+				WyilFile.FunctionOrMethod d = m.functionOrMethod(candidateID.name(), candidateType.nominal());
 				if (!d.hasModifier(Modifier.PUBLIC)) {
-					String msg = candidateID.module() + "." + name
-							+ parameterString(parameters) + " is not visible";
+					String msg = candidateID.module() + "." + name + parameterString(parameters) + " is not visible";
 					throw new ResolveError(msg);
 				}
 			}
 		}
 
-		return new Pair<NameID, Nominal.FunctionOrMethod>(candidateID,
-				candidateType);
+		return new Pair<NameID, Nominal.FunctionOrMethod>(candidateID, candidateType);
 	}
 
 	/**
@@ -2243,45 +2156,38 @@ private String parameterString(List<Nominal> paramTypes) {
 	 *            --- The context in which we are looking for the given method.
 	 * @throws IOException
 	 */
-	private void addCandidateFunctionsAndMethods(NameID nid,
-			List<?> parameters,
-			Collection<Pair<NameID, Nominal.FunctionOrMethod>> candidates,
-			Context context) throws IOException,ResolveError {
+	private void addCandidateFunctionsAndMethods(NameID nid, List<?> parameters,
+			Collection<Pair<NameID, Nominal.FunctionOrMethod>> candidates, Context context)
+					throws IOException, ResolveError {
 		Path.ID mid = nid.module();
 
 		int nparams = parameters != null ? parameters.size() : -1;
 
 		WhileyFile wf = builder.getSourceFile(mid);
 		if (wf != null) {
-			for (WhileyFile.FunctionOrMethod f : wf.declarations(
-					WhileyFile.FunctionOrMethod.class, nid.name())) {
+			for (WhileyFile.FunctionOrMethod f : wf.declarations(WhileyFile.FunctionOrMethod.class, nid.name())) {
 				if (nparams == -1 || f.parameters.size() == nparams) {
-					Nominal.FunctionOrMethod ft = (Nominal.FunctionOrMethod) resolveAsType(
-							f.unresolvedType(), f);
-					candidates.add(new Pair<NameID, Nominal.FunctionOrMethod>(
-							nid, ft));
+					Nominal.FunctionOrMethod ft = (Nominal.FunctionOrMethod) resolveAsType(f.unresolvedType(), f);
+					candidates.add(new Pair<NameID, Nominal.FunctionOrMethod>(nid, ft));
 				}
 			}
 		} else {
 			WyilFile m = builder.getModule(mid);
-			for (WyilFile.FunctionOrMethod mm : m
-					.functionOrMethods()) {
-				if ((mm.isFunction() || mm.isMethod())
-						&& mm.name().equals(nid.name())
+			for (WyilFile.FunctionOrMethod mm : m.functionOrMethods()) {
+				if ((mm.isFunction() || mm.isMethod()) && mm.name().equals(nid.name())
 						&& (nparams == -1 || mm.type().params().size() == nparams)) {
 					// FIXME: loss of visibility information (e.g if this
 					// function is declared in terms of a protected type)
 					Type.FunctionOrMethod t = (Type.FunctionOrMethod) mm.type();
-					Nominal.FunctionOrMethod fom;					
+					Nominal.FunctionOrMethod fom;
 					if (t instanceof Type.Function) {
-						Type.Function ft = (Type.Function) t;						
+						Type.Function ft = (Type.Function) t;
 						fom = new Nominal.Function(ft, (Type.Function) expander.getUnderlyingType(ft));
 					} else {
 						Type.Method mt = (Type.Method) t;
 						fom = new Nominal.Method(mt, (Type.Method) expander.getUnderlyingType(mt));
 					}
-					candidates.add(new Pair<NameID, Nominal.FunctionOrMethod>(
-							nid, fom));
+					candidates.add(new Pair<NameID, Nominal.FunctionOrMethod>(nid, fom));
 				}
 			}
 		}
@@ -2334,8 +2240,7 @@ private void addCandidateFunctionsAndMethods(NameID nid,
 	 * @throws IOException
 	 *             if it couldn't resolve the name
 	 */
-	public NameID resolveAsName(String name, Context context)
-			throws IOException, ResolveError {
+	public NameID resolveAsName(String name, Context context) throws IOException, ResolveError {
 		for (WhileyFile.Import imp : context.imports()) {
 			String impName = imp.name;
 			if (impName == null || impName.equals(name) || impName.equals("*")) {
@@ -2381,8 +2286,7 @@ public NameID resolveAsName(String name, Context context)
 	 * @throws IOException
 	 *             if it couldn't resolve the name
 	 */
-	public NameID resolveAsName(List<String> names, Context context)
-			throws IOException, ResolveError {
+	public NameID resolveAsName(List<String> names, Context context) throws IOException, ResolveError {
 		if (names.size() == 1) {
 			return resolveAsName(names.get(0), context);
 		} else if (names.size() == 2) {
@@ -2436,8 +2340,7 @@ public NameID resolveAsName(List<String> names, Context context)
 	 * @return
 	 * @throws IOException
 	 */
-	public Path.ID resolveAsModule(String name, Context context)
-			throws IOException, ResolveError {
+	public Path.ID resolveAsModule(String name, Context context) throws IOException, ResolveError {
 
 		for (WhileyFile.Import imp : context.imports()) {
 			Trie filter = imp.filter;
@@ -2461,12 +2364,11 @@ public NameID resolveAsName(List<String> names, Context context)
 	// ResolveAsType
 	// =========================================================================
 
-	public Nominal.Function resolveAsType(SyntacticType.Function t,
-			Context context) {
+	public Nominal.Function resolveAsType(SyntacticType.Function t, Context context) {
 		return (Nominal.Function) resolveAsType((SyntacticType.FunctionOrMethod) t, context);
 	}
 
-	public Nominal.Method resolveAsType(SyntacticType.Method t, Context context) { 
+	public Nominal.Method resolveAsType(SyntacticType.Method t, Context context) {
 		return (Nominal.Method) resolveAsType((SyntacticType.FunctionOrMethod) t, context);
 	}
 
@@ -2481,13 +2383,15 @@ public NameID resolveAsName(List<String> names, Context context)
 				syntaxError("empty type encountered", filename, param);
 			}
 		}
-		Nominal ret = resolveAsType(t.returnType, context);
-		if (!(t.returnType instanceof SyntacticType.Void) && Type.isSubtype(Type.T_VOID, ret.raw())) {
-			syntaxError("empty type encountered", filename, t.returnType);
+		for (SyntacticType ret : t.returnTypes) {
+			Nominal nominal = resolveAsType(ret, context);
+			if (Type.isSubtype(Type.T_VOID, nominal.raw())) {
+				syntaxError("empty type encountered", filename, ret);
+			}
 		}
 		return (Nominal.FunctionOrMethod) resolveAsType((SyntacticType) t, context);
 	}
-	
+
 	/**
 	 * Resolve a type in a given context by identifying all unknown names and
 	 * replacing them with nominal types. The context is that declaration (e.g.
@@ -2521,15 +2425,13 @@ public Nominal resolveAsType(SyntacticType type, Context context) {
 	 * @return
 	 * @throws IOException
 	 */
-	public Nominal resolveAsUnconstrainedType(SyntacticType type,
-			Context context) {
+	public Nominal resolveAsUnconstrainedType(SyntacticType type, Context context) {
 		Type nominalType = resolveAsType(type, context, true, true);
 		Type rawType = resolveAsType(type, context, false, true);
 		return Nominal.construct(nominalType, rawType);
 	}
 
-	private Type resolveAsType(SyntacticType t, Context context,
-			boolean nominal, boolean unconstrained) {
+	private Type resolveAsType(SyntacticType t, Context context, boolean nominal, boolean unconstrained) {
 
 		if (t instanceof SyntacticType.Primitive) {
 			if (t instanceof SyntacticType.Any) {
@@ -2547,8 +2449,7 @@ private Type resolveAsType(SyntacticType t, Context context,
 			} else if (t instanceof SyntacticType.Real) {
 				return Type.T_REAL;
 			} else {
-				internalFailure("unrecognised type encountered ("
-						+ t.getClass().getName() + ")", context, t);
+				internalFailure("unrecognised type encountered (" + t.getClass().getName() + ")", context, t);
 				return null; // deadcode
 			}
 		} else {
@@ -2571,13 +2472,11 @@ private Type resolveAsType(SyntacticType t, Context context,
 	 * @return
 	 * @throws IOException
 	 */
-	private int resolveAsType(SyntacticType type, Context context,
-			ArrayList<Automaton.State> states, HashMap<NameID, Integer> roots,
-			boolean nominal, boolean unconstrained) {
+	private int resolveAsType(SyntacticType type, Context context, ArrayList<Automaton.State> states,
+			HashMap<NameID, Integer> roots, boolean nominal, boolean unconstrained) {
 
 		if (type instanceof SyntacticType.Primitive) {
-			return resolveAsType((SyntacticType.Primitive) type, context,
-					states);
+			return resolveAsType((SyntacticType.Primitive) type, context, states);
 		}
 
 		int myIndex = states.size();
@@ -2592,21 +2491,18 @@ private int resolveAsType(SyntacticType type, Context context,
 			SyntacticType.Array lt = (SyntacticType.Array) type;
 			myKind = Type.K_LIST;
 			myChildren = new int[1];
-			myChildren[0] = resolveAsType(lt.element, context, states, roots,
-					nominal, unconstrained);
+			myChildren[0] = resolveAsType(lt.element, context, states, roots, nominal, unconstrained);
 			myData = false;
 		} else if (type instanceof SyntacticType.Record) {
 			SyntacticType.Record tt = (SyntacticType.Record) type;
 			HashMap<String, SyntacticType> ttTypes = tt.types;
-			Type.Record.State fields = new Type.Record.State(tt.isOpen,
-					ttTypes.keySet());
+			Type.Record.State fields = new Type.Record.State(tt.isOpen, ttTypes.keySet());
 			Collections.sort(fields);
 			myKind = Type.K_RECORD;
 			myChildren = new int[fields.size()];
 			for (int i = 0; i != fields.size(); ++i) {
 				String field = fields.get(i);
-				myChildren[i] = resolveAsType(ttTypes.get(field), context,
-						states, roots, nominal, unconstrained);
+				myChildren[i] = resolveAsType(ttTypes.get(field), context, states, roots, nominal, unconstrained);
 			}
 			myData = fields;
 		} else if (type instanceof SyntacticType.Nominal) {
@@ -2648,31 +2544,28 @@ private int resolveAsType(SyntacticType type, Context context,
 			SyntacticType.Negation ut = (SyntacticType.Negation) type;
 			myKind = Type.K_NEGATION;
 			myChildren = new int[1];
-			myChildren[0] = resolveAsType(ut.element, context, states, roots,
-					nominal, unconstrained);
+			myChildren[0] = resolveAsType(ut.element, context, states, roots, nominal, unconstrained);
 		} else if (type instanceof SyntacticType.Union) {
 			SyntacticType.Union ut = (SyntacticType.Union) type;
 			ArrayList<SyntacticType.NonUnion> utTypes = ut.bounds;
 			myKind = Type.K_UNION;
 			myChildren = new int[utTypes.size()];
 			for (int i = 0; i != utTypes.size(); ++i) {
-				myChildren[i] = resolveAsType(utTypes.get(i), context, states,
-						roots, nominal, unconstrained);
+				myChildren[i] = resolveAsType(utTypes.get(i), context, states, roots, nominal, unconstrained);
 			}
 			myDeterministic = false;
 		} else if (type instanceof SyntacticType.Intersection) {
-			internalFailure("intersection types not supported yet", context,
-					type);
+			internalFailure("intersection types not supported yet", context, type);
 			return 0; // dead-code
 		} else if (type instanceof SyntacticType.Reference) {
 			SyntacticType.Reference ut = (SyntacticType.Reference) type;
 			myKind = Type.K_REFERENCE;
 			myChildren = new int[1];
-			myChildren[0] = resolveAsType(ut.element, context, states, roots,
-					nominal, unconstrained);
+			myChildren[0] = resolveAsType(ut.element, context, states, roots, nominal, unconstrained);
 		} else {
-			SyntacticType.FunctionOrMethod ut = (SyntacticType.FunctionOrMethod) type;			
+			SyntacticType.FunctionOrMethod ut = (SyntacticType.FunctionOrMethod) type;
 			ArrayList<SyntacticType> utParamTypes = ut.paramTypes;
+			ArrayList<SyntacticType> utReturnTypes = ut.returnTypes;
 
 			if (ut instanceof SyntacticType.Method) {
 				myKind = Type.K_METHOD;
@@ -2680,25 +2573,27 @@ private int resolveAsType(SyntacticType type, Context context,
 				myKind = Type.K_FUNCTION;
 			}
 
-			myChildren = new int[utParamTypes.size()+1];
+			myChildren = new int[utParamTypes.size() + utReturnTypes.size()];
 
-			myChildren[0] = resolveAsType(ut.returnType, context, states, roots,
-					nominal, unconstrained);
-			for (int i = 0; i != utParamTypes.size(); ++i) {
+			int numParamTypes = utParamTypes.size();
+			for (int i = 0; i != numParamTypes; ++i) {
 				SyntacticType pt = utParamTypes.get(i);
-				myChildren[i + 1] = resolveAsType(pt, context, states, roots, nominal, unconstrained);
+				myChildren[i] = resolveAsType(pt, context, states, roots, nominal, unconstrained);
+			}
+			for (int i = 0; i != utReturnTypes.size(); ++i) {
+				SyntacticType pt = utReturnTypes.get(i);
+				myChildren[i + numParamTypes] = resolveAsType(pt, context, states, roots, nominal, unconstrained);
 			}
+			myData = ut.paramTypes.size();
 		}
 
-		states.set(myIndex, new Automaton.State(myKind, myData,
-				myDeterministic, myChildren));
+		states.set(myIndex, new Automaton.State(myKind, myData, myDeterministic, myChildren));
 
 		return myIndex;
 	}
 
-	private int resolveAsType(NameID key, ArrayList<Automaton.State> states,
-			HashMap<NameID, Integer> roots, boolean unconstrained)
-			throws IOException, ResolveError {
+	private int resolveAsType(NameID key, ArrayList<Automaton.State> states, HashMap<NameID, Integer> roots,
+			boolean unconstrained) throws IOException, ResolveError {
 
 		// First, check the various caches we have
 		Integer root = roots.get(key);
@@ -2716,11 +2611,11 @@ private int resolveAsType(NameID key, ArrayList<Automaton.State> states,
 			// where a type loaded from a WyIL file is not expanded. In the
 			// future, this will be the norm and we'll need to handle this is a
 			// better fashion.
-			return expander.getTypeHelper(td.type(),false,states,roots);
+			return expander.getTypeHelper(td.type(), false, states, roots);
 		}
 
 		WhileyFile.Type td = wf.typeDecl(key.name());
-		if (td == null) {			
+		if (td == null) {
 			throw new ResolveError("type not found: " + key);
 		}
 
@@ -2733,8 +2628,7 @@ private int resolveAsType(NameID key, ArrayList<Automaton.State> states,
 			int myIndex = states.size();
 			int kind = Type.leafKind(Type.T_VOID);
 			Object data = null;
-			states.add(new Automaton.State(kind, data, true,
-					Automaton.NOCHILDREN));
+			states.add(new Automaton.State(kind, data, true, Automaton.NOCHILDREN));
 			return myIndex;
 		} else if (type instanceof Type.Leaf) {
 			//
@@ -2745,8 +2639,7 @@ private int resolveAsType(NameID key, ArrayList<Automaton.State> states,
 			int myIndex = states.size();
 			int kind = Type.leafKind((Type.Leaf) type);
 			Object data = Type.leafData((Type.Leaf) type);
-			states.add(new Automaton.State(kind, data, true,
-					Automaton.NOCHILDREN));
+			states.add(new Automaton.State(kind, data, true, Automaton.NOCHILDREN));
 			return myIndex;
 		} else {
 			return resolveAsType(type, td, states, roots, false, unconstrained);
@@ -2759,8 +2652,7 @@ private int resolveAsType(NameID key, ArrayList<Automaton.State> states,
 		// index there could be an issue.
 	}
 
-	private int resolveAsType(SyntacticType.Primitive t, Context context,
-			ArrayList<Automaton.State> states) {
+	private int resolveAsType(SyntacticType.Primitive t, Context context, ArrayList<Automaton.State> states) {
 		int myIndex = states.size();
 		int kind;
 		if (t instanceof SyntacticType.Any) {
@@ -2778,8 +2670,7 @@ private int resolveAsType(SyntacticType.Primitive t, Context context,
 		} else if (t instanceof SyntacticType.Real) {
 			kind = Type.K_RATIONAL;
 		} else {
-			internalFailure("unrecognised type encountered ("
-					+ t.getClass().getName() + ")", context, t);
+			internalFailure("unrecognised type encountered (" + t.getClass().getName() + ")", context, t);
 			return 0; // dead-code
 		}
 		states.add(new Automaton.State(kind, null, true, Automaton.NOCHILDREN));
@@ -2826,8 +2717,7 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 	 * @return Constant value representing named constant
 	 * @throws IOException
 	 */
-	public Pair<Constant,Nominal> resolveAsConstant(NameID nid) throws IOException,
-			ResolveError {
+	public Pair<Constant, Nominal> resolveAsConstant(NameID nid) throws IOException, ResolveError {
 		return resolveAsConstant(nid, new HashSet<NameID>());
 	}
 
@@ -2850,7 +2740,7 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 	 * @param context
 	 * @return
 	 */
-	public Pair<Constant,Nominal> resolveAsConstant(Expr e, Context context) {
+	public Pair<Constant, Nominal> resolveAsConstant(Expr e, Context context) {
 		e = propagate(e, new Environment(), context);
 		return resolveAsConstant(e, context, new HashSet<NameID>());
 	}
@@ -2871,14 +2761,13 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 	 * @return
 	 * @throws IOException
 	 */
-	private Pair<Constant,Nominal> resolveAsConstant(NameID key, HashSet<NameID> visited)
+	private Pair<Constant, Nominal> resolveAsConstant(NameID key, HashSet<NameID> visited)
 			throws IOException, ResolveError {
-		Pair<Constant,Nominal> result = constantCache.get(key);
+		Pair<Constant, Nominal> result = constantCache.get(key);
 		if (result != null) {
 			return result;
 		} else if (visited.contains(key)) {
-			throw new ResolveError("cyclic constant definition encountered ("
-					+ key + " -> " + key + ")");
+			throw new ResolveError("cyclic constant definition encountered (" + key + " -> " + key + ")");
 		} else {
 			visited.add(key);
 		}
@@ -2893,7 +2782,7 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 					cd.constant = propagate(cd.constant, new Environment(), cd);
 					cd.resolvedValue = resolveAsConstant(cd.constant, cd, visited).first();
 				}
-				result = new Pair<Constant,Nominal>(cd.resolvedValue,cd.constant.result());
+				result = new Pair<Constant, Nominal>(cd.resolvedValue, cd.constant.result());
 			} else {
 				throw new ResolveError("unable to find constant " + key);
 			}
@@ -2903,7 +2792,7 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 			if (cd != null) {
 				Constant c = cd.constant();
 				Nominal t = Nominal.construct(c.type(), expander.getUnderlyingType(c.type()));
-				result = new Pair<Constant,Nominal>(c,t);
+				result = new Pair<Constant, Nominal>(c, t);
 			} else {
 				throw new ResolveError("unable to find constant " + key);
 			}
@@ -2929,12 +2818,11 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 	 *            --- set of all constants seen during this traversal (used to
 	 *            detect cycles).
 	 */
-	private Pair<Constant,Nominal> resolveAsConstant(Expr expr, Context context,
-			HashSet<NameID> visited) {
+	private Pair<Constant, Nominal> resolveAsConstant(Expr expr, Context context, HashSet<NameID> visited) {
 		try {
 			if (expr instanceof Expr.Constant) {
 				Expr.Constant c = (Expr.Constant) expr;
-				return new Pair<Constant,Nominal>(c.value,c.result());
+				return new Pair<Constant, Nominal>(c.value, c.result());
 			} else if (expr instanceof Expr.ConstantAccess) {
 				Expr.ConstantAccess c = (Expr.ConstantAccess) expr;
 				ArrayList<String> qualifications = new ArrayList<String>();
@@ -2953,44 +2841,43 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 				}
 			} else if (expr instanceof Expr.BinOp) {
 				Expr.BinOp bop = (Expr.BinOp) expr;
-				Pair<Constant,Nominal> lhs = resolveAsConstant(bop.lhs, context, visited);
-				Pair<Constant,Nominal> rhs = resolveAsConstant(bop.rhs, context, visited);
+				Pair<Constant, Nominal> lhs = resolveAsConstant(bop.lhs, context, visited);
+				Pair<Constant, Nominal> rhs = resolveAsConstant(bop.rhs, context, visited);
 				return new Pair<Constant, Nominal>(evaluate(bop, lhs.first(), rhs.first(), context), lhs.second());
 			} else if (expr instanceof Expr.UnOp) {
 				Expr.UnOp uop = (Expr.UnOp) expr;
-				Pair<Constant,Nominal> lhs = resolveAsConstant(uop.mhs, context, visited);
+				Pair<Constant, Nominal> lhs = resolveAsConstant(uop.mhs, context, visited);
 				return new Pair<Constant, Nominal>(evaluate(uop, lhs.first(), context), lhs.second());
 			} else if (expr instanceof Expr.ArrayInitialiser) {
 				Expr.ArrayInitialiser nop = (Expr.ArrayInitialiser) expr;
 				ArrayList<Constant> values = new ArrayList<Constant>();
 				Nominal element = Nominal.T_VOID;
 				for (Expr arg : nop.arguments) {
-					Pair<Constant,Nominal> e = resolveAsConstant(arg, context, visited);
+					Pair<Constant, Nominal> e = resolveAsConstant(arg, context, visited);
 					values.add(e.first());
 					element = Nominal.Union(element, e.second());
 				}
 				return new Pair<Constant, Nominal>(Constant.V_ARRAY(values),
 						Nominal.Array(element, !nop.arguments.isEmpty()));
 			} else if (expr instanceof Expr.ArrayGenerator) {
-				Expr.ArrayGenerator lg = (Expr.ArrayGenerator) expr;				
-				Pair<Constant,Nominal> element = resolveAsConstant(lg.element, context, visited);
-				Pair<Constant,Nominal> count = resolveAsConstant(lg.count, context, visited);
-				Constant.Array l = evaluate(lg,element.first(),count.first(),context);
-				return new Pair<Constant,Nominal>(l,Nominal.Array(element.second(), !l.values.isEmpty()));
+				Expr.ArrayGenerator lg = (Expr.ArrayGenerator) expr;
+				Pair<Constant, Nominal> element = resolveAsConstant(lg.element, context, visited);
+				Pair<Constant, Nominal> count = resolveAsConstant(lg.count, context, visited);
+				Constant.Array l = evaluate(lg, element.first(), count.first(), context);
+				return new Pair<Constant, Nominal>(l, Nominal.Array(element.second(), !l.values.isEmpty()));
 			} else if (expr instanceof Expr.Record) {
 				Expr.Record rg = (Expr.Record) expr;
 				HashMap<String, Constant> values = new HashMap<String, Constant>();
-				HashMap<String, Nominal> types =  new HashMap<String, Nominal>();
+				HashMap<String, Nominal> types = new HashMap<String, Nominal>();
 				for (Map.Entry<String, Expr> e : rg.fields.entrySet()) {
-					Pair<Constant,Nominal> v = resolveAsConstant(e.getValue(), context,
-							visited);
+					Pair<Constant, Nominal> v = resolveAsConstant(e.getValue(), context, visited);
 					if (v == null) {
 						return null;
 					}
 					values.put(e.getKey(), v.first());
 					types.put(e.getKey(), v.second());
 				}
-				return new Pair<Constant,Nominal>(Constant.V_RECORD(values),Nominal.Record(false, types));
+				return new Pair<Constant, Nominal>(Constant.V_RECORD(values), Nominal.Record(false, types));
 			} else if (expr instanceof Expr.FunctionOrMethod) {
 				// TODO: add support for proper lambdas
 				Expr.FunctionOrMethod f = (Expr.FunctionOrMethod) expr;
@@ -3002,8 +2889,7 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 			internalFailure(e.getMessage(), context, expr, e);
 		}
 
-		internalFailure("unknown constant expression: "
-				+ expr.getClass().getName(), context, expr);
+		internalFailure("unknown constant expression: " + expr.getClass().getName(), context, expr);
 		return null; // deadcode
 	}
 
@@ -3021,8 +2907,7 @@ private static int append(Type type, ArrayList<Automaton.State> states) {
 	 * @return True if given context permitted to access name
 	 * @throws IOException
 	 */
-	public boolean isNameVisible(NameID nid, Context context)
-			throws IOException {
+	public boolean isNameVisible(NameID nid, Context context) throws IOException {
 		// Any element in the same file is automatically visible
 		if (nid.module().equals(context.file().module)) {
 			return true;
@@ -3045,8 +2930,7 @@ public boolean isNameVisible(NameID nid, Context context)
 	 * @return True if given context permitted to access name
 	 * @throws IOException
 	 */
-	public boolean isTypeVisible(NameID nid, Context context)
-			throws IOException {
+	public boolean isTypeVisible(NameID nid, Context context) throws IOException {
 		// Any element in the same file is automatically visible
 		if (nid.module().equals(context.file().module)) {
 			return true;
@@ -3069,8 +2953,7 @@ public boolean isTypeVisible(NameID nid, Context context)
 	 * @return True if given context permitted to access name
 	 * @throws IOException
 	 */
-	public boolean hasModifier(NameID nid, Context context, Modifier modifier)
-			throws IOException {
+	public boolean hasModifier(NameID nid, Context context, Modifier modifier) throws IOException {
 		Path.ID mid = nid.module();
 
 		// Attempt to access source file first.
@@ -3115,16 +2998,14 @@ public boolean hasModifier(NameID nid, Context context, Modifier modifier)
 	 *            reporting)
 	 * @return
 	 */
-	private Constant evaluate(Expr.UnOp operator, Constant operand,
-			Context context) {
+	private Constant evaluate(Expr.UnOp operator, Constant operand, Context context) {
 		switch (operator.op) {
 		case NOT:
 			if (operand instanceof Constant.Bool) {
 				Constant.Bool b = (Constant.Bool) operand;
 				return Constant.V_BOOL(!b.value);
 			}
-			syntaxError(errorMessage(INVALID_BOOLEAN_EXPRESSION), context,
-					operator);
+			syntaxError(errorMessage(INVALID_BOOLEAN_EXPRESSION), context, operator);
 			break;
 		case NEG:
 			if (operand instanceof Constant.Integer) {
@@ -3134,8 +3015,7 @@ private Constant evaluate(Expr.UnOp operator, Constant operand,
 				Constant.Decimal b = (Constant.Decimal) operand;
 				return Constant.V_DECIMAL(b.value.negate());
 			}
-			syntaxError(errorMessage(INVALID_NUMERIC_EXPRESSION), context,
-					operator);
+			syntaxError(errorMessage(INVALID_NUMERIC_EXPRESSION), context, operator);
 			break;
 		case INVERT:
 			if (operand instanceof Constant.Byte) {
@@ -3148,8 +3028,7 @@ private Constant evaluate(Expr.UnOp operator, Constant operand,
 		return null;
 	}
 
-	private Constant evaluate(Expr.BinOp bop, Constant v1, Constant v2,
-			Context context) {
+	private Constant evaluate(Expr.BinOp bop, Constant v1, Constant v2, Context context) {
 		Type v1_type = v1.type();
 		Type v2_type = v2.type();
 		Type lub = Type.Union(v1_type, v2_type);
@@ -3157,13 +3036,10 @@ private Constant evaluate(Expr.BinOp bop, Constant v1, Constant v2,
 		// FIXME: there are bugs here related to coercions.
 
 		if (Type.isSubtype(Type.T_BOOL, lub)) {
-			return evaluateBoolean(bop, (Constant.Bool) v1, (Constant.Bool) v2,
-					context);
+			return evaluateBoolean(bop, (Constant.Bool) v1, (Constant.Bool) v2, context);
 		} else if (Type.isSubtype(Type.T_INT, lub)) {
-			return evaluate(bop, (Constant.Integer) v1, (Constant.Integer) v2,
-					context);
-		} else if (Type.isSubtype(Type.T_REAL, v1_type)
-				&& Type.isSubtype(Type.T_REAL, v1_type)) {
+			return evaluate(bop, (Constant.Integer) v1, (Constant.Integer) v2, context);
+		} else if (Type.isSubtype(Type.T_REAL, v1_type) && Type.isSubtype(Type.T_REAL, v1_type)) {
 			if (v1 instanceof Constant.Integer) {
 				Constant.Integer i1 = (Constant.Integer) v1;
 				v1 = Constant.V_DECIMAL(new BigDecimal(i1.value));
@@ -3171,18 +3047,15 @@ private Constant evaluate(Expr.BinOp bop, Constant v1, Constant v2,
 				Constant.Integer i2 = (Constant.Integer) v2;
 				v2 = Constant.V_DECIMAL(new BigDecimal(i2.value));
 			}
-			return evaluate(bop, (Constant.Decimal) v1, (Constant.Decimal) v2,
-					context);
+			return evaluate(bop, (Constant.Decimal) v1, (Constant.Decimal) v2, context);
 		} else if (Type.isSubtype(Type.T_ARRAY_ANY, lub)) {
-			return evaluate(bop, (Constant.Array) v1, (Constant.Array) v2,
-					context);
-		} 
+			return evaluate(bop, (Constant.Array) v1, (Constant.Array) v2, context);
+		}
 		syntaxError(errorMessage(INVALID_BINARY_EXPRESSION), context, bop);
 		return null;
 	}
 
-	private Constant evaluateBoolean(Expr.BinOp bop, Constant.Bool v1,
-			Constant.Bool v2, Context context) {
+	private Constant evaluateBoolean(Expr.BinOp bop, Constant.Bool v1, Constant.Bool v2, Context context) {
 		switch (bop.op) {
 		case AND:
 			return Constant.V_BOOL(v1.value & v2.value);
@@ -3195,8 +3068,7 @@ private Constant evaluateBoolean(Expr.BinOp bop, Constant.Bool v1,
 		return null;
 	}
 
-	private Constant evaluate(Expr.BinOp bop, Constant.Integer v1,
-			Constant.Integer v2, Context context) {
+	private Constant evaluate(Expr.BinOp bop, Constant.Integer v1, Constant.Integer v2, Context context) {
 		switch (bop.op) {
 		case ADD:
 			return Constant.V_INTEGER(v1.value.add(v2.value));
@@ -3213,8 +3085,7 @@ private Constant evaluate(Expr.BinOp bop, Constant.Integer v1,
 		return null;
 	}
 
-	private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1,
-			Constant.Decimal v2, Context context) {
+	private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1, Constant.Decimal v2, Context context) {
 		switch (bop.op) {
 		case ADD:
 			return Constant.V_DECIMAL(v1.value.add(v2.value));
@@ -3229,12 +3100,11 @@ private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1,
 		return null;
 	}
 
-	private Constant.Array evaluate(Expr.ArrayGenerator bop, Constant element,
-			Constant count, Context context) {
-		if(count instanceof Constant.Integer) {
-			Constant.Integer c = (Constant.Integer)count;
+	private Constant.Array evaluate(Expr.ArrayGenerator bop, Constant element, Constant count, Context context) {
+		if (count instanceof Constant.Integer) {
+			Constant.Integer c = (Constant.Integer) count;
 			ArrayList<Constant> items = new ArrayList<Constant>();
-			for(int i=0;i!=c.value.intValue();++i) {
+			for (int i = 0; i != c.value.intValue(); ++i) {
 				items.add(element);
 			}
 			return Constant.V_ARRAY(items);
@@ -3246,8 +3116,7 @@ private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1,
 	// expandAsType
 	// =========================================================================
 
-	public Nominal.Array expandAsEffectiveList(Nominal lhs)
-			throws IOException, ResolveError {
+	public Nominal.Array expandAsEffectiveList(Nominal lhs) throws IOException, ResolveError {
 		Type raw = lhs.raw();
 		if (raw instanceof Type.EffectiveArray) {
 			Type nominal = expandOneLevel(lhs.nominal());
@@ -3260,8 +3129,7 @@ private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1,
 		}
 	}
 
-	public Nominal.Record expandAsEffectiveRecord(Nominal lhs)
-			throws IOException, ResolveError {
+	public Nominal.Record expandAsEffectiveRecord(Nominal lhs) throws IOException, ResolveError {
 		Type raw = lhs.raw();
 
 		if (raw instanceof Type.Record) {
@@ -3282,8 +3150,7 @@ private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1,
 		}
 	}
 
-	public Nominal.Reference expandAsReference(Nominal lhs) throws IOException,
-			ResolveError {
+	public Nominal.Reference expandAsReference(Nominal lhs) throws IOException, ResolveError {
 		Type.Reference raw = Type.effectiveReference(lhs.raw());
 		if (raw != null) {
 			Type nominal = expandOneLevel(lhs.nominal());
@@ -3296,8 +3163,7 @@ private Constant evaluate(Expr.BinOp bop, Constant.Decimal v1,
 		}
 	}
 
-	public Nominal.FunctionOrMethod expandAsFunctionOrMethod(Nominal lhs)
-			throws IOException, ResolveError {
+	public Nominal.FunctionOrMethod expandAsFunctionOrMethod(Nominal lhs) throws IOException, ResolveError {
 		Type.FunctionOrMethod raw = Type.effectiveFunctionOrMethod(lhs.raw());
 		if (raw != null) {
 			Type nominal = expandOneLevel(lhs.nominal());
@@ -3323,8 +3189,7 @@ private Type expandOneLevel(Type type) throws IOException, ResolveError {
 				WhileyFile.Declaration decl = wf.declaration(nid.name());
 				if (decl instanceof WhileyFile.Type) {
 					WhileyFile.Type td = (WhileyFile.Type) decl;
-					r = resolveAsType(td.parameter.type, td)
-							.nominal();
+					r = resolveAsType(td.parameter.type, td).nominal();
 				}
 			} else {
 				WyilFile m = builder.getModule(mid);
@@ -3337,9 +3202,8 @@ private Type expandOneLevel(Type type) throws IOException, ResolveError {
 				throw new ResolveError("unable to locate " + nid);
 			}
 			return expandOneLevel(r);
-		} else if (type instanceof Type.Leaf || type instanceof Type.Reference
-				|| type instanceof Type.Array || type instanceof Type.Record
-				|| type instanceof Type.FunctionOrMethod
+		} else if (type instanceof Type.Leaf || type instanceof Type.Reference || type instanceof Type.Array
+				|| type instanceof Type.Record || type instanceof Type.FunctionOrMethod
 				|| type instanceof Type.Negation) {
 			return type;
 		} else {
@@ -3351,7 +3215,6 @@ private Type expandOneLevel(Type type) throws IOException, ResolveError {
 			return Type.Union(bounds);
 		}
 	}
-	
 
 	private Environment addDeclaredParameters(List<WhileyFile.Parameter> parameters, Environment environment,
 			WhileyFile.Context d) {
@@ -3360,17 +3223,16 @@ private Environment addDeclaredParameters(List<WhileyFile.Parameter> parameters,
 		}
 		return environment;
 	}
-	
+
 	private Environment addDeclaredParameter(WhileyFile.Parameter parameter, Environment environment,
 			WhileyFile.Context d) {
-		if(parameter != null) {
+		if (parameter != null) {
 			Nominal type = resolveAsType(parameter.type, d);
 			return environment.declare(parameter.name, type, type);
 		} else {
 			return environment;
 		}
 	}
-	
 
 	// =========================================================================
 	// Misc
@@ -3379,9 +3241,7 @@ private Environment addDeclaredParameter(WhileyFile.Parameter parameter, Environ
 	// Check t1 :> t2
 	private void checkIsSubtype(Nominal t1, Nominal t2, SyntacticElement elem) {
 		if (!Type.isSubtype(t1.raw(), t2.raw())) {
-			syntaxError(
-					errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.nominal()),
-					filename, elem);
+			syntaxError(errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.nominal()), filename, elem);
 		}
 	}
 
@@ -3389,9 +3249,7 @@ private void checkIsSubtype(Nominal t1, Expr t2) {
 		if (!Type.isSubtype(t1.raw(), t2.result().raw())) {
 			// We use the nominal type for error reporting, since this includes
 			// more helpful names.
-			syntaxError(
-					errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.result()
-							.nominal()), filename, t2);
+			syntaxError(errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.result().nominal()), filename, t2);
 		}
 	}
 
@@ -3399,18 +3257,14 @@ private void checkIsSubtype(Type t1, Expr t2) {
 		if (!Type.isSubtype(t1, t2.result().raw())) {
 			// We use the nominal type for error reporting, since this includes
 			// more helpful names.
-			syntaxError(errorMessage(SUBTYPE_ERROR, t1, t2.result().nominal()),
-					filename, t2);
+			syntaxError(errorMessage(SUBTYPE_ERROR, t1, t2.result().nominal()), filename, t2);
 		}
 	}
 
 	// Check t1 :> t2
-	private void checkIsSubtype(Nominal t1, Nominal t2, SyntacticElement elem,
-			Context context) {
+	private void checkIsSubtype(Nominal t1, Nominal t2, SyntacticElement elem, Context context) {
 		if (!Type.isSubtype(t1.raw(), t2.raw())) {
-			syntaxError(
-					errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.nominal()),
-					context, elem);
+			syntaxError(errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.nominal()), context, elem);
 		}
 	}
 
@@ -3418,9 +3272,7 @@ private void checkIsSubtype(Nominal t1, Expr t2, Context context) {
 		if (!Type.isSubtype(t1.raw(), t2.result().raw())) {
 			// We use the nominal type for error reporting, since this includes
 			// more helpful names.
-			syntaxError(
-					errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.result()
-							.nominal()), context, t2);
+			syntaxError(errorMessage(SUBTYPE_ERROR, t1.nominal(), t2.result().nominal()), context, t2);
 		}
 	}
 
@@ -3428,8 +3280,7 @@ private void checkIsSubtype(Type t1, Expr t2, Context context) {
 		if (!Type.isSubtype(t1, t2.result().raw())) {
 			// We use the nominal type for error reporting, since this includes
 			// more helpful names.
-			syntaxError(errorMessage(SUBTYPE_ERROR, t1, t2.result().nominal()),
-					context, t2);
+			syntaxError(errorMessage(SUBTYPE_ERROR, t1, t2.result().nominal()), context, t2);
 		}
 	}
 
@@ -3513,10 +3364,8 @@ public Environment() {
 		 */
 		private Environment(Environment environment) {
 			count = 1;
-			this.currentTypes = (HashMap<String, Nominal>) environment.currentTypes
-					.clone();
-			this.declaredTypes = (HashMap<String, Nominal>) environment.declaredTypes
-					.clone();
+			this.currentTypes = (HashMap<String, Nominal>) environment.currentTypes.clone();
+			this.declaredTypes = (HashMap<String, Nominal>) environment.declaredTypes.clone();
 		}
 
 		/**
@@ -3579,11 +3428,9 @@ public boolean containsKey(String variable) {
 		 * @return An updated version of the environment which contains the new
 		 *         association.
 		 */
-		public Environment declare(String variable, Nominal declared,
-				Nominal initial) {
+		public Environment declare(String variable, Nominal declared, Nominal initial) {
 			if (declaredTypes.containsKey(variable)) {
-				throw new RuntimeException("Variable already declared - "
-						+ variable);
+				throw new RuntimeException("Variable already declared - " + variable);
 			}
 			if (count == 1) {
 				declaredTypes.put(variable, declared);
@@ -3615,8 +3462,7 @@ public Environment declare(String variable, Nominal declared,
 		 */
 		public Environment update(String variable, Nominal type) {
 			if (!declaredTypes.containsKey(variable)) {
-				throw new RuntimeException("Variable not declared - "
-						+ variable);
+				throw new RuntimeException("Variable not declared - " + variable);
 			}
 			if (count == 1) {
 				currentTypes.put(variable, type);
@@ -3690,8 +3536,7 @@ public final Environment merge(Set<String> declared, Environment env) {
 			for (String variable : declared) {
 				Nominal lhs_t = this.getCurrentType(variable);
 				Nominal rhs_t = env.getCurrentType(variable);
-				result.declare(variable, this.getDeclaredType(variable),
-						Nominal.Union(lhs_t, rhs_t));
+				result.declare(variable, this.getDeclaredType(variable), Nominal.Union(lhs_t, rhs_t));
 			}
 
 			return result;
diff --git a/modules/wyc/src/wyc/io/WhileyFileParser.java b/modules/wyc/src/wyc/io/WhileyFileParser.java
index d6aba818e..54cdecc7a 100644
--- a/modules/wyc/src/wyc/io/WhileyFileParser.java
+++ b/modules/wyc/src/wyc/io/WhileyFileParser.java
@@ -288,14 +288,14 @@ private void parseFunctionOrMethodDeclaration(WhileyFile wf,
 		List<Parameter> parameters = parseParameters(wf,environment);
 		
 		// Parse (optional) return type
-		Parameter ret = null;
+		List<Parameter> returns = Collections.EMPTY_LIST;
 
 		if (tryAndMatch(true, MinusGreater) != null) {
 			// Explicit return type is given, so parse it! We first clone the
 			// environent and create a special one only for use within ensures
 			// clauses, since these are the only expressions which may refer to
 			// variables declared in the return type.
-			ret = parseOptionalParameter(wf,environment);		
+			returns = parseOptionalParameters(wf,environment);		
 		} 
 
 		// Parse optional requires/ensures clauses
@@ -336,10 +336,10 @@ private void parseFunctionOrMethodDeclaration(WhileyFile wf,
 
 		WhileyFile.Declaration declaration;
 		if (isFunction) {
-			declaration = wf.new Function(modifiers, name.text, ret, parameters, requires, ensures, stmts,
+			declaration = wf.new Function(modifiers, name.text, returns, parameters, requires, ensures, stmts,
 					sourceAttr(start, end - 1));
 		} else {
-			declaration = wf.new Method(modifiers, name.text, ret, parameters, requires, ensures, stmts,
+			declaration = wf.new Method(modifiers, name.text, returns, parameters, requires, ensures, stmts,
 					sourceAttr(start, end - 1));
 		}
 		wf.add(declaration);
@@ -368,6 +368,19 @@ private void parseFunctionOrMethodDeclaration(WhileyFile wf,
 		return parameters;
 	}
 	
+
+	public List<Parameter> parseOptionalParameters(WhileyFile wf, HashSet<String> environment) {
+		int next = skipWhiteSpace(index);
+		if(next < tokens.size() && tokens.get(next).kind == LeftBrace) {
+			return parseParameters(wf,environment);
+		} else {			
+			Parameter p = parseOptionalParameter(wf,environment);
+			ArrayList<Parameter> ps = new ArrayList<Parameter>();
+			ps.add(p);
+			return ps;
+		}
+	}
+	
 	public Parameter parseOptionalParameter(WhileyFile wf, HashSet<String> environment) {
 		int start = index;
 		boolean braced = false;
@@ -753,7 +766,7 @@ private Stmt parseStatement(WhileyFile wf, HashSet<String> environment,
 
 		match(Return);
 
-		Expr e = null;
+		ArrayList<Expr> returns = new ArrayList<Expr>();
 		// A return statement may optionally have a return expression.
 		// Therefore, we first skip all whitespace on the given line.
 		int next = skipLineSpace(index);
@@ -762,14 +775,14 @@ private Stmt parseStatement(WhileyFile wf, HashSet<String> environment,
 		// means expressions must start on the same line as a return. Otherwise,
 		// a potentially cryptic error message will be given.
 		if (next < tokens.size() && tokens.get(next).kind != NewLine) {
-			e = parseExpression(wf, environment, false);
+			returns.add(parseExpression(wf, environment, false));
 		}
 		// Finally, at this point we are expecting a new-line to signal the
 		// end-of-statement.
 		int end = index;
 		matchEndLine();
 		// Done.
-		return new Stmt.Return(e, sourceAttr(start, end - 1));
+		return new Stmt.Return(returns, sourceAttr(start, end - 1));
 	}
 
 	/**
@@ -3292,7 +3305,9 @@ private boolean mustParseAsType(SyntacticType type) {
 			for (SyntacticType element : tt.paramTypes) {
 				result |= mustParseAsType(element);
 			}
-			result |= mustParseAsType(tt.returnType);			
+			for (SyntacticType element : tt.returnTypes) {
+				result |= mustParseAsType(element);
+			}			
 			return result;
 		} else if (type instanceof SyntacticType.Intersection) {
 			SyntacticType.Intersection tt = (SyntacticType.Intersection) type;
@@ -3683,7 +3698,7 @@ private SyntacticType parseFunctionOrMethodType(boolean isFunction) {
 
 		// First, parse the parameter type(s).
 		List<SyntacticType> paramTypes = parseParameterTypes();
-		SyntacticType returnType = null;
+		List<SyntacticType> returnTypes = Collections.EMPTY_LIST;
 
 		// Second, parse the right arrow.
 		if (isFunction) {
@@ -3691,18 +3706,18 @@ private SyntacticType parseFunctionOrMethodType(boolean isFunction) {
 			// nops)
 			match(MinusGreater);
 			// Third, parse the return types.
-			returnType = parseType();
+			returnTypes = parseOptionalParameterTypes();
 		} else if (tryAndMatch(true, MinusGreater) != null) {
 			// Methods have an optional return type
 			// Third, parse the return type
-			returnType = parseType();
+			returnTypes = parseOptionalParameterTypes();
 		} 
 
 		// Done
 		if (isFunction) {
-			return new SyntacticType.Function(returnType, paramTypes, sourceAttr(start, index - 1));
+			return new SyntacticType.Function(returnTypes, paramTypes, sourceAttr(start, index - 1));
 		} else {
-			return new SyntacticType.Method(returnType, paramTypes, sourceAttr(start, index - 1));
+			return new SyntacticType.Method(returnTypes, paramTypes, sourceAttr(start, index - 1));
 		}
 	}	
 
@@ -3732,14 +3747,14 @@ private SyntacticType parseFunctionOrMethodType(boolean isFunction) {
 				// Therefore, we continue to pass the remaining type parameters.
 
 				List<SyntacticType> paramTypes = parseParameterTypes();
-				SyntacticType returnType;
+				List<SyntacticType> returnTypes = Collections.EMPTY_LIST; 
 				
 				if (lookahead.kind == Function) {
 					// Functions require a return type (since otherwise they are
 					// just nops)
 					match(MinusGreater);
 					// Third, parse the return type
-					returnType = parseType();
+					returnTypes = parseOptionalParameterTypes();
 				} else if (tryAndMatch(true, MinusGreater) != null) {
 					// Third, parse the (optional) return type. Observe that
 					// this is forced to be a
@@ -3748,17 +3763,15 @@ private SyntacticType parseFunctionOrMethodType(boolean isFunction) {
 					// may be part of an enclosing record type and we must
 					// disambiguate
 					// this.
-					returnType = parseType();
-				} else {
-					returnType = new SyntacticType.Void();
-				}
+					returnTypes = parseOptionalParameterTypes();
+				} 
 
 				// Done
 				SyntacticType type;
 				if (lookahead.kind == Token.Kind.Function) {
-					type = new SyntacticType.Function(returnType, paramTypes, sourceAttr(start, index - 1));
+					type = new SyntacticType.Function(returnTypes, paramTypes, sourceAttr(start, index - 1));
 				} else {
-					type = new SyntacticType.Method(returnType, paramTypes, sourceAttr(start, index - 1));
+					type = new SyntacticType.Method(returnTypes, paramTypes, sourceAttr(start, index - 1));
 				}
 				return new Pair<SyntacticType, Token>(type, id);
 			} else {
@@ -3776,6 +3789,18 @@ private SyntacticType parseFunctionOrMethodType(boolean isFunction) {
 		return new Pair<SyntacticType, Token>(type, id);
 	}
 
+	public List<SyntacticType> parseOptionalParameterTypes() {
+		int next = skipWhiteSpace(index);
+		if(next < tokens.size() && tokens.get(next).kind == LeftBrace) {
+			return parseParameterTypes();
+		} else {
+			SyntacticType t = parseType();
+			ArrayList<SyntacticType> rs = new ArrayList<SyntacticType>();
+			rs.add(t);
+			return rs;
+		}		
+	}
+	
 	public List<SyntacticType> parseParameterTypes() {
 		ArrayList<SyntacticType> paramTypes = new ArrayList<SyntacticType>();
 		match(LeftBrace);
diff --git a/modules/wyc/src/wyc/io/WhileyFilePrinter.java b/modules/wyc/src/wyc/io/WhileyFilePrinter.java
index a8440d283..9c84be5c2 100644
--- a/modules/wyc/src/wyc/io/WhileyFilePrinter.java
+++ b/modules/wyc/src/wyc/io/WhileyFilePrinter.java
@@ -69,17 +69,15 @@ public void print(WhileyFile.FunctionOrMethod fm) {
 		out.print(fm.name());
 		printParameters(fm.parameters);		
 		out.print(" -> ");
-		printParameter(fm.returnType,true);		
-
+		printParameters(fm.returns);
+		
 		for(Expr r : fm.requires) {
 			out.println();
 			out.print("requires ");
 			print(r);
 		}
-		boolean firstTime=true;
 		for(Expr r : fm.ensures) {
 			out.println();
-			firstTime = false;
 			out.print("ensures ");
 			print(r);
 		}
@@ -208,9 +206,12 @@ public void print(Stmt.Skip s) {
 
 	public void print(Stmt.Return s) {
 		out.print("return");
-		if(s.expr != null) {
-			out.print(" ");
-			print(s.expr);
+		for(int i=0;i!=s.returns.size();++i) {
+			if(i != 0) {
+				out.print(",");
+			}
+			out.print(" ");	
+			print(s.returns.get(i));
 		}
 		out.println();
 	}
@@ -670,7 +671,7 @@ public void print(SyntacticType t) {
 			}
 			printParameterTypes(tt.paramTypes);
 			out.print("->");
-			print(tt.returnType);			
+			printParameterTypes(tt.returnTypes);			
 		} else if(t instanceof SyntacticType.Record) {
 			SyntacticType.Record tt = (SyntacticType.Record) t;
 			out.print("{");
diff --git a/modules/wyc/src/wyc/lang/Expr.java b/modules/wyc/src/wyc/lang/Expr.java
index 5e061cf97..066d74e0d 100755
--- a/modules/wyc/src/wyc/lang/Expr.java
+++ b/modules/wyc/src/wyc/lang/Expr.java
@@ -588,7 +588,11 @@ public NameID nid() {
 		}
 
 		public Nominal result() {
-			return methodType.ret();
+			if(methodType.returns().isEmpty()) {
+				return null;
+			} else {
+				return methodType.returns().get(0);
+			}
 		}
 	}
 
@@ -622,7 +626,7 @@ public NameID nid() {
 		}
 
 		public Nominal result() {
-			return functionType.ret();
+			return functionType.returns().get(0);
 		}
 	}
 
@@ -666,7 +670,7 @@ public IndirectMethodCall(Expr src, Collection<Expr> arguments,
 		}
 
 		public Nominal result() {
-			return methodType.ret();
+			return methodType.returns().get(0);
 		}
 	}
 
@@ -684,7 +688,7 @@ public IndirectFunctionCall(Expr src, Collection<Expr> arguments,
 		}
 
 		public Nominal result() {
-			return functionType.ret();
+			return functionType.returns().get(0);
 		}
 	}
 
diff --git a/modules/wyc/src/wyc/lang/Nominal.java b/modules/wyc/src/wyc/lang/Nominal.java
index 76e741fed..75264440c 100755
--- a/modules/wyc/src/wyc/lang/Nominal.java
+++ b/modules/wyc/src/wyc/lang/Nominal.java
@@ -271,11 +271,25 @@ public int hashCode() {
 
 		abstract public Type.FunctionOrMethod raw();
 
-		public Nominal ret() {
-			Type nominalElement = nominal().ret();
-			Type rawElement = raw().ret();
+		public Nominal ret(int i) {
+			List<Type> rawElements = raw().returns();
+			List<Type> nominalElements = nominal().returns();
+			Type nominalElement = nominalElements.get(i);
+			Type rawElement = rawElements.get(i);
 			return construct(nominalElement,rawElement);
 		}
+		
+		public List<Nominal> returns() {
+			ArrayList<Nominal> r = new ArrayList<Nominal>();
+			List<Type> rawElements = raw().returns();
+			List<Type> nominalElements = nominal().returns();
+			for(int i=0;i!=rawElements.size();++i) {
+				Type nominalElement = nominalElements.get(i);
+				Type rawElement = rawElements.get(i);
+				r.add(construct(nominalElement,rawElement));
+			}
+			return r;
+		}
 				
 		public Nominal param(int i) {
 			List<Type> rawElements = raw().params();
diff --git a/modules/wyc/src/wyc/lang/Stmt.java b/modules/wyc/src/wyc/lang/Stmt.java
index e9d61b25f..4f7cad290 100755
--- a/modules/wyc/src/wyc/lang/Stmt.java
+++ b/modules/wyc/src/wyc/lang/Stmt.java
@@ -220,7 +220,7 @@ public Assume(String msg, Expr expr, Collection<Attribute> attributes) {
 	 *
 	 */
 	public static final class Return extends SyntacticElement.Impl implements Stmt {
-		public Expr expr;
+		public ArrayList<Expr> returns;
 
 		/**
 		 * Create a given return statement with an optional return value.
@@ -229,9 +229,9 @@ public Assume(String msg, Expr expr, Collection<Attribute> attributes) {
 		 *            value being returned (may be null)
 		 * @param attributes
 		 */
-		public Return(Expr expr, Attribute... attributes) {
+		public Return(List<Expr> returns, Attribute... attributes) {
 			super(attributes);
-			this.expr = expr;
+			this.returns = new ArrayList<Expr>(returns);
 		}
 
 		/**
@@ -241,17 +241,20 @@ public Return(Expr expr, Attribute... attributes) {
 		 *            the return value, which may be <code>null</code>.
 		 * @param attributes
 		 */
-		public Return(Expr expr, Collection<Attribute> attributes) {
+		public Return(List<Expr> returns, Collection<Attribute> attributes) {
 			super(attributes);
-			this.expr = expr;
+			this.returns = new ArrayList<Expr>(returns);
 		}
 
-		public String toString() {			
-			if(expr != null) {
-				return "return " + expr;
-			} else {
-				return "return";
-			}			
+		public String toString() {
+			String r = "return";
+			for(int i=0;i!=returns.size();++i) {
+				if(i != 0) {
+					r = r + ",";
+				}
+				r = r + " " + returns.get(i);
+			}
+			return r;
 		}
 	}
 
diff --git a/modules/wyc/src/wyc/lang/SyntacticType.java b/modules/wyc/src/wyc/lang/SyntacticType.java
index 70f50acb9..bb681a483 100755
--- a/modules/wyc/src/wyc/lang/SyntacticType.java
+++ b/modules/wyc/src/wyc/lang/SyntacticType.java
@@ -353,52 +353,66 @@ public Record(boolean isOpen,
 
 	public abstract static class FunctionOrMethod extends
 			SyntacticElement.Impl implements NonUnion {
-		public final SyntacticType returnType;
+		public final ArrayList<SyntacticType> returnTypes;
 		public final ArrayList<SyntacticType> paramTypes;
 
-		public FunctionOrMethod(SyntacticType returnType, Collection<SyntacticType> paramTypes,
+		public FunctionOrMethod(Collection<SyntacticType> returnTypes, Collection<SyntacticType> paramTypes,
 				Attribute... attributes) {
 			super(attributes);
-			this.returnType = returnType;			
+			this.returnTypes = new ArrayList<SyntacticType>(returnTypes);
 			this.paramTypes = new ArrayList<SyntacticType>(paramTypes);
-			if(returnType == null) {
-				throw new IllegalArgumentException("Invalid return type");
+			for(SyntacticType t : paramTypes) {
+				if(t == null) {
+					throw new IllegalArgumentException("parameter cannot be null"); 
+				}
+			}
+			for(SyntacticType t : returnTypes) {
+				if(t == null) {
+					throw new IllegalArgumentException("return cannot be null"); 
+				}
 			}
 		}
 
-		public FunctionOrMethod(SyntacticType returnType, Collection<SyntacticType> paramTypes,
+		public FunctionOrMethod(Collection<SyntacticType> returnTypes, Collection<SyntacticType> paramTypes,
 				Collection<Attribute> attributes) {
 			super(attributes);
-			this.returnType = returnType;
+			this.returnTypes = new ArrayList<SyntacticType>(returnTypes);
 			this.paramTypes = new ArrayList<SyntacticType>(paramTypes);
-			if(returnType == null) {
-				throw new IllegalArgumentException("Invalid return type");
+			for(SyntacticType t : paramTypes) {
+				if(t == null) {
+					throw new IllegalArgumentException("parameter cannot be null"); 
+				}
+			}
+			for(SyntacticType t : returnTypes) {
+				if(t == null) {
+					throw new IllegalArgumentException("return cannot be null"); 
+				}
 			}
 		}
 	}
 
 	public static class Function extends FunctionOrMethod
 	implements NonUnion {
-		public Function(SyntacticType returnType, 
+		public Function(Collection<SyntacticType> returnTypes, 
 				Collection<SyntacticType> paramTypes,
 				Attribute... attributes) {
-			super(returnType,paramTypes,attributes);
+			super(returnTypes,paramTypes,attributes);
 		}
-		public Function(SyntacticType returnType,  Collection<SyntacticType> paramTypes,
+		public Function(Collection<SyntacticType> returnTypes, Collection<SyntacticType> paramTypes,
 				Collection<Attribute> attributes) {
-			super(returnType,paramTypes,attributes);
+			super(returnTypes,paramTypes,attributes);
 		}
 	}
 
 	public static class Method extends FunctionOrMethod
 	implements NonUnion {
-				public Method(SyntacticType returnType,  Collection<SyntacticType> paramTypes,
+				public Method(Collection<SyntacticType> returnTypes, Collection<SyntacticType> paramTypes,
 				Attribute... attributes) {
-			super(returnType,paramTypes,attributes);
+			super(returnTypes,paramTypes,attributes);
 		}
-		public Method(SyntacticType returnType,  Collection<SyntacticType> paramTypes,
+		public Method(Collection<SyntacticType> returnTypes, Collection<SyntacticType> paramTypes,
 				Collection<Attribute> attributes) {
-			super(returnType,paramTypes,attributes);
+			super(returnTypes,paramTypes,attributes);
 		}
 	}
 }
diff --git a/modules/wyc/src/wyc/lang/WhileyFile.java b/modules/wyc/src/wyc/lang/WhileyFile.java
index df1b1f706..ecc75799c 100755
--- a/modules/wyc/src/wyc/lang/WhileyFile.java
+++ b/modules/wyc/src/wyc/lang/WhileyFile.java
@@ -422,7 +422,7 @@ public Type(List<Modifier> modifiers, Parameter type,
 	 */
 	public abstract class FunctionOrMethod extends NamedDeclaration {
 		public final ArrayList<Parameter> parameters;
-		public final Parameter returnType;
+		public final ArrayList<Parameter> returns;
 		public final ArrayList<Stmt> statements;
 		public List<Expr> requires;
 		public List<Expr> ensures;
@@ -445,12 +445,12 @@ public Type(List<Modifier> modifiers, Parameter type,
 		 *            - The Statements making up the function body.
 		 */
 		public FunctionOrMethod(List<Modifier> modifiers, String name,
-				Parameter returnType, List<Parameter> parameters,
+				List<Parameter> returns, List<Parameter> parameters,
 				List<Expr> requires, List<Expr> ensures,
 				List<Stmt> statements,
 				Attribute... attributes) {
 			super(name, modifiers,attributes);
-			this.returnType = returnType;
+			this.returns  = new ArrayList<Parameter>(returns);
 			this.parameters = new ArrayList<Parameter>(parameters);
 			this.requires = new ArrayList<Expr>(requires);
 			this.ensures = new ArrayList<Expr>(ensures);
@@ -499,26 +499,24 @@ public FunctionOrMethod(List<Modifier> modifiers, String name,
 	public final class Function extends FunctionOrMethod {
 		public Nominal.Function resolvedType;
 
-		public Function(List<Modifier> modifiers, String name, Parameter returnType,
+		public Function(List<Modifier> modifiers, String name, List<Parameter> returns,
 				List<Parameter> parameters, List<Expr> requires,
 				List<Expr> ensures,
 				List<Stmt> statements, Attribute... attributes) {
-			super(modifiers, name, returnType, parameters, requires, ensures,
+			super(modifiers, name, returns, parameters, requires, ensures,
 					statements, attributes);
 		}
 
 		public SyntacticType.Function unresolvedType() {
-			ArrayList<SyntacticType> params = new ArrayList<SyntacticType>();
+			ArrayList<SyntacticType> paramTypes = new ArrayList<SyntacticType>();
 			for (Parameter p : parameters) {
-				params.add(p.type);
+				paramTypes.add(p.type);
 			}
-			SyntacticType type;
-			if (returnType == null) {
-				type = new SyntacticType.Void();
-			} else {
-				type = returnType.type;
+			ArrayList<SyntacticType> returnTypes = new ArrayList<SyntacticType>();
+			for (Parameter r : returns) {
+				returnTypes.add(r.type);
 			}
-			return new SyntacticType.Function(type, params, attributes());
+			return new SyntacticType.Function(returnTypes, paramTypes, attributes());
 		}
 
 		public Nominal.Function resolvedType() {
@@ -561,23 +559,21 @@ public Function(List<Modifier> modifiers, String name, Parameter returnType,
 	public final class Method extends FunctionOrMethod {
 		public Nominal.Method resolvedType;
 
-		public Method(List<Modifier> modifiers, String name, Parameter returnType, List<Parameter> parameters,
+		public Method(List<Modifier> modifiers, String name, List<Parameter> returns, List<Parameter> parameters,
 				List<Expr> requires, List<Expr> ensures, List<Stmt> statements, Attribute... attributes) {
-			super(modifiers, name, returnType, parameters, requires, ensures, statements, attributes);
+			super(modifiers, name, returns, parameters, requires, ensures, statements, attributes);
 		}
 
 		public SyntacticType.Method unresolvedType() {
-			ArrayList<SyntacticType> params = new ArrayList<SyntacticType>();
+			ArrayList<SyntacticType> parameterTypes = new ArrayList<SyntacticType>();
 			for (Parameter p : parameters) {
-				params.add(p.type);
+				parameterTypes.add(p.type);
 			}
-			SyntacticType type;
-			if (returnType == null) {
-				type = new SyntacticType.Void();
-			} else {
-				type = returnType.type;
+			ArrayList<SyntacticType> returnTypes = new ArrayList<SyntacticType>();
+			for (Parameter r : returns) {
+				returnTypes.add(r.type);
 			}
-			return new SyntacticType.Method(type, params, attributes());
+			return new SyntacticType.Method(returnTypes, parameterTypes, attributes());
 		}
 
 		public Nominal.Method resolvedType() {
diff --git a/modules/wyc/src/wyc/testing/TestUtils.java b/modules/wyc/src/wyc/testing/TestUtils.java
index e575e884f..1f0d2f57a 100644
--- a/modules/wyc/src/wyc/testing/TestUtils.java
+++ b/modules/wyc/src/wyc/testing/TestUtils.java
@@ -60,7 +60,7 @@
 	 * @throws IOException
 	 */
 	public static void execWyil(String wyilDir, Path.ID id) throws IOException {
-		Type.Method sig = Type.Method(Type.T_VOID, Collections.EMPTY_LIST);
+		Type.Method sig = Type.Method(Collections.EMPTY_LIST, Collections.EMPTY_LIST);
 		NameID name = new NameID(id,"test");
 		Build.Project project = initialiseProject(wyilDir);
 		new Interpreter(project,null).execute(name,sig);
diff --git a/modules/wyil/src/wyil/Main.java b/modules/wyil/src/wyil/Main.java
index b74d21ecf..7e6412a69 100644
--- a/modules/wyil/src/wyil/Main.java
+++ b/modules/wyil/src/wyil/Main.java
@@ -88,7 +88,7 @@ public static void main(String[] args) {
 			WyilFile wf = new WyilFileReader(args[0]).read();
 			new WyilFilePrinter(System.out).apply(wf);
 			// FIXME: this is all a hack for now
-			Type.Method sig = Type.Method(Type.T_VOID, Collections.EMPTY_LIST);
+			Type.Method sig = Type.Method(Collections.EMPTY_LIST, Collections.EMPTY_LIST);
 			NameID name = new NameID(wf.id(),"test");
 			Build.Project project = initialiseProject(".");
 			Object r = new Interpreter(project,System.out).execute(name,sig);
diff --git a/modules/wyil/src/wyil/builders/VcGenerator.java b/modules/wyil/src/wyil/builders/VcGenerator.java
index a06947e9c..9f385fe49 100644
--- a/modules/wyil/src/wyil/builders/VcGenerator.java
+++ b/modules/wyil/src/wyil/builders/VcGenerator.java
@@ -167,14 +167,14 @@ protected void transform(WyilFile.FunctionOrMethod method, WyilFile wyilFile) {
 					precondition.get(i), fmm.params(), true);
 		}
 		prefix = method.name() + "_ensures_";
-		List<Type> postEnvironment = append(fmm.params(), fmm.ret());		
+		List<Type> postEnvironment = append(fmm.params(), fmm.returns());		
 		for (int i = 0; i != postcondition.size(); ++i) {
 			buildMacroBlock(prefix + i, CodeBlock.Index.ROOT,
 					postcondition.get(i), postEnvironment, true);
 		}
 
 		// Finally, add a function representing this function or method.
-		buildFunctionBlock(method.name(), fmm.params(), fmm.ret());
+		buildFunctionBlock(method.name(), fmm.params(), fmm.returns());
 
 		if (method.hasModifier(Modifier.NATIVE)) {
 			// We don't consider native methods because they have empty bodies,
@@ -240,7 +240,7 @@ protected void transform(WyilFile.FunctionOrMethod method, WyilFile wyilFile) {
 				break;
 			}
 			case TERMINATED: {
-				if (fmm.ret() instanceof Type.Void) {
+				if (fmm.returns().isEmpty()) {
 					// In this case, there is not return value and, hence, there
 					// is no need to ensure the postcondition holds.
 				} else {
@@ -254,12 +254,13 @@ protected void transform(WyilFile.FunctionOrMethod method, WyilFile wyilFile) {
 					Type rawType = expand(bodyEnvironment[ret.operand],attributes);
 					Expr rawTest = new Expr.Is(returnedOperand,
 							convert(rawType, attributes));
-					if (containsNominal(fmm.ret(),attributes)) {
+					// FIXME: needs to handle all returns
+					if (containsNominal(fmm.returns().get(0),attributes)) {
 						// FIXME: we need the raw test here, because the
 						// verifier can't work out the type of the expression
 						// otherwise.						
 						Expr nominalTest = new Expr.Is(returnedOperand,
-								convert(fmm.ret(), attributes));
+								convert(fmm.returns().get(0), attributes));
 						Expr vc = buildVerificationCondition(nominalTest,
 								branch, bodyEnvironment, body, rawTest);
 						// FIXME: add contextual information here
@@ -1707,11 +1708,12 @@ protected void transform(Codes.Invoke code, AttributedCodeBlock block,
 					wyccAttributes));
 
 			// This is a potential fix for #488, although it doesn't work
-			if(containsNominal(code.type().ret(),attributes)) {
+			// FIXME: needs to updated to handle multiple returns as well
+			if (containsNominal(code.type().returns().get(0), attributes)) {
 				// This is required to handle the implicit constraints implied
 				// by a nominal type. See #488.
 				Expr nominalTest = new Expr.Is(branch.read(code.target()),
-						convert(code.type().ret(), attributes));
+						convert(code.type().returns().get(0), attributes));
 				branch.assume(nominalTest);
 			}
 			
@@ -2101,21 +2103,26 @@ protected void buildMacroBlock(String name, CodeBlock.Index root,
 	 *            --- return type to use
 	 * @return
 	 */
-	protected void buildFunctionBlock(String name, List<Type> params, Type ret) {
+	protected void buildFunctionBlock(String name, List<Type> params, List<Type> returns) {
 
-		TypePattern.Leaf[] declarations = new TypePattern.Leaf[params.size()];
+		TypePattern.Leaf[] parameterPatterns = new TypePattern.Leaf[params.size()];
 		// second, set initial environment
 		for (int i = 0; i != params.size(); ++i) {
 			Expr.Variable v = new Expr.Variable("r" + i);
 			// FIXME: what attributes to pass into convert?
-			declarations[i] = new TypePattern.Leaf(convert(params.get(i),
+			parameterPatterns[i] = new TypePattern.Leaf(convert(params.get(i),
+					Collections.EMPTY_LIST), v);
+		}
+		TypePattern.Leaf[] returnPatterns = new TypePattern.Leaf[returns.size()];
+		// second, set initial environment
+		for (int i = 0; i != returns.size(); ++i) {
+			Expr.Variable v = new Expr.Variable("r" + i);
+			returnPatterns[i] = new TypePattern.Leaf(convert(returns.get(i),
 					Collections.EMPTY_LIST), v);
 		}
-
 		// Construct the type declaration for the new block macro
-		TypePattern from = new TypePattern.Tuple(declarations);
-		TypePattern to = new TypePattern.Leaf(convert(ret,
-				Collections.EMPTY_LIST), null);
+		TypePattern from = new TypePattern.Tuple(parameterPatterns);
+		TypePattern to = new TypePattern.Tuple(returnPatterns);
 
 		wyalFile.add(wyalFile.new Function(name, Collections.EMPTY_LIST, from,
 				to, null));
@@ -2694,7 +2701,12 @@ private boolean containsNominal(Type t,
 					return true;
 				}
 			}
-			return containsNominal(ft.ret(), attributes);
+			for (Type pt : ft.returns()) {
+				if (containsNominal(pt, attributes)) {
+					return true;
+				}
+			}
+			return false;
 		} else if (t instanceof Type.Nominal) {
 			return true;
 		} else {
@@ -2715,10 +2727,10 @@ private Type expand(Type t, Collection<wyil.lang.Attribute> attributes) {
 		return null; // dead-code
 	}
 	
-	private static <T> List<T> append(List<T> xs, T x) {
+	private static <T> List<T> append(List<T> xs, List<T> ys) {
 		ArrayList<T> rs = new ArrayList<T>();
 		rs.addAll(xs);
-		rs.add(x);		
+		rs.addAll(ys);		
 		return rs;
 	}
 
diff --git a/modules/wyil/src/wyil/checks/CoercionCheck.java b/modules/wyil/src/wyil/checks/CoercionCheck.java
index 756a63b88..7b8e2b62a 100755
--- a/modules/wyil/src/wyil/checks/CoercionCheck.java
+++ b/modules/wyil/src/wyil/checks/CoercionCheck.java
@@ -152,14 +152,8 @@ protected void check(Type from, Type to, HashSet<Pair<Type, Type>> visited,
 		} else if(from instanceof Type.Function && to instanceof Type.Function) {
 			Type.Function t1 = (Type.Function) from;
 			Type.Function t2 = (Type.Function) to;
-			List<Type> t1_elements = t1.params();
-			List<Type> t2_elements = t2.params();
-			for(int i=0;i!=t1_elements.size();++i) {
-				Type e1 = t1_elements.get(i);
-				Type e2 = t2_elements.get(i);
-				check(e1,e2,visited,location);
-			}
-			check(t1.ret(),t2.ret(),visited,location);
+			check(t1.params(),t2.params(),visited,location);
+			check(t1.returns(),t2.returns(),visited,location);
 		} else if(from instanceof Type.Union) {
 			Type.Union t1 = (Type.Union) from;
 			for(Type b : t1.bounds()) {
@@ -213,4 +207,13 @@ protected void check(Type from, Type to, HashSet<Pair<Type, Type>> visited,
 			}
 		}
 	}
+	
+	private void check(List<Type> params1, List<Type> params2, HashSet<Pair<Type, Type>> visited,
+			SourceLocation location) {
+		for (int i = 0; i != params1.size(); ++i) {
+			Type e1 = params1.get(i);
+			Type e2 = params2.get(i);
+			check(e1, e2, visited, location);
+		}
+	}
 }
diff --git a/modules/wyil/src/wyil/io/WyilFilePrinter.java b/modules/wyil/src/wyil/io/WyilFilePrinter.java
index 05b3d6748..54a6aaaa2 100755
--- a/modules/wyil/src/wyil/io/WyilFilePrinter.java
+++ b/modules/wyil/src/wyil/io/WyilFilePrinter.java
@@ -146,23 +146,13 @@ private void write(FunctionOrMethod method, PrintWriter out) {
 		} else {
 			out.print("method ");
 		}
-		List<Type> pts = ft.params();
-
-		out.print(method.name() + "(");
-		for (int i = 0; i != ft.params().size(); ++i) {
-			if (i != 0) {
-				out.print(", ");
-			}
-			out.print(pts.get(i));
-		}
-		out.print(")");
-
-		if (ft.ret() instanceof Type.Void) {
-			out.println(":");
-		} else {
-			out.println(" -> " + ft.ret() + ":");
-		}
-
+		writeParameters(ft.params(),out);		
+		if (!ft.returns().isEmpty()) {
+			out.print(" -> ");
+			writeParameters(ft.returns(),out);
+		}		
+		out.println(":");
+		
 		for (AttributedCodeBlock precondition : method.precondition()) {
 			out.println("requires:");
 			write(0, precondition, out);
@@ -179,6 +169,17 @@ private void write(FunctionOrMethod method, PrintWriter out) {
 		}
 	}
 
+	private void writeParameters(List<Type> parameters, PrintWriter out) {
+		out.print("(");
+		for (int i = 0; i != parameters.size(); ++i) {
+			if (i != 0) {
+				out.print(", ");
+			}
+			out.print(parameters.get(i));
+		}
+		out.print(")");
+	}
+	
 	private void write(int indent, CodeBlock blk, PrintWriter out) {
 		if(blk == null) { return; }
 		for(int i=0;i!=blk.size();++i) {
diff --git a/modules/wyil/src/wyil/lang/Codes.java b/modules/wyil/src/wyil/lang/Codes.java
index ef9a33c9b..5abdfa9c9 100644
--- a/modules/wyil/src/wyil/lang/Codes.java
+++ b/modules/wyil/src/wyil/lang/Codes.java
@@ -1448,7 +1448,7 @@ public boolean equals(Object o) {
 		}
 
 		public Type assignedType() {
-			return type().ret();
+			return type().returns().get(0);
 		}
 
 		public String toString() {
@@ -1623,7 +1623,7 @@ public int opcode() {
 		}
 
 		public Type assignedType() {
-			return type().ret();
+			return type().returns().get(0);
 		}
 
 		public int hashCode() {
@@ -1673,7 +1673,7 @@ public int opcode() {
 		}
 
 		public Type assignedType() {
-			return type().ret();
+			return type().returns().get(0);
 		}
 
 		public int hashCode() {
diff --git a/modules/wyil/src/wyil/lang/Constant.java b/modules/wyil/src/wyil/lang/Constant.java
index fc443a7e9..93bbb52d3 100755
--- a/modules/wyil/src/wyil/lang/Constant.java
+++ b/modules/wyil/src/wyil/lang/Constant.java
@@ -546,8 +546,7 @@ private Lambda(NameID name, wyil.lang.Type.FunctionOrMethod type, Collection<Con
 		
 		public wyil.lang.Type.FunctionOrMethod type() {
 			if (type == null) {
-				return wyil.lang.Type.Function(wyil.lang.Type.T_ANY,
-						wyil.lang.Type.T_ANY);
+				return wyil.lang.Type.Function(new wyil.lang.Type[] { wyil.lang.Type.T_ANY }, wyil.lang.Type.T_ANY);
 			} else {
 				return type;
 			}
diff --git a/modules/wyil/src/wyil/lang/Type.java b/modules/wyil/src/wyil/lang/Type.java
index f972fb53c..fd9f18f9d 100755
--- a/modules/wyil/src/wyil/lang/Type.java
+++ b/modules/wyil/src/wyil/lang/Type.java
@@ -155,14 +155,17 @@ public static final Type Negation(Type element) {
 	 *
 	 * @param element
 	 */
-	public static final Type.Function Function(Type ret,
+	public static final Type.Function Function(List<Type> returns,
 			List<Type> params) {		
-		Type[] rparams = new Type[params.size()+1];
-		rparams[0] = ret;
-		for(int i=0;i!=params.size();++i) {
-			rparams[i+1] = params.get(i);
+		Type[] rparams = new Type[params.size()+returns.size()];
+		int params_size = params.size();
+		for(int i=0;i!=params_size;++i) {
+			rparams[i] = params.get(i);
+		}
+		for(int i=0;i!=returns.size();++i) {
+			rparams[i+params_size] = returns.get(i);
 		}		
-		Type r = construct(K_FUNCTION, null, rparams);
+		Type r = construct(K_FUNCTION, params_size, rparams);
 		if (r instanceof Type.Function) {
 			return (Type.Function) r;
 		} else {
@@ -176,12 +179,12 @@ public static final Type Negation(Type element) {
 	 *
 	 * @param element
 	 */
-	public static final Type.Function Function(Type ret,
+	public static final Type.Function Function(Type[] returns,
 			Type... params) {		
-		Type[] rparams = new Type[params.length+1];
-		rparams[0] = ret;
-		System.arraycopy(params, 0, rparams, 1, params.length);		
-		Type r = construct(K_FUNCTION, null, rparams);
+		Type[] rparams = new Type[params.length+returns.length];
+		System.arraycopy(params, 0, rparams, 0, params.length);
+		System.arraycopy(returns, 0, rparams, params.length, returns.length);
+		Type r = construct(K_FUNCTION, params.length, rparams);
 		if (r instanceof Type.Function) {
 			return (Type.Function) r;
 		} else {
@@ -195,13 +198,16 @@ public static final Type Negation(Type element) {
 	 *
 	 * @param element
 	 */
-	public static final Type.Method Method(Type ret, List<Type> params) {
-		Type[] rparams = new Type[params.size()+1];
-		rparams[0] = ret;
-		for(int i=0;i!=params.size();++i) {
-			rparams[i+1] = params.get(i);
-		}	
-		Type r = construct(K_METHOD, null, rparams);
+	public static final Type.Method Method(List<Type> returns, List<Type> params) {
+		Type[] rparams = new Type[params.size()+returns.size()];
+		int params_size = params.size();
+		for(int i=0;i!=params_size;++i) {
+			rparams[i] = params.get(i);
+		}
+		for(int i=0;i!=returns.size();++i) {
+			rparams[i+params_size] = returns.get(i);
+		}			
+		Type r = construct(K_METHOD, params_size, rparams);
 		if (r instanceof Type.Method) {
 			return (Type.Method) r;
 		} else {
@@ -215,11 +221,11 @@ public static final Type Negation(Type element) {
 	 *
 	 * @param element
 	 */
-	public static final Type.Method Method(Type ret, Type... params) {
-		Type[] rparams = new Type[params.length+1];
-		rparams[0] = ret;
-		System.arraycopy(params, 0, rparams, 1, params.length);	
-		Type r = construct(K_METHOD, null, rparams);
+	public static final Type.Method Method(Type[] returns, Type... params) {
+		Type[] rparams = new Type[params.length+returns.length];
+		System.arraycopy(params, 0, rparams, 0, params.length);
+		System.arraycopy(returns, 0, rparams, params.length, returns.length);
+		Type r = construct(K_METHOD, params.length, rparams);
 		if (r instanceof Type.Method) {
 			return (Type.Method) r;
 		} else {
@@ -398,6 +404,9 @@ public Type readType() throws IOException {
 			}  else if(state.kind == Type.K_LIST || state.kind == Type.K_SET) {
 				boolean nonEmpty = reader.read_bit();
 				state.data = nonEmpty;
+			} else if(state.kind == Type.K_FUNCTION || state.kind == Type.K_METHOD) {
+				int numParameters = reader.read_uv();
+				state.data = numParameters;
 			}
 			return state;
 		}
@@ -450,6 +459,8 @@ public void write(Automaton.State state) throws IOException {
 				}
 			} else if(state.kind == Type.K_LIST || state.kind == Type.K_SET) {
 				writer.write_bit((Boolean) state.data);
+			}  else if(state.kind == Type.K_FUNCTION || state.kind == Type.K_METHOD) {
+				writer.write_uv((Integer) state.data);				
 			}
 		}
 
@@ -1163,26 +1174,34 @@ public Type element() {
 		FunctionOrMethod(Automaton automaton) {
 			super(automaton);
 		}
-
+		
 		/**
-		 * Get the return type of this function or method type.
+		 * Get the parameter types of this function or method type.
 		 *
 		 * @return
 		 */
-		public Type ret() {
-			int[] fields = automaton.states[0].children;
-			return construct(Automata.extract(automaton, fields[0]));
+		public ArrayList<Type> returns() {
+			Automaton.State state = automaton.states[0];
+			int[] fields = state.children;
+			int numParams = (Integer) state.data;
+			ArrayList<Type> r = new ArrayList<Type>();
+			for(int i=numParams;i<fields.length;++i) {
+				r.add(construct(Automata.extract(automaton, fields[i])));
+			}
+			return r;
 		}
-
+		
 		/**
 		 * Get the parameter types of this function or method type.
 		 *
 		 * @return
 		 */
 		public ArrayList<Type> params() {
-			int[] fields = automaton.states[0].children;
+			Automaton.State state = automaton.states[0];
+			int[] fields = state.children;
+			int numParams = (Integer) state.data;
 			ArrayList<Type> r = new ArrayList<Type>();
-			for(int i=1;i<fields.length;++i) {
+			for(int i=0;i<numParams;++i) {
 				r.add(construct(Automata.extract(automaton, fields[i])));
 			}
 			return r;
@@ -1364,21 +1383,26 @@ private final static String toString(int index, BitSet visited,
 		}
 		case K_METHOD:
 		case K_FUNCTION: {
-			middle = "";
+			String parameters = "";
 			int[] children = state.children;			;
-			String ret = toString(children[0], visited, headers, automaton);			
-			boolean firstTime=true;
-			for (int i = 1; i != children.length; ++i) {
-				if (!firstTime) {
-					middle += ",";
+			int numParameters = (Integer) state.data;
+			for (int i = 0; i != numParameters; ++i) {
+				if (i!=0) {
+					parameters += ",";
 				}
-				firstTime=false;
-				middle += toString(children[i], visited, headers, automaton);
+				parameters += toString(children[i], visited, headers, automaton);
+			}
+			String returns = "";
+			for (int i = numParameters; i != children.length; ++i) {
+				if (i!=numParameters) {
+					returns += ",";
+				}
+				returns += toString(children[i], visited, headers, automaton);
 			}
 			if(state.kind == K_FUNCTION) {
-				middle = "function(" + middle + ") -> " + ret;
+				middle = "function(" + parameters + ")->(" + returns + ")";
 			} else {
-				middle = "method(" + middle + ") -> " + ret;
+				middle = "method(" + parameters + ")->(" + returns + ")";
 			}			
 			break;
 		}
diff --git a/modules/wyil/src/wyil/util/Interpreter.java b/modules/wyil/src/wyil/util/Interpreter.java
index 5bc496f85..3e00bb88c 100644
--- a/modules/wyil/src/wyil/util/Interpreter.java
+++ b/modules/wyil/src/wyil/util/Interpreter.java
@@ -943,7 +943,7 @@ private Object execute(Codes.IndirectInvoke bytecode, Constant[] frame,
 		// Make the actual call
 		Constant result = execute(func.name, func.type(), arguments);
 		// Coerce the result (may not be actually necessary)
-		result = convert(result,bytecode.type().ret(),context);
+		result = convert(result,bytecode.type().returns().get(0),context);
 		// Check whether a return value was expected or not
 		if (bytecode.target() != Codes.NULL_REG) {
 			frame[bytecode.target()] = result;
diff --git a/modules/wyil/src/wyil/util/TypeExpander.java b/modules/wyil/src/wyil/util/TypeExpander.java
index 1dcdde889..61cf3f7cc 100644
--- a/modules/wyil/src/wyil/util/TypeExpander.java
+++ b/modules/wyil/src/wyil/util/TypeExpander.java
@@ -227,11 +227,16 @@ public int getTypeHelper(Type type, boolean maximallyConsumed,
 		} else if(type instanceof Type.FunctionOrMethod) {
 			Type.FunctionOrMethod tt = (Type.FunctionOrMethod) type;
 			List<Type> tt_params = tt.params();
+			List<Type> tt_returns = tt.returns();
 			myChildren = new int[tt_params.size()+1];
-			myChildren[0] = getTypeHelper(tt.ret(),maximallyConsumed,states,roots);			
-			for(int i=0;i!=tt_params.size();++i) {
-				myChildren[i+1] = getTypeHelper(tt_params.get(i),maximallyConsumed,states,roots);
+			int tt_params_size = tt_params.size();
+			for(int i=0;i!=tt_params_size;++i) {
+				myChildren[i] = getTypeHelper(tt_params.get(i),maximallyConsumed,states,roots);
 			}
+			for(int i=0;i!=tt_returns.size();++i) {
+				myChildren[i+tt_params_size] = getTypeHelper(tt_returns.get(i),maximallyConsumed,states,roots);
+			}
+			myData = tt_params_size;
 			myKind = tt instanceof Type.Function ? Type.K_FUNCTION
 					: Type.K_METHOD;			
 		}else {
diff --git a/modules/wyil/src/wyil/util/type/SubtypeOperator.java b/modules/wyil/src/wyil/util/type/SubtypeOperator.java
index 94ad019b7..7a28c8c7b 100644
--- a/modules/wyil/src/wyil/util/type/SubtypeOperator.java
+++ b/modules/wyil/src/wyil/util/type/SubtypeOperator.java
@@ -235,13 +235,18 @@ protected boolean isIntersectionInner(int fromIndex, boolean fromSign, int toInd
 					if(fromChildren.length != toChildren.length){
 						return false;
 					}
-
+					int fromNumParams = (Integer) fromState.data;
+					int toNumParams = (Integer) toState.data;
+					if(fromNumParams != toNumParams){
+						return false;
+					}		
 					boolean andChildren = true;
 					boolean orChildren = false;
+					 
 					for(int i=0;i<fromChildren.length;++i) {
 						boolean v;
-						if(i == 0) {
-							// return type is co-variant
+						if(i >= fromNumParams) {
+							// return type(s) are co-variant
 							v = isIntersection(fromChildren[i], fromSign,
 									toChildren[i], toSign);
 						} else {
diff --git a/modules/wyil/src/wyil/util/type/TypeAlgorithms.java b/modules/wyil/src/wyil/util/type/TypeAlgorithms.java
index dc2acced0..828d97b8b 100755
--- a/modules/wyil/src/wyil/util/type/TypeAlgorithms.java
+++ b/modules/wyil/src/wyil/util/type/TypeAlgorithms.java
@@ -107,6 +107,10 @@ public int compare(Automaton.State s1, Automaton.State s2) {
 				Boolean nid1 = (Boolean) s1.data;
 				Boolean nid2 = (Boolean) s2.data;
 				return nid1.toString().compareTo(nid2.toString());
+			} else if(s1.kind == Type.K_FUNCTION || s1.kind == Type.K_METHOD) {
+				int s1NumParams = (Integer) s1.data;
+				int s2NumParams = (Integer) s2.data;				
+				return Integer.compare(s1NumParams, s2NumParams);
 			} else {
 				String str1 = (String) s1.data;
 				String str2 = (String) s2.data;
@@ -299,11 +303,7 @@ private static boolean simplifyCompound(int index, Automaton.State state, Automa
 			isOpenRecord = data.isOpen;
 		}
 
-		for(int i=0;i<children.length;++i) {
-			if ((i == 0 || i == 1) && (kind == Type.K_METHOD || kind == Type.K_FUNCTION)) {
-				// headless method and function return or throws type allowed to be void
-				continue;
-			}
+		for(int i=0;i<children.length;++i) {			
 			Automaton.State child = automaton.states[children[i]];
 			if(child.kind == Type.K_VOID) {
 				automaton.states[index] = new Automaton.State(Type.K_VOID);
diff --git a/modules/wyil/src/wyil/util/type/TypeParser.java b/modules/wyil/src/wyil/util/type/TypeParser.java
index 2a6afb4ac..7a20317c9 100755
--- a/modules/wyil/src/wyil/util/type/TypeParser.java
+++ b/modules/wyil/src/wyil/util/type/TypeParser.java
@@ -28,6 +28,7 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 
 import wycc.lang.NameID;
 import wyfs.lang.Path;
@@ -56,7 +57,7 @@ public Type parse() {
 	}
 
 	public Type parse(HashSet<String> typeVariables) {
-		Type term = parseFunctionTerm(typeVariables);
+		Type term = parseNotTerm(typeVariables);
 		skipWhiteSpace();
 		while (index < str.length()
 				&& (str.charAt(index) == '|')) {
@@ -67,30 +68,35 @@ public Type parse(HashSet<String> typeVariables) {
 		}
 		return term;
 	}
-
-	public Type parseFunctionTerm(HashSet<String> typeVariables) {
-		Type t = parseNotTerm(typeVariables);
-		if(index >= str.length()) { return t; }
-		char lookahead = str.charAt(index);
-		if(lookahead == '(') {
-			// this is a tuple, not a bracketed type.
-			match("(");
-			ArrayList<Type> elems = new ArrayList();
-			elems.add(parse(typeVariables));
-			lookahead = str.charAt(index);
-			while(lookahead == ',') {
-				match(",");
-				elems.add(parse(typeVariables));
-				skipWhiteSpace();
-				lookahead = str.charAt(index);
-			}
-			match(")");
-			skipWhiteSpace();
-			return Function(t,elems);
-		}
-		return t;
-	}
-
+//  FIXME: This is broken and needs to be updated to handle multiple returns.
+//	public Type parseFunctionTerm(HashSet<String> typeVariables) {		
+//		Type t = parseNotTerm(typeVariables);
+//		if(index >= str.length()) { return t; }
+//		char lookahead = str.charAt(index);
+//		if(lookahead == '(') {
+//			// this is a tuple, not a bracketed type.
+//			List<Type> parameters = parseParameters(typeVariables);			
+//			skipWhiteSpace();
+//			return Function(t,parameters);
+//		}
+//		return t;
+//	}
+//
+//	private List<Type> parseParameters(HashSet<String> typeVariables) {
+//		match("(");
+//		ArrayList<Type> elems = new ArrayList();
+//		elems.add(parse(typeVariables));
+//		char lookahead = str.charAt(index);
+//		while(lookahead == ',') {
+//			match(",");
+//			elems.add(parse(typeVariables));
+//			skipWhiteSpace();
+//			lookahead = str.charAt(index);
+//		}
+//		match(")");
+//		return elems;
+//	}
+	
 	public Type parseNotTerm(HashSet<String> typeVariables) {
 		skipWhiteSpace();
 		char lookahead = str.charAt(index);
diff --git a/modules/wyil/src/wyil/util/type/TypeTester.java b/modules/wyil/src/wyil/util/type/TypeTester.java
index 0febbaa3f..6b15b7bf6 100755
--- a/modules/wyil/src/wyil/util/type/TypeTester.java
+++ b/modules/wyil/src/wyil/util/type/TypeTester.java
@@ -97,8 +97,9 @@ public boolean accepts(int index, Automaton automaton, Term value) {
 					return false;
 				}
 				int length = schildren.length;
+				int sNumParams = (Integer) state.data;
 				// First, do parameters (which are contravariant).
-				for(int i=2;i<length;++i) {
+				for(int i=0;i<sNumParams;++i) {
 					int schild = schildren[i];
 					Term vchild = vchildren[i];
 					if(accepts(schild,automaton,vchild)) {
@@ -106,9 +107,12 @@ public boolean accepts(int index, Automaton automaton, Term value) {
 					}
 				}
 				// Second, do return values (which are covariant)
-				if(!accepts(schildren[2],automaton,vchildren[2])) {
-					return false;
+				for(int i=sNumParams;i<schildren.length;++i) {
+					if(!accepts(schildren[i],automaton,vchildren[i])) {
+						return false;
+					}	
 				}
+				
 				// Third, do return values (which should be contra-variant)
 				return true;
 			}
diff --git a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
index 04f4797e2..ec6cd46d0 100755
--- a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
+++ b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
@@ -331,8 +331,7 @@ private void buildValues(HashMap<JvmConstant, Integer> constants,
 		codes.add(new Bytecode.Load(0, strArr));
 		codes.add(new Bytecode.Invoke(WHILEYUTIL, "systemConsole", ft1,
 				Bytecode.InvokeMode.STATIC));
-		Type.Method wyft = Type.Method(Type.T_VOID, Type.T_VOID,
-				WHILEY_SYSTEM_T);
+		Type.Method wyft = Type.Method(new Type[0], Type.T_VOID, WHILEY_SYSTEM_T);
 		JvmType.Function ft3 = convertFunType(wyft);
 		codes.add(new Bytecode.Invoke(owner, nameMangle("main", wyft), ft3,
 				Bytecode.InvokeMode.STATIC));
@@ -492,10 +491,10 @@ private void patchInvariantBlockHelper(String falseBranch, CodeBlock block) {
 					Bytecode.InvokeMode.STATIC));
 		}
 
-		if (ft.ret() == Type.T_VOID) {
+		if (ft.returns().isEmpty()) {
 			bytecodes.add(new Bytecode.Return(null));
 		} else {
-			bytecodes.add(new Bytecode.Return(convertUnderlyingType(ft.ret())));
+			bytecodes.add(new Bytecode.Return(convertUnderlyingType(ft.returns().get(0))));
 		}
 
 		return bytecodes;
@@ -1669,15 +1668,12 @@ private void translate(CodeBlock.Index index, Codes.Invoke c, int freeSlot,
 		bytecodes.add(new Bytecode.Invoke(owner, mangled, type,
 				Bytecode.InvokeMode.STATIC));
 
-		// now, handle the case of an invoke which returns a value that should
-		// be discarded.
 		if (c.target() != Codes.NULL_REG) {
-			bytecodes.add(new Bytecode.Store(c.target(),
-					convertUnderlyingType(c.type().ret())));
-		} else if (c.target() == Codes.NULL_REG
-				&& c.type().ret() != Type.T_VOID) {
-			bytecodes.add(new Bytecode.Pop(
-					convertUnderlyingType(c.type().ret())));
+			bytecodes.add(new Bytecode.Store(c.target(), convertUnderlyingType(c.type().returns().get(0))));
+		} else if (c.target() == Codes.NULL_REG && !(c.type().returns().isEmpty())) {
+			// handles the case of an invoke which returns a value that should
+			// be discarded.
+			bytecodes.add(new Bytecode.Pop(convertUnderlyingType(c.type().returns().get(0))));
 		}
 	}
 
@@ -1709,13 +1705,12 @@ private void translate(CodeBlock.Index index, Codes.IndirectInvoke c,
 		bytecodes.add(new Bytecode.Invoke(owner, "call", type,
 				Bytecode.InvokeMode.VIRTUAL));
 
-		// now, handle the case of an invoke which returns a value that should
-		// be discarded.
 		if (c.target() != Codes.NULL_REG) {
-			addReadConversion(ft.ret(), bytecodes);
-			bytecodes.add(new Bytecode.Store(c.target(),
-					convertUnderlyingType(c.type().ret())));
+			addReadConversion(ft.returns().get(0), bytecodes);
+			bytecodes.add(new Bytecode.Store(c.target(), convertUnderlyingType(c.type().returns().get(0))));
 		} else if (c.target() == Codes.NULL_REG) {
+			// handles the case of an invoke which returns a value that should
+			// be discarded.
 			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
 		}
 	}
@@ -2058,12 +2053,12 @@ protected ClassFile buildLambda(NameID name, Type.FunctionOrMethod type,
 		JvmType.Function fnType = convertFunType(type);
 		bytecodes.add(new Bytecode.Invoke(owner, mangled, fnType,
 				Bytecode.InvokeMode.STATIC));
-		if (type.ret() instanceof Type.Void) {
+		if (type.returns().isEmpty()) {
 			// Called function doesn't return anything, but we have to.
 			// Therefore, push on dummy null value.
 			bytecodes.add(new Bytecode.LoadConst(null));
 		} else {
-			addWriteConversion(type.ret(), bytecodes);
+			addWriteConversion(type.returns().get(0), bytecodes);
 		}
 
 		bytecodes.add(new Bytecode.Return(JAVA_LANG_OBJECT));
@@ -2496,7 +2491,12 @@ private void construct(JvmType.Clazz owner, int freeSlot,
 		for (Type pt : ft.params()) {
 			paramTypes.add(convertUnderlyingType(pt));
 		}
-		JvmType rt = convertUnderlyingType(ft.ret());
+		JvmType rt;
+		if (ft.returns().isEmpty()) {
+			rt = T_VOID;
+		} else {
+			rt = convertUnderlyingType(ft.returns().get(0));
+		}
 		return new JvmType.Function(rt, paramTypes);
 	}
 
diff --git a/modules/wyjc/src/wyjc/runtime/WyType.java b/modules/wyjc/src/wyjc/runtime/WyType.java
index f9235f80a..0b7192a20 100644
--- a/modules/wyjc/src/wyjc/runtime/WyType.java
+++ b/modules/wyjc/src/wyjc/runtime/WyType.java
@@ -170,9 +170,9 @@ public Negation(WyType element) {
 	}
 
 	public static final class Function extends WyType {
-		public WyType returns;
+		public final WyType[] returns;
 		public final WyType[] parameters;
-		public Function(WyType returns, WyType[] parameters) {
+		public Function(WyType[] returns, WyType[] parameters) {
 			super(K_FUNCTION);
 			this.parameters = parameters;
 			this.returns = returns;
@@ -180,9 +180,9 @@ public Function(WyType returns, WyType[] parameters) {
 	}
 	
 	public static final class Method extends WyType {
-		public WyType returns;
+		public final WyType[] returns;
 		public final WyType[] parameters;
-		public Method(WyType returns, WyType[] parameters) {
+		public Method(WyType[] returns, WyType[] parameters) {
 			super(K_METHOD);
 			this.parameters = parameters;
 			this.returns = returns;
@@ -278,10 +278,14 @@ private static WyType readNode(BinaryInputStream reader, ArrayList<WyType> nodes
 			return new WyType.Nominal(module + ":" + name);
 		}
 		case K_FUNCTION: {
-			return new WyType.Function(children[0],Arrays.copyOfRange(children, 2, children.length));
+			int numParams = reader.read_uv();
+			return new WyType.Function(Arrays.copyOfRange(children, numParams, children.length),
+					Arrays.copyOfRange(children, 0, numParams));
 		}
 		case K_METHOD: {
-			return new WyType.Function(children[0],Arrays.copyOfRange(children, 1, children.length));
+			int numParams = reader.read_uv();
+			return new WyType.Method(Arrays.copyOfRange(children, numParams, children.length),
+					Arrays.copyOfRange(children, 0, numParams));
 		}
 		}
 
@@ -355,13 +359,13 @@ private static void substitute(WyType type, ArrayList<WyType> nodes) {
 		}
 		case K_FUNCTION: {
 			Function t = (Function) type;
-			t.returns = substitute((Label)t.returns,nodes);
+			substitute(t.returns,nodes);
 			substitute(t.parameters,nodes);
 			return;
 		}
 		case K_METHOD: {
 			Method t = (Method) type;
-			t.returns = substitute((Label)t.returns,nodes);
+			substitute(t.returns,nodes);
 			substitute(t.parameters,nodes);
 			return;
 		}
@@ -472,11 +476,14 @@ private static WyType substitute(WyType type, String label, WyType root, HashSet
 			case K_FUNCTION:
 			{
 				WyType.Function ft = (WyType.Function) type;
-				WyType[] types = ft.parameters;
-				for(int i=0;i!=types.length;++i) {
-					types[i] = substitute(types[i],label,root,visited);
+				WyType[] paramTypes = ft.parameters;
+				for(int i=0;i!=paramTypes.length;++i) {
+					paramTypes[i] = substitute(paramTypes[i],label,root,visited);
+				}
+				WyType[] returnTypes = ft.returns;
+				for(int i=0;i!=returnTypes.length;++i) {
+					returnTypes[i] = substitute(returnTypes[i],label,root,visited);
 				}
-				ft.returns = substitute(ft.returns,label,root,visited);
 				break;
 			}
 			case K_METHOD:
@@ -486,7 +493,10 @@ private static WyType substitute(WyType type, String label, WyType root, HashSet
 				for(int i=0;i!=types.length;++i) {
 					types[i] = substitute(types[i],label,root,visited);
 				}
-				ft.returns = substitute(ft.returns,label,root,visited);
+				WyType[] returnTypes = ft.returns;
+				for(int i=0;i!=returnTypes.length;++i) {
+					returnTypes[i] = substitute(returnTypes[i],label,root,visited);
+				}
 				break;
 			}
 		}
@@ -567,17 +577,21 @@ private static String toString(WyType t, HashSet<WyType> visited) {
 		case K_METHOD: {
 			WyType.Method ft = (WyType.Method) t;
 			WyType[] types = ft.parameters;
-			String r = "function(";
-			for (int i = 0; i != types.length; ++i) {
-				if (i != 0) {
-					r = r + ",";
-				}
-				r += toString(types[i],visited);
-			}
-			return r + ")->(" + toString(ft.returns,visited) + ")";
+			return "function" + toString(ft.parameters, visited) + "->" + toString(ft.returns, visited);
 		}
 		}
 
 		throw new RuntimeException("unknow type encountered (kind: " + t.kind + ")");
 	}
+	
+	private static String toString(WyType[] types, HashSet<WyType> visited) {
+		String r = "(";
+		for (int i = 0; i != types.length; ++i) {
+			if (i != 0) {
+				r = r + ",";
+			}
+			r += toString(types[i],visited);
+		}
+		return r + ")";
+	}
 }
diff --git a/tests/valid/Access_Valid_1.whiley b/tests/valid/Access_Valid_1.whiley
index 85dd09ea4..45a587cf9 100644
--- a/tests/valid/Access_Valid_1.whiley
+++ b/tests/valid/Access_Valid_1.whiley
@@ -5,7 +5,7 @@ requires index >= 0 && index < |l|:
     //
     return l[index]
 
-public export method test() -> void:
+public export method test() :
     int[] l = [1, 2, 3]
     assume index(l,0) == 1
     assume index(l,1) == 2
diff --git a/tests/valid/Access_Valid_2.whiley b/tests/valid/Access_Valid_2.whiley
index 5a0cff2ae..1c7fb5086 100644
--- a/tests/valid/Access_Valid_2.whiley
+++ b/tests/valid/Access_Valid_2.whiley
@@ -7,7 +7,7 @@ function index(liststr l, int index) -> any
     //
     return l[index]
 
-public export method test() -> void:
+public export method test() :
     int[] l = [1, 2, 3]
     assume index(l, 0) == 1
     assume index(l, 1) == 2
diff --git a/tests/valid/Assume_Valid_1.whiley b/tests/valid/Assume_Valid_1.whiley
index 6c76a889c..cb2644bba 100644
--- a/tests/valid/Assume_Valid_1.whiley
+++ b/tests/valid/Assume_Valid_1.whiley
@@ -9,6 +9,6 @@ function sum(int[] list) -> nat:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     nat rs = sum([0, 1, 2, 3])
     assume rs == 6
diff --git a/tests/valid/Assume_Valid_2.whiley b/tests/valid/Assume_Valid_2.whiley
index 314186a1a..635a5d599 100644
--- a/tests/valid/Assume_Valid_2.whiley
+++ b/tests/valid/Assume_Valid_2.whiley
@@ -1,5 +1,5 @@
 
 
-public export method test() -> void:
+public export method test() :
     assert 1 == 1
 
diff --git a/tests/valid/BoolAssign_Valid_1.whiley b/tests/valid/BoolAssign_Valid_1.whiley
index 78060fd56..7d3f3892e 100644
--- a/tests/valid/BoolAssign_Valid_1.whiley
+++ b/tests/valid/BoolAssign_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     bool x = true
     assert x == true
     x = false
diff --git a/tests/valid/BoolAssign_Valid_2.whiley b/tests/valid/BoolAssign_Valid_2.whiley
index 70d4b2829..12a9f5c95 100644
--- a/tests/valid/BoolAssign_Valid_2.whiley
+++ b/tests/valid/BoolAssign_Valid_2.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     bool x = true
     bool y = false
     assert (x && x) == true
diff --git a/tests/valid/BoolAssign_Valid_3.whiley b/tests/valid/BoolAssign_Valid_3.whiley
index 2d568b94e..5f2d0dd83 100644
--- a/tests/valid/BoolAssign_Valid_3.whiley
+++ b/tests/valid/BoolAssign_Valid_3.whiley
@@ -20,7 +20,7 @@ ensures r > 0:
     else:
         return 1
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 1) == 1
     assume f(0, 0) == 1
     assume f(4, 345) == 349
diff --git a/tests/valid/BoolAssign_Valid_4.whiley b/tests/valid/BoolAssign_Valid_4.whiley
index 3029b83f4..f3d1c3f1e 100644
--- a/tests/valid/BoolAssign_Valid_4.whiley
+++ b/tests/valid/BoolAssign_Valid_4.whiley
@@ -14,7 +14,7 @@ function g(int x, int y) -> int:
     else:
         return 1
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 1) == 1
     assume f(0, 0) == 1
     assume f(4, 345) == 349
diff --git a/tests/valid/BoolAssign_Valid_5.whiley b/tests/valid/BoolAssign_Valid_5.whiley
index 76d492c36..80934e1b6 100644
--- a/tests/valid/BoolAssign_Valid_5.whiley
+++ b/tests/valid/BoolAssign_Valid_5.whiley
@@ -12,7 +12,7 @@ ensures r > 0:
     else:
         return 123
 
-public export method test() -> void:
+public export method test() :
     assume f(1,1) == 123
     assume f(2,1) == 123
     assume f(1,2) == 3
diff --git a/tests/valid/BoolAssign_Valid_6.whiley b/tests/valid/BoolAssign_Valid_6.whiley
index fc6f8ea1e..7b7b5b3b7 100644
--- a/tests/valid/BoolAssign_Valid_6.whiley
+++ b/tests/valid/BoolAssign_Valid_6.whiley
@@ -9,7 +9,7 @@ function f(int x, int y) -> int:
     else:
         return 123
 
-public export method test() -> void:
+public export method test() :
     assume f(1,1) == 123
     assume f(2,1) == 123
     assume f(1,2) == 3
diff --git a/tests/valid/BoolFun_Valid_1.whiley b/tests/valid/BoolFun_Valid_1.whiley
index 8e7b4f836..1502b7542 100644
--- a/tests/valid/BoolFun_Valid_1.whiley
+++ b/tests/valid/BoolFun_Valid_1.whiley
@@ -3,7 +3,7 @@
 function f(bool b) -> bool:
     return b
 
-public export method test() -> void:
+public export method test() :
     bool x = true
     assume f(x)
     x = false
diff --git a/tests/valid/BoolIfElse_Valid_1.whiley b/tests/valid/BoolIfElse_Valid_1.whiley
index f8ed6a5d8..e3c4d0310 100644
--- a/tests/valid/BoolIfElse_Valid_1.whiley
+++ b/tests/valid/BoolIfElse_Valid_1.whiley
@@ -6,6 +6,6 @@ function f(bool b) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f(true)
     assume !f(false)
diff --git a/tests/valid/BoolIfElse_Valid_2.whiley b/tests/valid/BoolIfElse_Valid_2.whiley
index 764a6c3d6..4c4fe1f2f 100644
--- a/tests/valid/BoolIfElse_Valid_2.whiley
+++ b/tests/valid/BoolIfElse_Valid_2.whiley
@@ -6,6 +6,6 @@ function f(bool b) -> int:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(true) == 1
     assume f(false) == 0
diff --git a/tests/valid/BoolList_Valid_1.whiley b/tests/valid/BoolList_Valid_1.whiley
index 749442ddb..0ed7c1efe 100644
--- a/tests/valid/BoolList_Valid_1.whiley
+++ b/tests/valid/BoolList_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     bool[] ls = [true, false, true]
     assert ls == [true, false, true]
     assert ls[0] == true
diff --git a/tests/valid/BoolList_Valid_2.whiley b/tests/valid/BoolList_Valid_2.whiley
index 8f920001b..9e4f20685 100644
--- a/tests/valid/BoolList_Valid_2.whiley
+++ b/tests/valid/BoolList_Valid_2.whiley
@@ -15,7 +15,7 @@ function isAlive(int i, bool[] board) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     bool[] xs = [true, true, true, true, true, true, true]
     assume xs == [true, true, true, true, true, true, true]
     xs = play(xs)
diff --git a/tests/valid/BoolList_Valid_3.whiley b/tests/valid/BoolList_Valid_3.whiley
index 6b527ded8..c3d30cd46 100644
--- a/tests/valid/BoolList_Valid_3.whiley
+++ b/tests/valid/BoolList_Valid_3.whiley
@@ -46,7 +46,7 @@ function isAlive(Board board, int row, int col) -> int:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     bool[][] board = [[false, true, false], [false, true, false], [false, true, false]]
     bool[][] nboard = update(board)
     assume board == [[false, true, false], [false, true, false], [false, true, false]]
diff --git a/tests/valid/BoolRecord_Valid_1.whiley b/tests/valid/BoolRecord_Valid_1.whiley
index 7e03f8684..44817d290 100644
--- a/tests/valid/BoolRecord_Valid_1.whiley
+++ b/tests/valid/BoolRecord_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     {bool flag, int code} x = {flag: true, code: 0}
     assert x == {flag: true, code: 0}
     x.flag = false
diff --git a/tests/valid/BoolRecord_Valid_2.whiley b/tests/valid/BoolRecord_Valid_2.whiley
index 33b0fdc55..09c9511a9 100644
--- a/tests/valid/BoolRecord_Valid_2.whiley
+++ b/tests/valid/BoolRecord_Valid_2.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     {bool flag, int code} x = {flag: true, code: 0}
     if x.flag:
         assert true
diff --git a/tests/valid/BoolRequires_Valid_1.whiley b/tests/valid/BoolRequires_Valid_1.whiley
index e221f3d92..9b28f3eaf 100644
--- a/tests/valid/BoolRequires_Valid_1.whiley
+++ b/tests/valid/BoolRequires_Valid_1.whiley
@@ -4,7 +4,7 @@ function f(bool[] x) -> bool[]
 requires (|x| > 0) && x[0]:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f([true]) == [true]
     assume f([true, false]) == [true, false]
     assume f([true, false, true]) == [true, false, true]
diff --git a/tests/valid/BoolReturn_Valid_1.whiley b/tests/valid/BoolReturn_Valid_1.whiley
index 08d6f73cf..5e7345a2a 100644
--- a/tests/valid/BoolReturn_Valid_1.whiley
+++ b/tests/valid/BoolReturn_Valid_1.whiley
@@ -3,6 +3,6 @@
 function pred() -> bool:
     return false
 
-public export method test() -> void:
+public export method test() :
     assume !pred()
 
diff --git a/tests/valid/Byte_Valid_1.whiley b/tests/valid/Byte_Valid_1.whiley
index 729ad418d..0c9e16bed 100644
--- a/tests/valid/Byte_Valid_1.whiley
+++ b/tests/valid/Byte_Valid_1.whiley
@@ -14,7 +14,7 @@ function inc(byte b) -> byte:
     return b | mask
     
 
-public export method test() -> void:
+public export method test() :
     byte r = 0b
     int i = 0
     while i < |constants|:
diff --git a/tests/valid/Byte_Valid_2.whiley b/tests/valid/Byte_Valid_2.whiley
index 82e937a6d..8a2719b3a 100644
--- a/tests/valid/Byte_Valid_2.whiley
+++ b/tests/valid/Byte_Valid_2.whiley
@@ -18,7 +18,7 @@ function and(byte b1, byte b2) -> byte:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_3.whiley b/tests/valid/Byte_Valid_3.whiley
index 4855dbe16..2d2745305 100644
--- a/tests/valid/Byte_Valid_3.whiley
+++ b/tests/valid/Byte_Valid_3.whiley
@@ -18,7 +18,7 @@ function or(byte b1, byte b2) -> byte:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_4.whiley b/tests/valid/Byte_Valid_4.whiley
index ce6253855..5194af1b0 100644
--- a/tests/valid/Byte_Valid_4.whiley
+++ b/tests/valid/Byte_Valid_4.whiley
@@ -19,7 +19,7 @@ function xor(byte b1, byte b2) -> byte:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_5.whiley b/tests/valid/Byte_Valid_5.whiley
index aa3b7db9d..21bfeda8e 100644
--- a/tests/valid/Byte_Valid_5.whiley
+++ b/tests/valid/Byte_Valid_5.whiley
@@ -8,7 +8,7 @@ function shr(byte b, int i) -> byte:
         i = i - 1
     return b
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_6.whiley b/tests/valid/Byte_Valid_6.whiley
index f39576e24..2015fbff0 100644
--- a/tests/valid/Byte_Valid_6.whiley
+++ b/tests/valid/Byte_Valid_6.whiley
@@ -8,7 +8,7 @@ function shl(byte b, int i) -> byte:
         i = i - 1
     return b
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_7.whiley b/tests/valid/Byte_Valid_7.whiley
index a61b5eb5b..3575b137d 100644
--- a/tests/valid/Byte_Valid_7.whiley
+++ b/tests/valid/Byte_Valid_7.whiley
@@ -18,7 +18,7 @@ function invert(byte b) -> byte:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_8.whiley b/tests/valid/Byte_Valid_8.whiley
index 1e1a28cc2..576a240d3 100644
--- a/tests/valid/Byte_Valid_8.whiley
+++ b/tests/valid/Byte_Valid_8.whiley
@@ -9,7 +9,7 @@ function shr(byte b, int i) -> byte:
         i = i - 1
     return b
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Byte_Valid_9.whiley b/tests/valid/Byte_Valid_9.whiley
index b21ba903b..eb750f7ae 100644
--- a/tests/valid/Byte_Valid_9.whiley
+++ b/tests/valid/Byte_Valid_9.whiley
@@ -24,7 +24,7 @@ function and(byte b1, byte b2) -> byte:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < |constants| where i >= 0:
         byte constant_i = constants[i]
diff --git a/tests/valid/Cast_Valid_1.whiley b/tests/valid/Cast_Valid_1.whiley
index 954370e7d..716d009fa 100644
--- a/tests/valid/Cast_Valid_1.whiley
+++ b/tests/valid/Cast_Valid_1.whiley
@@ -3,5 +3,5 @@
 function f(int i) -> real:
     return (real) i
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1.0
diff --git a/tests/valid/Cast_Valid_2.whiley b/tests/valid/Cast_Valid_2.whiley
index 643bf8f95..4d660f14d 100644
--- a/tests/valid/Cast_Valid_2.whiley
+++ b/tests/valid/Cast_Valid_2.whiley
@@ -3,5 +3,5 @@
 function f(int[] xs) -> real[]:
     return (real[]) xs
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3]) == [1.0, 2.0, 3.0]
diff --git a/tests/valid/Cast_Valid_3.whiley b/tests/valid/Cast_Valid_3.whiley
index 2d7a3265a..c17c64747 100644
--- a/tests/valid/Cast_Valid_3.whiley
+++ b/tests/valid/Cast_Valid_3.whiley
@@ -7,5 +7,5 @@ type R2 is {int x}
 function f(R2 i) -> R1:
     return (R1) i
 
-public export method test() -> void:
+public export method test() :
     assume f({x: 123542}) == {x: 123542.0}
diff --git a/tests/valid/Cast_Valid_4.whiley b/tests/valid/Cast_Valid_4.whiley
index fd55176f8..88cbeed45 100644
--- a/tests/valid/Cast_Valid_4.whiley
+++ b/tests/valid/Cast_Valid_4.whiley
@@ -9,5 +9,5 @@ type R3 is {int y, int x}
 function f(R3 i) -> R1 | R2:
     return (R1) i
 
-public export method test() -> void:
+public export method test() :
     assume f({y: 123, x: 123542}) == {y: 123, x: 123542.0}
diff --git a/tests/valid/Cast_Valid_5.whiley b/tests/valid/Cast_Valid_5.whiley
index b70fa286c..6165bcceb 100644
--- a/tests/valid/Cast_Valid_5.whiley
+++ b/tests/valid/Cast_Valid_5.whiley
@@ -41,7 +41,7 @@ public function toUnsignedByte(u8 v) -> byte:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int i = 32
     while i < 127 where i >= 0:
         int c = toUnsignedInt(toUnsignedByte(i))
diff --git a/tests/valid/Coercion_Valid_1.whiley b/tests/valid/Coercion_Valid_1.whiley
index ac44a3b67..1ac8ed952 100644
--- a/tests/valid/Coercion_Valid_1.whiley
+++ b/tests/valid/Coercion_Valid_1.whiley
@@ -3,5 +3,5 @@
 function f(int x) -> real:
     return (real) x
 
-public export method test() -> void:
+public export method test() :
     assume f(123) == 123.0
diff --git a/tests/valid/Coercion_Valid_2.whiley b/tests/valid/Coercion_Valid_2.whiley
index 8979783bb..b97a7d185 100644
--- a/tests/valid/Coercion_Valid_2.whiley
+++ b/tests/valid/Coercion_Valid_2.whiley
@@ -3,5 +3,5 @@
 function f(int[] x) -> int[]:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f("Hello World") == [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
diff --git a/tests/valid/Coercion_Valid_3.whiley b/tests/valid/Coercion_Valid_3.whiley
index d9493fb44..ab5135d8e 100644
--- a/tests/valid/Coercion_Valid_3.whiley
+++ b/tests/valid/Coercion_Valid_3.whiley
@@ -3,5 +3,5 @@
 function f(int x) -> int:
     return (int) x
 
-public export method test() -> void:
+public export method test() :
     assume f('H') == 72
diff --git a/tests/valid/Coercion_Valid_7.whiley b/tests/valid/Coercion_Valid_7.whiley
index dc3370c37..0e1332e83 100644
--- a/tests/valid/Coercion_Valid_7.whiley
+++ b/tests/valid/Coercion_Valid_7.whiley
@@ -6,6 +6,6 @@ function f(int | bool x) -> int:
     else:
         return 1
 
-public export method test() -> void:
+public export method test() :
     assume f(true) == 1
     assume f(123) == 123
diff --git a/tests/valid/Coercion_Valid_8.whiley b/tests/valid/Coercion_Valid_8.whiley
index d34d74a14..344a6020d 100644
--- a/tests/valid/Coercion_Valid_8.whiley
+++ b/tests/valid/Coercion_Valid_8.whiley
@@ -8,6 +8,6 @@ function f(Expr x) -> real:
     else:
         return x
 
-public export method test() -> void:
+public export method test() :
     assume f([1.0, 2.0, 3.0]) == 3.0
     assume f(1.234) == 1.234
diff --git a/tests/valid/Complex_Valid_1.whiley b/tests/valid/Complex_Valid_1.whiley
index c2eb0e620..2a34724f9 100644
--- a/tests/valid/Complex_Valid_1.whiley
+++ b/tests/valid/Complex_Valid_1.whiley
@@ -78,6 +78,6 @@ constant H1 is {col: 8, row: 1}
 constant A3 is {col: 1, row: 3}
 constant D3 is {col: 4, row: 3}
 
-public export method test() -> void:
+public export method test() :
     assume clearRowExcept(A1, H1, startingChessBoard) == false
     assume clearRowExcept(A3, D3, startingChessBoard) == true
diff --git a/tests/valid/Complex_Valid_2.whiley b/tests/valid/Complex_Valid_2.whiley
index 8353a0851..12e39773b 100644
--- a/tests/valid/Complex_Valid_2.whiley
+++ b/tests/valid/Complex_Valid_2.whiley
@@ -120,7 +120,7 @@ function piece2str(Piece p) -> string:
 function pos2str(Pos p) -> string:
     return ['a' + p.col,'1' + p.row]
 
-public export method test() -> void:
+public export method test() :
     Move m = {to: A1, from: A2, piece: WHITE_PAWN}
     assume move2str(m) == "a2-a1"
     m = {to: A1, from: A2, piece: WHITE_KNIGHT}
diff --git a/tests/valid/Complex_Valid_3.whiley b/tests/valid/Complex_Valid_3.whiley
index a8f509da6..e2a2cf5e0 100644
--- a/tests/valid/Complex_Valid_3.whiley
+++ b/tests/valid/Complex_Valid_3.whiley
@@ -35,7 +35,7 @@ function contains(BTree tree, int item) -> bool:
             else:
                 return contains(tree.right, item)
 
-public export method test() -> void:
+public export method test() :
     BTree tree = BTree()
     tree = add(tree, 1)
     tree = add(tree, 2)
diff --git a/tests/valid/Complex_Valid_4.whiley b/tests/valid/Complex_Valid_4.whiley
index 2efd97ab2..3de7f30f7 100644
--- a/tests/valid/Complex_Valid_4.whiley
+++ b/tests/valid/Complex_Valid_4.whiley
@@ -29,7 +29,7 @@ function contains(BTree tree, int item) -> bool:
 
 constant items is [5, 4, 6, 3, 7, 2, 8, 1, 9]
 
-public export method test() -> void:
+public export method test() :
     BTree tree = BTree()
     tree = add(tree, 1)
     tree = add(tree, 2)
diff --git a/tests/valid/Complex_Valid_5.whiley b/tests/valid/Complex_Valid_5.whiley
index 3d9a9789c..bea38aa89 100644
--- a/tests/valid/Complex_Valid_5.whiley
+++ b/tests/valid/Complex_Valid_5.whiley
@@ -18,7 +18,7 @@ requires pos < 9:
     b.pieces[pos] = p
     return b
 
-public export method test() -> void:
+public export method test() :
     Board b = EmptyBoard()
     b = play(b, CIRCLE, 0)
     assume b == {move:0,pieces:[1, 0, 0, 0, 0, 0, 0, 0, 0]}
diff --git a/tests/valid/Complex_Valid_6.whiley b/tests/valid/Complex_Valid_6.whiley
index fbb64b97a..db6952b90 100644
--- a/tests/valid/Complex_Valid_6.whiley
+++ b/tests/valid/Complex_Valid_6.whiley
@@ -22,7 +22,7 @@ ensures r == max(a - b, b - a):
     //
     return diff
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < 20:
         int j = 0
diff --git a/tests/valid/Constant_Valid_3.whiley b/tests/valid/Constant_Valid_3.whiley
index 105e84c56..144ad8001 100644
--- a/tests/valid/Constant_Valid_3.whiley
+++ b/tests/valid/Constant_Valid_3.whiley
@@ -2,5 +2,5 @@
 
 constant ITEMS is [-1, 2, 3]
 
-public export method test() -> void:
+public export method test() :
     assert ITEMS == [-1,2,3]
diff --git a/tests/valid/ConstrainedInt_Valid_1.whiley b/tests/valid/ConstrainedInt_Valid_1.whiley
index d1b0923c9..be0f3ffef 100644
--- a/tests/valid/ConstrainedInt_Valid_1.whiley
+++ b/tests/valid/ConstrainedInt_Valid_1.whiley
@@ -6,5 +6,5 @@ function f(cr1nat x) -> int:
     int y = x
     return y
 
-public export method test() -> void:
+public export method test() :
     assume f(9) == 9
diff --git a/tests/valid/ConstrainedInt_Valid_10.whiley b/tests/valid/ConstrainedInt_Valid_10.whiley
index e04d39fec..00077b339 100644
--- a/tests/valid/ConstrainedInt_Valid_10.whiley
+++ b/tests/valid/ConstrainedInt_Valid_10.whiley
@@ -12,5 +12,5 @@ function g(int x, nat z) -> int
 requires ((x == 1) || (x == 2)) && (z == 1 || z == 2 || z == 3 || z == x):
     return f(z)
 
-public export method test() -> void:
+public export method test() :
     assume g(1, 3) == 3
diff --git a/tests/valid/ConstrainedInt_Valid_12.whiley b/tests/valid/ConstrainedInt_Valid_12.whiley
index 6bf726d3a..8e09f59c8 100644
--- a/tests/valid/ConstrainedInt_Valid_12.whiley
+++ b/tests/valid/ConstrainedInt_Valid_12.whiley
@@ -6,5 +6,5 @@ function f(cr1nat x) -> int:
     int y = x
     return y
 
-public export method test() -> void:
+public export method test() :
     assume f(9) == 9
diff --git a/tests/valid/ConstrainedInt_Valid_13.whiley b/tests/valid/ConstrainedInt_Valid_13.whiley
index b78a27ac3..07173f05d 100644
--- a/tests/valid/ConstrainedInt_Valid_13.whiley
+++ b/tests/valid/ConstrainedInt_Valid_13.whiley
@@ -6,5 +6,5 @@ function f(code x) -> int:
     int y = x.op
     return y
 
-public export method test() -> void:
+public export method test() :
     assume f({op: 1, payload: [1]}) == 1
diff --git a/tests/valid/ConstrainedInt_Valid_15.whiley b/tests/valid/ConstrainedInt_Valid_15.whiley
index 0781025ea..a4a3273f3 100644
--- a/tests/valid/ConstrainedInt_Valid_15.whiley
+++ b/tests/valid/ConstrainedInt_Valid_15.whiley
@@ -12,7 +12,7 @@ function isPosNeg(any v) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume isPosNeg(1)
     assume !isPosNeg(0)
     assume isPosNeg(-1)
diff --git a/tests/valid/ConstrainedInt_Valid_16.whiley b/tests/valid/ConstrainedInt_Valid_16.whiley
index ad296611c..e30e4d891 100644
--- a/tests/valid/ConstrainedInt_Valid_16.whiley
+++ b/tests/valid/ConstrainedInt_Valid_16.whiley
@@ -10,7 +10,7 @@ function f(oddeven x) -> even:
         return 2
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 1
     y = f(1)
     assume y == 2
diff --git a/tests/valid/ConstrainedInt_Valid_17.whiley b/tests/valid/ConstrainedInt_Valid_17.whiley
index 432d74788..04333d491 100644
--- a/tests/valid/ConstrainedInt_Valid_17.whiley
+++ b/tests/valid/ConstrainedInt_Valid_17.whiley
@@ -10,7 +10,7 @@ function atob(anat x) -> bnat:
 function btoa(bnat x) -> anat:
     return x
 
-public export method test() -> void:
+public export method test() :
     int x = 1
     assume atob(x) == 1
     assume btoa(x) == 1
diff --git a/tests/valid/ConstrainedInt_Valid_18.whiley b/tests/valid/ConstrainedInt_Valid_18.whiley
index 64bb89957..dfeda9ee3 100644
--- a/tests/valid/ConstrainedInt_Valid_18.whiley
+++ b/tests/valid/ConstrainedInt_Valid_18.whiley
@@ -10,7 +10,7 @@ function atob(anat x) -> bnat:
 function btoa(bnat x) -> anat:
     return x
 
-public export method test() -> void:
+public export method test() :
     int x = 1
     assume atob(x) == 1
     assume btoa(x) == 1
diff --git a/tests/valid/ConstrainedInt_Valid_19.whiley b/tests/valid/ConstrainedInt_Valid_19.whiley
index 131a743a3..33001b044 100644
--- a/tests/valid/ConstrainedInt_Valid_19.whiley
+++ b/tests/valid/ConstrainedInt_Valid_19.whiley
@@ -10,7 +10,7 @@ function f(a_nat x) -> b_nat:
     else:
         return f(x - 1)
 
-public export method test() -> void:
+public export method test() :
     int x = 0
     x = f(x)
     assume x == 1
diff --git a/tests/valid/ConstrainedInt_Valid_2.whiley b/tests/valid/ConstrainedInt_Valid_2.whiley
index 9878e3aae..213b9c013 100644
--- a/tests/valid/ConstrainedInt_Valid_2.whiley
+++ b/tests/valid/ConstrainedInt_Valid_2.whiley
@@ -5,6 +5,6 @@ type cr3nat is (int x) where x < 10
 function f(cr3nat x) -> cr3nat:
     return 1
 
-public export method test() -> void:
+public export method test() :
     int y = f(9)
     assume y == 1
diff --git a/tests/valid/ConstrainedInt_Valid_20.whiley b/tests/valid/ConstrainedInt_Valid_20.whiley
index 422016814..86ce032b4 100644
--- a/tests/valid/ConstrainedInt_Valid_20.whiley
+++ b/tests/valid/ConstrainedInt_Valid_20.whiley
@@ -10,7 +10,7 @@ function f(a_nat x) -> b_nat:
     else:
         return f(x - 1)
 
-public export method test() -> void:
+public export method test() :
     int x = 0
     x = f(x)
     assume x == 1
diff --git a/tests/valid/ConstrainedInt_Valid_21.whiley b/tests/valid/ConstrainedInt_Valid_21.whiley
index c06c61330..812f416dd 100644
--- a/tests/valid/ConstrainedInt_Valid_21.whiley
+++ b/tests/valid/ConstrainedInt_Valid_21.whiley
@@ -6,5 +6,5 @@ ensures r != 1:
     //
     return x + 1
 
-public export method test() -> void:
+public export method test() :
     assume f(9) == 10
diff --git a/tests/valid/ConstrainedInt_Valid_22.whiley b/tests/valid/ConstrainedInt_Valid_22.whiley
index 32e6b7139..b269af976 100644
--- a/tests/valid/ConstrainedInt_Valid_22.whiley
+++ b/tests/valid/ConstrainedInt_Valid_22.whiley
@@ -13,7 +13,7 @@ method get(item day, int count) -> int[]:
     else:
         return Days[day]
 
-public export method test() -> void:
+public export method test() :
     assume get(0, 0) == "Monday"
     assume get(0, 1) == "Tuesday"
     assume get(0, 2) == "Wednesday"
diff --git a/tests/valid/ConstrainedInt_Valid_23.whiley b/tests/valid/ConstrainedInt_Valid_23.whiley
index 2136ff07c..4f35682ba 100644
--- a/tests/valid/ConstrainedInt_Valid_23.whiley
+++ b/tests/valid/ConstrainedInt_Valid_23.whiley
@@ -4,5 +4,5 @@ function f(cr2num x) -> int:
     int y = x
     return y
 
-public export method test() -> void:
+public export method test() :
     assume f(3) == 3
diff --git a/tests/valid/ConstrainedInt_Valid_3.whiley b/tests/valid/ConstrainedInt_Valid_3.whiley
index 387d36f32..318bf4009 100644
--- a/tests/valid/ConstrainedInt_Valid_3.whiley
+++ b/tests/valid/ConstrainedInt_Valid_3.whiley
@@ -5,6 +5,6 @@ type cr3nat is int
 function f(cr3nat x) -> cr3nat:
     return 1
 
-public export method test() -> void:
+public export method test() :
     int y = f(9)
     assume y == 1
diff --git a/tests/valid/ConstrainedInt_Valid_4.whiley b/tests/valid/ConstrainedInt_Valid_4.whiley
index d3ffed40d..1ca936021 100644
--- a/tests/valid/ConstrainedInt_Valid_4.whiley
+++ b/tests/valid/ConstrainedInt_Valid_4.whiley
@@ -5,5 +5,5 @@ type nat is (int x) where x < 10
 function f() -> nat:
     return 1
 
-public export method test() -> void:
+public export method test() :
     assume f() == 1
diff --git a/tests/valid/ConstrainedInt_Valid_5.whiley b/tests/valid/ConstrainedInt_Valid_5.whiley
index 737ece82e..806258ff3 100644
--- a/tests/valid/ConstrainedInt_Valid_5.whiley
+++ b/tests/valid/ConstrainedInt_Valid_5.whiley
@@ -5,5 +5,5 @@ type nat is int
 function f() -> nat:
     return 1
 
-public export method test() -> void:
+public export method test() :
     assume f() == 1
diff --git a/tests/valid/ConstrainedInt_Valid_6.whiley b/tests/valid/ConstrainedInt_Valid_6.whiley
index a349218fe..7aa977042 100644
--- a/tests/valid/ConstrainedInt_Valid_6.whiley
+++ b/tests/valid/ConstrainedInt_Valid_6.whiley
@@ -10,5 +10,5 @@ function g(int x, int z) -> int
 requires (x == 1 || x == 2) && (z == 1 || z == 2 || z == 3 || z == x):
     return f(z)
 
-public export method test() -> void:
+public export method test() :
     assume g(1, 2) == 2
diff --git a/tests/valid/ConstrainedInt_Valid_8.whiley b/tests/valid/ConstrainedInt_Valid_8.whiley
index ce5ed61f4..472a0c292 100644
--- a/tests/valid/ConstrainedInt_Valid_8.whiley
+++ b/tests/valid/ConstrainedInt_Valid_8.whiley
@@ -22,5 +22,5 @@ function g(bignum[] zs, int z) -> int:
     else:
         return -1
 
-public export method test() -> void:
+public export method test() :
     assume g([1, 2, 3, 5], 3) == 3
diff --git a/tests/valid/ConstrainedList_Valid_1.whiley b/tests/valid/ConstrainedList_Valid_1.whiley
index c0d097dab..73ee5d08c 100644
--- a/tests/valid/ConstrainedList_Valid_1.whiley
+++ b/tests/valid/ConstrainedList_Valid_1.whiley
@@ -4,6 +4,6 @@ function f(int x) -> u8[]
 requires x == 0 || x == 169:
     return [x]
 
-public export method test() -> void:
+public export method test() :
     u8[] bytes = f(0)
     assume bytes == [0]
diff --git a/tests/valid/ConstrainedList_Valid_11.whiley b/tests/valid/ConstrainedList_Valid_11.whiley
index 815e1937a..308285eec 100644
--- a/tests/valid/ConstrainedList_Valid_11.whiley
+++ b/tests/valid/ConstrainedList_Valid_11.whiley
@@ -13,5 +13,5 @@ function f(state st) -> int:
             return st.input[st.pos]
     return ' '
 
-public export method test() -> void:
+public export method test() :
     assume f({input: "hello", pos: 0}) == 104
diff --git a/tests/valid/ConstrainedList_Valid_12.whiley b/tests/valid/ConstrainedList_Valid_12.whiley
index 0eb56b0b1..826111441 100644
--- a/tests/valid/ConstrainedList_Valid_12.whiley
+++ b/tests/valid/ConstrainedList_Valid_12.whiley
@@ -3,5 +3,5 @@
 function f(int x) -> int[]:
     return [x]
 
-public export method test() -> void:
+public export method test() :
     assume f(0) == [0]
diff --git a/tests/valid/ConstrainedList_Valid_14.whiley b/tests/valid/ConstrainedList_Valid_14.whiley
index 3d030d6f7..ef7b8cf71 100644
--- a/tests/valid/ConstrainedList_Valid_14.whiley
+++ b/tests/valid/ConstrainedList_Valid_14.whiley
@@ -7,5 +7,5 @@ requires |xs| > 0:
     xs[0] = 1
     return xs
 
-public export method test() -> void:
+public export method test() :
     assume f([-1, -2]) == [1,-2]
diff --git a/tests/valid/ConstrainedList_Valid_15.whiley b/tests/valid/ConstrainedList_Valid_15.whiley
index d86a8b724..0eeb067cd 100644
--- a/tests/valid/ConstrainedList_Valid_15.whiley
+++ b/tests/valid/ConstrainedList_Valid_15.whiley
@@ -3,5 +3,5 @@
 function f() -> int[]:
     return ""
 
-public export method test() -> void:
+public export method test() :
     assume f() == ""
diff --git a/tests/valid/ConstrainedList_Valid_16.whiley b/tests/valid/ConstrainedList_Valid_16.whiley
index 79022588a..705661129 100644
--- a/tests/valid/ConstrainedList_Valid_16.whiley
+++ b/tests/valid/ConstrainedList_Valid_16.whiley
@@ -6,6 +6,6 @@ function f(int[] xs) -> nat[]
 requires |xs| == 0:
     return xs
 
-public export method test() -> void:
+public export method test() :
     nat[] rs = f([0;0])
     assume rs == [0;0]
diff --git a/tests/valid/ConstrainedList_Valid_17.whiley b/tests/valid/ConstrainedList_Valid_17.whiley
index 1fa931b6d..7719535b5 100644
--- a/tests/valid/ConstrainedList_Valid_17.whiley
+++ b/tests/valid/ConstrainedList_Valid_17.whiley
@@ -6,6 +6,6 @@ function f(nat[][] xs) -> nat[]
 requires |xs| > 0:
     return xs[0]
 
-public export method test() -> void:
+public export method test() :
     nat[] rs = f([[1, 2, 3], [4, 5, 6]])
     assume rs == [1,2,3]
diff --git a/tests/valid/ConstrainedList_Valid_18.whiley b/tests/valid/ConstrainedList_Valid_18.whiley
index 28b9cbf23..1a5da17ec 100644
--- a/tests/valid/ConstrainedList_Valid_18.whiley
+++ b/tests/valid/ConstrainedList_Valid_18.whiley
@@ -8,6 +8,6 @@ ensures some { i in 0..|rs| | rs[i] >= 0 }:
     //
     return xs
 
-public export method test() -> void:
+public export method test() :
     int[] rs = f([1, 2, 3])
     assume rs == [1,2,3]
diff --git a/tests/valid/ConstrainedList_Valid_19.whiley b/tests/valid/ConstrainedList_Valid_19.whiley
index d5fcfb498..5df87fa50 100644
--- a/tests/valid/ConstrainedList_Valid_19.whiley
+++ b/tests/valid/ConstrainedList_Valid_19.whiley
@@ -8,6 +8,6 @@ function g(nat[] xs) -> nat[]:
 function f(nat[] xs) -> nat[]:
     return g(xs)
 
-public export method test() -> void:
+public export method test() :
     nat[] rs = f([1, 2, 3])
     assume rs == [1,2,3]
diff --git a/tests/valid/ConstrainedList_Valid_2.whiley b/tests/valid/ConstrainedList_Valid_2.whiley
index f78af35a6..f1c80e078 100644
--- a/tests/valid/ConstrainedList_Valid_2.whiley
+++ b/tests/valid/ConstrainedList_Valid_2.whiley
@@ -18,7 +18,7 @@ function abs(int x) -> nat:
     else:
         return -x
 
-public export method test() -> void:
+public export method test() :
     nat[] xs = [1, -3, -5, 7, -9, 11]
     xs = abs(xs)
     assume xs == [1,3,5,7,9,11]
diff --git a/tests/valid/ConstrainedList_Valid_20.whiley b/tests/valid/ConstrainedList_Valid_20.whiley
index da8a1b348..cee0555c2 100644
--- a/tests/valid/ConstrainedList_Valid_20.whiley
+++ b/tests/valid/ConstrainedList_Valid_20.whiley
@@ -11,7 +11,7 @@ ensures r >= 0:
     else:
         return ls[i]
 
-public export method test() -> void:
+public export method test() :
     int[] xs = [1, 3, 5, 7, 9, 11]
     assume get(xs, 0) == 1
     assume get(xs, 1) == 3
diff --git a/tests/valid/ConstrainedList_Valid_21.whiley b/tests/valid/ConstrainedList_Valid_21.whiley
index 1981c14fa..8b7566524 100644
--- a/tests/valid/ConstrainedList_Valid_21.whiley
+++ b/tests/valid/ConstrainedList_Valid_21.whiley
@@ -34,7 +34,7 @@ requires no { i in 0..|coins| | coins[i] >= |Value| }:
         i = i + 1
     return cash
 
-public export method test() -> void:
+public export method test() :
     Cash cash = Cash([ONE_DOLLAR, FIVE_CENTS])
     assume cash == [0, 1, 0, 0, 0, 1, 0, 0]
     cash = Cash([FIVE_DOLLARS, TEN_CENTS, FIFTY_CENTS])
diff --git a/tests/valid/ConstrainedList_Valid_22.whiley b/tests/valid/ConstrainedList_Valid_22.whiley
index 6e5a3a4b4..18d0498bb 100644
--- a/tests/valid/ConstrainedList_Valid_22.whiley
+++ b/tests/valid/ConstrainedList_Valid_22.whiley
@@ -15,7 +15,7 @@ function inc(nat[] xs) -> nat[]:
     assert no { k in 0..|xs| | xs[k] < 0 }
     return xs
 
-public export method test() -> void:
+public export method test() :
     assume inc([0]) == [1]
     assume inc([1, 2, 3]) == [2,3,4]
     assume inc([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
diff --git a/tests/valid/ConstrainedList_Valid_23.whiley b/tests/valid/ConstrainedList_Valid_23.whiley
index e49395a40..9ec985224 100644
--- a/tests/valid/ConstrainedList_Valid_23.whiley
+++ b/tests/valid/ConstrainedList_Valid_23.whiley
@@ -24,7 +24,7 @@ requires (|A| > 0) && ((|B| > 0) && (|B| == |A[0]|)):
         i = i + 1
     return C
 
-public export method test() -> void:
+public export method test() :
     Matrix m1 = [[1, 2], [3, 4]]
     Matrix m2 = [[5, 6], [7, 8]]
     Matrix m3 = run(m1, m2)
diff --git a/tests/valid/ConstrainedList_Valid_25.whiley b/tests/valid/ConstrainedList_Valid_25.whiley
index a21b238ab..d5158156b 100644
--- a/tests/valid/ConstrainedList_Valid_25.whiley
+++ b/tests/valid/ConstrainedList_Valid_25.whiley
@@ -5,7 +5,7 @@ requires all { i in 0..|list| | list[i] >= 0 }
 requires index >= 0 && index < |list|:
     return list[index]
 
-public export method test() -> void:
+public export method test() :
     int[] items = [5, 4, 6, 3, 7, 2, 8, 1]
     int i = 0
     while i < |items|:
diff --git a/tests/valid/ConstrainedList_Valid_26.whiley b/tests/valid/ConstrainedList_Valid_26.whiley
index 4fc2e2dec..f5e14b9be 100644
--- a/tests/valid/ConstrainedList_Valid_26.whiley
+++ b/tests/valid/ConstrainedList_Valid_26.whiley
@@ -8,7 +8,7 @@ ensures r == [0;0]:
     else:
         return [0;0]
 
-public export method test() -> void:
+public export method test() :
     int[] items = [5, 4, 6, 3, 7, 2, 8, 1]
     assume f(items) == [0;0]
     assume f([0;0]) == [0;0]
diff --git a/tests/valid/ConstrainedList_Valid_28.whiley b/tests/valid/ConstrainedList_Valid_28.whiley
index c39980755..739b6f176 100644
--- a/tests/valid/ConstrainedList_Valid_28.whiley
+++ b/tests/valid/ConstrainedList_Valid_28.whiley
@@ -33,4 +33,4 @@ public export method test():
     assume lastIndexOf(arr,-1,0) == -1
 
 
-        
\ No newline at end of file
+        
diff --git a/tests/valid/ConstrainedList_Valid_3.whiley b/tests/valid/ConstrainedList_Valid_3.whiley
index ed95702f0..7606bcd43 100644
--- a/tests/valid/ConstrainedList_Valid_3.whiley
+++ b/tests/valid/ConstrainedList_Valid_3.whiley
@@ -16,7 +16,7 @@ ensures all { i in 0..|result| | result[i] == value }:
     //
     return data
 
-public export method test() -> void:
+public export method test() :
     assume init(0,0) == [0;0]
     assume init(1,1) == [1]
     assume init(2,2) == [2,2]
diff --git a/tests/valid/ConstrainedList_Valid_4.whiley b/tests/valid/ConstrainedList_Valid_4.whiley
index d06eb2402..3a4b94517 100644
--- a/tests/valid/ConstrainedList_Valid_4.whiley
+++ b/tests/valid/ConstrainedList_Valid_4.whiley
@@ -7,6 +7,6 @@ ensures (r > 0) && (r < 125):
 function f(int x) -> i8[]:
     return [g(x)]
 
-public export method test() -> void:
+public export method test() :
     int[] bytes = f(0)
     assume bytes == [1]
diff --git a/tests/valid/ConstrainedList_Valid_5.whiley b/tests/valid/ConstrainedList_Valid_5.whiley
index 1daf7f13a..033c670c9 100644
--- a/tests/valid/ConstrainedList_Valid_5.whiley
+++ b/tests/valid/ConstrainedList_Valid_5.whiley
@@ -9,6 +9,6 @@ function g(int x) -> int:
 function f(int x) -> int[]:
     return [g(x)]
 
-public export method test() -> void:
+public export method test() :
     int[] bytes = f(0)
     assume bytes == [1]
diff --git a/tests/valid/ConstrainedList_Valid_6.whiley b/tests/valid/ConstrainedList_Valid_6.whiley
index d669fb5ff..105027f68 100644
--- a/tests/valid/ConstrainedList_Valid_6.whiley
+++ b/tests/valid/ConstrainedList_Valid_6.whiley
@@ -35,7 +35,7 @@ requires all { i in 0..|coins| | coins[i] < |Value| }:
         i = i + 1
     return cash
 
-public export method test() -> void:
+public export method test() :
     assume Cash([ONE_DOLLAR, FIVE_CENTS]) == [0, 1, 0, 0, 0, 1, 0, 0]
     assume Cash([FIVE_DOLLARS, TEN_CENTS, FIFTY_CENTS]) == [0, 0, 1, 0, 1, 0, 1, 0]
     assume Cash([ONE_DOLLAR, ONE_DOLLAR, TWENTY_CENTS]) == [0, 0, 0, 1, 0, 2, 0, 0]
diff --git a/tests/valid/ConstrainedList_Valid_7.whiley b/tests/valid/ConstrainedList_Valid_7.whiley
index 39cf51247..ce8a93038 100644
--- a/tests/valid/ConstrainedList_Valid_7.whiley
+++ b/tests/valid/ConstrainedList_Valid_7.whiley
@@ -10,7 +10,7 @@ requires x[0] == 0:
     assert |x| > 0
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f([0, 1, 2]) == [0,1,2]
     assume g([0]) == [0]
     assume g([0, 1, 2]) == [0,1,2]
diff --git a/tests/valid/ConstrainedList_Valid_8.whiley b/tests/valid/ConstrainedList_Valid_8.whiley
index b2e44c09a..9996064a2 100644
--- a/tests/valid/ConstrainedList_Valid_8.whiley
+++ b/tests/valid/ConstrainedList_Valid_8.whiley
@@ -7,7 +7,7 @@ requires index < |list|:
     list[index] = value
     return list
 
-public export method test() -> void:
+public export method test() :
     nat[] xs = [1, 2, 3, 4]
     xs = update(xs, 0, 2)
     xs = update(xs, 1, 3)
diff --git a/tests/valid/ConstrainedList_Valid_9.whiley b/tests/valid/ConstrainedList_Valid_9.whiley
index dbe828fbe..d10e33c68 100644
--- a/tests/valid/ConstrainedList_Valid_9.whiley
+++ b/tests/valid/ConstrainedList_Valid_9.whiley
@@ -18,5 +18,5 @@ ensures r >= 0:
     //
     return sum(ls, 0)
 
-public export method test() -> void:
+public export method test() :
     assume sum([1, 2, 3, 4, 5, 6, 7]) == 28
diff --git a/tests/valid/ConstrainedNegation_Valid_1.whiley b/tests/valid/ConstrainedNegation_Valid_1.whiley
index 08f234c63..d12db6682 100644
--- a/tests/valid/ConstrainedNegation_Valid_1.whiley
+++ b/tests/valid/ConstrainedNegation_Valid_1.whiley
@@ -9,6 +9,6 @@ ensures y < 0:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(-1) == -1
     assume f(-2) == -2
diff --git a/tests/valid/ConstrainedRecord_Valid_1.whiley b/tests/valid/ConstrainedRecord_Valid_1.whiley
index 5b3dd3aa7..d34fd6fa4 100644
--- a/tests/valid/ConstrainedRecord_Valid_1.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_1.whiley
@@ -11,6 +11,6 @@ type UNIT is {unitCode op}
 function f(UNIT x) -> int[]:
     return [x.op]
 
-public export method test() -> void:
+public export method test() :
     int[] bytes = f({op: NOP})
     assume bytes == [NOP]
diff --git a/tests/valid/ConstrainedRecord_Valid_2.whiley b/tests/valid/ConstrainedRecord_Valid_2.whiley
index cbc3676c6..7037293e8 100644
--- a/tests/valid/ConstrainedRecord_Valid_2.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_2.whiley
@@ -11,6 +11,6 @@ type UNIT is {unitCode op}
 function f(UNIT x) -> int:
     return x.op
 
-public export method test() -> void:
+public export method test() :
     int bytes = f({op: NOP})
     assume bytes == NOP
diff --git a/tests/valid/ConstrainedRecord_Valid_3.whiley b/tests/valid/ConstrainedRecord_Valid_3.whiley
index 099e43a65..10d25a5de 100644
--- a/tests/valid/ConstrainedRecord_Valid_3.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_3.whiley
@@ -5,5 +5,5 @@ type btup is {int index, int op}
 function f(btup b) -> int[]:
     return [b.op, b.index]
 
-public export method test() -> void:
+public export method test() :
     assume f({index: 2, op: 1}) == [1,2]
diff --git a/tests/valid/ConstrainedRecord_Valid_4.whiley b/tests/valid/ConstrainedRecord_Valid_4.whiley
index 923784460..ecbeb2a61 100644
--- a/tests/valid/ConstrainedRecord_Valid_4.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_4.whiley
@@ -5,7 +5,7 @@ type point is ({
     int y
 } p) where p.x > 0 && p.y > 0
 
-public export method test() -> void:
+public export method test() :
     point p = {y: 1, x: 1}
     assert p.y == 1
     assert p.x == 1
diff --git a/tests/valid/ConstrainedRecord_Valid_5.whiley b/tests/valid/ConstrainedRecord_Valid_5.whiley
index 5796b6607..28c09735b 100644
--- a/tests/valid/ConstrainedRecord_Valid_5.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_5.whiley
@@ -2,7 +2,7 @@
 
 type point is {int y, int x}
 
-public export method test() -> void:
+public export method test() :
     point p = {y: 1, x: 1}
     assert p.y == 1
     assert p.x == 1
diff --git a/tests/valid/ConstrainedRecord_Valid_6.whiley b/tests/valid/ConstrainedRecord_Valid_6.whiley
index b9c970385..23cd746de 100644
--- a/tests/valid/ConstrainedRecord_Valid_6.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_6.whiley
@@ -12,6 +12,6 @@ function parseTerm(state st) -> state:
     st = parseWhiteSpace(st)
     return st
 
-public export method test() -> void:
+public export method test() :
     state st = {input: "  Hello", pos: 0}
     assume parseTerm(st) == {input:[32, 32, 72, 101, 108, 108, 111],pos:2}
diff --git a/tests/valid/ConstrainedRecord_Valid_8.whiley b/tests/valid/ConstrainedRecord_Valid_8.whiley
index 299cc961c..134459cb5 100644
--- a/tests/valid/ConstrainedRecord_Valid_8.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_8.whiley
@@ -13,7 +13,7 @@ type EmptyBoard is (Board b) where no { i in 0..|b.pieces| | b.pieces[i] != BLAN
 function EmptyBoard() -> EmptyBoard:
     return {pieces: [BLANK, BLANK, BLANK, BLANK, BLANK, BLANK, BLANK, BLANK, BLANK], move: 0}
 
-public export method test() -> void:
+public export method test() :
     Board b = EmptyBoard()
     assert b.pieces[0] == BLANK
     assert b.pieces[1] == BLANK
diff --git a/tests/valid/ConstrainedRecord_Valid_9.whiley b/tests/valid/ConstrainedRecord_Valid_9.whiley
index 1f6a3f412..e10da6048 100644
--- a/tests/valid/ConstrainedRecord_Valid_9.whiley
+++ b/tests/valid/ConstrainedRecord_Valid_9.whiley
@@ -36,7 +36,7 @@ ensures (C.width == B.width) && (C.height == A.height):
         i = i + 1
     return Matrix(B.width, A.height, C_data)
     
-public export method test() -> void:
+public export method test() :
     Matrix m1 = Matrix(2, 2, [[1, 0], [-3, 2]])
     Matrix m2 = Matrix(2, 2, [[-1, 4], [3, 5]])
     Matrix m3 = run(m1, m2)
diff --git a/tests/valid/Contractive_Valid_1.whiley b/tests/valid/Contractive_Valid_1.whiley
index 649739d04..f06c75038 100644
--- a/tests/valid/Contractive_Valid_1.whiley
+++ b/tests/valid/Contractive_Valid_1.whiley
@@ -5,6 +5,6 @@ type Contractive is Contractive | null
 function f(Contractive x) -> Contractive:
     return x
 
-public export method test() -> void:
+public export method test() :
     x = f(null)
     assume x == null
diff --git a/tests/valid/Contractive_Valid_2.whiley b/tests/valid/Contractive_Valid_2.whiley
index e22435a34..7e9f4d484 100644
--- a/tests/valid/Contractive_Valid_2.whiley
+++ b/tests/valid/Contractive_Valid_2.whiley
@@ -18,6 +18,6 @@ method h(C3 x) -> C1:
 method i(C3 x) -> C2:
     return x
 
-public export method test() -> void:
+public export method test() :
     C3 x = f(null)
     assume x == null
diff --git a/tests/valid/DecimalAssignment_Valid_1.whiley b/tests/valid/DecimalAssignment_Valid_1.whiley
index bb1834e14..4b7ea725a 100644
--- a/tests/valid/DecimalAssignment_Valid_1.whiley
+++ b/tests/valid/DecimalAssignment_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     real x = 5.0
     assert x == 5.0
     x = 3.234
diff --git a/tests/valid/Define_Valid_1.whiley b/tests/valid/Define_Valid_1.whiley
index 7b0842107..758ab1e0d 100644
--- a/tests/valid/Define_Valid_1.whiley
+++ b/tests/valid/Define_Valid_1.whiley
@@ -4,7 +4,7 @@ type point is {int y, int x}
 
 type listint is int[]
 
-public export method test() -> void:
+public export method test() :
     listint li = [1, 2, 3]
     point p = {y: 2, x: 1}
     int x = p.x
diff --git a/tests/valid/Define_Valid_2.whiley b/tests/valid/Define_Valid_2.whiley
index 965711376..b3f02bf59 100644
--- a/tests/valid/Define_Valid_2.whiley
+++ b/tests/valid/Define_Valid_2.whiley
@@ -2,7 +2,7 @@
 
 type dr2point is {real y, real x}
 
-public export method test() -> void:
+public export method test() :
     dr2point p = {y: 2.23, x: 1.0}
     assert p == {x:1.0, y:2.23}
 
diff --git a/tests/valid/Define_Valid_3.whiley b/tests/valid/Define_Valid_3.whiley
index 909df19b3..e8a555e2b 100644
--- a/tests/valid/Define_Valid_3.whiley
+++ b/tests/valid/Define_Valid_3.whiley
@@ -2,6 +2,6 @@
 
 type odd is (int x) where x == 1 || x == 3 || x == 5
 
-public export method test() -> void:
+public export method test() :
     odd y = 1
     assert y == 1
diff --git a/tests/valid/Define_Valid_4.whiley b/tests/valid/Define_Valid_4.whiley
index 49eabe711..dab6a6e50 100644
--- a/tests/valid/Define_Valid_4.whiley
+++ b/tests/valid/Define_Valid_4.whiley
@@ -8,5 +8,5 @@ function f(codeOp x) -> code:
     code y = {op: x, payload: [0]}
     return y
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == {op:1, payload: [0]}
diff --git a/tests/valid/DoWhile_Valid_1.whiley b/tests/valid/DoWhile_Valid_1.whiley
index 64b83f04e..da66425ae 100644
--- a/tests/valid/DoWhile_Valid_1.whiley
+++ b/tests/valid/DoWhile_Valid_1.whiley
@@ -12,7 +12,7 @@ requires |args| >= 2:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3]) == 3
     assume f([1, 2]) == 1
     assume f([1, 2, 3, 4, 5, 6]) == 15
diff --git a/tests/valid/DoWhile_Valid_2.whiley b/tests/valid/DoWhile_Valid_2.whiley
index aceb7e4f1..9d9bc5814 100644
--- a/tests/valid/DoWhile_Valid_2.whiley
+++ b/tests/valid/DoWhile_Valid_2.whiley
@@ -2,7 +2,7 @@
 
 
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     do:
         if i == 2:
diff --git a/tests/valid/DoWhile_Valid_3.whiley b/tests/valid/DoWhile_Valid_3.whiley
index aceb7e4f1..9d9bc5814 100644
--- a/tests/valid/DoWhile_Valid_3.whiley
+++ b/tests/valid/DoWhile_Valid_3.whiley
@@ -2,7 +2,7 @@
 
 
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     do:
         if i == 2:
diff --git a/tests/valid/DoWhile_Valid_4.whiley b/tests/valid/DoWhile_Valid_4.whiley
index 5e25e5bc1..5c53925a8 100644
--- a/tests/valid/DoWhile_Valid_4.whiley
+++ b/tests/valid/DoWhile_Valid_4.whiley
@@ -16,7 +16,7 @@ function dist(Link list) -> Leaf:
     //
     return iter + distance
 
-public export method test() -> void:
+public export method test() :
     LinkedList list = 123
     list = {next: list}
     list = {next: list}
diff --git a/tests/valid/DoWhile_Valid_5.whiley b/tests/valid/DoWhile_Valid_5.whiley
index 341d0157d..10c722ba2 100644
--- a/tests/valid/DoWhile_Valid_5.whiley
+++ b/tests/valid/DoWhile_Valid_5.whiley
@@ -12,7 +12,7 @@ requires |xs| > 0:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     assume sum([1]) == 1
     assume sum([1, 2]) == 3
     assume sum([1, 2, 3]) == 6
diff --git a/tests/valid/EffectiveList_Valid_1.whiley b/tests/valid/EffectiveList_Valid_1.whiley
index e4c1cfa24..c2b56f1e5 100644
--- a/tests/valid/EffectiveList_Valid_1.whiley
+++ b/tests/valid/EffectiveList_Valid_1.whiley
@@ -15,7 +15,7 @@ function f(int[] xs) -> nbool[]:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] e = [0;0]
     assume f(e) == [false;0]
     e = [1, 2, 3, 4]
diff --git a/tests/valid/Ensures_Valid_1.whiley b/tests/valid/Ensures_Valid_1.whiley
index 1cdb46cba..b3b3501ec 100644
--- a/tests/valid/Ensures_Valid_1.whiley
+++ b/tests/valid/Ensures_Valid_1.whiley
@@ -9,6 +9,6 @@ ensures r > 0:
     else:
         return x + y
 
-public export method test() -> void:
+public export method test() :
     assume add(1,2) == 3
     assume add(1,1) == 1
diff --git a/tests/valid/Ensures_Valid_2.whiley b/tests/valid/Ensures_Valid_2.whiley
index 84e731311..51bd38c8f 100644
--- a/tests/valid/Ensures_Valid_2.whiley
+++ b/tests/valid/Ensures_Valid_2.whiley
@@ -5,6 +5,6 @@ ensures y > x:
     x = x + 1
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = f(1)
     assume y == 2
diff --git a/tests/valid/Ensures_Valid_3.whiley b/tests/valid/Ensures_Valid_3.whiley
index 61ab82e85..8f8d8db42 100644
--- a/tests/valid/Ensures_Valid_3.whiley
+++ b/tests/valid/Ensures_Valid_3.whiley
@@ -26,7 +26,7 @@ ensures no { i in 0..|ys| | ys[i] < 0 }:
     //
     return zs
 
-public export method test() -> void:
+public export method test() :
     int[] a1 = selectOver([1, -2, 3, 4])
     int[] a2 = selectOver([1, -2, -3, 4])
     assume a1 == [1,3,4]
diff --git a/tests/valid/Ensures_Valid_4.whiley b/tests/valid/Ensures_Valid_4.whiley
index c32576520..27dd38dc3 100644
--- a/tests/valid/Ensures_Valid_4.whiley
+++ b/tests/valid/Ensures_Valid_4.whiley
@@ -5,5 +5,5 @@ requires x >= 0
 ensures r >= 0 && x >= 0:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(10) == 10
diff --git a/tests/valid/Ensures_Valid_5.whiley b/tests/valid/Ensures_Valid_5.whiley
index d5e102f0f..125761217 100644
--- a/tests/valid/Ensures_Valid_5.whiley
+++ b/tests/valid/Ensures_Valid_5.whiley
@@ -6,5 +6,5 @@ ensures r > x:
     x = x + 1
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 2
diff --git a/tests/valid/FunctionRef_Valid_1.whiley b/tests/valid/FunctionRef_Valid_1.whiley
index 815e16f69..f9625374d 100644
--- a/tests/valid/FunctionRef_Valid_1.whiley
+++ b/tests/valid/FunctionRef_Valid_1.whiley
@@ -11,6 +11,6 @@ type func_t is function(int) -> int
 function g(func_t func) -> int:
     return func(1234)
 
-public export method test() -> void:
+public export method test() :
     assume g(&f1) == 1235
     assume g(&f2) == 2468
diff --git a/tests/valid/FunctionRef_Valid_2.whiley b/tests/valid/FunctionRef_Valid_2.whiley
index b43644c09..9824d5c15 100644
--- a/tests/valid/FunctionRef_Valid_2.whiley
+++ b/tests/valid/FunctionRef_Valid_2.whiley
@@ -6,5 +6,5 @@ function f(real x) -> real:
 function g(function(int)->real func) -> real:
     return func(1)
 
-public export method test() -> void:
+public export method test() :
     assume g(&f) == 2.0
diff --git a/tests/valid/FunctionRef_Valid_3.whiley b/tests/valid/FunctionRef_Valid_3.whiley
index f9c298335..c08851fca 100644
--- a/tests/valid/FunctionRef_Valid_3.whiley
+++ b/tests/valid/FunctionRef_Valid_3.whiley
@@ -6,5 +6,5 @@ function f(int x) -> int:
 function g(function(int)->real func) -> real:
     return func(1)
 
-public export method test() -> void:
+public export method test() :
     assume g((function(int)->real) &f) == 12.0
diff --git a/tests/valid/FunctionRef_Valid_4.whiley b/tests/valid/FunctionRef_Valid_4.whiley
index de37203a7..32a41d731 100644
--- a/tests/valid/FunctionRef_Valid_4.whiley
+++ b/tests/valid/FunctionRef_Valid_4.whiley
@@ -14,6 +14,6 @@ function g(int d) -> int:
     func y = table[d]
     return y(123)
 
-public export method test() -> void:
+public export method test() :
     assume g(0) == 123
     assume g(1) == -123
diff --git a/tests/valid/FunctionRef_Valid_5.whiley b/tests/valid/FunctionRef_Valid_5.whiley
index 3823185f6..22a13bc85 100644
--- a/tests/valid/FunctionRef_Valid_5.whiley
+++ b/tests/valid/FunctionRef_Valid_5.whiley
@@ -10,7 +10,7 @@ function id(int x) -> int:
 function test(Func f, int arg) -> int:
     return f.read(arg)
 
-public export method test() -> void:
+public export method test() :
     int x = test({read: &id}, 123)
     assume x == 123
     x = test({read: &id}, 12545)
diff --git a/tests/valid/FunctionRef_Valid_6.whiley b/tests/valid/FunctionRef_Valid_6.whiley
index 8cdb4621e..c54f96495 100644
--- a/tests/valid/FunctionRef_Valid_6.whiley
+++ b/tests/valid/FunctionRef_Valid_6.whiley
@@ -10,7 +10,7 @@ function id(int x) -> int:
 function test(Func f, int arg) -> int:
     return f.read(arg)
 
-public export method test() -> void:
+public export method test() :
     int x = test({read: &id}, 123)
     assume x == 123
     x = test({read: &id}, 12545)
diff --git a/tests/valid/FunctionRef_Valid_7.whiley b/tests/valid/FunctionRef_Valid_7.whiley
index 870fe64d2..0b1b94696 100644
--- a/tests/valid/FunctionRef_Valid_7.whiley
+++ b/tests/valid/FunctionRef_Valid_7.whiley
@@ -8,7 +8,7 @@ method read(Proc this, int x) -> int:
 public export method test(Proc p, int arg) -> int:
     return read(p,arg)
 
-public export method test() -> void:
+public export method test() :
     Proc p = new {data: 1}
     int x = test(p, 123)
     assume x == 124
diff --git a/tests/valid/FunctionRef_Valid_8.whiley b/tests/valid/FunctionRef_Valid_8.whiley
index 38f700304..4fc36bc85 100644
--- a/tests/valid/FunctionRef_Valid_8.whiley
+++ b/tests/valid/FunctionRef_Valid_8.whiley
@@ -9,7 +9,7 @@ function id(int x) -> int:
 function test(function (int)->int read, int arg) -> int:
     return read(arg)
 
-public export method test() -> void:
+public export method test() :
     int x = test(&id, 1)
     assume x == 1
     x = test(&id, 123)
diff --git a/tests/valid/FunctionRef_Valid_9.whiley b/tests/valid/FunctionRef_Valid_9.whiley
index 61207cb9d..87b6ca633 100644
--- a/tests/valid/FunctionRef_Valid_9.whiley
+++ b/tests/valid/FunctionRef_Valid_9.whiley
@@ -13,7 +13,7 @@ public export method test(Proc this, int arg) -> int:
 function id(int x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     Proc p = new {func: &id}
     int x = test(p, 123)
     assume x == 123
diff --git a/tests/valid/Function_Valid_1.whiley b/tests/valid/Function_Valid_1.whiley
index f2398d36a..265660fda 100644
--- a/tests/valid/Function_Valid_1.whiley
+++ b/tests/valid/Function_Valid_1.whiley
@@ -6,6 +6,6 @@ function f(real x) -> int:
 function f(int x) -> int:
     return 2
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 2
     assume f(1.23) == 1
diff --git a/tests/valid/Function_Valid_11.whiley b/tests/valid/Function_Valid_11.whiley
index c4d768d71..48d92fd83 100644
--- a/tests/valid/Function_Valid_11.whiley
+++ b/tests/valid/Function_Valid_11.whiley
@@ -10,7 +10,7 @@ function f(fr8nat y) -> bool:
 function f(fr8neg x) -> bool:
     return false
 
-public export method test() -> void:
+public export method test() :
     fr8nat x = 1
     assume f(x) == true
     fr8neg y = -1
diff --git a/tests/valid/Function_Valid_12.whiley b/tests/valid/Function_Valid_12.whiley
index 183ad45bc..6aaf3d15b 100644
--- a/tests/valid/Function_Valid_12.whiley
+++ b/tests/valid/Function_Valid_12.whiley
@@ -11,6 +11,6 @@ function f(int[] ls) -> int[]:
 function f(real[] ls) -> real[]:
     return ls
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3]) == [1,2,3]
     assume f([1.2, 2.2, 3.3]) == [1.2,2.2,3.3]
diff --git a/tests/valid/Function_Valid_13.whiley b/tests/valid/Function_Valid_13.whiley
index 50e992235..f86a6a595 100644
--- a/tests/valid/Function_Valid_13.whiley
+++ b/tests/valid/Function_Valid_13.whiley
@@ -11,7 +11,7 @@ function Point(int i, int j) -> Point:
     else:
         return {y: -1, x: 1}
 
-public export method test() -> void:
+public export method test() :
     Point rs = Point(1, 1)
     assume rs == {x:1,y:-1}
     rs = Point(1, 2)
diff --git a/tests/valid/Function_Valid_14.whiley b/tests/valid/Function_Valid_14.whiley
index 56c2f8aab..97546f868 100644
--- a/tests/valid/Function_Valid_14.whiley
+++ b/tests/valid/Function_Valid_14.whiley
@@ -9,7 +9,7 @@ function f(real y) -> int:
 function f(int[] xs) -> int:
     return 3
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
     assume f(1.234) == 2
     assume f([1, 2, 3]) == 3
diff --git a/tests/valid/Function_Valid_15.whiley b/tests/valid/Function_Valid_15.whiley
index 72dc49806..7e3efd1e4 100644
--- a/tests/valid/Function_Valid_15.whiley
+++ b/tests/valid/Function_Valid_15.whiley
@@ -10,7 +10,7 @@ function f(msg1 m) -> int:
 function f(msg2 m) -> int:
     return 2
 
-public export method test() -> void:
+public export method test() :
     msg1 m1 = {op: 1, s: 123}
     msg1 m2 = {op: 2, s: 123}
     assume f(m1) == 1
diff --git a/tests/valid/Function_Valid_16.whiley b/tests/valid/Function_Valid_16.whiley
index 683dd6645..a1e47e2d8 100644
--- a/tests/valid/Function_Valid_16.whiley
+++ b/tests/valid/Function_Valid_16.whiley
@@ -10,7 +10,7 @@ function g(int x, int y) -> int
 requires x > y:
     return x + y
 
-public export method test() -> void:
+public export method test() :
     int a = 2
     int b = 1
     if a < b:
diff --git a/tests/valid/Function_Valid_17.whiley b/tests/valid/Function_Valid_17.whiley
index a7ce8ec61..92b1aa406 100644
--- a/tests/valid/Function_Valid_17.whiley
+++ b/tests/valid/Function_Valid_17.whiley
@@ -6,7 +6,7 @@ function f(int x) -> int:
 function g(int x, int y) -> int:
     return x + y
 
-public export method test() -> void:
+public export method test() :
     int a = 2
     int b = 1
     if a < b:
diff --git a/tests/valid/Function_Valid_18.whiley b/tests/valid/Function_Valid_18.whiley
index 4246e7c6f..d8e9794cc 100644
--- a/tests/valid/Function_Valid_18.whiley
+++ b/tests/valid/Function_Valid_18.whiley
@@ -14,7 +14,7 @@ ensures item == r:
     //
     return abs(item)
 
-public export method test() -> void:
+public export method test() :
     nat xs = abs(-123)
     assume xs == 123
     xs = nop(1)
diff --git a/tests/valid/Function_Valid_2.whiley b/tests/valid/Function_Valid_2.whiley
index c03d87a1f..57b1db30c 100644
--- a/tests/valid/Function_Valid_2.whiley
+++ b/tests/valid/Function_Valid_2.whiley
@@ -5,6 +5,6 @@ type fr3nat is (int x) where x >= 0
 function f(int x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 1
     assume f(y) == 1
diff --git a/tests/valid/Function_Valid_20.whiley b/tests/valid/Function_Valid_20.whiley
index f42167a39..1afc7376e 100644
--- a/tests/valid/Function_Valid_20.whiley
+++ b/tests/valid/Function_Valid_20.whiley
@@ -5,6 +5,6 @@ type fr2nat is (int x) where x >= 0
 function f(fr2nat x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 1
     assume f(y) == 1
diff --git a/tests/valid/Function_Valid_21.whiley b/tests/valid/Function_Valid_21.whiley
index 0d320eee6..b726d228f 100644
--- a/tests/valid/Function_Valid_21.whiley
+++ b/tests/valid/Function_Valid_21.whiley
@@ -5,6 +5,6 @@ type fr2nat is int
 function f(fr2nat x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 1
     assume f(y) == 1
diff --git a/tests/valid/Function_Valid_3.whiley b/tests/valid/Function_Valid_3.whiley
index a7f948d30..179b24481 100644
--- a/tests/valid/Function_Valid_3.whiley
+++ b/tests/valid/Function_Valid_3.whiley
@@ -5,6 +5,6 @@ type fr3nat is int
 function f(int x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 234987234987234982304980130982398723
     assume f(y) == y
diff --git a/tests/valid/Function_Valid_4.whiley b/tests/valid/Function_Valid_4.whiley
index 176f9ae48..7ca7a7877 100644
--- a/tests/valid/Function_Valid_4.whiley
+++ b/tests/valid/Function_Valid_4.whiley
@@ -8,6 +8,6 @@ function g(fr4nat x) -> fr4nat:
 function f(fr4nat x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 1
     assume f(g(y)) == 2
diff --git a/tests/valid/Function_Valid_5.whiley b/tests/valid/Function_Valid_5.whiley
index 8c6969f0a..c6e67466f 100644
--- a/tests/valid/Function_Valid_5.whiley
+++ b/tests/valid/Function_Valid_5.whiley
@@ -8,6 +8,6 @@ function g(fr4nat x) -> fr4nat:
 function f(fr4nat x) -> int:
     return x
 
-public export method test() -> void:
+public export method test() :
     int y = 1
     assume f(g(y)) == 2
diff --git a/tests/valid/Function_Valid_6.whiley b/tests/valid/Function_Valid_6.whiley
index 7c53fe048..6c73469a8 100644
--- a/tests/valid/Function_Valid_6.whiley
+++ b/tests/valid/Function_Valid_6.whiley
@@ -12,6 +12,6 @@ function g(fr5nat[] xs) -> fr5nat[]:
 function f(fr5nat[] x) -> int[]:
     return x
 
-public export method test() -> void:
+public export method test() :
     int[] ys = [1, 2, 3]
     assume f(g(ys)) == [0, 2, 3]
diff --git a/tests/valid/Function_Valid_7.whiley b/tests/valid/Function_Valid_7.whiley
index d3f9b7843..be4ef1731 100644
--- a/tests/valid/Function_Valid_7.whiley
+++ b/tests/valid/Function_Valid_7.whiley
@@ -15,6 +15,6 @@ function g(fr5nat[] xs) -> fr5nat[]:
 function f(fr5nat[] x) -> int[]:
     return x
 
-public export method test() -> void:
+public export method test() :
     int[] ys = [1, 2, 3]
     assume f(g(ys)) == [0, 2, 3]
diff --git a/tests/valid/Function_Valid_8.whiley b/tests/valid/Function_Valid_8.whiley
index 01d9d8700..7a2c67763 100644
--- a/tests/valid/Function_Valid_8.whiley
+++ b/tests/valid/Function_Valid_8.whiley
@@ -12,7 +12,7 @@ function g(nat[] xs) -> nat[]:
 function f(int[] x) -> int[]:
     return x
 
-public export method test() -> void:
+public export method test() :
     int[] ys = [1, 2, 3]
     assume f(g(ys)) == [0, 2, 3]
 
diff --git a/tests/valid/Function_Valid_9.whiley b/tests/valid/Function_Valid_9.whiley
index 8736858af..f091a783e 100644
--- a/tests/valid/Function_Valid_9.whiley
+++ b/tests/valid/Function_Valid_9.whiley
@@ -15,7 +15,7 @@ function g(nat[] xs) -> nat[]:
 function f(int[] x) -> int[]:
     return x
 
-public export method test() -> void:
+public export method test() :
     int[] ys = [-12309812, 1, 2, 2987, 2349872, 234987234987, 234987234987234]
     assume f(g(ys)) == [0, 0, 2, 2987, 2349872, 234987234987, 234987234987234]
 
diff --git a/tests/valid/HexAssign_Valid_1.whiley b/tests/valid/HexAssign_Valid_1.whiley
index fe0b043d4..3e1f08f87 100644
--- a/tests/valid/HexAssign_Valid_1.whiley
+++ b/tests/valid/HexAssign_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int x = 200
     assert x == 200
     x = 1
diff --git a/tests/valid/IfElse_Valid_1.whiley b/tests/valid/IfElse_Valid_1.whiley
index 80eb948dd..eb52893a3 100644
--- a/tests/valid/IfElse_Valid_1.whiley
+++ b/tests/valid/IfElse_Valid_1.whiley
@@ -9,7 +9,7 @@ function f(int x) -> int:
         else:
             return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == -1
     assume f(10) == 0
     assume f(11) == 1
diff --git a/tests/valid/IfElse_Valid_2.whiley b/tests/valid/IfElse_Valid_2.whiley
index 20bc6903a..0ccae8b93 100644
--- a/tests/valid/IfElse_Valid_2.whiley
+++ b/tests/valid/IfElse_Valid_2.whiley
@@ -8,7 +8,7 @@ function f(int x) -> int:
             return 2
     return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
     assume f(10) == 0
     assume f(11) == 2
diff --git a/tests/valid/IfElse_Valid_3.whiley b/tests/valid/IfElse_Valid_3.whiley
index a256f2dba..188185160 100644
--- a/tests/valid/IfElse_Valid_3.whiley
+++ b/tests/valid/IfElse_Valid_3.whiley
@@ -6,7 +6,7 @@ function f(int x) -> int:
     else:
         return 2
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
     assume f(10) == 2
     assume f(11) == 2
diff --git a/tests/valid/IfElse_Valid_4.whiley b/tests/valid/IfElse_Valid_4.whiley
index 3535a697a..400eedc79 100644
--- a/tests/valid/IfElse_Valid_4.whiley
+++ b/tests/valid/IfElse_Valid_4.whiley
@@ -22,7 +22,7 @@ function sum_3(LinkedList ls) -> int:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     LinkedList ls = {next: null, data: 1}
     ls = {next: ls, data: 2}
     ls = {next: ls, data: 3}
diff --git a/tests/valid/Import_Valid_1.whiley b/tests/valid/Import_Valid_1.whiley
index d9a3e7b8d..7dc56fc9e 100644
--- a/tests/valid/Import_Valid_1.whiley
+++ b/tests/valid/Import_Valid_1.whiley
@@ -6,5 +6,5 @@ function f(int x) -> int:
     else:
         return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
diff --git a/tests/valid/Import_Valid_2.whiley b/tests/valid/Import_Valid_2.whiley
index 5e460720b..89e3956ea 100644
--- a/tests/valid/Import_Valid_2.whiley
+++ b/tests/valid/Import_Valid_2.whiley
@@ -4,5 +4,5 @@ function f(int[] x) -> int
 requires |x| > 0:
     return x[0]
 
-public export method test() -> void:
+public export method test() :
     assume f("1") == '1'
diff --git a/tests/valid/Import_Valid_3.whiley b/tests/valid/Import_Valid_3.whiley
index de1999a28..0220664c7 100644
--- a/tests/valid/Import_Valid_3.whiley
+++ b/tests/valid/Import_Valid_3.whiley
@@ -9,6 +9,6 @@ function toInt(int[] ls) -> int:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] ls = [1, 2, 3, 4]
     assume toInt(ls) == 10
diff --git a/tests/valid/Import_Valid_4.whiley b/tests/valid/Import_Valid_4.whiley
index 550eaac5f..ded0386a4 100644
--- a/tests/valid/Import_Valid_4.whiley
+++ b/tests/valid/Import_Valid_4.whiley
@@ -7,6 +7,6 @@ import toString from whiley.lang.Real
 function g(real x) -> int[]:
     return toString(x)
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == "1"
     assume g(1.2344) == "1.2344"
diff --git a/tests/valid/Import_Valid_5.whiley b/tests/valid/Import_Valid_5.whiley
index cc0c132de..d156dbbc5 100644
--- a/tests/valid/Import_Valid_5.whiley
+++ b/tests/valid/Import_Valid_5.whiley
@@ -1,3 +1,3 @@
 
-public export method test() -> void:
+public export method test() :
     assume toString(1223374) == "1223374"
diff --git a/tests/valid/Import_Valid_6.whiley b/tests/valid/Import_Valid_6.whiley
index c92f78ed4..1346f96a3 100644
--- a/tests/valid/Import_Valid_6.whiley
+++ b/tests/valid/Import_Valid_6.whiley
@@ -1,5 +1,5 @@
 
-public export method test() -> void:
+public export method test() :
     int x = 1
     int y = 2
     assert x + y == 3
diff --git a/tests/valid/IntConst_Valid_1.whiley b/tests/valid/IntConst_Valid_1.whiley
index a01c9034a..91fad3399 100644
--- a/tests/valid/IntConst_Valid_1.whiley
+++ b/tests/valid/IntConst_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int x = 1234567891011121314151617181920
     x = x + 1
     assert x == 1234567891011121314151617181921
diff --git a/tests/valid/IntDefine_Valid_1.whiley b/tests/valid/IntDefine_Valid_1.whiley
index 981c33b79..ac98e4bb2 100644
--- a/tests/valid/IntDefine_Valid_1.whiley
+++ b/tests/valid/IntDefine_Valid_1.whiley
@@ -10,7 +10,7 @@ function f(int x) -> int:
         return y
     return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 0
     assume f(2) == 0
     assume f(3) == 3
diff --git a/tests/valid/IntDefine_Valid_2.whiley b/tests/valid/IntDefine_Valid_2.whiley
index d094e70c7..da3cd56de 100644
--- a/tests/valid/IntDefine_Valid_2.whiley
+++ b/tests/valid/IntDefine_Valid_2.whiley
@@ -10,7 +10,7 @@ function f(int x) -> int:
         return y
     return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 0
     assume f(2) == 0
     assume f(3) == 3
diff --git a/tests/valid/IntDiv_Valid_1.whiley b/tests/valid/IntDiv_Valid_1.whiley
index 962f358b0..5dccfde60 100644
--- a/tests/valid/IntDiv_Valid_1.whiley
+++ b/tests/valid/IntDiv_Valid_1.whiley
@@ -4,7 +4,7 @@ function f(int x, int y) -> int
 requires y != 0:
     return x / y
 
-public export method test() -> void:
+public export method test() :
     assume f(10, 2) == 5
     assume f(9, 3) == 3
     assume f(10, 3) == 3
diff --git a/tests/valid/IntDiv_Valid_3.whiley b/tests/valid/IntDiv_Valid_3.whiley
index 37b3672e9..63cdac659 100644
--- a/tests/valid/IntDiv_Valid_3.whiley
+++ b/tests/valid/IntDiv_Valid_3.whiley
@@ -11,6 +11,6 @@ requires y > 0:
         z = y / x
     return z
 
-public export method test() -> void:
+public export method test() :
     assume f(10, 2) == 5
 
diff --git a/tests/valid/IntDiv_Valid_4.whiley b/tests/valid/IntDiv_Valid_4.whiley
index 3fb56b840..7104e7be6 100644
--- a/tests/valid/IntDiv_Valid_4.whiley
+++ b/tests/valid/IntDiv_Valid_4.whiley
@@ -3,5 +3,5 @@
 function f(int x) -> int:
     return x / 3
 
-public export method test() -> void:
+public export method test() :
     assume f(10) == 3
diff --git a/tests/valid/IntDiv_Valid_5.whiley b/tests/valid/IntDiv_Valid_5.whiley
index d5ae0954d..2e98bb149 100644
--- a/tests/valid/IntDiv_Valid_5.whiley
+++ b/tests/valid/IntDiv_Valid_5.whiley
@@ -7,5 +7,5 @@ requires x == (2 * y):
     assert (2 * y) == x
     return {nx: x, ny: y}
 
-public export method test() -> void:
+public export method test() :
     assume f(2, 1) == {nx: 4, ny: 2}
diff --git a/tests/valid/IntEquals_Valid_1.whiley b/tests/valid/IntEquals_Valid_1.whiley
index bf0946470..125e034b7 100644
--- a/tests/valid/IntEquals_Valid_1.whiley
+++ b/tests/valid/IntEquals_Valid_1.whiley
@@ -6,7 +6,7 @@ function f(int x, real y) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 4.0) == false
     assume f(1, 4.2) == false
     assume f(0, 0.0) == true
diff --git a/tests/valid/IntMul_Valid_1.whiley b/tests/valid/IntMul_Valid_1.whiley
index f3f5e7b4a..e3b9e5947 100644
--- a/tests/valid/IntMul_Valid_1.whiley
+++ b/tests/valid/IntMul_Valid_1.whiley
@@ -1,5 +1,5 @@
 
 
-public export method test() -> void:
+public export method test() :
     int x = (2 * 3) + 1
     assert x == 7
diff --git a/tests/valid/IntOp_Valid_1.whiley b/tests/valid/IntOp_Valid_1.whiley
index 3833e9c64..839d23e1b 100644
--- a/tests/valid/IntOp_Valid_1.whiley
+++ b/tests/valid/IntOp_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int x = 112233445566778899
     assert x == 112233445566778899
     x = x + 1
diff --git a/tests/valid/Intersection_Valid_1.whiley b/tests/valid/Intersection_Valid_1.whiley
index e0effee73..ece967741 100644
--- a/tests/valid/Intersection_Valid_1.whiley
+++ b/tests/valid/Intersection_Valid_1.whiley
@@ -5,5 +5,5 @@ type EmptyList is int[] & real[]
 function size(EmptyList l) -> int:
     return |l|
 
-public export method test() -> void:
+public export method test() :
     assume size([0;0]) == 0
diff --git a/tests/valid/Intersection_Valid_2.whiley b/tests/valid/Intersection_Valid_2.whiley
index 283a61c19..b737dea0a 100644
--- a/tests/valid/Intersection_Valid_2.whiley
+++ b/tests/valid/Intersection_Valid_2.whiley
@@ -9,6 +9,6 @@ type InterList is UnitList & LinkedList
 function f(InterList l) -> int:
     return l.data
 
-public export method test() -> void:
+public export method test() :
     list = {next: null, data: 1234}
     assume f(list) == 1234
diff --git a/tests/valid/Lambda_Valid_1.whiley b/tests/valid/Lambda_Valid_1.whiley
index dbc92c996..f5f21663d 100644
--- a/tests/valid/Lambda_Valid_1.whiley
+++ b/tests/valid/Lambda_Valid_1.whiley
@@ -5,7 +5,7 @@ type func is function(int) -> int
 function g() -> func:
     return &(int x -> x + 1)
 
-public export method test() -> void:
+public export method test() :
     func f = g()
     assume f(1) == 2
     assume f(2) == 3
diff --git a/tests/valid/Lambda_Valid_2.whiley b/tests/valid/Lambda_Valid_2.whiley
index 50d265ddf..55716580a 100644
--- a/tests/valid/Lambda_Valid_2.whiley
+++ b/tests/valid/Lambda_Valid_2.whiley
@@ -5,7 +5,7 @@ type func is function(int) -> int
 function g(int y) -> func:
     return &(int x -> x + y)
 
-public export method test() -> void:
+public export method test() :
     func f = g(3)
     assume f(1) == 4
     assume f(2) == 5
diff --git a/tests/valid/Lambda_Valid_3.whiley b/tests/valid/Lambda_Valid_3.whiley
index 37f112d6a..642290eec 100644
--- a/tests/valid/Lambda_Valid_3.whiley
+++ b/tests/valid/Lambda_Valid_3.whiley
@@ -57,7 +57,7 @@ public method BufferInputStream(byte[] buffer) -> InputStream:
     BufferState this = new {bytes: buffer, pos: 0}
     return {read: &(int x -> read(this, x))}
 
-public export method test() -> void:
+public export method test() :
     InputStream bis = BufferInputStream(toBytes("hello"))
     byte[] bytes = bis.read(7)
     assume bytes == [01101000b, 01100101b, 01101100b, 01101100b, 01101111b, 0b, 0b]
diff --git a/tests/valid/Lambda_Valid_4.whiley b/tests/valid/Lambda_Valid_4.whiley
index 564059660..6c83a75e7 100644
--- a/tests/valid/Lambda_Valid_4.whiley
+++ b/tests/valid/Lambda_Valid_4.whiley
@@ -74,6 +74,6 @@ method read(string s) -> byte[]:
     //
     return bytes
         
-public export method test() -> void:
+public export method test() :
     assume read("hello") == [01101100b, 01101111b, 0b]
     
diff --git a/tests/valid/Lambda_Valid_5.whiley b/tests/valid/Lambda_Valid_5.whiley
index 2a0ccb7e4..404b1e39d 100644
--- a/tests/valid/Lambda_Valid_5.whiley
+++ b/tests/valid/Lambda_Valid_5.whiley
@@ -6,6 +6,6 @@ method f(int x) -> int:
 method g(method func(int) -> int, int p) -> int:
     return func(p)
 
-public export method test() -> void:
+public export method test() :
     int y = g(&(int x -> f(x + 1)), 5)
     assume y == 7
diff --git a/tests/valid/Lambda_Valid_6.whiley b/tests/valid/Lambda_Valid_6.whiley
index 7a68a053f..e85c62e27 100644
--- a/tests/valid/Lambda_Valid_6.whiley
+++ b/tests/valid/Lambda_Valid_6.whiley
@@ -9,6 +9,6 @@ method g(int p) -> int:
     func_t func = &(int x -> f(x + 1))
     return func(p)
 
-public export method test() -> void:
+public export method test() :
     int x = g(5)
     assume x == 7
diff --git a/tests/valid/Lambda_Valid_7.whiley b/tests/valid/Lambda_Valid_7.whiley
index 663526bbe..d5979a305 100644
--- a/tests/valid/Lambda_Valid_7.whiley
+++ b/tests/valid/Lambda_Valid_7.whiley
@@ -11,6 +11,6 @@ requires p >= 0:
     func_t func = &(int x -> f(x + 1))
     return func(p)
 
-public export method test() -> void:
+public export method test() :
     int x = g(5)
     assume x == 7
diff --git a/tests/valid/Lambda_Valid_8.whiley b/tests/valid/Lambda_Valid_8.whiley
index 2f4026c34..3ae3ddccb 100644
--- a/tests/valid/Lambda_Valid_8.whiley
+++ b/tests/valid/Lambda_Valid_8.whiley
@@ -3,17 +3,17 @@
 function g(int x, int y) -> int:
     return x + y
 
-function f1(int x) -> function(int) -> int:
+function f1(int x) -> function(int)->(int):
     //
     return &(int y -> g(x, y))
 
-function f2(int y) -> function(int) -> int:
+function f2(int y) -> function(int)->(int):
     //
     return &(int x -> g(x, y))
 
-type func is function(int) -> int
+type func is function(int)->(int)
 
-public export method test() -> void:
+public export method test() :
     func fx = f1(10)
     func fy = f2(20)
     assume fx(1) == 11
diff --git a/tests/valid/Lambda_Valid_9.whiley b/tests/valid/Lambda_Valid_9.whiley
index 1c5ba5aaa..03d0281bd 100644
--- a/tests/valid/Lambda_Valid_9.whiley
+++ b/tests/valid/Lambda_Valid_9.whiley
@@ -3,8 +3,8 @@
 type Point is {
     int x,
     int y,
-    function toString(Point) -> int,
-    function getX(Point) -> int
+    function toString(Point)->(int),
+    function getX(Point)->(int)
 }
 
 function toString(Point p) -> int:
diff --git a/tests/valid/LengthOf_Valid_1.whiley b/tests/valid/LengthOf_Valid_1.whiley
index fc631aa99..23c975a9f 100644
--- a/tests/valid/LengthOf_Valid_1.whiley
+++ b/tests/valid/LengthOf_Valid_1.whiley
@@ -5,7 +5,7 @@ type list is int[] | bool[]
 function len(list l) -> int:
     return |l|
 
-public export method test() -> void:
+public export method test() :
     int[] l = [1, 2, 3]
     assume len(l) == 3
     bool[] s = [true,false,true]
diff --git a/tests/valid/LengthOf_Valid_4.whiley b/tests/valid/LengthOf_Valid_4.whiley
index a3ade2c07..592527345 100644
--- a/tests/valid/LengthOf_Valid_4.whiley
+++ b/tests/valid/LengthOf_Valid_4.whiley
@@ -5,7 +5,7 @@ type listibr is int[] | bool[] | real[]
 function len(listibr l) -> int:
     return |l|
 
-public export method test() -> void:
+public export method test() :
     bool[] s = [true,false,true]
     assume len(s) == 3
     int[] l = [1, 2]
diff --git a/tests/valid/LengthOf_Valid_5.whiley b/tests/valid/LengthOf_Valid_5.whiley
index bae8f35bc..af3eb46d1 100644
--- a/tests/valid/LengthOf_Valid_5.whiley
+++ b/tests/valid/LengthOf_Valid_5.whiley
@@ -5,7 +5,7 @@ type list is int[]
 function len(list l) -> int:
     return |l|
 
-public export method test() -> void:
+public export method test() :
     int[] l = [1, 2]
     assume len(l) == 2
     int[] s = "Hello World"
diff --git a/tests/valid/ListAccess_Valid_1.whiley b/tests/valid/ListAccess_Valid_1.whiley
index 37cbfca4c..6a5b9cf4c 100644
--- a/tests/valid/ListAccess_Valid_1.whiley
+++ b/tests/valid/ListAccess_Valid_1.whiley
@@ -1,12 +1,12 @@
 
 
-function f(int[] x) -> void
+function f(int[] x) 
 requires |x| > 0:
     int y = x[0]
     int z = x[0]
     assert y == z
 
-public export method test() -> void:
+public export method test() :
     int[] arr = [1, 2, 3]
     f(arr)
     assert arr[0] == 1
diff --git a/tests/valid/ListAccess_Valid_3.whiley b/tests/valid/ListAccess_Valid_3.whiley
index 1a7aa3ef5..0943a6d68 100644
--- a/tests/valid/ListAccess_Valid_3.whiley
+++ b/tests/valid/ListAccess_Valid_3.whiley
@@ -1,6 +1,6 @@
 
 
-function f(int[] x, int i) -> void
+function f(int[] x, int i) 
 requires |x| > 0:
     if (i < 0) || (i >= |x|):
         i = 0
@@ -9,7 +9,7 @@ requires |x| > 0:
     int z = x[i]
     assert y == z
 
-public export method test() -> void:
+public export method test() :
     int[] arr = [1, 2, 3]
     f(arr, 1)
     assume arr == [1,2,3]
diff --git a/tests/valid/ListAccess_Valid_5.whiley b/tests/valid/ListAccess_Valid_5.whiley
index 54157c746..c6875f012 100644
--- a/tests/valid/ListAccess_Valid_5.whiley
+++ b/tests/valid/ListAccess_Valid_5.whiley
@@ -3,6 +3,6 @@
 function f(int[] x) -> int:
     return |x|
 
-public export method test() -> void:
+public export method test() :
     int[][] arr = [[1, 2, 3]]
     assume f(arr[0]) == 3
diff --git a/tests/valid/ListAccess_Valid_6.whiley b/tests/valid/ListAccess_Valid_6.whiley
index 581d8aaac..4f4ae205f 100644
--- a/tests/valid/ListAccess_Valid_6.whiley
+++ b/tests/valid/ListAccess_Valid_6.whiley
@@ -12,5 +12,5 @@ function f(int[] str) -> int[]:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     assume f("Hello") == [0,0,0,0,0]
diff --git a/tests/valid/ListAccess_Valid_8.whiley b/tests/valid/ListAccess_Valid_8.whiley
index 65e8dc7f7..3f827f25e 100644
--- a/tests/valid/ListAccess_Valid_8.whiley
+++ b/tests/valid/ListAccess_Valid_8.whiley
@@ -20,7 +20,7 @@ public function meth(byte[] bytes) -> int[]:
         i = i + 1
     return data
 
-public export method test() -> void:
+public export method test() :
     byte[] bytes = [00000000b, 00000001b, 00000011b, 00000111b]
     assume meth(bytes) == [0,1,3,7]
 
diff --git a/tests/valid/ListAssign_Valid_1.whiley b/tests/valid/ListAssign_Valid_1.whiley
index d18674f1f..696d7e4e9 100644
--- a/tests/valid/ListAssign_Valid_1.whiley
+++ b/tests/valid/ListAssign_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int[] arr1 = [1, 2, 3]
     int[] arr2 = arr1
     arr2[2] = 2
diff --git a/tests/valid/ListAssign_Valid_11.whiley b/tests/valid/ListAssign_Valid_11.whiley
index 3ad6cd68d..8ca4e0fc0 100644
--- a/tests/valid/ListAssign_Valid_11.whiley
+++ b/tests/valid/ListAssign_Valid_11.whiley
@@ -7,7 +7,7 @@ requires |a| > 0:
     a[0] = 5
     return a
 
-public export method test() -> void:
+public export method test() :
     int[] b = [1, 2, 3]
     assume f(b) == [5,2,3]
 
diff --git a/tests/valid/ListAssign_Valid_2.whiley b/tests/valid/ListAssign_Valid_2.whiley
index dba665cb6..feb25f4a3 100644
--- a/tests/valid/ListAssign_Valid_2.whiley
+++ b/tests/valid/ListAssign_Valid_2.whiley
@@ -5,7 +5,7 @@ type intlist is int | int[]
 function f(intlist[] l) -> any:
     return l
 
-public export method test() -> void:
+public export method test() :
     (int|int[])[] x
 
     if 0 == 0:
diff --git a/tests/valid/ListAssign_Valid_3.whiley b/tests/valid/ListAssign_Valid_3.whiley
index f0a7ead27..abb4bd56b 100644
--- a/tests/valid/ListAssign_Valid_3.whiley
+++ b/tests/valid/ListAssign_Valid_3.whiley
@@ -12,7 +12,7 @@ requires |ls| > 0 && |ls[0]| > 0:
     int[][] nls = update(ls)
     return {f1: ls, f2: nls}
 
-public export method test() -> void:
+public export method test() :
     int[][] ls = [[1, 2, 3, 4]]
     {int[][] f1, int[][] f2} r = f(ls)
     assume r.f1 == [[1,2,3,4]]
diff --git a/tests/valid/ListAssign_Valid_4.whiley b/tests/valid/ListAssign_Valid_4.whiley
index dd8c54464..32b2b54a9 100644
--- a/tests/valid/ListAssign_Valid_4.whiley
+++ b/tests/valid/ListAssign_Valid_4.whiley
@@ -20,6 +20,6 @@ requires |board.rows| > 0:
     board.rows[0] = BLACK_PAWN
     return board
 
-public export method test() -> void:
+public export method test() :
     Board r1 = {flag: false, rows: [WHITE_PAWN]}
     assume f(r1) == {flag:false,rows:[{colour:false,kind:0}]}
diff --git a/tests/valid/ListAssign_Valid_5.whiley b/tests/valid/ListAssign_Valid_5.whiley
index 8f09bee46..1a72eebe8 100644
--- a/tests/valid/ListAssign_Valid_5.whiley
+++ b/tests/valid/ListAssign_Valid_5.whiley
@@ -11,7 +11,7 @@ requires to + 1 < |list[to]|:
     list[to][to + 1] = tmp
     return list
 
-public export method test() -> void:
+public export method test() :
     nint[][] ls = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
     ls = move(0, 1, ls)
     assume ls == [[1, null, 3], [4, 5, 2], [7, 8, 9]]
diff --git a/tests/valid/ListAssign_Valid_6.whiley b/tests/valid/ListAssign_Valid_6.whiley
index 7584d91c0..70299a7b5 100644
--- a/tests/valid/ListAssign_Valid_6.whiley
+++ b/tests/valid/ListAssign_Valid_6.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int[] arr1 = [1, 2, 4]
     int[] arr2 = arr1
     arr2[2] = 3
diff --git a/tests/valid/ListAssign_Valid_7.whiley b/tests/valid/ListAssign_Valid_7.whiley
index dbec8669c..b68e479b0 100644
--- a/tests/valid/ListAssign_Valid_7.whiley
+++ b/tests/valid/ListAssign_Valid_7.whiley
@@ -10,6 +10,6 @@ function f(int i) -> {int[] f1,int[] f2}:
     assert arr2[2] == |arr1|
     return {f1: arr1, f2: arr2}
 
-public export method test() -> void:
+public export method test() :
     assume f(2) == {f1: [1, 2, 64], f2: [1, 2, 3]}
     assume f(3) == {f1: [1, 2, 64], f2: [1, 2, 3]}
diff --git a/tests/valid/ListAssign_Valid_8.whiley b/tests/valid/ListAssign_Valid_8.whiley
index 54a157b64..45a12d468 100644
--- a/tests/valid/ListAssign_Valid_8.whiley
+++ b/tests/valid/ListAssign_Valid_8.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int[][] a1 = [[1, 2, 3], [0]]
     int[][] a2 = a1
     a2[0] = [3, 4, 5]
diff --git a/tests/valid/ListAssign_Valid_9.whiley b/tests/valid/ListAssign_Valid_9.whiley
index 39e4d5738..8481f6d9a 100644
--- a/tests/valid/ListAssign_Valid_9.whiley
+++ b/tests/valid/ListAssign_Valid_9.whiley
@@ -6,7 +6,7 @@ ensures |rs| > 1:
     //
     return [1, 2]
 
-public export method test() -> void:
+public export method test() :
     int[] a1 = f()
     int[] a2 = f()
     a2[0] = 0
diff --git a/tests/valid/ListConversion_Valid_1.whiley b/tests/valid/ListConversion_Valid_1.whiley
index acf1d226a..0965cef91 100644
--- a/tests/valid/ListConversion_Valid_1.whiley
+++ b/tests/valid/ListConversion_Valid_1.whiley
@@ -3,6 +3,6 @@
 function f(real[] ls) -> real[]:
     return ls
 
-public export method test() -> void:
+public export method test() :
     int[] ls = [1,2,3]
     assume f((real[]) ls) == [1.0,2.0,3.0]
diff --git a/tests/valid/ListEmpty_Valid_1.whiley b/tests/valid/ListEmpty_Valid_1.whiley
index b91487a4d..b592794e1 100644
--- a/tests/valid/ListEmpty_Valid_1.whiley
+++ b/tests/valid/ListEmpty_Valid_1.whiley
@@ -3,6 +3,6 @@
 function f(int[] xs) -> int[]:
     return xs
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 4]) == [1,4]
     assume f([0;0]) == [0;0]
diff --git a/tests/valid/ListEquals_Valid_1.whiley b/tests/valid/ListEquals_Valid_1.whiley
index aaa219f45..2ac166e0c 100644
--- a/tests/valid/ListEquals_Valid_1.whiley
+++ b/tests/valid/ListEquals_Valid_1.whiley
@@ -6,7 +6,7 @@ function f(int[] xs, real[] ys) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 4], [1.0, 4.0]) == true
     assume f([1, 4], [1.0, 4.2]) == false
     assume f([0;0], [0.0;0]) == true
diff --git a/tests/valid/ListGenerator_Valid_1.whiley b/tests/valid/ListGenerator_Valid_1.whiley
index 3d030fa6e..477942c3b 100644
--- a/tests/valid/ListGenerator_Valid_1.whiley
+++ b/tests/valid/ListGenerator_Valid_1.whiley
@@ -7,6 +7,6 @@ requires |x| > 0:
     int z = |x|
     return x[z-1]
 
-public export method test() -> void:
+public export method test() :
     int[] arr = [1, 2, 3]
     assume f(arr) == 3
diff --git a/tests/valid/ListGenerator_Valid_2.whiley b/tests/valid/ListGenerator_Valid_2.whiley
index 93b86bedf..f342cc065 100644
--- a/tests/valid/ListGenerator_Valid_2.whiley
+++ b/tests/valid/ListGenerator_Valid_2.whiley
@@ -1,9 +1,9 @@
 
 
-method f(int[] x) -> void:
+method f(int[] x) :
     int z = |x|
     assume x[z - 1] == 3
 
-public export method test() -> void:
+public export method test() :
     int[] arr = [1, 2, 3]
     f(arr)
diff --git a/tests/valid/ListGenerator_Valid_3.whiley b/tests/valid/ListGenerator_Valid_3.whiley
index f1fa3d758..0c32836fb 100644
--- a/tests/valid/ListGenerator_Valid_3.whiley
+++ b/tests/valid/ListGenerator_Valid_3.whiley
@@ -9,6 +9,6 @@ requires |x| > 0:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     int[][] arr = [[1, 2, 3], [1]]
     assume f(arr) == 2
diff --git a/tests/valid/ListGenerator_Valid_5.whiley b/tests/valid/ListGenerator_Valid_5.whiley
index 0009ef317..497a7b326 100644
--- a/tests/valid/ListGenerator_Valid_5.whiley
+++ b/tests/valid/ListGenerator_Valid_5.whiley
@@ -3,6 +3,6 @@
 function f(int[] x) -> int:
     return |x|
 
-public export method test() -> void:
+public export method test() :
     int[] arr = [0;0]
     assume f(arr) == 0
diff --git a/tests/valid/ListLength_Valid_1.whiley b/tests/valid/ListLength_Valid_1.whiley
index b0e46fe9a..409676d20 100644
--- a/tests/valid/ListLength_Valid_1.whiley
+++ b/tests/valid/ListLength_Valid_1.whiley
@@ -5,6 +5,6 @@ type nat is (int x) where x >= 0
 function f(int[] xs) -> nat:
     return |xs|
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3]) == 3
     assume f([0;0]) == 0
diff --git a/tests/valid/ListLength_Valid_2.whiley b/tests/valid/ListLength_Valid_2.whiley
index 17d7ae5e3..c2c61eef4 100644
--- a/tests/valid/ListLength_Valid_2.whiley
+++ b/tests/valid/ListLength_Valid_2.whiley
@@ -1,3 +1,3 @@
-public export method test() -> void:
+public export method test() :
     int[] arr = [1, 2, 3]
     assert |arr| == 3
diff --git a/tests/valid/ListLength_Valid_3.whiley b/tests/valid/ListLength_Valid_3.whiley
index 4b8c4cdb7..4c81e6367 100644
--- a/tests/valid/ListLength_Valid_3.whiley
+++ b/tests/valid/ListLength_Valid_3.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int[] arr = [1, 2, 3]
     assert arr[0] < |arr|
     assert arr[1] < |arr|
diff --git a/tests/valid/MessageRef_Valid_1.whiley b/tests/valid/MessageRef_Valid_1.whiley
index 4dbf497ff..77e1a5962 100644
--- a/tests/valid/MessageRef_Valid_1.whiley
+++ b/tests/valid/MessageRef_Valid_1.whiley
@@ -10,7 +10,7 @@ method read(MyProc this, int x) -> int:
 public export method test(MyMeth m, MyProc proc) -> int:
     return m(proc,1)
 
-public export method test() -> void:
+public export method test() :
     MyProc p = new {position: 0}
     int r = test(&read, p)
     assume r == 124
diff --git a/tests/valid/MessageRef_Valid_2.whiley b/tests/valid/MessageRef_Valid_2.whiley
index 91fef2e13..2b23331e2 100644
--- a/tests/valid/MessageRef_Valid_2.whiley
+++ b/tests/valid/MessageRef_Valid_2.whiley
@@ -15,7 +15,7 @@ method openReader() -> Reader:
     FileReader proc = new {position: 123}
     return {thus: proc, read: &read}
 
-public export method test() -> void:
+public export method test() :
     Reader reader = openReader()
     FileReader target = reader.thus
     int data = reader.read(target, 1)
diff --git a/tests/valid/MessageSend_Valid_1.whiley b/tests/valid/MessageSend_Valid_1.whiley
index b118c04c5..0fbb2a4a9 100644
--- a/tests/valid/MessageSend_Valid_1.whiley
+++ b/tests/valid/MessageSend_Valid_1.whiley
@@ -2,10 +2,10 @@
 
 type MyObject is &{int field}
 
-method f(MyObject this, int x) -> void:
+method f(MyObject this, int x) :
     assume x == 1
 
-public export method test() -> void:
+public export method test() :
     MyObject m = new {field: 1}
     f(m,1)
     
diff --git a/tests/valid/MessageSend_Valid_2.whiley b/tests/valid/MessageSend_Valid_2.whiley
index f5b78f161..b1dd660be 100644
--- a/tests/valid/MessageSend_Valid_2.whiley
+++ b/tests/valid/MessageSend_Valid_2.whiley
@@ -8,6 +8,6 @@ method get(Proc this) -> int:
 method f(Proc x) -> int:
     return get(x)
 
-public export method test() -> void:
+public export method test() :
     Proc proc = new {state: 123}
     assume f(proc) == 123
diff --git a/tests/valid/MessageSend_Valid_3.whiley b/tests/valid/MessageSend_Valid_3.whiley
index 7c70df391..208cda363 100644
--- a/tests/valid/MessageSend_Valid_3.whiley
+++ b/tests/valid/MessageSend_Valid_3.whiley
@@ -8,6 +8,6 @@ method get(Proc this) -> int:
 method f(Proc x) -> int[]:
     return [1, 2, 3, get(x)]
 
-public export method test() -> void:
+public export method test() :
     Proc proc = new {state: 1}
     assume f(proc) == [1,2,3,1]
diff --git a/tests/valid/MessageSend_Valid_4.whiley b/tests/valid/MessageSend_Valid_4.whiley
index 6f879e594..3ec5bc69b 100644
--- a/tests/valid/MessageSend_Valid_4.whiley
+++ b/tests/valid/MessageSend_Valid_4.whiley
@@ -10,6 +10,6 @@ method get(Proc this) -> int:
 method f(Proc x, int y) -> wmcr6tup:
     return {y: get(x), x: y}
 
-public export method test() -> void:
+public export method test() :
     Proc proc = new {state: 1}
     assume f(proc, 2) == {y: 1, x: 2}
diff --git a/tests/valid/MessageSend_Valid_5.whiley b/tests/valid/MessageSend_Valid_5.whiley
index f10271ab0..6c3a585f8 100644
--- a/tests/valid/MessageSend_Valid_5.whiley
+++ b/tests/valid/MessageSend_Valid_5.whiley
@@ -2,7 +2,7 @@
 
 type Sum is &{int result, int[] items}
 
-method start(Sum this) -> void:
+method start(Sum this) :
     int sum = 0
     int i = 0
     int[] items = this->items
@@ -17,7 +17,7 @@ method get(Sum this) -> int:
 method create(int[] items) -> Sum:
     return new {result: 0, items: items}
 
-public export method test() -> void:
+public export method test() :
     int[] data = [1, 3, 5, 7, 3, 198, 1, 4, 6]
     Sum sum = create(data)
     start(sum)
diff --git a/tests/valid/MethodCall_Valid_1.whiley b/tests/valid/MethodCall_Valid_1.whiley
index 81294bad6..9329f5d0a 100644
--- a/tests/valid/MethodCall_Valid_1.whiley
+++ b/tests/valid/MethodCall_Valid_1.whiley
@@ -1,7 +1,7 @@
 
 
-method f(int x) -> void:
+method f(int x) :
     skip
 
-public export method test() -> void:
+public export method test() :
     f(1)
diff --git a/tests/valid/MethodCall_Valid_2.whiley b/tests/valid/MethodCall_Valid_2.whiley
index 147befb3d..016927d1a 100644
--- a/tests/valid/MethodCall_Valid_2.whiley
+++ b/tests/valid/MethodCall_Valid_2.whiley
@@ -6,6 +6,6 @@ method get() -> int:
 method f() -> int[]:
     return [1, 2, 3, get()]
 
-public export method test() -> void:
+public export method test() :
     &{int state} proc = new {state: 1}
     assume f() == [1,2,3,1]
diff --git a/tests/valid/MethodCall_Valid_3.whiley b/tests/valid/MethodCall_Valid_3.whiley
index e8d9a8231..783181025 100644
--- a/tests/valid/MethodCall_Valid_3.whiley
+++ b/tests/valid/MethodCall_Valid_3.whiley
@@ -8,5 +8,5 @@ method get() -> int:
 method f(int y) -> wmcr6tup:
     return {y: get(), x: y}
 
-public export method test() -> void:
+public export method test() :
     assume f(2) == {y: 1, x: 2}
diff --git a/tests/valid/MethodCall_Valid_4.whiley b/tests/valid/MethodCall_Valid_4.whiley
index eab803134..8f0c88441 100644
--- a/tests/valid/MethodCall_Valid_4.whiley
+++ b/tests/valid/MethodCall_Valid_4.whiley
@@ -1,6 +1,6 @@
 type Sum is &{int result, int[] items}
 
-method start(Sum this) -> void:
+method start(Sum this) :
     int sum = 0
     int i = 0
     int[] items = this->items
@@ -33,7 +33,7 @@ type pst is method (int[])->int
 method sum(pst m, int[] data) -> int:
     return m(data)
 
-public export method test() -> void:
+public export method test() :
     int[] data = [1, 3, 5, 7, 3, 93, 1, 4, 6]
     int s1 = sum(&parSum, data)
     assume s1 == 123
diff --git a/tests/valid/MethodRef_Valid_1.whiley b/tests/valid/MethodRef_Valid_1.whiley
index becce9e7b..0abd10789 100644
--- a/tests/valid/MethodRef_Valid_1.whiley
+++ b/tests/valid/MethodRef_Valid_1.whiley
@@ -8,6 +8,6 @@ method read(int x) -> int:
 public export method test(MyMeth m) -> int:
     return m(1)
 
-public export method test() -> void:
+public export method test() :
     int r = test(&read)
     assume r == 124
diff --git a/tests/valid/MethodRef_Valid_2.whiley b/tests/valid/MethodRef_Valid_2.whiley
index 1a99c2541..f06ee8cab 100644
--- a/tests/valid/MethodRef_Valid_2.whiley
+++ b/tests/valid/MethodRef_Valid_2.whiley
@@ -10,7 +10,7 @@ method f(int amount) -> int:
 method m(Reader r, int x) -> int:
     return r.read(x)
 
-public export method test() -> void:
+public export method test() :
     Reader reader = {read: &f}
     int data = m(reader, 1)
     assume data == 1
diff --git a/tests/valid/Method_Valid_1.whiley b/tests/valid/Method_Valid_1.whiley
index 929aeb4ed..d8b55878e 100644
--- a/tests/valid/Method_Valid_1.whiley
+++ b/tests/valid/Method_Valid_1.whiley
@@ -25,7 +25,7 @@ method update(Board b) -> Board:
     b[0] = CIRCLE
     return b
 
-public export method test() -> void:
+public export method test() :
     Board b = EmptyBoard()
     b = update(b)
     assume b == [2, 1, 0, 0, 0, 0, 0, 0, 0]
diff --git a/tests/valid/MultiLineComment_Valid_1.whiley b/tests/valid/MultiLineComment_Valid_1.whiley
index 67bbdb38e..60cc9ef79 100644
--- a/tests/valid/MultiLineComment_Valid_1.whiley
+++ b/tests/valid/MultiLineComment_Valid_1.whiley
@@ -3,5 +3,5 @@
 /**
  * This is a multiline comment
  */
-public export method test() -> void:
+public export method test() :
     assert true == true
diff --git a/tests/valid/MultiLineComment_Valid_2.whiley b/tests/valid/MultiLineComment_Valid_2.whiley
index e3beba52f..670fea0d4 100644
--- a/tests/valid/MultiLineComment_Valid_2.whiley
+++ b/tests/valid/MultiLineComment_Valid_2.whiley
@@ -1,4 +1,4 @@
 
 
-public export method test() -> void:
+public export method test() :
     assert 5 == 5 /* a comment */
diff --git a/tests/valid/NegationType_Valid_1.whiley b/tests/valid/NegationType_Valid_1.whiley
index 9da737042..c6286ae80 100644
--- a/tests/valid/NegationType_Valid_1.whiley
+++ b/tests/valid/NegationType_Valid_1.whiley
@@ -6,6 +6,6 @@ function f(any x) -> !null:
     else:
         return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
     assume f([1, 2, 3]) == [1,2,3]
diff --git a/tests/valid/NegationType_Valid_2.whiley b/tests/valid/NegationType_Valid_2.whiley
index 977057dc1..6d52c0dee 100644
--- a/tests/valid/NegationType_Valid_2.whiley
+++ b/tests/valid/NegationType_Valid_2.whiley
@@ -3,5 +3,5 @@
 function f(int x) -> !null:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
diff --git a/tests/valid/NegationType_Valid_3.whiley b/tests/valid/NegationType_Valid_3.whiley
index 0273cfcbc..948091afa 100644
--- a/tests/valid/NegationType_Valid_3.whiley
+++ b/tests/valid/NegationType_Valid_3.whiley
@@ -3,5 +3,5 @@
 function f(int[] x) -> !null & !int:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f("Hello World") == "Hello World"
diff --git a/tests/valid/NegationType_Valid_4.whiley b/tests/valid/NegationType_Valid_4.whiley
index 0166747b5..a7e5e9307 100644
--- a/tests/valid/NegationType_Valid_4.whiley
+++ b/tests/valid/NegationType_Valid_4.whiley
@@ -3,5 +3,5 @@
 function f(int[] x) -> !null | int:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f("Hello World") == "Hello World"
diff --git a/tests/valid/OpenRecord_Valid_1.whiley b/tests/valid/OpenRecord_Valid_1.whiley
index 7451bca1b..a5b68ad79 100644
--- a/tests/valid/OpenRecord_Valid_1.whiley
+++ b/tests/valid/OpenRecord_Valid_1.whiley
@@ -5,7 +5,7 @@ type OpenRecord is {int field, ...}
 function getField(OpenRecord r) -> int:
     return r.field
 
-public export method test() -> void:
+public export method test() :
     OpenRecord r = {field: 1}
     assume getField(r) == 1
     r = {field: 2, x: "hello"}
diff --git a/tests/valid/OpenRecord_Valid_10.whiley b/tests/valid/OpenRecord_Valid_10.whiley
index 85b8b4b81..08f2747fe 100644
--- a/tests/valid/OpenRecord_Valid_10.whiley
+++ b/tests/valid/OpenRecord_Valid_10.whiley
@@ -11,7 +11,7 @@ function match(Attribute attr) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     Attribute r = {name: "Hello"}
     assume match(r) == false
     r = {maxLocals: 0, maxStack: 0, name: "Code", data: [0b;0]}
diff --git a/tests/valid/OpenRecord_Valid_2.whiley b/tests/valid/OpenRecord_Valid_2.whiley
index 78692735d..a75822f62 100644
--- a/tests/valid/OpenRecord_Valid_2.whiley
+++ b/tests/valid/OpenRecord_Valid_2.whiley
@@ -25,7 +25,7 @@ function codeLength(Attribute a) -> null | int:
         return |a.data|
     return null
 
-public export method test() -> void:
+public export method test() :
     Attribute attr = {name: "Code", data: [{op: 2, offset: 1}]}
     assume codeLength(attr) == 1
     attr = {name: "Blah"}
diff --git a/tests/valid/OpenRecord_Valid_3.whiley b/tests/valid/OpenRecord_Valid_3.whiley
index 45100ae06..e77851fac 100644
--- a/tests/valid/OpenRecord_Valid_3.whiley
+++ b/tests/valid/OpenRecord_Valid_3.whiley
@@ -11,6 +11,6 @@ public function myFn(Object o) -> int:
 public function get(Object o) -> int:
     return o.fn(o)
 
-public export method test() -> void:
+public export method test() :
     Object o = {fn: &myFn}
     assume get(o) == 123
diff --git a/tests/valid/OpenRecord_Valid_4.whiley b/tests/valid/OpenRecord_Valid_4.whiley
index f01f595e1..e63101afc 100644
--- a/tests/valid/OpenRecord_Valid_4.whiley
+++ b/tests/valid/OpenRecord_Valid_4.whiley
@@ -11,7 +11,7 @@ function getField(OpenRecord r) -> int:
         else:
             return -r.x
 
-public export method test() -> void:
+public export method test() :
     OpenRecord r = {x: 1}
     assume getField(r) == 1
     r = {y: 1, x: 3}
diff --git a/tests/valid/OpenRecord_Valid_5.whiley b/tests/valid/OpenRecord_Valid_5.whiley
index 6109caeb9..d50fa1804 100644
--- a/tests/valid/OpenRecord_Valid_5.whiley
+++ b/tests/valid/OpenRecord_Valid_5.whiley
@@ -15,7 +15,7 @@ function sum(VecPoint vp) -> int:
             i = i + 1
         return r
 
-public export method test() -> void:
+public export method test() :
     VecPoint vp = {y: 2, x: 1}
     assume sum(vp) == 3
     vp = [{y: 2, x: 1}, {y: 4, x: -1}]
diff --git a/tests/valid/OpenRecord_Valid_6.whiley b/tests/valid/OpenRecord_Valid_6.whiley
index acd93b65c..a9e231e11 100644
--- a/tests/valid/OpenRecord_Valid_6.whiley
+++ b/tests/valid/OpenRecord_Valid_6.whiley
@@ -15,7 +15,7 @@ function sum(VecPoint vp) -> int:
     else:
         return vp.x + vp.y
 
-public export method test() -> void:
+public export method test() :
     VecPoint vp = {y: 2, x: 1}
     assume sum(vp) == 3
     vp = [{y: 2, x: 1}, {y: 5, x: -10}]
diff --git a/tests/valid/OpenRecord_Valid_7.whiley b/tests/valid/OpenRecord_Valid_7.whiley
index b97884ccc..0f5d7fd76 100644
--- a/tests/valid/OpenRecord_Valid_7.whiley
+++ b/tests/valid/OpenRecord_Valid_7.whiley
@@ -12,7 +12,7 @@ function sum(Point vp) -> real:
     else:
         return vp.x + vp.y
 
-public export method test() -> void:
+public export method test() :
     Point vp = {y: 2, x: 1}
     assume sum(vp) == 3.0
     vp = {y: 2.34, x: 1.23}
diff --git a/tests/valid/OpenRecord_Valid_8.whiley b/tests/valid/OpenRecord_Valid_8.whiley
index fb17c06dd..e17698b63 100644
--- a/tests/valid/OpenRecord_Valid_8.whiley
+++ b/tests/valid/OpenRecord_Valid_8.whiley
@@ -10,7 +10,7 @@ function sum(Point vp) -> real:
     RealPoint rp = (RealPoint) vp
     return rp.x + rp.y
 
-public export method test() -> void:
+public export method test() :
     Point vp = {y: 2, x: 1}
     assume sum(vp) == 3.0
     vp = {y: 2.34, x: 1.23}
diff --git a/tests/valid/OpenRecord_Valid_9.whiley b/tests/valid/OpenRecord_Valid_9.whiley
index de65c819b..4ae0f3a31 100644
--- a/tests/valid/OpenRecord_Valid_9.whiley
+++ b/tests/valid/OpenRecord_Valid_9.whiley
@@ -17,7 +17,7 @@ function sum(Point vp) -> real:
         else:
             return (real) (vp.x + vp.y)
 
-public export method test() -> void:
+public export method test() :
     Point vp = {y: 2, x: 1}
     assume sum(vp) == 3.0
     vp = {z: 2, y: 2, x: 1}
diff --git a/tests/valid/ProcessAccess_Valid_1.whiley b/tests/valid/ProcessAccess_Valid_1.whiley
index dbb32419e..e76b48364 100644
--- a/tests/valid/ProcessAccess_Valid_1.whiley
+++ b/tests/valid/ProcessAccess_Valid_1.whiley
@@ -6,7 +6,7 @@ method get(Ptype this) -> int:
     this->rest = 123
     return this->mode
 
-public export method test() -> void:
+public export method test() :
     Ptype p = new {rest: 2, mode: 2}
     assume (*p) == {rest: 2, mode: 2}
     int x = get(p)
diff --git a/tests/valid/ProcessAccess_Valid_2.whiley b/tests/valid/ProcessAccess_Valid_2.whiley
index 27684b0ac..3176f7fd6 100644
--- a/tests/valid/ProcessAccess_Valid_2.whiley
+++ b/tests/valid/ProcessAccess_Valid_2.whiley
@@ -2,11 +2,11 @@ type state is {int y, int x}
 
 type pState is &state
 
-method send(pState this, int z) -> void:
+method send(pState this, int z) :
     assume this->x == 1
     assume this->y == 2
     assume z == 1
 
-public export method test() -> void:
+public export method test() :
     pState ps = new {y: 2, x: 1}
     send(ps,1)
diff --git a/tests/valid/Process_Valid_1.whiley b/tests/valid/Process_Valid_1.whiley
index 42db55a82..6b9c87512 100644
--- a/tests/valid/Process_Valid_1.whiley
+++ b/tests/valid/Process_Valid_1.whiley
@@ -4,11 +4,11 @@ type state is {int y, int x}
 
 type pState is &state
 
-method send(pState this, int x) -> void:
+method send(pState this, int x) :
     this->x = x
     assert this->x == x
     assume (*this) == {x: 3, y: 2}
 
-public export method test() -> void:
+public export method test() :
     pState ps = new {y: 2, x: 1}
     send(ps, 3)
diff --git a/tests/valid/Process_Valid_10.whiley b/tests/valid/Process_Valid_10.whiley
index d042d0e5a..519ece427 100644
--- a/tests/valid/Process_Valid_10.whiley
+++ b/tests/valid/Process_Valid_10.whiley
@@ -6,14 +6,14 @@ method get(&Queue this) -> int:
     this->length = this->length - 1
     return this->items[this->length]
 
-method put(&Queue this, int item) -> void:
+method put(&Queue this, int item) :
     this->items[this->length] = item
     this->length = this->length + 1
 
 method isEmpty(&Queue this) -> bool:
     return this->length == 0
 
-public export method test() -> void:
+public export method test() :
     int[] items = [1, 2, 3, 4, 5]
     &Queue q = new {items: [0,0,0,0,0], length: 0}
     // Put items into the queue    
diff --git a/tests/valid/Process_Valid_11.whiley b/tests/valid/Process_Valid_11.whiley
index 6cd801cd5..bbc7f6ccf 100644
--- a/tests/valid/Process_Valid_11.whiley
+++ b/tests/valid/Process_Valid_11.whiley
@@ -7,6 +7,6 @@ type pState is &state
 method send2(pState this, int x) -> int:
     return this->x + this->y
 
-public export method test() -> void:
+public export method test() :
     int x = send2(new {y: 2, x: 1},1)
     assume x == 3
diff --git a/tests/valid/Process_Valid_12.whiley b/tests/valid/Process_Valid_12.whiley
index 4307eb4cd..9c694dfe7 100644
--- a/tests/valid/Process_Valid_12.whiley
+++ b/tests/valid/Process_Valid_12.whiley
@@ -7,6 +7,6 @@ type pState is &state
 method send2(pState this, int x) -> int:
     return this->x + this->y
 
-public export method test() -> void:
+public export method test() :
     int x = send2(new {y: 2, x: 1},1)
     assume x == 3
diff --git a/tests/valid/Process_Valid_2.whiley b/tests/valid/Process_Valid_2.whiley
index 2e5ac031e..5c15bcca1 100644
--- a/tests/valid/Process_Valid_2.whiley
+++ b/tests/valid/Process_Valid_2.whiley
@@ -1,5 +1,5 @@
 
 
-public export method test() -> void:
+public export method test() :
     int out = 1
     assume out == 1
diff --git a/tests/valid/Process_Valid_3.whiley b/tests/valid/Process_Valid_3.whiley
index 00a7bc312..31c5ce7c9 100644
--- a/tests/valid/Process_Valid_3.whiley
+++ b/tests/valid/Process_Valid_3.whiley
@@ -2,5 +2,5 @@
 
 constant out is 123.456
 
-public export method test() -> void:
+public export method test() :
     assume out == 123.456
diff --git a/tests/valid/Process_Valid_4.whiley b/tests/valid/Process_Valid_4.whiley
index b18270280..882c1a2c9 100644
--- a/tests/valid/Process_Valid_4.whiley
+++ b/tests/valid/Process_Valid_4.whiley
@@ -2,10 +2,10 @@
 
 type MyProc is &{int x}
 
-method inc(MyProc this, int i) -> void:
+method inc(MyProc this, int i) :
     this->x = this->x + i
 
-public export method test() -> void:
+public export method test() :
     MyProc mproc = new {x: 1}
     inc(mproc, 10)
     assume mproc->x == 11
diff --git a/tests/valid/Process_Valid_5.whiley b/tests/valid/Process_Valid_5.whiley
index 151cd107d..704d1647d 100644
--- a/tests/valid/Process_Valid_5.whiley
+++ b/tests/valid/Process_Valid_5.whiley
@@ -8,7 +8,7 @@ method run(MyProc this) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     MyProc mproc = new {flag: false}
     assume run(mproc) == false
     mproc = new {flag: true}
diff --git a/tests/valid/Process_Valid_6.whiley b/tests/valid/Process_Valid_6.whiley
index f3a41b149..02b7c048e 100644
--- a/tests/valid/Process_Valid_6.whiley
+++ b/tests/valid/Process_Valid_6.whiley
@@ -16,7 +16,7 @@ requires n >= 0:
         j = j + 1
     return row
 
-public export method test() -> void:
+public export method test() :
     (&Actor)[] actors = createActors(10)
     int r = 0
     //
diff --git a/tests/valid/Process_Valid_7.whiley b/tests/valid/Process_Valid_7.whiley
index dba4da35b..5600c7dbc 100644
--- a/tests/valid/Process_Valid_7.whiley
+++ b/tests/valid/Process_Valid_7.whiley
@@ -2,7 +2,7 @@
 
 type MyProc2 is &{any data}
 
-method set(MyProc2 this, int d) -> void:
+method set(MyProc2 this, int d) :
     this->data = d
 
 method get(MyProc2 this) -> any:
@@ -11,7 +11,7 @@ method get(MyProc2 this) -> any:
 method create(any data) -> MyProc2:
     return new {data: data}
 
-public export method test() -> void:
+public export method test() :
     MyProc2 p2 = create(1.23)
     set(p2,1)
     assume get(p2) == 1
diff --git a/tests/valid/Process_Valid_8.whiley b/tests/valid/Process_Valid_8.whiley
index 49e97e8d1..47970b2f8 100644
--- a/tests/valid/Process_Valid_8.whiley
+++ b/tests/valid/Process_Valid_8.whiley
@@ -2,7 +2,7 @@
 
 type MyProc2 is {any data}
 
-method set(&MyProc2 this, int d) -> void:
+method set(&MyProc2 this, int d) :
     this->data = d
 
 method get(&MyProc2 this) -> any:
@@ -11,7 +11,7 @@ method get(&MyProc2 this) -> any:
 method create(any data) -> &MyProc2:
     return new {data: data}
 
-public export method test() -> void:
+public export method test() :
     &MyProc2 p2 = create(1.23)
     set(p2,1)
     assume get(p2) == 1
diff --git a/tests/valid/Process_Valid_9.whiley b/tests/valid/Process_Valid_9.whiley
index b8e6be8f2..40116c435 100644
--- a/tests/valid/Process_Valid_9.whiley
+++ b/tests/valid/Process_Valid_9.whiley
@@ -4,7 +4,7 @@ method get(&Queue this) -> int:
     this->length = this->length - 1
     return this->items[this->length]
 
-method put(&Queue this, int item) -> void:
+method put(&Queue this, int item) :
     this->items[this->length] = item
     this->length = this->length + 1
 
@@ -16,7 +16,7 @@ method Queue(int capacity) -> &Queue:
     //
     return new {items: slots, length: 0}
 
-public export method test() -> void:
+public export method test() :
     int[] items = [1, 2, 3, 4, 5]
     &Queue q = Queue(5)
     // Put items into the queue    
diff --git a/tests/valid/Quantifiers_Valid_1.whiley b/tests/valid/Quantifiers_Valid_1.whiley
index 19c812766..2bf659613 100644
--- a/tests/valid/Quantifiers_Valid_1.whiley
+++ b/tests/valid/Quantifiers_Valid_1.whiley
@@ -4,7 +4,7 @@ function f(int[] xs) -> int[]
 requires no { i in 0..|xs| | xs[i] < 0 }:
     return xs
 
-public export method test() -> void:
+public export method test() :
     int[] ys = [1, 2, 3]
     int[] zs = ys
     assume f(zs) == [1,2,3]
diff --git a/tests/valid/RealConst_Valid_1.whiley b/tests/valid/RealConst_Valid_1.whiley
index c7a31aa7f..5ec6a575d 100644
--- a/tests/valid/RealConst_Valid_1.whiley
+++ b/tests/valid/RealConst_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     real x = 12376523476123.98712345
     x = x + 0.002348976
     assume x == 12376523476123.989472426
diff --git a/tests/valid/RealDiv_Valid_1.whiley b/tests/valid/RealDiv_Valid_1.whiley
index 0f019247e..0f51e5aee 100644
--- a/tests/valid/RealDiv_Valid_1.whiley
+++ b/tests/valid/RealDiv_Valid_1.whiley
@@ -7,5 +7,5 @@ function f(int x, int y) -> real
 requires (x >= 0) && (y > 0):
     return g(x)
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 2) == (1.0/3.0)
diff --git a/tests/valid/RealDiv_Valid_2.whiley b/tests/valid/RealDiv_Valid_2.whiley
index a160b2e39..6001dbb4e 100644
--- a/tests/valid/RealDiv_Valid_2.whiley
+++ b/tests/valid/RealDiv_Valid_2.whiley
@@ -6,5 +6,5 @@ function g(int x) -> real:
 function f(int x, int y) -> real:
     return g(x)
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 2) == (1.0/3.123)
diff --git a/tests/valid/RealDiv_Valid_3.whiley b/tests/valid/RealDiv_Valid_3.whiley
index 0f019247e..0f51e5aee 100644
--- a/tests/valid/RealDiv_Valid_3.whiley
+++ b/tests/valid/RealDiv_Valid_3.whiley
@@ -7,5 +7,5 @@ function f(int x, int y) -> real
 requires (x >= 0) && (y > 0):
     return g(x)
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 2) == (1.0/3.0)
diff --git a/tests/valid/RealDiv_Valid_4.whiley b/tests/valid/RealDiv_Valid_4.whiley
index 473c0c62d..3d44caf65 100644
--- a/tests/valid/RealDiv_Valid_4.whiley
+++ b/tests/valid/RealDiv_Valid_4.whiley
@@ -6,5 +6,5 @@ function g(int x) -> real:
 function f(int x, int y) -> real:
     return g(x)
 
-public export method test() -> void:
+public export method test() :
     assume f(1, 2) == 0.0
diff --git a/tests/valid/RealDiv_Valid_5.whiley b/tests/valid/RealDiv_Valid_5.whiley
index 2ac12eb7b..f6d4b09ac 100644
--- a/tests/valid/RealDiv_Valid_5.whiley
+++ b/tests/valid/RealDiv_Valid_5.whiley
@@ -6,5 +6,5 @@ ensures y <= 0.166666666666668:
     //
     return x / 3.0
 
-public export method test() -> void:
+public export method test() :
     assume g(0.234) == (0.234/3.0)
diff --git a/tests/valid/RealDiv_Valid_6.whiley b/tests/valid/RealDiv_Valid_6.whiley
index f0a137b26..d006b226c 100644
--- a/tests/valid/RealDiv_Valid_6.whiley
+++ b/tests/valid/RealDiv_Valid_6.whiley
@@ -3,5 +3,5 @@
 function g(real x) -> real:
     return x / 3.0
 
-public export method test() -> void:
+public export method test() :
     assume g(0.234) == (0.468/6.0)
diff --git a/tests/valid/RealDiv_Valid_7.whiley b/tests/valid/RealDiv_Valid_7.whiley
index ada8f964d..945ef511a 100644
--- a/tests/valid/RealDiv_Valid_7.whiley
+++ b/tests/valid/RealDiv_Valid_7.whiley
@@ -5,7 +5,7 @@ requires y != 0.0 && z != 0.0:
     //
     return (x / y) / z
 
-public export method test() -> void:
+public export method test() :
     assume diver(1.2, 3.4, 4.5) == (4.0/51.0)
     assume diver(1000.0, 300.0, 400.0) == (1.0/120.0)
 
diff --git a/tests/valid/RealNeg_Valid_1.whiley b/tests/valid/RealNeg_Valid_1.whiley
index 619065107..29cdb3237 100644
--- a/tests/valid/RealNeg_Valid_1.whiley
+++ b/tests/valid/RealNeg_Valid_1.whiley
@@ -5,7 +5,7 @@ requires x > 0.0
 ensures y < 0.0:
     return -x
 
-public export method test() -> void:
+public export method test() :
     assume f(1.2) == -1.2
     assume f(0.00001) == -0.00001
     assume f(5632.0) == -5632.0
diff --git a/tests/valid/RealNeg_Valid_2.whiley b/tests/valid/RealNeg_Valid_2.whiley
index c0bea123b..492e340d3 100644
--- a/tests/valid/RealNeg_Valid_2.whiley
+++ b/tests/valid/RealNeg_Valid_2.whiley
@@ -3,7 +3,7 @@
 function f(real x) -> real:
     return -x
 
-public export method test() -> void:
+public export method test() :
     assume f(1.2) == -1.2
     assume f(0.00001) == -0.00001
     assume f(5632.0) == -5632.0
diff --git a/tests/valid/RealSplit_Valid_1.whiley b/tests/valid/RealSplit_Valid_1.whiley
index 7c1ca9ac0..9a325e02e 100644
--- a/tests/valid/RealSplit_Valid_1.whiley
+++ b/tests/valid/RealSplit_Valid_1.whiley
@@ -6,7 +6,7 @@ function f(real z) -> {int n, int d}:
     x/y = z
     return {n: x, d: y}
 
-public export method test() -> void:
+public export method test() :
     assume f(10.0 / 5.0) == {n: 2, d: 1}
     assume f(10.0 / 4.0) == {n: 5, d: 2}
     assume f(1.0 / 4.0) == {n: 1, d: 4}
diff --git a/tests/valid/RealSub_Valid_1.whiley b/tests/valid/RealSub_Valid_1.whiley
index 77382544d..98ea2ef30 100644
--- a/tests/valid/RealSub_Valid_1.whiley
+++ b/tests/valid/RealSub_Valid_1.whiley
@@ -6,5 +6,5 @@ ensures y < -0.2:
     //
     return 0.0 - x
 
-public export method test() -> void:
+public export method test() :
     assume f(1.234) == -1.234
diff --git a/tests/valid/RealSub_Valid_2.whiley b/tests/valid/RealSub_Valid_2.whiley
index a56091d41..7020365db 100644
--- a/tests/valid/RealSub_Valid_2.whiley
+++ b/tests/valid/RealSub_Valid_2.whiley
@@ -3,5 +3,5 @@
 function f(real x) -> real:
     return 0.0 - x
 
-public export method test() -> void:
+public export method test() :
     assume f(1.234) == -1.234
diff --git a/tests/valid/RealSub_Valid_3.whiley b/tests/valid/RealSub_Valid_3.whiley
index 571133c27..41be2ce47 100644
--- a/tests/valid/RealSub_Valid_3.whiley
+++ b/tests/valid/RealSub_Valid_3.whiley
@@ -3,7 +3,7 @@
 function suber(real x, real y, real z) -> real:
     return (x - y) - z
 
-public export method test() -> void:
+public export method test() :
     assume suber(1.2, 3.4, 4.5) == -6.7
     assume suber(1000.0, 300.0, 400.0) == 300.0
 
diff --git a/tests/valid/Real_Valid_1.whiley b/tests/valid/Real_Valid_1.whiley
index 2e3e27d6f..137b7999b 100644
--- a/tests/valid/Real_Valid_1.whiley
+++ b/tests/valid/Real_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     real x = 1.20
     real y = 2.40
     assume x + y == 3.6
diff --git a/tests/valid/RecordAccess_Valid_1.whiley b/tests/valid/RecordAccess_Valid_1.whiley
index f3e1a1c66..b4b1818fb 100644
--- a/tests/valid/RecordAccess_Valid_1.whiley
+++ b/tests/valid/RecordAccess_Valid_1.whiley
@@ -8,6 +8,6 @@ method get(Ptype this) -> int:
     this->mode = 1
     return this->mode
 
-public export method test() -> void:
+public export method test() :
     assume get(new {mode:2}) == 1
     assume get(new {mode:3,x:1}) == 1
diff --git a/tests/valid/RecordAccess_Valid_2.whiley b/tests/valid/RecordAccess_Valid_2.whiley
index e91e1d8bd..abbf76959 100644
--- a/tests/valid/RecordAccess_Valid_2.whiley
+++ b/tests/valid/RecordAccess_Valid_2.whiley
@@ -10,7 +10,7 @@ function sum(Point vp) -> real:
     RealPoint rp = (RealPoint) vp
     return rp.x + rp.y
 
-public export method test() -> void:
+public export method test() :
     Point vp = {y: 2, x: 1}
     assume sum(vp) == 3.0
     vp = {y: 2.34, x: 1.23}
diff --git a/tests/valid/RecordAssign_Valid_1.whiley b/tests/valid/RecordAssign_Valid_1.whiley
index d408ad478..fa83a8f14 100644
--- a/tests/valid/RecordAssign_Valid_1.whiley
+++ b/tests/valid/RecordAssign_Valid_1.whiley
@@ -5,7 +5,7 @@ type tac1tup is ({int f1, int f2} this) where this.f1 < this.f2
 function f() -> tac1tup:
     return {f1: 2, f2: 3}
 
-public export method test() -> void:
+public export method test() :
     tac1tup x = f()
     x.f1 = x.f2 - 2
     assert x.f1 != x.f2
diff --git a/tests/valid/RecordAssign_Valid_10.whiley b/tests/valid/RecordAssign_Valid_10.whiley
index 4566f0c97..a5bb8dae0 100644
--- a/tests/valid/RecordAssign_Valid_10.whiley
+++ b/tests/valid/RecordAssign_Valid_10.whiley
@@ -6,7 +6,7 @@ function f(int a) -> bytes:
     bytes bs = {b1: a, b2: a + 1}
     return bs
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == {b1: 1, b2: 2}
     assume f(2) == {b1: 2, b2: 3}
     assume f(9) == {b1: 9, b2: 10}
diff --git a/tests/valid/RecordAssign_Valid_2.whiley b/tests/valid/RecordAssign_Valid_2.whiley
index 8fde371bc..efee2e12b 100644
--- a/tests/valid/RecordAssign_Valid_2.whiley
+++ b/tests/valid/RecordAssign_Valid_2.whiley
@@ -5,6 +5,6 @@ function f(rec2 r) -> rec2:
     r.current.x = 1
     return r
 
-public export method test() -> void:
+public export method test() :
     rec2 r = {current: {x: 0}}
     assume f(r) == {current: {x: 1}}
diff --git a/tests/valid/RecordAssign_Valid_3.whiley b/tests/valid/RecordAssign_Valid_3.whiley
index 4e2447cf2..95765fbdb 100644
--- a/tests/valid/RecordAssign_Valid_3.whiley
+++ b/tests/valid/RecordAssign_Valid_3.whiley
@@ -5,7 +5,7 @@ type tac1tup is {int f1, int f2}
 function f() -> tac1tup:
     return {f1: 2, f2: 3}
 
-public export method test() -> void:
+public export method test() :
     tac1tup x = f()
     x.f1 = x.f2 - 2
     assert x.f1 != x.f2
diff --git a/tests/valid/RecordAssign_Valid_4.whiley b/tests/valid/RecordAssign_Valid_4.whiley
index b797513ae..70691fe9f 100644
--- a/tests/valid/RecordAssign_Valid_4.whiley
+++ b/tests/valid/RecordAssign_Valid_4.whiley
@@ -7,7 +7,7 @@ type tac2tb is ({int f1, int f2} this) where (this.f1 + 1) < this.f2
 function f(tac2ta x) -> tac2tb:
     return {f1: x.f1 - 1, f2: x.f2}
 
-public export method test() -> void:
+public export method test() :
     tac2ta x = {f1: 2, f2: 3}
     assume x == {f1: 2, f2: 3}
     x.f1 = 1
diff --git a/tests/valid/RecordAssign_Valid_5.whiley b/tests/valid/RecordAssign_Valid_5.whiley
index 1726d1f73..1aff50ac1 100644
--- a/tests/valid/RecordAssign_Valid_5.whiley
+++ b/tests/valid/RecordAssign_Valid_5.whiley
@@ -7,7 +7,7 @@ type tac2tb is {int f1, int f2}
 function f(tac2ta x) -> tac2tb:
     return {f1: x.f1 - 1, f2: x.f2}
 
-public export method test() -> void:
+public export method test() :
     tac2ta x = {f1: 2, f2: 3}
     assume x == {f1: 2, f2: 3}
     x.f1 = 1
diff --git a/tests/valid/RecordAssign_Valid_6.whiley b/tests/valid/RecordAssign_Valid_6.whiley
index b3f19fb53..262c355e8 100644
--- a/tests/valid/RecordAssign_Valid_6.whiley
+++ b/tests/valid/RecordAssign_Valid_6.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     {int f1, int f2} x = {f1: 2, f2: 3}
     {int f1, int f2} y = {f1: 1, f2: 3}
     assert x != y
diff --git a/tests/valid/RecordAssign_Valid_7.whiley b/tests/valid/RecordAssign_Valid_7.whiley
index de4877b6e..b9032e29c 100644
--- a/tests/valid/RecordAssign_Valid_7.whiley
+++ b/tests/valid/RecordAssign_Valid_7.whiley
@@ -6,7 +6,7 @@ type bytes is {i8 b1, i8 b2}
 function f(i8 b) -> bytes:
     return {b1: b, b2: 2}
 
-public export method test() -> void:
+public export method test() :
     i8 b = 1
     bytes bs = f(b)
     assume bs == {b1: 1, b2: 2}
diff --git a/tests/valid/RecordAssign_Valid_8.whiley b/tests/valid/RecordAssign_Valid_8.whiley
index a96da9488..ce10b7081 100644
--- a/tests/valid/RecordAssign_Valid_8.whiley
+++ b/tests/valid/RecordAssign_Valid_8.whiley
@@ -5,7 +5,7 @@ type bytes is {int b1, int b2}
 function f(int b) -> bytes:
     return {b1: b, b2: 2}
 
-public export method test() -> void:
+public export method test() :
     int b = 1
     bytes bs = f(b)
     assume bs == {b1: 1, b2: 2}
diff --git a/tests/valid/RecordAssign_Valid_9.whiley b/tests/valid/RecordAssign_Valid_9.whiley
index cacf0b7f9..06078e0d6 100644
--- a/tests/valid/RecordAssign_Valid_9.whiley
+++ b/tests/valid/RecordAssign_Valid_9.whiley
@@ -8,7 +8,7 @@ requires a > 0 && a < 10:
     bytes bs = {b1: a, b2: a + 1}
     return bs
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == {b1: 1, b2: 2}
     assume f(2) == {b1: 2, b2: 3}
     assume f(9) == {b1: 9, b2: 10}
diff --git a/tests/valid/RecordCoercion_Valid_1.whiley b/tests/valid/RecordCoercion_Valid_1.whiley
index 20a0a52a1..5cabe37f0 100644
--- a/tests/valid/RecordCoercion_Valid_1.whiley
+++ b/tests/valid/RecordCoercion_Valid_1.whiley
@@ -10,7 +10,7 @@ function f(Rec2 rec) -> int:
     x/y = rec.x
     return x
 
-public export method test() -> void:
+public export method test() :
     Rec1 rec = {x: 1}
     int num = f((Rec2) rec)
     assume num == 1
diff --git a/tests/valid/RecordConversion_Valid_1.whiley b/tests/valid/RecordConversion_Valid_1.whiley
index 35e776d21..02824d170 100644
--- a/tests/valid/RecordConversion_Valid_1.whiley
+++ b/tests/valid/RecordConversion_Valid_1.whiley
@@ -6,6 +6,6 @@ function f(realtup t) -> real:
     real x = t.op
     return x
 
-public export method test() -> void:
+public export method test() :
     {int op} t = {op: 1}
     assume f((realtup) t) == 1.0
diff --git a/tests/valid/RecordDefine_Valid_1.whiley b/tests/valid/RecordDefine_Valid_1.whiley
index fb0eb3cf2..9835a071b 100644
--- a/tests/valid/RecordDefine_Valid_1.whiley
+++ b/tests/valid/RecordDefine_Valid_1.whiley
@@ -3,6 +3,6 @@ type Point is ({int y, int x} p) where p.x > 0 && p.y > 0
 function f(Point x) -> Point:
     return x
 
-public export method test() -> void:
+public export method test() :
     Point p = f({y: 1, x: 1})
     assume p == {y: 1, x: 1}
diff --git a/tests/valid/RecordDefine_Valid_2.whiley b/tests/valid/RecordDefine_Valid_2.whiley
index 539a3587a..fe0906585 100644
--- a/tests/valid/RecordDefine_Valid_2.whiley
+++ b/tests/valid/RecordDefine_Valid_2.whiley
@@ -5,6 +5,6 @@ type Point is {int y, int x}
 function f(Point x) -> Point:
     return x
 
-public export method test() -> void:
+public export method test() :
     Point p = f({y: 1, x: 1})
     assume p == {y: 1, x: 1}
diff --git a/tests/valid/RecordSubtype_Valid_1.whiley b/tests/valid/RecordSubtype_Valid_1.whiley
index 3c6e818db..062787a6e 100644
--- a/tests/valid/RecordSubtype_Valid_1.whiley
+++ b/tests/valid/RecordSubtype_Valid_1.whiley
@@ -11,7 +11,7 @@ type R4 is R2 | R3
 function f(R1 x) -> R4:
     return x
 
-public export method test() -> void:
+public export method test() :
     R4 z1 = f({x: 1})
     R4 z2 = f({x: null})
     assume z1 == {x: 1}
diff --git a/tests/valid/RecordSubtype_Valid_2.whiley b/tests/valid/RecordSubtype_Valid_2.whiley
index 893e71708..dc13d917c 100644
--- a/tests/valid/RecordSubtype_Valid_2.whiley
+++ b/tests/valid/RecordSubtype_Valid_2.whiley
@@ -11,7 +11,7 @@ type List4 is List3 | List2
 function f(List1 r) -> List4:
     return r
 
-public export method test() -> void:
+public export method test() :
     List1 list = {next: null, data: 1}
     list = {next: list, data: null}
     List4 ans = f(list)
diff --git a/tests/valid/RecursiveType_Valid_1.whiley b/tests/valid/RecursiveType_Valid_1.whiley
index c04c3308b..b1b0d6f9e 100644
--- a/tests/valid/RecursiveType_Valid_1.whiley
+++ b/tests/valid/RecursiveType_Valid_1.whiley
@@ -2,6 +2,6 @@
 
 type Expr is int | {int op, Expr left, Expr right}
 
-public export method test() -> void:
+public export method test() :
     Expr e = 1
     assume e == 1
diff --git a/tests/valid/RecursiveType_Valid_10.whiley b/tests/valid/RecursiveType_Valid_10.whiley
index be4d383a6..14120d73f 100644
--- a/tests/valid/RecursiveType_Valid_10.whiley
+++ b/tests/valid/RecursiveType_Valid_10.whiley
@@ -2,7 +2,7 @@
 
 type expr is int | {int op, expr left, expr right}
 
-public export method test() -> void:
+public export method test() :
     expr e = {op: 1, left: 1, right: 2}
     assert e.op == 1
     assert e.left == 1
diff --git a/tests/valid/RecursiveType_Valid_11.whiley b/tests/valid/RecursiveType_Valid_11.whiley
index 98222affb..dcc8a92fa 100644
--- a/tests/valid/RecursiveType_Valid_11.whiley
+++ b/tests/valid/RecursiveType_Valid_11.whiley
@@ -10,7 +10,7 @@ where this.op == ADD || this.op ==  SUB || this.op ==  MUL || this.op ==  DIV
 
 type expr is int | binop
 
-public export method test() -> void:
+public export method test() :
     expr e1 = {op: ADD, left: 1, right: 2}
     expr e2 = {op: SUB, left: e1, right: 2}
     expr e3 = {op: SUB, left: {op: MUL, left: 2, right: 2}, right: 2}
diff --git a/tests/valid/RecursiveType_Valid_12.whiley b/tests/valid/RecursiveType_Valid_12.whiley
index 4799066f1..0bbc51fe2 100644
--- a/tests/valid/RecursiveType_Valid_12.whiley
+++ b/tests/valid/RecursiveType_Valid_12.whiley
@@ -9,7 +9,7 @@ function Tree(int data, Tree left, Tree right) -> Tree
 requires ((left == null) || (left.data < data)) && ((right == null) || (right.data > data)):
     return {data: data, rhs: right, lhs: left}
 
-public export method test() -> void:
+public export method test() :
     Tree l1 = Tree(1, null, null)
     Tree l2 = Tree(3, null, null)
     Tree l3 = Tree(5, null, null)
diff --git a/tests/valid/RecursiveType_Valid_13.whiley b/tests/valid/RecursiveType_Valid_13.whiley
index 7ad971b9e..1ad84eebf 100644
--- a/tests/valid/RecursiveType_Valid_13.whiley
+++ b/tests/valid/RecursiveType_Valid_13.whiley
@@ -12,7 +12,7 @@ type binop is {int op, expr left, expr right}
 
 type expr is int | binop
 
-public export method test() -> void:
+public export method test() :
     expr e1 = {op: ADD, left: 1, right: 2}
     expr e2 = {op: SUB, left: e1, right: 2}
     expr e3 = {op: SUB, left: {op: MUL, left: 2, right: 2}, right: 2}
diff --git a/tests/valid/RecursiveType_Valid_14.whiley b/tests/valid/RecursiveType_Valid_14.whiley
index a54f7e67c..b7081a2a6 100644
--- a/tests/valid/RecursiveType_Valid_14.whiley
+++ b/tests/valid/RecursiveType_Valid_14.whiley
@@ -14,7 +14,7 @@ type asbinop is ({int op, Expr left, Expr right} this) where this.op == ADD || t
 
 type Expr is int | binop
 
-public export method test() -> void:
+public export method test() :
     Expr bop1 = {op: ADD, left: 1, right: 2}
     Expr bop2 = bop1
     Expr e1 = bop1
diff --git a/tests/valid/RecursiveType_Valid_15.whiley b/tests/valid/RecursiveType_Valid_15.whiley
index 826b0dbc9..a7028b395 100644
--- a/tests/valid/RecursiveType_Valid_15.whiley
+++ b/tests/valid/RecursiveType_Valid_15.whiley
@@ -14,7 +14,7 @@ type asbinop is {int op, Expr left, Expr right}
 
 type Expr is int | binop
 
-public export method test() -> void:
+public export method test() :
     Expr bop1 = {op: ADD, left: 1, right: 2}
     Expr bop2 = bop1
     Expr e1 = bop1
diff --git a/tests/valid/RecursiveType_Valid_16.whiley b/tests/valid/RecursiveType_Valid_16.whiley
index 838348ad2..610be532f 100644
--- a/tests/valid/RecursiveType_Valid_16.whiley
+++ b/tests/valid/RecursiveType_Valid_16.whiley
@@ -8,6 +8,6 @@ function parseTerm() -> Expr:
 function parseIdentifier() -> Expr:
     return {err: "err"}
 
-public export method test() -> void:
+public export method test() :
     Expr e = parseTerm()
     assume e == {err: "err"}
diff --git a/tests/valid/RecursiveType_Valid_17.whiley b/tests/valid/RecursiveType_Valid_17.whiley
index b1d4733ce..aa578b42e 100644
--- a/tests/valid/RecursiveType_Valid_17.whiley
+++ b/tests/valid/RecursiveType_Valid_17.whiley
@@ -12,7 +12,7 @@ function parse(int[] input) -> Expr:
 function parseAddSubExpr(State st) -> {Expr e, State st}:
     return {e: {num: 1}, st: st}
 
-public export method test() -> void:
+public export method test() :
     Expr e = parse("Hello")
     assume e == {num:1}
 
diff --git a/tests/valid/RecursiveType_Valid_18.whiley b/tests/valid/RecursiveType_Valid_18.whiley
index a20552fc4..7c3f99f47 100644
--- a/tests/valid/RecursiveType_Valid_18.whiley
+++ b/tests/valid/RecursiveType_Valid_18.whiley
@@ -11,7 +11,7 @@ function parse(int[] input) -> Expr:
 function parseAddSubExpr(State st) -> {Expr e, State st}:
     return {e: {num: 1}, st: st}
 
-public export method test() -> void:
+public export method test() :
     Expr e = parse("Hello")
     assume e == {num:1}
 
diff --git a/tests/valid/RecursiveType_Valid_19.whiley b/tests/valid/RecursiveType_Valid_19.whiley
index e7f8c1746..35164977c 100644
--- a/tests/valid/RecursiveType_Valid_19.whiley
+++ b/tests/valid/RecursiveType_Valid_19.whiley
@@ -12,7 +12,7 @@ function f(posExpr e1) -> expr:
     expr e2 = e1
     return e2
 
-public export method test() -> void:
+public export method test() :
     expr e = f({rhs: 1, lhs: {rhs: 2, lhs: 1}})
     assume e == {lhs:{lhs:1,rhs:2},rhs:1}
 
diff --git a/tests/valid/RecursiveType_Valid_2.whiley b/tests/valid/RecursiveType_Valid_2.whiley
index 566afbed5..236ec3d69 100644
--- a/tests/valid/RecursiveType_Valid_2.whiley
+++ b/tests/valid/RecursiveType_Valid_2.whiley
@@ -27,7 +27,7 @@ function evaluate(Expr e) -> real:
     else:
         return evaluate(e.lhs) + evaluate(e.rhs)
 
-public export method test() -> void:
+public export method test() :
     assume evaluate(build(-5)) == 46.0
     assume evaluate(build(-4)) == 41.0
     assume evaluate(build(-3)) == 35.0
diff --git a/tests/valid/RecursiveType_Valid_20.whiley b/tests/valid/RecursiveType_Valid_20.whiley
index 213e18f95..e0e1bca7c 100644
--- a/tests/valid/RecursiveType_Valid_20.whiley
+++ b/tests/valid/RecursiveType_Valid_20.whiley
@@ -12,7 +12,7 @@ function f(posExpr e1) -> expr:
     expr e2 = e1
     return e2
 
-public export method test() -> void:
+public export method test() :
     expr e = f({rhs: 1, lhs: {rhs: 2, lhs: 1}})
     assume e == {lhs:{lhs:1,rhs:2},rhs:1}
 
diff --git a/tests/valid/RecursiveType_Valid_21.whiley b/tests/valid/RecursiveType_Valid_21.whiley
index 2b800a4de..c0115938f 100644
--- a/tests/valid/RecursiveType_Valid_21.whiley
+++ b/tests/valid/RecursiveType_Valid_21.whiley
@@ -10,7 +10,7 @@ function sum(LinkedList l) -> int:
     else:
         return l.data + sum(l.next)
 
-public export method test() -> void:
+public export method test() :
     LinkedList l1 = {next: null, data: 1}
     LinkedList l2 = {next: l1, data: 2}
     LinkedList l3 = {next: l2, data: 3}
diff --git a/tests/valid/RecursiveType_Valid_22.whiley b/tests/valid/RecursiveType_Valid_22.whiley
index 7b7cdbeae..3370cc314 100644
--- a/tests/valid/RecursiveType_Valid_22.whiley
+++ b/tests/valid/RecursiveType_Valid_22.whiley
@@ -21,7 +21,7 @@ function contains(int item, SortedList list) -> bool:
             else:
                 return contains(item, list.next)
 
-public export method test() -> void:
+public export method test() :
     SortedList list = SortedList(10, null)
     list = SortedList(5, list)
     list = SortedList(3, list)
diff --git a/tests/valid/RecursiveType_Valid_23.whiley b/tests/valid/RecursiveType_Valid_23.whiley
index 7f9f19415..cdc771b6b 100644
--- a/tests/valid/RecursiveType_Valid_23.whiley
+++ b/tests/valid/RecursiveType_Valid_23.whiley
@@ -10,7 +10,7 @@ function f(Expr e) -> int:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     int v = f([1.0, 2.0, 3.0])
     assume v == 3
     v = f(1.234)
diff --git a/tests/valid/RecursiveType_Valid_24.whiley b/tests/valid/RecursiveType_Valid_24.whiley
index c5f48eef7..35cd5dd12 100644
--- a/tests/valid/RecursiveType_Valid_24.whiley
+++ b/tests/valid/RecursiveType_Valid_24.whiley
@@ -14,7 +14,7 @@ function maxDepth(Link links) -> int:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     Link l1 = null
     Link l2 = [l1]
     Link l3 = [l2]
diff --git a/tests/valid/RecursiveType_Valid_25.whiley b/tests/valid/RecursiveType_Valid_25.whiley
index f77028b8a..5b45553c3 100644
--- a/tests/valid/RecursiveType_Valid_25.whiley
+++ b/tests/valid/RecursiveType_Valid_25.whiley
@@ -7,7 +7,7 @@ type Value is real | Value[]
 function init() -> Value:
     return 0.0123
 
-public export method test() -> void:
+public export method test() :
     Value v = init()
     if v is Expr[]:
         assume false
diff --git a/tests/valid/RecursiveType_Valid_26.whiley b/tests/valid/RecursiveType_Valid_26.whiley
index 821513f18..068258e26 100644
--- a/tests/valid/RecursiveType_Valid_26.whiley
+++ b/tests/valid/RecursiveType_Valid_26.whiley
@@ -13,7 +13,7 @@ function toString(Expr e) -> int:
     else:
         return -1
 
-public export method test() -> void:
+public export method test() :
     SubExpr se1 = 0.1234
     SubExpr se2 = {data: 1, lhs: se1}
     SubExpr se3 = {data: 45, lhs: se2}
diff --git a/tests/valid/RecursiveType_Valid_27.whiley b/tests/valid/RecursiveType_Valid_27.whiley
index d51b15153..b5e014484 100644
--- a/tests/valid/RecursiveType_Valid_27.whiley
+++ b/tests/valid/RecursiveType_Valid_27.whiley
@@ -25,7 +25,7 @@ function sbuild(int i) -> SExpr:
     else:
         return build(i)
 
-public export method test() -> void:
+public export method test() :
     assume sbuild(-5) == {lhs:5.0,rhs:{lhs:6.0,rhs:{lhs:7.0,rhs:{lhs:8.0,rhs:{lhs:9.0,rhs:{lhs:10.0,rhs:1.0}}}}}}
     assume sbuild(-4) == {lhs:6.0,rhs:{lhs:7.0,rhs:{lhs:8.0,rhs:{lhs:9.0,rhs:{lhs:10.0,rhs:1.0}}}}}
     assume sbuild(-3) == {lhs:7.0,rhs:{lhs:8.0,rhs:{lhs:9.0,rhs:{lhs:10.0,rhs:1.0}}}}
diff --git a/tests/valid/RecursiveType_Valid_3.whiley b/tests/valid/RecursiveType_Valid_3.whiley
index 6b27043db..f27ff8c26 100644
--- a/tests/valid/RecursiveType_Valid_3.whiley
+++ b/tests/valid/RecursiveType_Valid_3.whiley
@@ -24,7 +24,7 @@ function evaluate(Expr e) -> Value:
             else:
                 return null
 
-public export method test() -> void:
+public export method test() :
     assume evaluate(1) == 1
     assume evaluate({index: 0, src: [112, 212, 342]}) == 112
     assume evaluate({index: 2, src: [112312, 289712, 31231242]}) == 31231242
diff --git a/tests/valid/RecursiveType_Valid_4.whiley b/tests/valid/RecursiveType_Valid_4.whiley
index e799cafe2..221aa9142 100644
--- a/tests/valid/RecursiveType_Valid_4.whiley
+++ b/tests/valid/RecursiveType_Valid_4.whiley
@@ -27,7 +27,7 @@ function evaluate(Expr e) -> null | Value:
             else:
                 return null
 
-public export method test() -> void:
+public export method test() :
     assume evaluate(123) == 123
     assume evaluate({index: 0, src: [112, 212332, 342]}) == 112
     assume evaluate({index: 2, src: [112312, -289712, 312242]}) == 312242
diff --git a/tests/valid/RecursiveType_Valid_6.whiley b/tests/valid/RecursiveType_Valid_6.whiley
index 576dfa463..ef28f28fd 100644
--- a/tests/valid/RecursiveType_Valid_6.whiley
+++ b/tests/valid/RecursiveType_Valid_6.whiley
@@ -4,6 +4,6 @@ type binop is {int op, expr left, expr right}
 
 type expr is int | binop
 
-public export method test() -> void:
+public export method test() :
     expr e = 123
     assert e == 123
diff --git a/tests/valid/RecursiveType_Valid_7.whiley b/tests/valid/RecursiveType_Valid_7.whiley
index 4e1b15f28..73694d666 100644
--- a/tests/valid/RecursiveType_Valid_7.whiley
+++ b/tests/valid/RecursiveType_Valid_7.whiley
@@ -51,7 +51,7 @@ function code2toString(Bytecode b) -> string:
 
 constant bytecodeStrings is ["nop", "aconst_null", "iconst_m1", "iconst_0", "iconst_1", "iconst_2", "iconst_3", "iconst_4", "iconst_5", "lconst_0", "lconst_1", "fconst_0", "fconst_1", "fconst_2", "dconst_0", "dconst_1", "bipush", "sipush", "ldc", "ldc_w", "ldc2_w", "iload", "lload", "fload", "dload", "aload", "iload_0", "iload_1", "iload_2", "iload_3", "lload_0", "lload_1", "lload_2", "lload_3", "fload_0", "fload_1", "fload_2", "fload_3", "dload_0", "dload_1", "dload_2", "dload_3", "aload_0", "aload_1", "aload_2", "aload_3", "iaload", "laload", "faload", "daload", "aaload", "baload", "caload", "saload", "istore", "lstore", "fstore", "dstore", "astore", "istore_0", "istore_1", "istore_2", "istore_3", "lstore_0", "lstore_1", "lstore_2", "lstore_3", "fstore_0", "fstore_1", "fstore_2", "fstore_3", "dstore_0", "dstore_1", "dstore_2", "dstore_3", "astore_0", "astore_1", "astore_2", "astore_3", "iastore", "lastore", "fastore", "dastore", "aastore", "bastore", "castore", "sastore", "pop", "pop2", "dup", "dup_x1", "dup_x2", "dup2", "dup2_x1", "dup2_x2", "swap", "iadd", "ladd", "fadd", "dadd", "isub", "lsub", "fsub", "dsub", "imul", "lmul", "fmul", "dmul", "idiv", "ldiv", "fdiv", "ddiv", "irem", "lrem", "frem", "drem", "ineg", "lneg", "fneg", "dneg", "ishl", "lshl", "ishr", "lshr", "iushr", "lushr", "iand", "land", "ior", "lor", "ixor", "lxor", "iinc", "i2l", "i2f", "i2d", "l2i", "l2f", "l2d", "f2i", "f2l", "f2d", "d2i", "d2l", "d2f", "i2b", "i2c", "i2s", "lcmp", "fcmpl", "fcmpg", "dcmpl", "dcmpg", "ifeq", "ifne", "iflt", "ifge", "ifgt", "ifle", "if_icmpeq", "if_icmpne", "if_icmplt", "if_icmpge", "if_icmpgt", "if_icmple", "if_acmpeq", "if_acmpne", "goto", "jsr", "ret", "tableswitch", "lookupswitch", "ireturn", "lreturn", "freturn", "dreturn", "areturn", "return", "getstatic", "putstatic", "getfield", "putfield", "invokevirtual", "invokespecial", "invokestatic", "invokeerface", "unused", "new", "newarray", "anewarray", "arraylength", "athrow", "checkcast", "instanceof", "monitorenter", "monitorexit", "wide", "multianewarray", "ifnull", "ifnonnull", "goto_w", "jsr_w", "breakpo", "impdep1", "impdep2"]
 
-public export method test() -> void:
+public export method test() :
     int[] s1 = code2toString(Unit(0, 1))
     assume s1 == "aconst_null"
     int[] s2 = code2toString(FieldIndex(0, 180, {classes: ["Object"], pkg: "java.lang"}, "field", T_INT))
diff --git a/tests/valid/RecursiveType_Valid_8.whiley b/tests/valid/RecursiveType_Valid_8.whiley
index 49012a2d4..564bfe1d0 100644
--- a/tests/valid/RecursiveType_Valid_8.whiley
+++ b/tests/valid/RecursiveType_Valid_8.whiley
@@ -4,6 +4,6 @@ type nat is (int n) where n >= 0
 
 type expr is nat | {int op, expr left, expr right}
 
-public export method test() -> void:
+public export method test() :
     expr e = 14897
     assert e == 14897
diff --git a/tests/valid/RecursiveType_Valid_9.whiley b/tests/valid/RecursiveType_Valid_9.whiley
index 3ab688440..79b408f7f 100644
--- a/tests/valid/RecursiveType_Valid_9.whiley
+++ b/tests/valid/RecursiveType_Valid_9.whiley
@@ -4,6 +4,6 @@ type nat is int
 
 type expr is nat | {int op, expr left, expr right}
 
-public export method test() -> void:
+public export method test() :
     expr e = 14897
     assert e == 14897
diff --git a/tests/valid/Reference_Valid_6.whiley b/tests/valid/Reference_Valid_6.whiley
index 94394b14e..516ff2f69 100644
--- a/tests/valid/Reference_Valid_6.whiley
+++ b/tests/valid/Reference_Valid_6.whiley
@@ -12,4 +12,4 @@ public export method test():
     &(&int) k = new l // k = -> [ -> [ 0 ] ] 
     m(k)
     assert (*l) == 1
-    assert (*(*k)) == 1
\ No newline at end of file
+    assert (*(*k)) == 1
diff --git a/tests/valid/Remainder_Valid_1.whiley b/tests/valid/Remainder_Valid_1.whiley
index 507b9124c..21175f90f 100644
--- a/tests/valid/Remainder_Valid_1.whiley
+++ b/tests/valid/Remainder_Valid_1.whiley
@@ -4,7 +4,7 @@ function f(int x, int y) -> int
     requires y != 0:
     return x % y
 
-public export method test() -> void:
+public export method test() :
     assume f(10, 5) == 0
     assume f(10, 4) == 2
     assume f(1, 4) == 1
diff --git a/tests/valid/Requires_Valid_1.whiley b/tests/valid/Requires_Valid_1.whiley
index 0e93fe2ae..f59f7f660 100644
--- a/tests/valid/Requires_Valid_1.whiley
+++ b/tests/valid/Requires_Valid_1.whiley
@@ -8,7 +8,7 @@ requires y == f(x):
     //
     return {nx: x, ny: y}
 
-public export method test() -> void:
+public export method test() :
     {int nx, int ny} p = g(1, f(1))
     assume p.nx == 1
     assume p.ny == 2
diff --git a/tests/valid/Resolution_Valid_1.whiley b/tests/valid/Resolution_Valid_1.whiley
index aa1d6e051..9328dd551 100644
--- a/tests/valid/Resolution_Valid_1.whiley
+++ b/tests/valid/Resolution_Valid_1.whiley
@@ -3,6 +3,6 @@
 function f(int b) -> int:
     return b + 1
 
-public export method test() -> void:
+public export method test() :
     int b = f(10)
     assume b == 11
diff --git a/tests/valid/SingleLineComment_Valid_1.whiley b/tests/valid/SingleLineComment_Valid_1.whiley
index ccd0716ac..b016e4b93 100644
--- a/tests/valid/SingleLineComment_Valid_1.whiley
+++ b/tests/valid/SingleLineComment_Valid_1.whiley
@@ -1,4 +1,4 @@
 
 
-public export method test() -> void:
+public export method test() :
     assert 1 != 2 // this is a single line comment
diff --git a/tests/valid/Skip_Valid_1.whiley b/tests/valid/Skip_Valid_1.whiley
index 5e0ea138d..82855bb70 100644
--- a/tests/valid/Skip_Valid_1.whiley
+++ b/tests/valid/Skip_Valid_1.whiley
@@ -7,6 +7,6 @@ function f(int x) -> int:
         return -1
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
     assume f(-10) == -1
diff --git a/tests/valid/String_Valid_2.whiley b/tests/valid/String_Valid_2.whiley
index 80bc53b43..1f429da8b 100644
--- a/tests/valid/String_Valid_2.whiley
+++ b/tests/valid/String_Valid_2.whiley
@@ -8,7 +8,7 @@ public function has(int c, int[] str) -> bool:
         i = i + 1
     return false
 
-public export method test() -> void:
+public export method test() :
     int[] s = "Hello World"
     assume has('l', s) == true
     assume has('e', s) == true
diff --git a/tests/valid/String_Valid_3.whiley b/tests/valid/String_Valid_3.whiley
index 35c3467ff..7dd855efe 100644
--- a/tests/valid/String_Valid_3.whiley
+++ b/tests/valid/String_Valid_3.whiley
@@ -8,7 +8,7 @@ public function has(int c1, int[] str) -> bool:
         i = i + 1
     return false
 
-public export method test() -> void:
+public export method test() :
     int[] s = "Hello World"
     assume has('l', s) == true
     assume has('e', s) == true
diff --git a/tests/valid/String_Valid_4.whiley b/tests/valid/String_Valid_4.whiley
index d4be01555..6ce4a7418 100644
--- a/tests/valid/String_Valid_4.whiley
+++ b/tests/valid/String_Valid_4.whiley
@@ -8,6 +8,6 @@ public function repl(int old, int n, int[] str) -> int[]:
         i = i + 1
     return str
 
-public export method test() -> void:
+public export method test() :
     int[] s = "Hello World"
     assume repl('l', '1', s) == "He11o Wor1d"
diff --git a/tests/valid/String_Valid_5.whiley b/tests/valid/String_Valid_5.whiley
index 532674ad5..a6be81e28 100644
--- a/tests/valid/String_Valid_5.whiley
+++ b/tests/valid/String_Valid_5.whiley
@@ -6,7 +6,7 @@ function indexOf(int c1, int[] str) -> int | null:
         i = i + 1
     return null
 
-public export method test() -> void:
+public export method test() :
     assume indexOf('H', "Hello World") == 0
     assume indexOf('e', "Hello World") == 1
     assume indexOf('l', "Hello World") == 2
diff --git a/tests/valid/String_Valid_6.whiley b/tests/valid/String_Valid_6.whiley
index 1a4ac88d7..6964066f1 100644
--- a/tests/valid/String_Valid_6.whiley
+++ b/tests/valid/String_Valid_6.whiley
@@ -21,5 +21,5 @@ ensures |zs| == |xs| + |ys|:
     //
     return rs
     
-public export method test() -> void:
+public export method test() :
     assume append("Hello ","122") == "Hello 122"
diff --git a/tests/valid/Subtype_Valid_1.whiley b/tests/valid/Subtype_Valid_1.whiley
index 69eecdd60..8cf2dc8e8 100644
--- a/tests/valid/Subtype_Valid_1.whiley
+++ b/tests/valid/Subtype_Valid_1.whiley
@@ -2,7 +2,7 @@
 
 type sr3nat is (int n) where n > 0
 
-public export method test() -> void:
+public export method test() :
     int[] x = [2]
     x[0] = 1
     assert x == [1]
diff --git a/tests/valid/Subtype_Valid_10.whiley b/tests/valid/Subtype_Valid_10.whiley
index b2615785c..468c4ee28 100644
--- a/tests/valid/Subtype_Valid_10.whiley
+++ b/tests/valid/Subtype_Valid_10.whiley
@@ -2,7 +2,7 @@
 
 type sr5nat is (int n) where n > 0
 
-public export method test() -> void:
+public export method test() :
     {sr5nat f} x = {f: 1}
     x.f = 2
     assert x == {f: 2}
diff --git a/tests/valid/Subtype_Valid_11.whiley b/tests/valid/Subtype_Valid_11.whiley
index 20e00ea79..139f306eb 100644
--- a/tests/valid/Subtype_Valid_11.whiley
+++ b/tests/valid/Subtype_Valid_11.whiley
@@ -2,7 +2,7 @@
 
 type sr5nat is int
 
-public export method test() -> void:
+public export method test() :
     {sr5nat f} x = {f: 1}
     x.f = 2
     assert x == {f: 2}
diff --git a/tests/valid/Subtype_Valid_12.whiley b/tests/valid/Subtype_Valid_12.whiley
index 2bd0d4c41..ff603abfc 100644
--- a/tests/valid/Subtype_Valid_12.whiley
+++ b/tests/valid/Subtype_Valid_12.whiley
@@ -4,7 +4,7 @@ type sr6nat is (int n) where n > 0
 
 type sr6tup is ({sr6nat f, int g} r) where r.g > r.f
 
-public export method test() -> void:
+public export method test() :
     sr6tup x = {f: 1, g: 5}
     x.f = 2
     assert x == {f: 2, g: 5}
diff --git a/tests/valid/Subtype_Valid_13.whiley b/tests/valid/Subtype_Valid_13.whiley
index 923c7d43a..7b5c8cb77 100644
--- a/tests/valid/Subtype_Valid_13.whiley
+++ b/tests/valid/Subtype_Valid_13.whiley
@@ -4,7 +4,7 @@ type sr6nat is int
 
 type sr6tup is {sr6nat f, int g}
 
-public export method test() -> void:
+public export method test() :
     sr6tup x = {f: 1, g: 5}
     x.g = 2
     assert x == {f: 1, g: 2}
diff --git a/tests/valid/Subtype_Valid_14.whiley b/tests/valid/Subtype_Valid_14.whiley
index ad172170c..1656d7008 100644
--- a/tests/valid/Subtype_Valid_14.whiley
+++ b/tests/valid/Subtype_Valid_14.whiley
@@ -2,7 +2,7 @@
 
 type sr7nat is (int n) where n > 0
 
-public export method test() -> void:
+public export method test() :
     {sr7nat f} x = {f: 1}
     x.f = x.f + 1
     assert x == {f: 2}
diff --git a/tests/valid/Subtype_Valid_2.whiley b/tests/valid/Subtype_Valid_2.whiley
index 911bc2538..4741e70c9 100644
--- a/tests/valid/Subtype_Valid_2.whiley
+++ b/tests/valid/Subtype_Valid_2.whiley
@@ -2,7 +2,7 @@
 
 type sr7nat is int
 
-public export method test() -> void:
+public export method test() :
     {int f} x = {f: 1}
     x.f = x.f + 1
     assume x == {f:2}
diff --git a/tests/valid/Subtype_Valid_3.whiley b/tests/valid/Subtype_Valid_3.whiley
index fbd2adcd2..760c716b1 100644
--- a/tests/valid/Subtype_Valid_3.whiley
+++ b/tests/valid/Subtype_Valid_3.whiley
@@ -2,7 +2,7 @@ type sr8nat is (int n) where n > 0
 
 type sr8tup is ({sr8nat f, int g} r) where r.g > r.f
 
-public export method test() -> void:
+public export method test() :
     sr8tup[] x = [{f: 1, g: 3}, {f: 4, g: 8}]
     x[0].f = 2
     assume x == [{f: 2, g: 3}, {f: 4, g: 8}]
diff --git a/tests/valid/Subtype_Valid_4.whiley b/tests/valid/Subtype_Valid_4.whiley
index df5734d55..e533906a5 100644
--- a/tests/valid/Subtype_Valid_4.whiley
+++ b/tests/valid/Subtype_Valid_4.whiley
@@ -4,7 +4,7 @@ type sr8nat is int
 
 type sr8tup is {sr8nat f, int g}
 
-public export method test() -> void:
+public export method test() :
     sr8tup[] x = [{f: 1, g: 3}, {f: 4, g: 8}]
     x[0].f = 2
     assume x == [{f: 2, g: 3}, {f: 4, g: 8}]
diff --git a/tests/valid/Subtype_Valid_5.whiley b/tests/valid/Subtype_Valid_5.whiley
index e65c3325a..9d7f70301 100644
--- a/tests/valid/Subtype_Valid_5.whiley
+++ b/tests/valid/Subtype_Valid_5.whiley
@@ -6,7 +6,7 @@ type sr9tup is ({sr9nat f, int g} r) where r.g > r.f
 
 type sr9arr is (sr9tup[] xs) where some { i in 0..|xs| | xs[i].f == 1 }
 
-public export method test() -> void:
+public export method test() :
     sr9arr x = [{f: 1, g: 2}, {f: 1, g: 8}]
     x[0].f = 2
     assume x == [{f: 2, g: 2}, {f: 1, g: 8}]
diff --git a/tests/valid/Subtype_Valid_6.whiley b/tests/valid/Subtype_Valid_6.whiley
index 9bf674b21..40917eaa5 100644
--- a/tests/valid/Subtype_Valid_6.whiley
+++ b/tests/valid/Subtype_Valid_6.whiley
@@ -4,7 +4,7 @@ type sr9tup is {sr9nat f, int g}
 
 type sr9arr is {sr9nat f, int g}[]
 
-public export method test() -> void:
+public export method test() :
     sr9arr x = [{f: 1, g: 2}, {f: 1, g: 8}]
     x[0].f = 2
     assume x == [{f: 2, g: 2}, {f: 1, g: 8}]
diff --git a/tests/valid/Subtype_Valid_7.whiley b/tests/valid/Subtype_Valid_7.whiley
index 6fb7dd22c..d6be18b5e 100644
--- a/tests/valid/Subtype_Valid_7.whiley
+++ b/tests/valid/Subtype_Valid_7.whiley
@@ -1,4 +1,4 @@
-public export method test() -> void:
+public export method test() :
     int[] x = [1,2]
     x[0] = 2
     assert x == [2,2]
diff --git a/tests/valid/Subtype_Valid_8.whiley b/tests/valid/Subtype_Valid_8.whiley
index edeab16b4..e7467c38d 100644
--- a/tests/valid/Subtype_Valid_8.whiley
+++ b/tests/valid/Subtype_Valid_8.whiley
@@ -2,6 +2,6 @@
 
 type sr4list is (int[] xs) where |xs| > 0
 
-public export method test() -> void:
+public export method test() :
     sr4list x = [1]
     assert x == [1]
diff --git a/tests/valid/Subtype_Valid_9.whiley b/tests/valid/Subtype_Valid_9.whiley
index 082c17eb7..55022d01a 100644
--- a/tests/valid/Subtype_Valid_9.whiley
+++ b/tests/valid/Subtype_Valid_9.whiley
@@ -2,6 +2,6 @@
 
 type sr4list is int[]
 
-public export method test() -> void:
+public export method test() :
     sr4list x = [1]
     assert x == [1]
diff --git a/tests/valid/Switch_Valid_1.whiley b/tests/valid/Switch_Valid_1.whiley
index ee34b0015..b5f6651bc 100644
--- a/tests/valid/Switch_Valid_1.whiley
+++ b/tests/valid/Switch_Valid_1.whiley
@@ -10,7 +10,7 @@ function f(int x) -> nat:
             return x + 1
     return 1
 
-public export method test() -> void:
+public export method test() :
     assume f(2) == 1
     assume f(1) == 0
     assume f(0) == 1
diff --git a/tests/valid/Switch_Valid_10.whiley b/tests/valid/Switch_Valid_10.whiley
index 1147fc1b6..59b6d8fab 100644
--- a/tests/valid/Switch_Valid_10.whiley
+++ b/tests/valid/Switch_Valid_10.whiley
@@ -8,7 +8,7 @@ function f(real x) -> int:
             return -1
     return 10
 
-public export method test() -> void:
+public export method test() :
     assume f(1.23) == 0
     assume f(2.01) == -1
     assume f(3.0) == 10
diff --git a/tests/valid/Switch_Valid_11.whiley b/tests/valid/Switch_Valid_11.whiley
index 4cf5817a8..ca7f99e1e 100644
--- a/tests/valid/Switch_Valid_11.whiley
+++ b/tests/valid/Switch_Valid_11.whiley
@@ -11,7 +11,7 @@ ensures r >= 0 && r <= 2:
             return 1
     return 2
 
-public export method test() -> void:
+public export method test() :
     assume f(2) == 1
     assume f(1) == 0
     assume f(0) == 2
diff --git a/tests/valid/Switch_Valid_12.whiley b/tests/valid/Switch_Valid_12.whiley
index fbed832fb..9be6a17d2 100644
--- a/tests/valid/Switch_Valid_12.whiley
+++ b/tests/valid/Switch_Valid_12.whiley
@@ -8,7 +8,7 @@ function f(int[] x) -> int:
             return -1
     return 10
 
-public export method test() -> void:
+public export method test() :
     assume f([0;0]) == 0
     assume f([1]) == -1
     assume f([3]) == 10
diff --git a/tests/valid/Switch_Valid_13.whiley b/tests/valid/Switch_Valid_13.whiley
index a25c40c0b..748eb10a6 100644
--- a/tests/valid/Switch_Valid_13.whiley
+++ b/tests/valid/Switch_Valid_13.whiley
@@ -8,7 +8,7 @@ function f(int x) -> int:
             return 1
     return 10
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == -1
     assume f(2) == -1
     assume f(3) == 1
diff --git a/tests/valid/Switch_Valid_2.whiley b/tests/valid/Switch_Valid_2.whiley
index 1684f269c..338857a95 100644
--- a/tests/valid/Switch_Valid_2.whiley
+++ b/tests/valid/Switch_Valid_2.whiley
@@ -11,7 +11,7 @@ function f(int x) -> int:
             y = 0
     return y
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == -1
     assume f(2) == -2
     assume f(3) == 0
diff --git a/tests/valid/Switch_Valid_3.whiley b/tests/valid/Switch_Valid_3.whiley
index 6e1c43c13..12ce9bae5 100644
--- a/tests/valid/Switch_Valid_3.whiley
+++ b/tests/valid/Switch_Valid_3.whiley
@@ -21,7 +21,7 @@ requires |input| > 0:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     assume f("N") == 1
     assume f("B") == 2
     assume f("R") == 3
diff --git a/tests/valid/Switch_Valid_4.whiley b/tests/valid/Switch_Valid_4.whiley
index a9bc575ff..d480d149f 100644
--- a/tests/valid/Switch_Valid_4.whiley
+++ b/tests/valid/Switch_Valid_4.whiley
@@ -17,7 +17,7 @@ function f(RGB c) -> int:
         default:
             return 456
 
-public export method test() -> void:
+public export method test() :
     assume f(Red) == 123
     assume f(Green) == 456
     assume f(Blue) == 234
diff --git a/tests/valid/Switch_Valid_5.whiley b/tests/valid/Switch_Valid_5.whiley
index d7d938bd2..6c947e1f5 100644
--- a/tests/valid/Switch_Valid_5.whiley
+++ b/tests/valid/Switch_Valid_5.whiley
@@ -27,7 +27,7 @@ public function f(int type) -> int:
         default:
             return 6
 
-public export method test() -> void:
+public export method test() :
     assume f(IHDR_TYPE) == 1
     assume f(IEND_TYPE) == 2
     assume f(PLTE_TYPE) == 3
diff --git a/tests/valid/Switch_Valid_6.whiley b/tests/valid/Switch_Valid_6.whiley
index 2a6d674d5..36b7b5af4 100644
--- a/tests/valid/Switch_Valid_6.whiley
+++ b/tests/valid/Switch_Valid_6.whiley
@@ -8,7 +8,7 @@ function f(int x) -> int:
             return -1
     return 10
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 0
     assume f(2) == -1
     assume f(3) == 10
diff --git a/tests/valid/Switch_Valid_7.whiley b/tests/valid/Switch_Valid_7.whiley
index e3eff7f18..3379dafea 100644
--- a/tests/valid/Switch_Valid_7.whiley
+++ b/tests/valid/Switch_Valid_7.whiley
@@ -14,7 +14,7 @@ ensures r == 0 || r == 1:
         default:
             return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(2) == 0
     assume f(1) == 1
     assume f(0) == 0
diff --git a/tests/valid/Switch_Valid_8.whiley b/tests/valid/Switch_Valid_8.whiley
index 22ea4f113..da88c8405 100644
--- a/tests/valid/Switch_Valid_8.whiley
+++ b/tests/valid/Switch_Valid_8.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int x = 1
     switch x:
         case 1:
diff --git a/tests/valid/Switch_Valid_9.whiley b/tests/valid/Switch_Valid_9.whiley
index dfdb43e3b..0609b86fa 100644
--- a/tests/valid/Switch_Valid_9.whiley
+++ b/tests/valid/Switch_Valid_9.whiley
@@ -11,7 +11,7 @@ ensures r != 1:
             return 2
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(2) == 2
     assume f(1) == 2
     assume f(0) == 0
diff --git a/tests/valid/Syntax_Valid_1.whiley b/tests/valid/Syntax_Valid_1.whiley
index 16cae680b..03c285977 100644
--- a/tests/valid/Syntax_Valid_1.whiley
+++ b/tests/valid/Syntax_Valid_1.whiley
@@ -1,4 +1,4 @@
 
 
-public export method test() -> void:
+public export method test() :
     debug ""
diff --git a/tests/valid/TypeEquals_Valid_1.whiley b/tests/valid/TypeEquals_Valid_1.whiley
index 97ff54a99..a9d4f620c 100644
--- a/tests/valid/TypeEquals_Valid_1.whiley
+++ b/tests/valid/TypeEquals_Valid_1.whiley
@@ -2,13 +2,13 @@ type bop is ({int y, int x} r) where r.x > 0
 
 type expr is int | bop
 
-function f(expr e) -> bool:
+function f(expr e) -> (bool r):
     if e is int:
         return true
     else:
         return false
 
-public export method test() -> void:
+public export method test():
     expr e = 1
     assume f(e) == true
     e = {y: 2, x: 1}
diff --git a/tests/valid/TypeEquals_Valid_10.whiley b/tests/valid/TypeEquals_Valid_10.whiley
index edd458784..05a46bde8 100644
--- a/tests/valid/TypeEquals_Valid_10.whiley
+++ b/tests/valid/TypeEquals_Valid_10.whiley
@@ -8,6 +8,6 @@ function f(Rtypes e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f({y: 1, x: 3}) == true
     assume f({z: 1, x: 3}) == false
diff --git a/tests/valid/TypeEquals_Valid_11.whiley b/tests/valid/TypeEquals_Valid_11.whiley
index 19bc57ff0..208cd083e 100644
--- a/tests/valid/TypeEquals_Valid_11.whiley
+++ b/tests/valid/TypeEquals_Valid_11.whiley
@@ -8,7 +8,7 @@ function f(Rtypes e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f({y: 1.2, x: 1.2}) == false
     assume f({y: 1.0, x: 1.0}) == false
     assume f({z: 1, x: 1}) == true
diff --git a/tests/valid/TypeEquals_Valid_12.whiley b/tests/valid/TypeEquals_Valid_12.whiley
index 45fb80d80..f43b178fe 100644
--- a/tests/valid/TypeEquals_Valid_12.whiley
+++ b/tests/valid/TypeEquals_Valid_12.whiley
@@ -10,7 +10,7 @@ function f(expr e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     expr e = 1
     assume f(e) == true
     e = {y: 2, x: 1}
diff --git a/tests/valid/TypeEquals_Valid_14.whiley b/tests/valid/TypeEquals_Valid_14.whiley
index 39dfb66aa..8d0dc2ab3 100644
--- a/tests/valid/TypeEquals_Valid_14.whiley
+++ b/tests/valid/TypeEquals_Valid_14.whiley
@@ -10,7 +10,7 @@ function f(src e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f({x: 1}) == true
     assume f({y: 2}) == true
     assume f(1) == false
diff --git a/tests/valid/TypeEquals_Valid_15.whiley b/tests/valid/TypeEquals_Valid_15.whiley
index 7f51cd52b..4a5e429f5 100644
--- a/tests/valid/TypeEquals_Valid_15.whiley
+++ b/tests/valid/TypeEquals_Valid_15.whiley
@@ -8,7 +8,7 @@ function f(src e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3]) == true
     assume f([[1], [2]]) == true
     assume f(1) == false
diff --git a/tests/valid/TypeEquals_Valid_16.whiley b/tests/valid/TypeEquals_Valid_16.whiley
index 4aac5d890..95e0369e5 100644
--- a/tests/valid/TypeEquals_Valid_16.whiley
+++ b/tests/valid/TypeEquals_Valid_16.whiley
@@ -6,7 +6,7 @@ function f(src e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f([1]) == true
     assume f([[1]]) == true
     assume f([[[1]]]) == true
diff --git a/tests/valid/TypeEquals_Valid_17.whiley b/tests/valid/TypeEquals_Valid_17.whiley
index abf37f7a4..5fe02e0cb 100644
--- a/tests/valid/TypeEquals_Valid_17.whiley
+++ b/tests/valid/TypeEquals_Valid_17.whiley
@@ -8,7 +8,7 @@ function f(rlist l) -> int:
     else:
         return |l|
 
-public export method test() -> void:
+public export method test() :
     assume f(123.0) == 0
     assume f(1.23) == 0
     assume f([1, 2, 3]) == 3
diff --git a/tests/valid/TypeEquals_Valid_18.whiley b/tests/valid/TypeEquals_Valid_18.whiley
index 2bac775c8..eab337942 100644
--- a/tests/valid/TypeEquals_Valid_18.whiley
+++ b/tests/valid/TypeEquals_Valid_18.whiley
@@ -6,7 +6,7 @@ function f(intr[] e) -> int[]:
     else:
         return [1, 2, 3]
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7]
     assume f([0;0]) == [0;0]
     assume f([1, 2, 2.01]) == [1,2,3]
diff --git a/tests/valid/TypeEquals_Valid_19.whiley b/tests/valid/TypeEquals_Valid_19.whiley
index 0b985a138..e6bfcf763 100644
--- a/tests/valid/TypeEquals_Valid_19.whiley
+++ b/tests/valid/TypeEquals_Valid_19.whiley
@@ -6,7 +6,7 @@ function f(intr[][] e) -> int[]:
     else:
         return [1, 2, 3]
 
-public export method test() -> void:
+public export method test() :
     assume f([[1, 2, 3, 4, 5, 6, 7]]) == [1, 2, 3, 4, 5, 6, 7]
     assume f([[0;0]]) == [0;0]
     assume f([[1, 2, 2.01]]) == [1,2,3]
diff --git a/tests/valid/TypeEquals_Valid_2.whiley b/tests/valid/TypeEquals_Valid_2.whiley
index 8ea229864..c90ae7605 100644
--- a/tests/valid/TypeEquals_Valid_2.whiley
+++ b/tests/valid/TypeEquals_Valid_2.whiley
@@ -8,7 +8,7 @@ function f(expr e) -> int:
     else:
         return -1
 
-public export method test() -> void:
+public export method test() :
     int x = f({err: "Hello World"})
     assume x == 11
     x = f({op: 1, lhs: {err: "Gotcha"}})
diff --git a/tests/valid/TypeEquals_Valid_21.whiley b/tests/valid/TypeEquals_Valid_21.whiley
index 97242355d..a15973e30 100644
--- a/tests/valid/TypeEquals_Valid_21.whiley
+++ b/tests/valid/TypeEquals_Valid_21.whiley
@@ -8,7 +8,7 @@ function f(expr e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     expr e = true
     assume f(e) == false
     e = [1, 2, 3, 4]
diff --git a/tests/valid/TypeEquals_Valid_23.whiley b/tests/valid/TypeEquals_Valid_23.whiley
index 8b8979961..019b31b8f 100644
--- a/tests/valid/TypeEquals_Valid_23.whiley
+++ b/tests/valid/TypeEquals_Valid_23.whiley
@@ -10,7 +10,7 @@ function f(expr e) -> int:
     else:
         return e + 1
 
-public export method test() -> void:
+public export method test() :
     x = f(1)
     assume x == 2
     x = f({y: 10, x: 4})
diff --git a/tests/valid/TypeEquals_Valid_24.whiley b/tests/valid/TypeEquals_Valid_24.whiley
index fc59e3df1..8ce6d0452 100644
--- a/tests/valid/TypeEquals_Valid_24.whiley
+++ b/tests/valid/TypeEquals_Valid_24.whiley
@@ -8,6 +8,6 @@ function f(T x) -> int:
     else:
         return x
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3, 4]) == 4
     assume f(123) == 123
diff --git a/tests/valid/TypeEquals_Valid_25.whiley b/tests/valid/TypeEquals_Valid_25.whiley
index ed53b8bce..46516e4fa 100644
--- a/tests/valid/TypeEquals_Valid_25.whiley
+++ b/tests/valid/TypeEquals_Valid_25.whiley
@@ -35,7 +35,7 @@ function evaluate(Expr e) -> Value:
                 else:
                     return 0
 
-public export method test() -> void:
+public export method test() :
     Expr e = {op: ADD, rhs: 1, lhs: 123}
     Value v = evaluate(e)
     assume v == 123
diff --git a/tests/valid/TypeEquals_Valid_27.whiley b/tests/valid/TypeEquals_Valid_27.whiley
index 160e54a10..cfbf2e3f9 100644
--- a/tests/valid/TypeEquals_Valid_27.whiley
+++ b/tests/valid/TypeEquals_Valid_27.whiley
@@ -12,7 +12,7 @@ public export method test(Points t) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     Point3D p3d = {z: 3, y: 2, x: 1}
     assume test(p3d) == false
     Point p2d = {y: 2, x: 1}
diff --git a/tests/valid/TypeEquals_Valid_28.whiley b/tests/valid/TypeEquals_Valid_28.whiley
index c0a9ef9c4..27f3f69ef 100644
--- a/tests/valid/TypeEquals_Valid_28.whiley
+++ b/tests/valid/TypeEquals_Valid_28.whiley
@@ -12,7 +12,7 @@ public export method test(Points t) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     Point3D p3d = {z: 3, y: 2, x: 1}
     assume test(p3d) == true
     Point p2d = {y: 2, x: 1}
diff --git a/tests/valid/TypeEquals_Valid_29.whiley b/tests/valid/TypeEquals_Valid_29.whiley
index 957ab7152..38523c232 100644
--- a/tests/valid/TypeEquals_Valid_29.whiley
+++ b/tests/valid/TypeEquals_Valid_29.whiley
@@ -25,7 +25,7 @@ function shortPos2str(ShortPos p) -> int[]:
             else:
                 return pos2str(p)
 
-public export method test() -> void:
+public export method test() :
     assume shortPos2str(null) == ""
     assume shortPos2str({row: 1}) == "2"
     assume shortPos2str({col: 1}) == "b"
diff --git a/tests/valid/TypeEquals_Valid_3.whiley b/tests/valid/TypeEquals_Valid_3.whiley
index bfca4f68b..d0d85c8f7 100644
--- a/tests/valid/TypeEquals_Valid_3.whiley
+++ b/tests/valid/TypeEquals_Valid_3.whiley
@@ -10,7 +10,7 @@ function create(nat size, nat value) -> nat[]:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     assume create(10, 10) == [10,10,10,10,10, 10,10,10,10,10]
     assume create(5, 0) == [0,0,0,0,0]
     assume create(0, 0) == [0;0]
diff --git a/tests/valid/TypeEquals_Valid_30.whiley b/tests/valid/TypeEquals_Valid_30.whiley
index 3d3c382a0..9283de552 100644
--- a/tests/valid/TypeEquals_Valid_30.whiley
+++ b/tests/valid/TypeEquals_Valid_30.whiley
@@ -33,7 +33,7 @@ function evaluate(Expr e) -> int:
                 else:
                     return -1
 
-public export method test() -> void:
+public export method test() :
     Expr e = 1
     assume evaluate(e) == 1
     e = {op: ADD, rhs: e, lhs: e}
diff --git a/tests/valid/TypeEquals_Valid_31.whiley b/tests/valid/TypeEquals_Valid_31.whiley
index f34bc5c8a..88b70fe0a 100644
--- a/tests/valid/TypeEquals_Valid_31.whiley
+++ b/tests/valid/TypeEquals_Valid_31.whiley
@@ -11,7 +11,7 @@ type rec12 is rec1 | rec2
 function f(rec12 x) -> int:
     return 1
 
-public export method test() -> void:
+public export method test() :
     rec1 r1 = {f1: "hello", f2: 2}
     rec2 r2 = {f1: 1, f2: 0}
     assume f(r1) == 1
diff --git a/tests/valid/TypeEquals_Valid_32.whiley b/tests/valid/TypeEquals_Valid_32.whiley
index 693504dbf..48f8abee1 100644
--- a/tests/valid/TypeEquals_Valid_32.whiley
+++ b/tests/valid/TypeEquals_Valid_32.whiley
@@ -23,7 +23,7 @@ function f(expr e) -> int[]:
     else:
         return [0;0]
 
-public export method test() -> void:
+public export method test() :
     int[] e = [1, 2, 3, 4]
     assume f(e) == [0, 1, 2, 3, 4]
     assume f(false) == [0;0]
diff --git a/tests/valid/TypeEquals_Valid_33.whiley b/tests/valid/TypeEquals_Valid_33.whiley
index ee79261af..91e15b658 100644
--- a/tests/valid/TypeEquals_Valid_33.whiley
+++ b/tests/valid/TypeEquals_Valid_33.whiley
@@ -12,7 +12,7 @@ function f(expr e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f(-1) == false
     assume f(1) == true
     assume f(1234) == true
diff --git a/tests/valid/TypeEquals_Valid_34.whiley b/tests/valid/TypeEquals_Valid_34.whiley
index d63688928..bfc6dfcbd 100644
--- a/tests/valid/TypeEquals_Valid_34.whiley
+++ b/tests/valid/TypeEquals_Valid_34.whiley
@@ -10,7 +10,7 @@ function f(expr e) -> int:
     else:
         return e + 1
 
-public export method test() -> void:
+public export method test() :
     int x = f(1)
     assume x == 2
     x = f({y: 10, x: 4})
diff --git a/tests/valid/TypeEquals_Valid_35.whiley b/tests/valid/TypeEquals_Valid_35.whiley
index 47fc42b04..a57e3b5d5 100644
--- a/tests/valid/TypeEquals_Valid_35.whiley
+++ b/tests/valid/TypeEquals_Valid_35.whiley
@@ -13,7 +13,7 @@ function f(expr e) -> int:
     else:
         return 0
 
-public export method test() -> void:
+public export method test() :
     assume f(-1) == 0
     assume f(1) == 2
     assume f(1234) == 1235
diff --git a/tests/valid/TypeEquals_Valid_36.whiley b/tests/valid/TypeEquals_Valid_36.whiley
index a74e367aa..b5272f3be 100644
--- a/tests/valid/TypeEquals_Valid_36.whiley
+++ b/tests/valid/TypeEquals_Valid_36.whiley
@@ -12,7 +12,7 @@ function f(tup t) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f({p: 0, lhs: [0]}) == true
     assume f({p: 0, lhs: [0, 1]}) == true
     assume f({p: 0, lhs: [1, 1]}) == false
diff --git a/tests/valid/TypeEquals_Valid_37.whiley b/tests/valid/TypeEquals_Valid_37.whiley
index 40655cfed..bb60c931f 100644
--- a/tests/valid/TypeEquals_Valid_37.whiley
+++ b/tests/valid/TypeEquals_Valid_37.whiley
@@ -12,7 +12,7 @@ function f(tup t) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f({p: 0, lhs: [0]}) == true
     assume f({p: 0, lhs: [0, 1]}) == true
     assume f({p: 0, lhs: [1, 1]}) == false
diff --git a/tests/valid/TypeEquals_Valid_38.whiley b/tests/valid/TypeEquals_Valid_38.whiley
index 696ae1f8d..eba865aaa 100644
--- a/tests/valid/TypeEquals_Valid_38.whiley
+++ b/tests/valid/TypeEquals_Valid_38.whiley
@@ -10,7 +10,7 @@ function f(tup t) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f({p: 0, lhs: [0]}) == true
     assume f({p: 0, lhs: [1]}) == false
     assume f({p: 0, lhs: [0;0]}) == false
diff --git a/tests/valid/TypeEquals_Valid_39.whiley b/tests/valid/TypeEquals_Valid_39.whiley
index b53170155..629da9cce 100644
--- a/tests/valid/TypeEquals_Valid_39.whiley
+++ b/tests/valid/TypeEquals_Valid_39.whiley
@@ -12,7 +12,7 @@ function f(expr e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f(-1) == false
     assume f(1.0) == true
     assume f(1234.0) == true
diff --git a/tests/valid/TypeEquals_Valid_40.whiley b/tests/valid/TypeEquals_Valid_40.whiley
index f801ca138..35146c080 100644
--- a/tests/valid/TypeEquals_Valid_40.whiley
+++ b/tests/valid/TypeEquals_Valid_40.whiley
@@ -15,7 +15,7 @@ function f(expr e) -> int:
         else:
             return 2
 
-public export method test() -> void:
+public export method test() :
     assume f(-1) == 1
     assume f(1.0) == 0
     assume f(1.234) == 0
diff --git a/tests/valid/TypeEquals_Valid_41.whiley b/tests/valid/TypeEquals_Valid_41.whiley
index 6fc4bc8c6..59ce232ca 100644
--- a/tests/valid/TypeEquals_Valid_41.whiley
+++ b/tests/valid/TypeEquals_Valid_41.whiley
@@ -10,7 +10,7 @@ function f(expr e) -> int:
     else:
         return e
 
-public export method test() -> void:
+public export method test() :
     x = f(1)
     assume x == 1
     x = f({y: 10, x: 4})
diff --git a/tests/valid/TypeEquals_Valid_42.whiley b/tests/valid/TypeEquals_Valid_42.whiley
index 379f5a1a2..506eb439c 100644
--- a/tests/valid/TypeEquals_Valid_42.whiley
+++ b/tests/valid/TypeEquals_Valid_42.whiley
@@ -10,7 +10,7 @@ function f(expr e) -> int:
     else:
         return e
 
-public export method test() -> void:
+public export method test() :
     int x = f(1)
     assume x == 1
     x = f({y: 10, x: 4})
diff --git a/tests/valid/TypeEquals_Valid_43.whiley b/tests/valid/TypeEquals_Valid_43.whiley
index 896568640..830ce8c06 100644
--- a/tests/valid/TypeEquals_Valid_43.whiley
+++ b/tests/valid/TypeEquals_Valid_43.whiley
@@ -8,6 +8,6 @@ function getMessage(imsg m) -> any:
     else:
         return m
 
-public export method test() -> void:
+public export method test() :
     assume getMessage({msg: "HELLO WORLD"}) == "HELLO WORLD"
     assume getMessage(1) == 1
diff --git a/tests/valid/TypeEquals_Valid_44.whiley b/tests/valid/TypeEquals_Valid_44.whiley
index 360770230..8cbde120c 100644
--- a/tests/valid/TypeEquals_Valid_44.whiley
+++ b/tests/valid/TypeEquals_Valid_44.whiley
@@ -11,7 +11,7 @@ function getMessage(imsg m) -> any:
         else:
             return m
 
-public export method test() -> void:
+public export method test() :
     assume getMessage({msg: "HELLO WORLD"}) == "HELLO WORLD"
     assume getMessage(1) == 1
     assume getMessage({op: 123}) == 123
diff --git a/tests/valid/TypeEquals_Valid_45.whiley b/tests/valid/TypeEquals_Valid_45.whiley
index 8861f09b3..d8daccffa 100644
--- a/tests/valid/TypeEquals_Valid_45.whiley
+++ b/tests/valid/TypeEquals_Valid_45.whiley
@@ -11,7 +11,7 @@ function f(intlist x) -> int:
         return x
     return 1
 
-public export method test() -> void:
+public export method test() :
     int x = f([1, 2, 3])
     assume x == 1
     x = f(123)
diff --git a/tests/valid/TypeEquals_Valid_46.whiley b/tests/valid/TypeEquals_Valid_46.whiley
index bda77e496..4da60f1f7 100644
--- a/tests/valid/TypeEquals_Valid_46.whiley
+++ b/tests/valid/TypeEquals_Valid_46.whiley
@@ -11,7 +11,7 @@ function f(intlist x) -> int:
         return x
     return 1
 
-public export method test() -> void:
+public export method test() :
     int x = f([1, 2, 3])
     assume x == 1
     x = f(123)
diff --git a/tests/valid/TypeEquals_Valid_47.whiley b/tests/valid/TypeEquals_Valid_47.whiley
index daa458a92..4497210dc 100644
--- a/tests/valid/TypeEquals_Valid_47.whiley
+++ b/tests/valid/TypeEquals_Valid_47.whiley
@@ -10,7 +10,7 @@ function f(T x) -> int:
     else:
         return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 0
     assume f(-1) == -1
     assume f([1, 2, 3]) == 0
diff --git a/tests/valid/TypeEquals_Valid_5.whiley b/tests/valid/TypeEquals_Valid_5.whiley
index 9e3853256..8017c607a 100644
--- a/tests/valid/TypeEquals_Valid_5.whiley
+++ b/tests/valid/TypeEquals_Valid_5.whiley
@@ -6,7 +6,7 @@ function f(int | null x) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     int|null x = null
     assume f(x) == true
     assume f(1) == false
diff --git a/tests/valid/TypeEquals_Valid_6.whiley b/tests/valid/TypeEquals_Valid_6.whiley
index ff01e2c45..1ff336001 100644
--- a/tests/valid/TypeEquals_Valid_6.whiley
+++ b/tests/valid/TypeEquals_Valid_6.whiley
@@ -18,6 +18,6 @@ function f(int x) -> bool:
 function syntaxError(int[] errorMessage) -> SyntaxError:
     return {msg: errorMessage}
 
-public export method test() -> void:
+public export method test() :
     assume f(0) == true
     assume f(1) == false
diff --git a/tests/valid/TypeEquals_Valid_7.whiley b/tests/valid/TypeEquals_Valid_7.whiley
index c06c26019..fce8a5cb2 100644
--- a/tests/valid/TypeEquals_Valid_7.whiley
+++ b/tests/valid/TypeEquals_Valid_7.whiley
@@ -8,7 +8,7 @@ function f(intreal e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == true
     assume f(1.134) == false
     assume f(1.0) == false
diff --git a/tests/valid/TypeEquals_Valid_8.whiley b/tests/valid/TypeEquals_Valid_8.whiley
index 035a435d3..b9f1aa6b3 100644
--- a/tests/valid/TypeEquals_Valid_8.whiley
+++ b/tests/valid/TypeEquals_Valid_8.whiley
@@ -13,7 +13,7 @@ function f(rlist e) -> bool:
 function g(ilist e) -> bool:
     return f((rlist) e)
 
-public export method test() -> void:
+public export method test() :
     assume f(1.0) == false
     assume f([1]) == true
     assume f([0;0]) == true
diff --git a/tests/valid/TypeEquals_Valid_9.whiley b/tests/valid/TypeEquals_Valid_9.whiley
index 29114ee4b..200d1dd42 100644
--- a/tests/valid/TypeEquals_Valid_9.whiley
+++ b/tests/valid/TypeEquals_Valid_9.whiley
@@ -8,7 +8,7 @@ function f(expr e) -> bool:
     else:
         return false
 
-public export method test() -> void:
+public export method test() :
     expr e = 1
     assume f(e) == false
     e = [1, 2, 3, 4]
diff --git a/tests/valid/UnionType_Valid_1.whiley b/tests/valid/UnionType_Valid_1.whiley
index e3c9f7166..224836f6f 100644
--- a/tests/valid/UnionType_Valid_1.whiley
+++ b/tests/valid/UnionType_Valid_1.whiley
@@ -1,6 +1,6 @@
 
 
-public export method test() -> void:
+public export method test() :
     int|int[] x
     //
     if 0 == 1:
diff --git a/tests/valid/UnionType_Valid_10.whiley b/tests/valid/UnionType_Valid_10.whiley
index 47a18cf71..c23db24f3 100644
--- a/tests/valid/UnionType_Valid_10.whiley
+++ b/tests/valid/UnionType_Valid_10.whiley
@@ -11,6 +11,6 @@ type msgType is msg1 | msg2
 function f(msgType m) -> msgType:
     return m
 
-public export method test() -> void:
+public export method test() :
     msg1 x = {op: 11, data: [0;0]}
     assume f(x) == {op: 11, data: [0;0]}
diff --git a/tests/valid/UnionType_Valid_11.whiley b/tests/valid/UnionType_Valid_11.whiley
index 77e1f1016..af851c95a 100644
--- a/tests/valid/UnionType_Valid_11.whiley
+++ b/tests/valid/UnionType_Valid_11.whiley
@@ -11,7 +11,7 @@ type msgType is msg1 | msg2
 function f(msgType m) -> msgType:
     return m
 
-public export method test() -> void:
+public export method test() :
     msg1 m1 = {op: 11, data: [0;0]}
     msg2 m2 = {index: 1}
     assume f(m1) == {op: 11, data: [0;0]}
diff --git a/tests/valid/UnionType_Valid_12.whiley b/tests/valid/UnionType_Valid_12.whiley
index 57c04a084..4e3842bbd 100644
--- a/tests/valid/UnionType_Valid_12.whiley
+++ b/tests/valid/UnionType_Valid_12.whiley
@@ -8,7 +8,7 @@ function f(IntList y) -> IntList:
 function g({int op, int mode} z) -> IntList:
     return z
 
-public export method test() -> void:
+public export method test() :
     IntList x = {op: 1, rest: [1.23]}
     assume f(x) == {op: 1, rest: [1.23]}
     x = {op: 123, mode: 0}
diff --git a/tests/valid/UnionType_Valid_13.whiley b/tests/valid/UnionType_Valid_13.whiley
index 8d29c860c..c11b032e6 100644
--- a/tests/valid/UnionType_Valid_13.whiley
+++ b/tests/valid/UnionType_Valid_13.whiley
@@ -11,7 +11,7 @@ type msgType is msg1 | msg2
 function f(msgType m) -> msgType:
     return m
 
-public export method test() -> void:
+public export method test() :
     msg1 m1 = {op: 11, data: [0;0]}
     msg2 m2 = {index: 1}
     assume f(m1) == {op: 11, data: [0;0]}
diff --git a/tests/valid/UnionType_Valid_14.whiley b/tests/valid/UnionType_Valid_14.whiley
index f2ba50d5c..c714c8a15 100644
--- a/tests/valid/UnionType_Valid_14.whiley
+++ b/tests/valid/UnionType_Valid_14.whiley
@@ -25,7 +25,7 @@ function f(Expr e) -> int:
         else:
             return 1
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
     assume f([1, 2, 3]) == 3
     assume f({op: ADD, rhs: 2, lhs: 1}) == 1
diff --git a/tests/valid/UnionType_Valid_15.whiley b/tests/valid/UnionType_Valid_15.whiley
index dbfca6f57..e262c5739 100644
--- a/tests/valid/UnionType_Valid_15.whiley
+++ b/tests/valid/UnionType_Valid_15.whiley
@@ -6,7 +6,7 @@ type msgType is msg1 | msg2
 function f(msgType m) -> msgType:
     return m
 
-public export method test() -> void:
+public export method test() :
     msg1 x = {op: 1, data: [1, 2, 3]}
     assume f(x) == {op: 1, data: [1, 2, 3]}
     int[] list = x.data
diff --git a/tests/valid/UnionType_Valid_16.whiley b/tests/valid/UnionType_Valid_16.whiley
index c26a1cb38..e4a8181e7 100644
--- a/tests/valid/UnionType_Valid_16.whiley
+++ b/tests/valid/UnionType_Valid_16.whiley
@@ -2,7 +2,7 @@
 
 type IntList is {int | int[] op}
 
-public export method test() -> void:
+public export method test() :
     IntList x = {op: 2}
     x.op = 1
     IntList y = x
diff --git a/tests/valid/UnionType_Valid_17.whiley b/tests/valid/UnionType_Valid_17.whiley
index 1ee8a43a7..8dc3379f1 100644
--- a/tests/valid/UnionType_Valid_17.whiley
+++ b/tests/valid/UnionType_Valid_17.whiley
@@ -8,7 +8,7 @@ method f(int y) -> int:
 method g(int[] z) -> int[]:
     return z
 
-public export method test() -> void:
+public export method test() :
     IntList x = 123
     assume f(x) == 123
     x = [1, 2, 3]
diff --git a/tests/valid/UnionType_Valid_18.whiley b/tests/valid/UnionType_Valid_18.whiley
index e67a4ec9e..a4ee1305e 100644
--- a/tests/valid/UnionType_Valid_18.whiley
+++ b/tests/valid/UnionType_Valid_18.whiley
@@ -11,6 +11,6 @@ ensures result >= 0:
     //
     return y.op
 
-public export method test() -> void:
+public export method test() :
     tupper x = {op: 1, il: 1}
     assume f(x) == 1
diff --git a/tests/valid/UnionType_Valid_19.whiley b/tests/valid/UnionType_Valid_19.whiley
index 486f92755..aa07d053d 100644
--- a/tests/valid/UnionType_Valid_19.whiley
+++ b/tests/valid/UnionType_Valid_19.whiley
@@ -9,6 +9,6 @@ type tupper is {int op, intList il}
 function f(tupper y) -> int:
     return y.op
 
-public export method test() -> void:
+public export method test() :
     tupper x = {op: 1, il: 1}
     assume f(x) == 1
diff --git a/tests/valid/UnionType_Valid_2.whiley b/tests/valid/UnionType_Valid_2.whiley
index 6f9ef59ed..3397a6104 100644
--- a/tests/valid/UnionType_Valid_2.whiley
+++ b/tests/valid/UnionType_Valid_2.whiley
@@ -22,7 +22,7 @@ function parseNumber(State st) -> {Expr f1, State f2}:
         st.pos = st.pos + 1
     return {f1: (real) n, f2: st}
 
-public export method test() -> void:
+public export method test() :
     {SExpr f1, State f2} s = parseTerm({input: "123", pos: 0})
     assume s.f1 == 6.0
     s = parseTerm({input: "abc", pos: 0})
diff --git a/tests/valid/UnionType_Valid_20.whiley b/tests/valid/UnionType_Valid_20.whiley
index 3468053c7..564073a05 100644
--- a/tests/valid/UnionType_Valid_20.whiley
+++ b/tests/valid/UnionType_Valid_20.whiley
@@ -13,6 +13,6 @@ type byteCode is STORE | BRANCH
 function f(byteCode b) -> byteCode:
     return b
 
-public export method test() -> void:
+public export method test() :
     STORE b = {index: 1, op: 0}
     assume f(b) == {index: 1, op: 0}
diff --git a/tests/valid/UnionType_Valid_21.whiley b/tests/valid/UnionType_Valid_21.whiley
index bee77db70..d49df7c52 100644
--- a/tests/valid/UnionType_Valid_21.whiley
+++ b/tests/valid/UnionType_Valid_21.whiley
@@ -7,6 +7,6 @@ function f(int x) -> nlist:
     else:
         return f(x - 1)
 
-public export method test() -> void:
+public export method test() :
     nlist x = f(2)
     assume x == 0
diff --git a/tests/valid/UnionType_Valid_22.whiley b/tests/valid/UnionType_Valid_22.whiley
index 62687c767..2202a627f 100644
--- a/tests/valid/UnionType_Valid_22.whiley
+++ b/tests/valid/UnionType_Valid_22.whiley
@@ -7,6 +7,6 @@ function f(int i, nlist[] xs) -> nlist:
     else:
         return xs[i]
 
-public export method test() -> void:
+public export method test() :
     nlist x = f(2, [2, 3, 4])
     assume x == 4
diff --git a/tests/valid/UnionType_Valid_23.whiley b/tests/valid/UnionType_Valid_23.whiley
index 7d5331772..51ed10a7b 100644
--- a/tests/valid/UnionType_Valid_23.whiley
+++ b/tests/valid/UnionType_Valid_23.whiley
@@ -5,7 +5,7 @@ type IntList is {int op, real[] rest} | {int op, int mode}
 function f(IntList y) -> IntList:
     return y
 
-public export method test() -> void:
+public export method test() :
     {int|real op, real[] rest} x = {op: 1, rest: [1.23]}
     if 0 == 10:
         x = {op: 1.23, rest: [1.0]}
diff --git a/tests/valid/UnionType_Valid_3.whiley b/tests/valid/UnionType_Valid_3.whiley
index d060f315d..0f8c9b529 100644
--- a/tests/valid/UnionType_Valid_3.whiley
+++ b/tests/valid/UnionType_Valid_3.whiley
@@ -8,6 +8,6 @@ function f(TYPE[] xs, TYPE p) -> int:
         i = i + 1
     return -1
 
-public export method test() -> void:
+public export method test() :
     assume f([null, 1, 2], null) == 0
     assume f([1, 2, null, 10], 10) == 3
diff --git a/tests/valid/UnionType_Valid_4.whiley b/tests/valid/UnionType_Valid_4.whiley
index 4c0f3c5cc..1fc39d523 100644
--- a/tests/valid/UnionType_Valid_4.whiley
+++ b/tests/valid/UnionType_Valid_4.whiley
@@ -5,7 +5,7 @@ type IntReal is int | real
 function f(IntReal y) -> IntReal:
     return y
 
-public export method test() -> void:
+public export method test() :
     IntReal x = 123
     assume f(x) == 123
     x = 1.234
diff --git a/tests/valid/UnionType_Valid_5.whiley b/tests/valid/UnionType_Valid_5.whiley
index 852843455..ea4b0c5f9 100644
--- a/tests/valid/UnionType_Valid_5.whiley
+++ b/tests/valid/UnionType_Valid_5.whiley
@@ -9,5 +9,5 @@ type wur4nat is ur4nat | tur4nat
 function f(wur4nat x) -> any:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
diff --git a/tests/valid/UnionType_Valid_6.whiley b/tests/valid/UnionType_Valid_6.whiley
index a1f4eaae7..772cbbd11 100644
--- a/tests/valid/UnionType_Valid_6.whiley
+++ b/tests/valid/UnionType_Valid_6.whiley
@@ -9,5 +9,5 @@ type wur4nat is ur4nat | tur4nat
 function f(wur4nat x) -> any:
     return x
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 1
diff --git a/tests/valid/UnionType_Valid_7.whiley b/tests/valid/UnionType_Valid_7.whiley
index 05ff69a5f..c94881f89 100644
--- a/tests/valid/UnionType_Valid_7.whiley
+++ b/tests/valid/UnionType_Valid_7.whiley
@@ -9,5 +9,5 @@ type msgType is msgType1 | msgType2
 function f(msgType msg) -> any:
     return msg.op
 
-public export method test() -> void:
+public export method test() :
     assume f({op: 1, payload: [1, 2, 3]}) == 1
diff --git a/tests/valid/UnionType_Valid_8.whiley b/tests/valid/UnionType_Valid_8.whiley
index 3ba7d3054..65c65b598 100644
--- a/tests/valid/UnionType_Valid_8.whiley
+++ b/tests/valid/UnionType_Valid_8.whiley
@@ -9,5 +9,5 @@ type msgType is msgType1 | msgType2
 function f(msgType msg) -> any:
     return msg.op
 
-public export method test() -> void:
+public export method test() :
     assume f({op: 1, payload: [1, 2, 3]}) == 1
diff --git a/tests/valid/UnionType_Valid_9.whiley b/tests/valid/UnionType_Valid_9.whiley
index c3644d64e..947ce3885 100644
--- a/tests/valid/UnionType_Valid_9.whiley
+++ b/tests/valid/UnionType_Valid_9.whiley
@@ -11,6 +11,6 @@ type msgType is msg1 | msg2
 function f(msgType m) -> any:
     return m
 
-public export method test() -> void:
+public export method test() :
     msg1 x = {op: 11, data: [0;0]}
     assume f(x) == {op: 11, data: [0;0]}
diff --git a/tests/valid/Update_Valid_2.whiley b/tests/valid/Update_Valid_2.whiley
index 907adfb6c..002b7dbdd 100644
--- a/tests/valid/Update_Valid_2.whiley
+++ b/tests/valid/Update_Valid_2.whiley
@@ -7,7 +7,7 @@ requires 0 <= index && index < |l|:
     l[index] = value
     return l
 
-public export method test() -> void:
+public export method test() :
     int[] l = ['1', '2', '3']
     assume update(l, 1, 0) == ['1',0,'3']
     assume update(l, 2, 0) == ['1','2',0]
diff --git a/tests/valid/VarDecl_Valid_1.whiley b/tests/valid/VarDecl_Valid_1.whiley
index 46aed6b84..e0bd4c4b1 100644
--- a/tests/valid/VarDecl_Valid_1.whiley
+++ b/tests/valid/VarDecl_Valid_1.whiley
@@ -1,5 +1,5 @@
 
 
-public export method test() -> void:
+public export method test() :
     int x = 1
     assert x == 1
diff --git a/tests/valid/VarDecl_Valid_2.whiley b/tests/valid/VarDecl_Valid_2.whiley
index 6bd5f9a24..8304ab083 100644
--- a/tests/valid/VarDecl_Valid_2.whiley
+++ b/tests/valid/VarDecl_Valid_2.whiley
@@ -9,5 +9,5 @@ requires x > 0:
     int y = x + 1
     return g(y)
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 2
diff --git a/tests/valid/VarDecl_Valid_3.whiley b/tests/valid/VarDecl_Valid_3.whiley
index 6cf673dd1..759c3bfec 100644
--- a/tests/valid/VarDecl_Valid_3.whiley
+++ b/tests/valid/VarDecl_Valid_3.whiley
@@ -7,5 +7,5 @@ function f(int x) -> int:
     int y = x + 1
     return g(y)
 
-public export method test() -> void:
+public export method test() :
     assume f(1) == 2
diff --git a/tests/valid/VarDecl_Valid_4.whiley b/tests/valid/VarDecl_Valid_4.whiley
index 0b716d189..6666f9c31 100644
--- a/tests/valid/VarDecl_Valid_4.whiley
+++ b/tests/valid/VarDecl_Valid_4.whiley
@@ -3,6 +3,6 @@
 function constantPool() -> int:
     return 12478623847120981
 
-public export method test() -> void:
+public export method test() :
     int pool = constantPool()
     assume pool == 12478623847120981
diff --git a/tests/valid/While_Valid_1.whiley b/tests/valid/While_Valid_1.whiley
index 6010449f8..d81b37870 100644
--- a/tests/valid/While_Valid_1.whiley
+++ b/tests/valid/While_Valid_1.whiley
@@ -9,6 +9,6 @@ function reverse(int[] ls) -> int[]:
         r[i] = item
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] rs = reverse([1, 2, 3, 4, 5])
     assume rs == [5,4,3,2,1]
diff --git a/tests/valid/While_Valid_10.whiley b/tests/valid/While_Valid_10.whiley
index 789e65e81..fab67ecf9 100644
--- a/tests/valid/While_Valid_10.whiley
+++ b/tests/valid/While_Valid_10.whiley
@@ -8,7 +8,7 @@ function extract(int[] ls) -> int[]:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] rs = extract([1, 2, 3, 4, 5, 6, 7])
     assume rs == [1, 1, 1, 1, 1, 1, 1]
     rs = extract([0;0])
diff --git a/tests/valid/While_Valid_11.whiley b/tests/valid/While_Valid_11.whiley
index 5c22a1d55..197db5a78 100644
--- a/tests/valid/While_Valid_11.whiley
+++ b/tests/valid/While_Valid_11.whiley
@@ -14,7 +14,7 @@ function extract(int[] ls) -> nat[]:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] rs = extract([-1, 2, 3, -4, 5, 6, 7, 23987, -23897, 0, -1, 1, -2389])
     assume rs == [1, 2, 3, 4, 5, 6, 7, 23987, 23897, 0, 1, 1, 2389]
     rs = extract([0;0])
diff --git a/tests/valid/While_Valid_12.whiley b/tests/valid/While_Valid_12.whiley
index 0bed3c067..f97ecd079 100644
--- a/tests/valid/While_Valid_12.whiley
+++ b/tests/valid/While_Valid_12.whiley
@@ -12,7 +12,7 @@ ensures |vr| == |v1|:
         i = i + 1
     return v1
 
-public export method test() -> void:
+public export method test() :
     assume add([1, 2, 3], [4, 5, 6]) == [5,7,9]
     assume add([1], [4]) == [5]
     assume add([0;0], [0;0]) == [0;0]
diff --git a/tests/valid/While_Valid_14.whiley b/tests/valid/While_Valid_14.whiley
index 60e5e89dd..fdecc1784 100644
--- a/tests/valid/While_Valid_14.whiley
+++ b/tests/valid/While_Valid_14.whiley
@@ -8,6 +8,6 @@ ensures r >= |ls|:
         i = i + 1
     return i
 
-public export method test() -> void:
+public export method test() :
     int rs = extract([-2, -3, 1, 2, -23, 3, 2345, 4, 5])
     assume rs == 9
diff --git a/tests/valid/While_Valid_15.whiley b/tests/valid/While_Valid_15.whiley
index e98c8799b..dfdfde0f6 100644
--- a/tests/valid/While_Valid_15.whiley
+++ b/tests/valid/While_Valid_15.whiley
@@ -13,7 +13,7 @@ function dist(LinkedList list) -> Leaf:
         distance = distance + 1
     return list + distance
 
-public export method test() -> void:
+public export method test() :
     LinkedList list = 123
     list = {next: list}
     list = {next: list}
diff --git a/tests/valid/While_Valid_16.whiley b/tests/valid/While_Valid_16.whiley
index 6b725989b..285479b99 100644
--- a/tests/valid/While_Valid_16.whiley
+++ b/tests/valid/While_Valid_16.whiley
@@ -17,7 +17,7 @@ ensures no { x in 0 .. |src| | result[x] <= 0 }:
         i = i + 1
     return src
 
-public export method test() -> void:
+public export method test() :
     nat[] xs = [1, 3, 5, 7, 9, 11]
     xs = inc(xs)
     assume xs == [2, 4, 6, 8, 10, 12]
diff --git a/tests/valid/While_Valid_17.whiley b/tests/valid/While_Valid_17.whiley
index 04f12d5d0..87f6afe11 100644
--- a/tests/valid/While_Valid_17.whiley
+++ b/tests/valid/While_Valid_17.whiley
@@ -2,7 +2,7 @@
 
 
 
-public export method test() -> void:
+public export method test() :
     int i = 0
     while i < 5:
         if i == 3:
diff --git a/tests/valid/While_Valid_18.whiley b/tests/valid/While_Valid_18.whiley
index ed62bbe35..ff6769c1b 100644
--- a/tests/valid/While_Valid_18.whiley
+++ b/tests/valid/While_Valid_18.whiley
@@ -12,7 +12,7 @@ function match(byte[] data, nat offset, nat end) -> int:
     //
     return len
 
-public export method test() -> void:
+public export method test() :
     byte[] xs = [
         00000000b,
         00000101b,
diff --git a/tests/valid/While_Valid_19.whiley b/tests/valid/While_Valid_19.whiley
index 0554b5a14..7be3600bb 100644
--- a/tests/valid/While_Valid_19.whiley
+++ b/tests/valid/While_Valid_19.whiley
@@ -2,7 +2,7 @@
 
 constant SIZE is 5
 
-public export method test() -> void:
+public export method test() :
     int[][] components = [[0;0]; SIZE]
     int i = 0
     while i < |components| where i >= 0:
diff --git a/tests/valid/While_Valid_20.whiley b/tests/valid/While_Valid_20.whiley
index 1c7107c37..69ba76346 100644
--- a/tests/valid/While_Valid_20.whiley
+++ b/tests/valid/While_Valid_20.whiley
@@ -9,7 +9,7 @@ function sum(LinkedList l) -> int:
         l = l.next
     return r
 
-public export method test() -> void:
+public export method test() :
     LinkedList list = null
     assume sum(list) == 0
     list = {next: list, data: 1}
diff --git a/tests/valid/While_Valid_21.whiley b/tests/valid/While_Valid_21.whiley
index 680a27e38..eb881e992 100644
--- a/tests/valid/While_Valid_21.whiley
+++ b/tests/valid/While_Valid_21.whiley
@@ -13,7 +13,7 @@ ensures |result| == count:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     assume create(3, 3) == [3,3,3]
     assume create(2, 2) == [2,2]
     assume create(2, 1) == [1,1]
diff --git a/tests/valid/While_Valid_22.whiley b/tests/valid/While_Valid_22.whiley
index ff4e53565..0e1929a62 100644
--- a/tests/valid/While_Valid_22.whiley
+++ b/tests/valid/While_Valid_22.whiley
@@ -21,7 +21,7 @@ ensures no { i in 0..|xs| | xs[i] > result }:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     assume max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10
     assume max([-8, 7, 9, 1, -1, 2, 5, 6, -200, 4]) == 9
     assume max([1]) == 1
diff --git a/tests/valid/While_Valid_23.whiley b/tests/valid/While_Valid_23.whiley
index 1482489f1..00efcd911 100644
--- a/tests/valid/While_Valid_23.whiley
+++ b/tests/valid/While_Valid_23.whiley
@@ -15,5 +15,5 @@ ensures some { i in 0 .. |xs| | result == xs[i] }:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     assume f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10
diff --git a/tests/valid/While_Valid_24.whiley b/tests/valid/While_Valid_24.whiley
index c77892c8b..0d7270a09 100644
--- a/tests/valid/While_Valid_24.whiley
+++ b/tests/valid/While_Valid_24.whiley
@@ -11,6 +11,6 @@ ensures result is null || xs[result] == x:
         i = i + 1
     return null
 
-public export method test() -> void:
+public export method test() :
     assume indexOf([1, 2, 3], 1) == 0
     assume indexOf([1, 2, 3], 0) == null
diff --git a/tests/valid/While_Valid_25.whiley b/tests/valid/While_Valid_25.whiley
index afeadb3a1..c85a9b520 100644
--- a/tests/valid/While_Valid_25.whiley
+++ b/tests/valid/While_Valid_25.whiley
@@ -8,5 +8,5 @@ function f(int n) -> int:
         y = y + 2
     return x + y
 
-public export method test() -> void:
+public export method test() :
     assume f(10) == 30
diff --git a/tests/valid/While_Valid_28.whiley b/tests/valid/While_Valid_28.whiley
index 64a4ed146..ceb09d9a4 100644
--- a/tests/valid/While_Valid_28.whiley
+++ b/tests/valid/While_Valid_28.whiley
@@ -19,7 +19,7 @@ requires |xs| > 0:
     //
     return r
 
-public export method test() -> void:
+public export method test() :
     assume sum([1]) == 1
     assume sum([1, 2]) == 3
     assume sum([1, 2, 3]) == 6
diff --git a/tests/valid/While_Valid_3.whiley b/tests/valid/While_Valid_3.whiley
index c52f16cef..15e8f967b 100644
--- a/tests/valid/While_Valid_3.whiley
+++ b/tests/valid/While_Valid_3.whiley
@@ -10,7 +10,7 @@ function sum(nat[] ls) -> nat:
         i = i + 1
     return sum
 
-public export method test() -> void:
+public export method test() :
     assume sum([0;0]) == 0
     assume sum([1, 2, 3]) == 6
     assume sum([12387, 98123, 12398, 12309, 0]) == 135217
diff --git a/tests/valid/While_Valid_44.whiley b/tests/valid/While_Valid_44.whiley
index fadaca4ff..3f857bdf7 100644
--- a/tests/valid/While_Valid_44.whiley
+++ b/tests/valid/While_Valid_44.whiley
@@ -10,7 +10,7 @@ ensures |result| == |ls|:
         r[i] = item
     return r
 
-public export method test() -> void:
+public export method test() :
     assume reverse([0;0]) == [0;0]
     assume reverse([1]) == [1]
     assume reverse([1,2]) == [2,1]
diff --git a/tests/valid/While_Valid_5.whiley b/tests/valid/While_Valid_5.whiley
index 089f7c988..92d238673 100644
--- a/tests/valid/While_Valid_5.whiley
+++ b/tests/valid/While_Valid_5.whiley
@@ -15,6 +15,6 @@ function extract(int[] ls) -> nat[]:
         i = i + 1
     return rs
 
-public export method test() -> void:
+public export method test() :
     int[] rs = extract([-2, -3, 1, 2, -23, 3, 2345, 4, 5])
     assume rs ==       [ 0,  0, 1, 2,   0, 3, 2345, 4, 5]
diff --git a/tests/valid/While_Valid_7.whiley b/tests/valid/While_Valid_7.whiley
index 2c0a5d97c..330893546 100644
--- a/tests/valid/While_Valid_7.whiley
+++ b/tests/valid/While_Valid_7.whiley
@@ -11,6 +11,6 @@ ensures |rs| > 0:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] rs = extract([-2, -3, 1, 2, -23, 3, 2345, 4, 5])
     assume rs == [-2, -3, 1, 2, -23, 3, 2345, 4, 5]
diff --git a/tests/valid/While_Valid_9.whiley b/tests/valid/While_Valid_9.whiley
index 0d69fa302..58668808f 100644
--- a/tests/valid/While_Valid_9.whiley
+++ b/tests/valid/While_Valid_9.whiley
@@ -10,7 +10,7 @@ ensures |result| > 0:
         i = i + 1
     return r
 
-public export method test() -> void:
+public export method test() :
     int[] rs = extract([1, 2, 3, 4, 5, 6, 7])
     assume rs == [1, 1, 1, 1, 1, 1, 1, 0]
     rs = extract([0;0])
