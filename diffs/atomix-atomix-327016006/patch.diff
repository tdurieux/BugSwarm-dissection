diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/RaftServer.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/RaftServer.java
index 00195afa4..10db3b759 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/RaftServer.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/RaftServer.java
@@ -15,6 +15,7 @@
  */
 package io.atomix.protocols.raft;
 
+import io.atomix.cluster.ClusterService;
 import io.atomix.cluster.NodeId;
 import io.atomix.primitive.PrimitiveType;
 import io.atomix.primitive.PrimitiveTypeRegistry;
@@ -41,7 +42,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static io.atomix.protocols.raft.RaftException.*;
+import static io.atomix.protocols.raft.RaftException.ConfigurationException;
 
 /**
  * Provides a standalone implementation of the <a href="http://raft.github.io/">Raft consensus algorithm</a>.
@@ -562,21 +563,18 @@ default boolean isFollower() {
   abstract class Builder implements io.atomix.utils.Builder<RaftServer> {
     private static final Duration DEFAULT_ELECTION_TIMEOUT = Duration.ofMillis(750);
     private static final Duration DEFAULT_HEARTBEAT_INTERVAL = Duration.ofMillis(250);
-    private static final int DEFAULT_ELECTION_THRESHOLD = 3;
     private static final Duration DEFAULT_SESSION_TIMEOUT = Duration.ofMillis(5000);
-    private static final int DEFAULT_SESSION_FAILURE_THRESHOLD = 3;
     private static final ThreadModel DEFAULT_THREAD_MODEL = ThreadModel.SHARED_THREAD_POOL;
     private static final int DEFAULT_THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();
 
     protected String name;
     protected NodeId localNodeId;
+    protected ClusterService clusterService;
     protected RaftServerProtocol protocol;
     protected RaftStorage storage;
     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;
     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;
-    protected int electionThreshold = DEFAULT_ELECTION_THRESHOLD;
     protected Duration sessionTimeout = DEFAULT_SESSION_TIMEOUT;
-    protected int sessionFailureThreshold = DEFAULT_SESSION_FAILURE_THRESHOLD;
     protected PrimitiveTypeRegistry primitiveTypes = new PrimitiveTypeRegistry();
     protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;
     protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;
@@ -598,6 +596,17 @@ public Builder withName(String name) {
       return this;
     }
 
+    /**
+     * Sets the cluster service.
+     *
+     * @param clusterService the cluster service
+     * @return the server builder
+     */
+    public Builder withClusterService(ClusterService clusterService) {
+      this.clusterService = checkNotNull(clusterService, "clusterService cannot be null");
+      return this;
+    }
+
     /**
      * Sets the initial server member type.
      *
@@ -699,22 +708,6 @@ public Builder withHeartbeatInterval(Duration heartbeatInterval) {
       return this;
     }
 
-    /**
-     * Sets the election failure detection threshold.
-     * <p>
-     * This is the phi value at which a follower will attempt to start a new election after not receiving any
-     * communication from the leader.
-     *
-     * @param electionThreshold the election failure detection threshold
-     * @return The Raft server builder
-     * @throws IllegalArgumentException if the threshold is not positive
-     */
-    public Builder withElectionThreshold(int electionThreshold) {
-      checkArgument(electionThreshold > 0, "electionThreshold must be positive");
-      this.electionThreshold = electionThreshold;
-      return this;
-    }
-
     /**
      * Sets the Raft session timeout, returning the Raft configuration for method chaining.
      *
@@ -731,21 +724,6 @@ public Builder withSessionTimeout(Duration sessionTimeout) {
       return this;
     }
 
-    /**
-     * Sets the session failure detection threshold.
-     * <p>
-     * The threshold is a phi value at which sessions will be expired if the leader cannot communicate with the client.
-     *
-     * @param sessionFailureThreshold the session failure threshold
-     * @return The Raft server builder.
-     * @throws IllegalArgumentException if the threshold is not positive
-     */
-    public Builder withSessionFailureThreshold(int sessionFailureThreshold) {
-      checkArgument(sessionFailureThreshold > 0, "sessionFailureThreshold must be positive");
-      this.sessionFailureThreshold = sessionFailureThreshold;
-      return this;
-    }
-
     /**
      * Sets the server thread pool size.
      *
@@ -758,5 +736,4 @@ public Builder withThreadPoolSize(int threadPoolSize) {
       return this;
     }
   }
-
 }
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/DefaultRaftServer.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/DefaultRaftServer.java
index a3d7482ba..9290251b5 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/DefaultRaftServer.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/DefaultRaftServer.java
@@ -238,12 +238,10 @@ public RaftServer build() {
         storage = RaftStorage.builder().build();
       }
 
-      RaftContext raft = new RaftContext(name, localNodeId, protocol, storage, primitiveTypes, threadModel, threadPoolSize);
+      RaftContext raft = new RaftContext(name, localNodeId, clusterService, protocol, storage, primitiveTypes, threadModel, threadPoolSize);
       raft.setElectionTimeout(electionTimeout);
       raft.setHeartbeatInterval(heartbeatInterval);
-      raft.setElectionThreshold(electionThreshold);
       raft.setSessionTimeout(sessionTimeout);
-      raft.setSessionFailureThreshold(sessionFailureThreshold);
 
       return new DefaultRaftServer(raft);
     }
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/RaftContext.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/RaftContext.java
index 34412cc51..07326c382 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/RaftContext.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/impl/RaftContext.java
@@ -15,6 +15,7 @@
  */
 package io.atomix.protocols.raft.impl;
 
+import io.atomix.cluster.ClusterService;
 import io.atomix.cluster.NodeId;
 import io.atomix.primitive.PrimitiveTypeRegistry;
 import io.atomix.protocols.raft.RaftException;
@@ -81,6 +82,7 @@
   protected final String name;
   protected final ThreadContext threadContext;
   protected final PrimitiveTypeRegistry primitiveTypes;
+  protected final ClusterService clusterService;
   protected final RaftClusterContext cluster;
   protected final RaftServerProtocol protocol;
   protected final RaftStorage storage;
@@ -101,13 +103,10 @@
   protected RaftRole role = new InactiveRole(this);
   private Duration electionTimeout = Duration.ofMillis(500);
   private Duration heartbeatInterval = Duration.ofMillis(150);
-  private int electionThreshold = 3;
   private Duration sessionTimeout = Duration.ofMillis(5000);
-  private int sessionFailureThreshold = 5;
   private volatile NodeId leader;
   private volatile long term;
   private NodeId lastVotedFor;
-  private long lastHeartbeatTime;
   private long commitIndex;
   private volatile long firstCommitIndex;
   private volatile long lastApplied;
@@ -116,12 +115,14 @@
   public RaftContext(
       String name,
       NodeId localNodeId,
+      ClusterService clusterService,
       RaftServerProtocol protocol,
       RaftStorage storage,
       PrimitiveTypeRegistry primitiveTypes,
       ThreadModel threadModel,
       int threadPoolSize) {
     this.name = checkNotNull(name, "name cannot be null");
+    this.clusterService = checkNotNull(clusterService, "clusterService cannot be null");
     this.protocol = checkNotNull(protocol, "protocol cannot be null");
     this.storage = checkNotNull(storage, "storage cannot be null");
     this.primitiveTypes = checkNotNull(primitiveTypes, "registry cannot be null");
@@ -211,7 +212,7 @@ public void removeStateChangeListener(Consumer<State> listener) {
   /**
    * Awaits a state change.
    *
-   * @param state the state for which to wait
+   * @param state    the state for which to wait
    * @param listener the listener to call when the next state change occurs
    */
   public void awaitState(State state, Consumer<State> listener) {
@@ -255,6 +256,15 @@ public ThreadContext getThreadContext() {
     return threadContext;
   }
 
+  /**
+   * Returns the cluster service.
+   *
+   * @return the cluster service
+   */
+  public ClusterService getClusterService() {
+    return clusterService;
+  }
+
   /**
    * Returns the server protocol.
    *
@@ -318,24 +328,6 @@ public Duration getHeartbeatInterval() {
     return heartbeatInterval;
   }
 
-  /**
-   * Sets the election threshold.
-   *
-   * @param electionThreshold the election threshold
-   */
-  public void setElectionThreshold(int electionThreshold) {
-    this.electionThreshold = electionThreshold;
-  }
-
-  /**
-   * Returns the election threshold.
-   *
-   * @return the election threshold
-   */
-  public int getElectionThreshold() {
-    return electionThreshold;
-  }
-
   /**
    * Returns the session timeout.
    *
@@ -354,24 +346,6 @@ public void setSessionTimeout(Duration sessionTimeout) {
     this.sessionTimeout = checkNotNull(sessionTimeout, "sessionTimeout cannot be null");
   }
 
-  /**
-   * Returns the session failure threshold.
-   *
-   * @return the session failure threshold
-   */
-  public int getSessionFailureThreshold() {
-    return sessionFailureThreshold;
-  }
-
-  /**
-   * Sets the session failure threshold.
-   *
-   * @param sessionFailureThreshold the session failure threshold
-   */
-  public void setSessionFailureThreshold(int sessionFailureThreshold) {
-    this.sessionFailureThreshold = sessionFailureThreshold;
-  }
-
   /**
    * Sets the state leader.
    *
@@ -474,31 +448,6 @@ public void setLastVotedFor(NodeId candidate) {
     }
   }
 
-  /**
-   * Returns the last time a request was received from the leader.
-   *
-   * @return The last time a request was received
-   */
-  public long getLastHeartbeatTime() {
-    return lastHeartbeatTime;
-  }
-
-  /**
-   * Sets the last time a request was received from the leader.
-   */
-  public void setLastHeartbeatTime() {
-    setLastHeartbeatTime(System.currentTimeMillis());
-  }
-
-  /**
-   * Sets the last time a request was received by the node.
-   *
-   * @param lastHeartbeatTime The last time a request was received
-   */
-  public void setLastHeartbeatTime(long lastHeartbeatTime) {
-    this.lastHeartbeatTime = lastHeartbeatTime;
-  }
-
   /**
    * Returns the state last voted for candidate.
    *
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/RaftPartition.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/RaftPartition.java
index cfd28e532..de2e9066d 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/RaftPartition.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/RaftPartition.java
@@ -178,6 +178,7 @@ protected RaftPartitionServer createServer(PartitionManagementService management
     return new RaftPartitionServer(
         this,
         managementService.getClusterService().getLocalNode().id(),
+        managementService.getClusterService(),
         managementService.getCommunicationService(),
         managementService.getPrimitiveTypes());
   }
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/impl/RaftPartitionServer.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/impl/RaftPartitionServer.java
index a47a49a42..ef1c18a81 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/impl/RaftPartitionServer.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/partition/impl/RaftPartitionServer.java
@@ -15,6 +15,7 @@
  */
 package io.atomix.protocols.raft.partition.impl;
 
+import io.atomix.cluster.ClusterService;
 import io.atomix.cluster.NodeId;
 import io.atomix.cluster.messaging.ClusterMessagingService;
 import io.atomix.primitive.PrimitiveTypeRegistry;
@@ -51,6 +52,7 @@
 
   private final NodeId localNodeId;
   private final RaftPartition partition;
+  private final ClusterService clusterService;
   private final ClusterMessagingService clusterCommunicator;
   private final PrimitiveTypeRegistry primitiveTypes;
   private RaftServer server;
@@ -58,10 +60,12 @@
   public RaftPartitionServer(
       RaftPartition partition,
       NodeId localNodeId,
+      ClusterService clusterService,
       ClusterMessagingService clusterCommunicator,
       PrimitiveTypeRegistry primitiveTypes) {
     this.partition = partition;
     this.localNodeId = localNodeId;
+    this.clusterService = clusterService;
     this.clusterCommunicator = clusterCommunicator;
     this.primitiveTypes = primitiveTypes;
   }
@@ -130,6 +134,7 @@ public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOEx
   private RaftServer buildServer() {
     return RaftServer.builder(localNodeId)
         .withName(partition.name())
+        .withClusterService(clusterService)
         .withProtocol(new RaftServerCommunicator(
             partition.name(),
             Serializer.using(RaftNamespaces.RAFT_PROTOCOL),
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/AbstractRole.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/AbstractRole.java
index 60f8e320f..6a1af1a87 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/AbstractRole.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/AbstractRole.java
@@ -117,11 +117,6 @@ protected boolean updateTermAndLeader(long term, NodeId leader) {
       raft.getCluster().reset();
       return true;
     }
-
-    // If the leader is non-null, update the last heartbeat time.
-    if (leader != null) {
-      raft.setLastHeartbeatTime();
-    }
     return false;
   }
 
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/FollowerRole.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/FollowerRole.java
index 5e264d781..9452358ea 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/FollowerRole.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/FollowerRole.java
@@ -15,11 +15,19 @@
  */
 package io.atomix.protocols.raft.roles;
 
-import io.atomix.cluster.impl.PhiAccrualFailureDetector;
+import io.atomix.cluster.ClusterEvent;
+import io.atomix.cluster.ClusterEventListener;
 import io.atomix.protocols.raft.RaftServer;
+import io.atomix.protocols.raft.cluster.RaftMember;
 import io.atomix.protocols.raft.cluster.impl.DefaultRaftMember;
 import io.atomix.protocols.raft.cluster.impl.RaftMemberContext;
 import io.atomix.protocols.raft.impl.RaftContext;
+import io.atomix.protocols.raft.protocol.AppendRequest;
+import io.atomix.protocols.raft.protocol.AppendResponse;
+import io.atomix.protocols.raft.protocol.ConfigureRequest;
+import io.atomix.protocols.raft.protocol.ConfigureResponse;
+import io.atomix.protocols.raft.protocol.InstallRequest;
+import io.atomix.protocols.raft.protocol.InstallResponse;
 import io.atomix.protocols.raft.protocol.PollRequest;
 import io.atomix.protocols.raft.protocol.VoteRequest;
 import io.atomix.protocols.raft.protocol.VoteResponse;
@@ -33,17 +41,15 @@
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Collectors;
 
 /**
  * Follower state.
  */
 public final class FollowerRole extends ActiveRole {
-  private final PhiAccrualFailureDetector failureDetector = new PhiAccrualFailureDetector();
+  private final ClusterEventListener clusterListener = this::handleClusterEvent;
   private final Random random = new Random();
   private Scheduled heartbeatTimer;
-  private Scheduled heartbeatTimeout;
 
   public FollowerRole(RaftContext context) {
     super(context);
@@ -56,49 +62,43 @@ public FollowerRole(RaftContext context) {
 
   @Override
   public synchronized CompletableFuture<RaftRole> start() {
-    raft.setLastHeartbeatTime();
-    return super.start().thenRun(this::startHeartbeatTimer).thenApply(v -> this);
+    raft.getClusterService().addListener(clusterListener);
+    return super.start().thenRun(this::resetHeartbeatTimeout).thenApply(v -> this);
   }
 
   /**
-   * Starts the heartbeat timer.
+   * Handles a cluster event.
    */
-  private void startHeartbeatTimer() {
-    log.trace("Starting heartbeat timer");
-    AtomicLong lastHeartbeat = new AtomicLong();
-    heartbeatTimer = raft.getThreadContext().schedule(raft.getHeartbeatInterval(), raft.getHeartbeatInterval(), () -> {
-      if (raft.getLastHeartbeatTime() > lastHeartbeat.get()) {
-        failureDetector.report(raft.getLastHeartbeatTime());
-      }
-      lastHeartbeat.set(raft.getLastHeartbeatTime());
-    });
-    resetHeartbeatTimeout();
+  private void handleClusterEvent(ClusterEvent event) {
+    RaftMember leader = raft.getLeader();
+    if (leader != null && event.type() == ClusterEvent.Type.NODE_DEACTIVATED && event.subject().id().equals(leader.nodeId())) {
+      sendPollRequests();
+    }
   }
 
   /**
    * Resets the heartbeat timer.
    */
   private void resetHeartbeatTimeout() {
-    // Ensure any existing timers are cancelled.
-    if (heartbeatTimeout != null) {
-      heartbeatTimeout.cancel();
+    raft.checkThread();
+    if (!isRunning()) {
+      return;
     }
 
-    // Compute a semi-random delay between the 1 * and 2 * the heartbeat frequency.
-    Duration delay = raft.getHeartbeatInterval().dividedBy(2)
-        .plus(Duration.ofMillis(random.nextInt((int) raft.getHeartbeatInterval().dividedBy(2).toMillis())));
+    // If a timer is already set, cancel the timer.
+    if (heartbeatTimer != null) {
+      heartbeatTimer.cancel();
+    }
 
-    // Schedule a delay after which to check whether the election has timed out.
-    heartbeatTimeout = raft.getThreadContext().schedule(delay, () -> {
-      heartbeatTimeout = null;
+    // Set the election timeout in a semi-random fashion with the random range
+    // being election timeout and 2 * election timeout.
+    Duration delay = raft.getElectionTimeout().plus(Duration.ofMillis(random.nextInt((int) raft.getElectionTimeout().toMillis())));
+    heartbeatTimer = raft.getThreadContext().schedule(delay, () -> {
+      heartbeatTimer = null;
       if (isRunning()) {
-        if (System.currentTimeMillis() - raft.getLastHeartbeatTime() > raft.getElectionTimeout().toMillis()
-            || failureDetector.phi() >= raft.getElectionThreshold()) {
-          log.debug("Heartbeat timed out in {}", System.currentTimeMillis() - raft.getLastHeartbeatTime());
-          sendPollRequests();
-        } else {
-          resetHeartbeatTimeout();
-        }
+        raft.setLeader(null);
+        log.debug("Heartbeat timed out in {}", delay);
+        sendPollRequests();
       }
     });
   }
@@ -107,25 +107,21 @@ private void resetHeartbeatTimeout() {
    * Polls all members of the cluster to determine whether this member should transition to the CANDIDATE state.
    */
   private void sendPollRequests() {
-    final AtomicBoolean complete = new AtomicBoolean();
-
     // Set a new timer within which other nodes must respond in order for this node to transition to candidate.
-    heartbeatTimeout = raft.getThreadContext().schedule(raft.getElectionTimeout(), () -> {
+    heartbeatTimer = raft.getThreadContext().schedule(raft.getElectionTimeout(), () -> {
       log.debug("Failed to poll a majority of the cluster in {}", raft.getElectionTimeout());
-      complete.set(true);
       resetHeartbeatTimeout();
     });
 
     // Create a quorum that will track the number of nodes that have responded to the poll request.
-    final Set<DefaultRaftMember> votingMembers = raft.getCluster()
-        .getActiveMemberStates()
+    final AtomicBoolean complete = new AtomicBoolean();
+    final Set<DefaultRaftMember> votingMembers = raft.getCluster().getActiveMemberStates()
         .stream()
         .map(RaftMemberContext::getMember)
         .collect(Collectors.toSet());
 
     // If there are no other members in the cluster, immediately transition to leader.
     if (votingMembers.isEmpty()) {
-      raft.setLeader(null);
       raft.transition(RaftServer.Role.CANDIDATE);
       return;
     }
@@ -134,7 +130,6 @@ private void sendPollRequests() {
       // If a majority of the cluster indicated they would vote for us then transition to candidate.
       complete.set(true);
       if (elected) {
-        raft.setLeader(null);
         raft.transition(RaftServer.Role.CANDIDATE);
       } else {
         resetHeartbeatTimeout();
@@ -152,8 +147,6 @@ private void sendPollRequests() {
       lastTerm = 0;
     }
 
-    final DefaultRaftMember leader = raft.getLeader();
-
     log.debug("Polling members {}", votingMembers);
 
     // Once we got the last log term, iterate through each current member
@@ -179,12 +172,7 @@ private void sendPollRequests() {
 
             if (!response.accepted()) {
               log.debug("Received rejected poll from {}", member);
-              if (leader != null && response.term() == raft.getTerm() && member.nodeId().equals(leader.nodeId())) {
-                quorum.cancel();
-                resetHeartbeatTimeout();
-              } else {
-                quorum.fail();
-              }
+              quorum.fail();
             } else if (response.term() != raft.getTerm()) {
               log.debug("Received accepted poll for a different term from {}", member);
               quorum.fail();
@@ -198,12 +186,35 @@ private void sendPollRequests() {
     }
   }
 
+  @Override
+  public CompletableFuture<InstallResponse> onInstall(InstallRequest request) {
+    CompletableFuture<InstallResponse> future = super.onInstall(request);
+    resetHeartbeatTimeout();
+    return future;
+  }
+
+  @Override
+  public CompletableFuture<ConfigureResponse> onConfigure(ConfigureRequest request) {
+    CompletableFuture<ConfigureResponse> future = super.onConfigure(request);
+    resetHeartbeatTimeout();
+    return future;
+  }
+
+  @Override
+  public CompletableFuture<AppendResponse> onAppend(AppendRequest request) {
+    CompletableFuture<AppendResponse> future = super.onAppend(request);
+
+    // Reset the heartbeat timeout.
+    resetHeartbeatTimeout();
+    return future;
+  }
+
   @Override
   protected VoteResponse handleVote(VoteRequest request) {
     // Reset the heartbeat timeout if we voted for another candidate.
     VoteResponse response = super.handleVote(request);
     if (response.voted()) {
-      raft.setLastHeartbeatTime();
+      resetHeartbeatTimeout();
     }
     return response;
   }
@@ -213,16 +224,14 @@ protected VoteResponse handleVote(VoteRequest request) {
    */
   private void cancelHeartbeatTimers() {
     if (heartbeatTimer != null) {
-      heartbeatTimer.cancel();
-    }
-    if (heartbeatTimeout != null) {
       log.trace("Cancelling heartbeat timer");
-      heartbeatTimeout.cancel();
+      heartbeatTimer.cancel();
     }
   }
 
   @Override
   public synchronized CompletableFuture<Void> stop() {
+    raft.getClusterService().removeListener(clusterListener);
     return super.stop().thenRun(this::cancelHeartbeatTimers);
   }
 
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/LeaderRole.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/LeaderRole.java
index e1a0c442f..135ea1692 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/LeaderRole.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/roles/LeaderRole.java
@@ -15,9 +15,8 @@
  */
 package io.atomix.protocols.raft.roles;
 
-import com.google.common.collect.Sets;
-import io.atomix.cluster.NodeId;
-import io.atomix.primitive.session.SessionId;
+import io.atomix.cluster.ClusterEvent;
+import io.atomix.cluster.ClusterEventListener;
 import io.atomix.protocols.raft.RaftError;
 import io.atomix.protocols.raft.RaftException;
 import io.atomix.protocols.raft.RaftServer;
@@ -33,7 +32,6 @@
 import io.atomix.protocols.raft.protocol.CloseSessionResponse;
 import io.atomix.protocols.raft.protocol.CommandRequest;
 import io.atomix.protocols.raft.protocol.CommandResponse;
-import io.atomix.protocols.raft.protocol.HeartbeatRequest;
 import io.atomix.protocols.raft.protocol.JoinRequest;
 import io.atomix.protocols.raft.protocol.JoinResponse;
 import io.atomix.protocols.raft.protocol.KeepAliveRequest;
@@ -74,10 +72,6 @@
 import java.time.Duration;
 import java.time.Instant;
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.OptionalLong;
-import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.stream.Collectors;
@@ -88,10 +82,9 @@
 public final class LeaderRole extends ActiveRole {
   private static final int MAX_APPEND_ATTEMPTS = 5;
 
+  private final ClusterEventListener clusterListener = this::handleClusterEvent;
   private final LeaderAppender appender;
   private Scheduled appendTimer;
-  private final Map<NodeId, Scheduled> heartbeatTimers = new HashMap<>();
-  private final Set<SessionId> expiring = Sets.newHashSet();
   private long configuring;
   private boolean transferring;
 
@@ -116,9 +109,11 @@ public LeaderRole(RaftContext context) {
     // Commit the initial leader entries.
     commitInitialEntries();
 
+    // Register the cluster event listener.
+    raft.getClusterService().addListener(clusterListener);
+
     return super.start()
         .thenRun(this::startAppendTimer)
-        .thenRun(this::startHeartbeatTimer)
         .thenApply(v -> this);
   }
 
@@ -190,90 +185,16 @@ private void appendMembers() {
   }
 
   /**
-   * Starts checking for session heartbeat timeouts.
-   */
-  private void startHeartbeatTimer() {
-    raft.setLastHeartbeatTime();
-    raft.getSessions().getSessions().forEach(s -> s.resetHeartbeats());
-    log.trace("Starting heartbeat timers");
-    raft.getSessions().getSessions().stream()
-        .map(s -> s.nodeId())
-        .distinct()
-        .forEach(this::resetHeartbeatTimer);
-  }
-
-  /**
-   * Resets the heartbeat timer.
+   * Handles a cluster event.
    */
-  private void resetHeartbeatTimer(NodeId member) {
-    // Compute the smallest timeout of all open sessions for the member.
-    OptionalLong minTimeout = raft.getSessions().getSessions().stream()
-        .filter(s -> s.nodeId().equals(member))
-        .mapToLong(s -> s.minTimeout())
-        .min();
-
-    Scheduled oldTimer;
-    if (minTimeout.isPresent()) {
-      Scheduled newTimer = raft.getThreadContext().schedule(
-          Duration.ZERO,
-          Duration.ofMillis(minTimeout.getAsLong()),
-          () -> sendHeartbeats(member));
-      oldTimer = heartbeatTimers.put(member, newTimer);
-    } else {
-      oldTimer = heartbeatTimers.remove(member);
-    }
-
-    // Cancel the old timer if one exists.
-    if (oldTimer != null) {
-      oldTimer.cancel();
+  private void handleClusterEvent(ClusterEvent event) {
+    if (event.type() == ClusterEvent.Type.NODE_DEACTIVATED) {
+      raft.getSessions().getSessions().stream()
+          .filter(session -> session.nodeId().equals(event.subject().id()))
+          .forEach(this::expireSession);
     }
   }
 
-  /**
-   * Sends heartbeats to sessions of the given member.
-   *
-   * @param member the member to which to send heartbeats
-   */
-  private void sendHeartbeats(NodeId member) {
-    sendHeartbeat(member, raft.getSessions().getSessions().stream()
-        .filter(s -> s.nodeId().equals(member))
-        .collect(Collectors.toList()));
-  }
-
-  /**
-   * Attempts to send a heartbeat to the given session.
-   */
-  private void sendHeartbeat(NodeId member, Collection<RaftSession> sessions) {
-    HeartbeatRequest request = HeartbeatRequest.builder()
-        .withLeader(raft.getCluster().getMember().nodeId())
-        .withMembers(raft.getCluster().getMembers().stream()
-            .map(RaftMember::nodeId)
-            .filter(m -> m != null)
-            .collect(Collectors.toList()))
-        .build();
-    log.trace("Sending {} to {}", request, member);
-    raft.getProtocol().heartbeat(member, request).whenCompleteAsync((response, error) -> {
-      long timestamp = System.currentTimeMillis();
-      if (error == null && response.status() == RaftResponse.Status.OK) {
-        log.trace("Received {} from {}", response, member);
-        sessions.forEach(s -> s.setLastHeartbeat(timestamp));
-      } else {
-        sessions.forEach(session -> {
-          // If no heartbeats have been received, use the session's minimum timeout.
-          if (session.getLastHeartbeat() == 0) {
-            if (timestamp - raft.getLastHeartbeatTime() > session.minTimeout()) {
-              expireSession(session);
-            }
-          }
-          // Otherwise, if the session is still active but has failed according to the failure detector, expire the session.
-          else if (session.getState().active() && session.isFailed(raft.getSessionFailureThreshold())) {
-            expireSession(session);
-          }
-        });
-      }
-    }, raft.getThreadContext());
-  }
-
   /**
    * Expires the given session.
    */
@@ -281,21 +202,11 @@ private void expireSession(RaftSession session) {
     log.debug("Expiring session due to heartbeat failure: {}", session);
     appendAndCompact(new CloseSessionEntry(raft.getTerm(), System.currentTimeMillis(), session.sessionId().id(), true))
         .whenCompleteAsync((entry, error) -> {
-          if (error != null) {
-            expiring.remove(session.sessionId());
-            return;
-          }
-
           log.trace("Appended {}", entry);
           appender.appendEntries(entry.index()).whenComplete((commitIndex, commitError) -> {
             raft.checkThread();
-            if (isRunning()) {
-              if (commitError == null) {
-                raft.getStateMachine().<Long>apply(entry.index())
-                    .whenCompleteAsync((r, e) -> expiring.remove(session.sessionId()), raft.getThreadContext());
-              } else {
-                expiring.remove(session.sessionId());
-              }
+            if (isRunning() && commitError == null) {
+              raft.getStateMachine().<Long>apply(entry.index());
             }
           });
         }, raft.getThreadContext());
@@ -883,7 +794,6 @@ private void commitCommand(CommandRequest request, CompletableFuture<CommandResp
               if (commitError == null) {
                 raft.getStateMachine().<Long>apply(entry.index()).whenComplete((sessionId, sessionError) -> {
                   if (sessionError == null) {
-                    resetHeartbeatTimer(NodeId.from(request.node()));
                     future.complete(logResponse(OpenSessionResponse.builder()
                         .withStatus(RaftResponse.Status.OK)
                         .withSession(sessionId)
@@ -1108,14 +1018,6 @@ private void cancelAppendTimer() {
     }
   }
 
-  /**
-   * Cancels the heartbeat timers.
-   */
-  private void cancelHeartbeatTimers() {
-    log.trace("Cancelling heartbeat timers");
-    heartbeatTimers.values().forEach(Scheduled::cancel);
-  }
-
   /**
    * Ensures the local server is not the leader.
    */
@@ -1127,10 +1029,10 @@ private void stepDown() {
 
   @Override
   public synchronized CompletableFuture<Void> stop() {
+    raft.getClusterService().removeListener(clusterListener);
     return super.stop()
         .thenRun(appender::close)
         .thenRun(this::cancelAppendTimer)
-        .thenRun(this::cancelHeartbeatTimers)
         .thenRun(this::stepDown);
   }
 
diff --git a/protocols/raft/src/main/java/io/atomix/protocols/raft/session/RaftSession.java b/protocols/raft/src/main/java/io/atomix/protocols/raft/session/RaftSession.java
index 4f9ca0be2..39649b865 100644
--- a/protocols/raft/src/main/java/io/atomix/protocols/raft/session/RaftSession.java
+++ b/protocols/raft/src/main/java/io/atomix/protocols/raft/session/RaftSession.java
@@ -16,10 +16,9 @@
 package io.atomix.protocols.raft.session;
 
 import io.atomix.cluster.NodeId;
-import io.atomix.cluster.impl.PhiAccrualFailureDetector;
+import io.atomix.primitive.PrimitiveType;
 import io.atomix.primitive.event.PrimitiveEvent;
 import io.atomix.primitive.operation.OperationType;
-import io.atomix.primitive.PrimitiveType;
 import io.atomix.primitive.session.Session;
 import io.atomix.primitive.session.SessionEvent;
 import io.atomix.primitive.session.SessionEventListener;
@@ -67,8 +66,6 @@
   private final ThreadContext eventExecutor;
   private volatile State state = State.CLOSED;
   private volatile long lastUpdated;
-  private long lastHeartbeat;
-  private PhiAccrualFailureDetector failureDetector = new PhiAccrualFailureDetector();
   private long requestSequence;
   private volatile long commandSequence;
   private volatile long lastApplied;
@@ -193,43 +190,6 @@ public boolean isTimedOut(long timestamp) {
     return lastUpdated > 0 && timestamp - lastUpdated > maxTimeout;
   }
 
-  /**
-   * Returns the current heartbeat time.
-   *
-   * @return The current heartbeat time.
-   */
-  public long getLastHeartbeat() {
-    return lastHeartbeat;
-  }
-
-  /**
-   * Sets the last heartbeat time.
-   *
-   * @param lastHeartbeat The last heartbeat time.
-   */
-  public void setLastHeartbeat(long lastHeartbeat) {
-    this.lastHeartbeat = Math.max(this.lastHeartbeat, lastHeartbeat);
-    failureDetector.report(lastHeartbeat);
-  }
-
-  /**
-   * Resets heartbeat times.
-   */
-  public void resetHeartbeats() {
-    this.lastHeartbeat = 0;
-    this.failureDetector = new PhiAccrualFailureDetector();
-  }
-
-  /**
-   * Returns a boolean indicating whether the session appears to have failed due to lack of heartbeats.
-   *
-   * @param threshold The phi failure threshold
-   * @return Indicates whether the session has failed.
-   */
-  public boolean isFailed(int threshold) {
-    return failureDetector.phi() >= threshold;
-  }
-
   @Override
   public State getState() {
     return state;
diff --git a/protocols/raft/src/test/java/io/atomix/protocols/raft/RaftTest.java b/protocols/raft/src/test/java/io/atomix/protocols/raft/RaftTest.java
index f24511ffd..6dc5b724e 100644
--- a/protocols/raft/src/test/java/io/atomix/protocols/raft/RaftTest.java
+++ b/protocols/raft/src/test/java/io/atomix/protocols/raft/RaftTest.java
@@ -15,6 +15,7 @@
  */
 package io.atomix.protocols.raft;
 
+import io.atomix.cluster.ClusterService;
 import io.atomix.cluster.NodeId;
 import io.atomix.primitive.DistributedPrimitiveBuilder;
 import io.atomix.primitive.PrimitiveManagementService;
@@ -82,6 +83,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
 
 /**
  * Raft test.
@@ -1209,6 +1211,7 @@ private RaftMember nextMember(RaftMember.Type type) {
    */
   private RaftServer createServer(NodeId nodeId) {
     RaftServer.Builder builder = RaftServer.builder(nodeId)
+        .withClusterService(mock(ClusterService.class))
         .withProtocol(protocolFactory.newServerProtocol(nodeId))
         .withStorage(RaftStorage.builder()
             .withStorageLevel(StorageLevel.DISK)
