diff --git a/its/ruling/src/test/resources/guava/squid-S1162.json b/its/ruling/src/test/resources/guava/squid-S1162.json
index d84714957c..df7933af78 100644
--- a/its/ruling/src/test/resources/guava/squid-S1162.json
+++ b/its/ruling/src/test/resources/guava/squid-S1162.json
@@ -81,14 +81,6 @@
 'com.google.guava:guava:src/com/google/common/net/HostSpecifier.java':[
 130,
 ],
-'com.google.guava:guava:src/com/google/common/util/concurrent/AbstractCheckedFuture.java':[
-81,
-83,
-85,
-110,
-112,
-114,
-],
 'com.google.guava:guava:src/com/google/common/util/concurrent/AbstractFuture.java':[
 473,
 ],
diff --git a/its/ruling/src/test/resources/guava/squid-S2175.json b/its/ruling/src/test/resources/guava/squid-S2175.json
new file mode 100644
index 0000000000..8f1f9cc66f
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S2175.json
@@ -0,0 +1,10 @@
+{
+'com.google.guava:guava:src/com/google/common/cache/LocalCache.java':[
+3669,
+3806,
+],
+'com.google.guava:guava:src/com/google/common/collect/MapMakerInternalMap.java':[
+3168,
+3304,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S2388.json b/its/ruling/src/test/resources/guava/squid-S2388.json
index 3624c6c369..5eb48fcdb7 100644
--- a/its/ruling/src/test/resources/guava/squid-S2388.json
+++ b/its/ruling/src/test/resources/guava/squid-S2388.json
@@ -4,6 +4,11 @@
 1618,
 1665,
 ],
+'com.google.guava:guava:src/com/google/common/collect/AbstractBiMap.java':[
+424,
+431,
+436,
+],
 'com.google.guava:guava:src/com/google/common/collect/AbstractMapBasedMultimap.java':[
 625,
 789,
@@ -26,6 +31,12 @@
 'com.google.guava:guava:src/com/google/common/io/BaseEncoding.java':[
 870,
 ],
+'com.google.guava:guava:src/com/google/common/reflect/Invokable.java':[
+222,
+250,
+264,
+290,
+],
 'com.google.guava:guava:src/com/google/common/util/concurrent/AbstractExecutionThreadService.java':[
 58,
 ],
@@ -33,4 +44,7 @@
 207,
 237,
 ],
+'com.google.guava:guava:src/com/google/common/util/concurrent/Striped.java':[
+304,
+],
 }
diff --git a/its/ruling/src/test/resources/guava/squid-S2974.json b/its/ruling/src/test/resources/guava/squid-S2974.json
index 7140bcc426..bb6dca5e07 100644
--- a/its/ruling/src/test/resources/guava/squid-S2974.json
+++ b/its/ruling/src/test/resources/guava/squid-S2974.json
@@ -54,11 +54,7 @@
 105,
 1108,
 ],
-'com.google.guava:guava:src/com/google/common/collect/TreeRangeSet.java':[
-44,
-],
 'com.google.guava:guava:src/com/google/common/util/concurrent/Striped.java':[
-88,
 312,
 ],
 'com.google.guava:guava:src/com/google/common/xml/XmlEscapers.java':[
diff --git a/java-checks/src/main/java/org/sonar/java/checks/FinalClassCheck.java b/java-checks/src/main/java/org/sonar/java/checks/FinalClassCheck.java
index ba0e63c729..310c1a6aaf 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/FinalClassCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/FinalClassCheck.java
@@ -58,7 +58,7 @@ public void visitNode(Tree tree) {
   }
 
   private static boolean isExtended(ClassTree classTree) {
-    IsExtendedVisitor isExtendedVisitor = new IsExtendedVisitor(classTree.symbol().type());
+    IsExtendedVisitor isExtendedVisitor = new IsExtendedVisitor(classTree.symbol().type().erasure());
     classTree.accept(isExtendedVisitor);
     return isExtendedVisitor.isExtended;
   }
@@ -95,7 +95,7 @@ protected void scan(@Nullable Tree tree) {
     @Override
     public void visitClass(ClassTree tree) {
       TypeTree superClass = tree.superClass();
-      if (superClass != null && superClass.symbolType() == type) {
+      if (superClass != null && superClass.symbolType().erasure() == type) {
         isExtended = true;
       }
       super.visitClass(tree);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java
index 0b839a5ca5..c8678d9228 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java
@@ -205,8 +205,8 @@ private static boolean hasLocalAccess(Symbol scope, Symbol symbol) {
         return true;
       }
       if (scope.isTypeSymbol() && symbol.isTypeSymbol()) {
-        Type scopeType = scope.type();
-        Type symbolType = symbol.type();
+        Type scopeType = scope.type().erasure();
+        Type symbolType = symbol.type().erasure();
         if (scopeType.isSubtypeOf(symbolType)) {
           return true;
         }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java
index e1dc5f380b..10ae514d77 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java
@@ -120,7 +120,7 @@ public void visitIdentifier(IdentifierTree tree) {
       if (type instanceof MethodJavaType) {
         type = ((MethodJavaType) type).resultType();
       }
-      if (!sameErasure(type) && type.isSubtypeOf(classType)) {
+      if (!sameErasure(type) && type.isSubtypeOf(classType.erasure())) {
         reportIssue(tree, String.format("Remove this reference to \"%s\".", type.symbol().name()));
       }
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SymmetricEqualsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SymmetricEqualsCheck.java
index 6dde4e9cfa..18b6f55e2f 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/SymmetricEqualsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/SymmetricEqualsCheck.java
@@ -69,7 +69,7 @@ private boolean isOwnerFinal() {
 
     @Override
     public void visitInstanceOf(InstanceOfTree tree) {
-      if (tree.type().symbolType().equals(owner.type())) {
+      if (tree.type().symbolType().equals(owner.type().erasure())) {
         if (!isOwnerFinal() && !methodSymbol.isFinal()) {
           reportIssue(tree, "Compare to \"this.getClass()\" instead.");
         }
diff --git a/java-checks/src/test/files/checks/SubClassStaticReferenceCheck.java b/java-checks/src/test/files/checks/SubClassStaticReferenceCheck.java
index f6622e1571..8f06848376 100644
--- a/java-checks/src/test/files/checks/SubClassStaticReferenceCheck.java
+++ b/java-checks/src/test/files/checks/SubClassStaticReferenceCheck.java
@@ -37,3 +37,8 @@ static int getVersion() {
 }
 
 class D extends C { }
+
+public class V<T>  {
+  private static class VSub extends V {}
+  static V V1 = new VSub(); // Noncompliant
+}
diff --git a/java-checks/src/test/files/checks/SymmetricEqualsCheck.java b/java-checks/src/test/files/checks/SymmetricEqualsCheck.java
index 7ea9d5fb0e..4bcdb819c6 100644
--- a/java-checks/src/test/files/checks/SymmetricEqualsCheck.java
+++ b/java-checks/src/test/files/checks/SymmetricEqualsCheck.java
@@ -86,3 +86,10 @@ public boolean equals(Object obj) {
     }
   }
 }
+final class Foo<T> {
+  public boolean equals(Object o) {
+    if(o instanceof Foo) {
+
+    }
+  }
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/Resolve.java b/java-frontend/src/main/java/org/sonar/java/resolve/Resolve.java
index 20eb3bfd88..69c8900ceb 100644
--- a/java-frontend/src/main/java/org/sonar/java/resolve/Resolve.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/Resolve.java
@@ -575,7 +575,7 @@ private Resolution selectBest(Env env, JavaType defSite, JavaType callSite, List
     JavaSymbol.MethodJavaSymbol mostSpecificMethod = (JavaSymbol.MethodJavaSymbol) mostSpecific;
     List<JavaType> thrownTypes = ((MethodJavaType) mostSpecific.type).thrown;
     JavaType returnType = ((MethodJavaType) mostSpecificMethod.type).resultType;
-    if((substitution.unchecked || applicableWithUncheckedConversion(mostSpecificMethod, defSite, typeParams)) && !mostSpecificMethod.isConstructor()) {
+    if((substitution.isUnchecked() || applicableWithUncheckedConversion(mostSpecificMethod, defSite, typeParams)) && !mostSpecificMethod.isConstructor()) {
       returnType = returnType.erasure();
       thrownTypes = erasure(thrownTypes);
     } else {
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/TypeInferenceSolver.java b/java-frontend/src/main/java/org/sonar/java/resolve/TypeInferenceSolver.java
index e9d880941e..5f7757ab74 100644
--- a/java-frontend/src/main/java/org/sonar/java/resolve/TypeInferenceSolver.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/TypeInferenceSolver.java
@@ -67,7 +67,7 @@ private TypeSubstitution inferTypeSubstitutionRec(MethodJavaSymbol method, List<
 
       substitution = inferTypeSubstitution(method, substitution, formalType, argType, variableArity, remainingArgTypes);
 
-      if (substitution.unchecked || (!method.isConstructor() && substitution.typeVariables().containsAll(method.typeVariableTypes))) {
+      if (substitution.isUnchecked() || (!method.isConstructor() && substitution.typeVariables().containsAll(method.typeVariableTypes))) {
         // we found all the substitution
         break;
       }
@@ -148,15 +148,7 @@ private TypeSubstitution inferTypeSubstitutionInParameterizedType(MethodJavaSymb
       }
 
     } else if (isRawTypeOfType(argType, formalType) || isNullType(argType)) {
-      TypeSubstitution typeSubstitution = new TypeSubstitution();
-      typeSubstitution.unchecked = true;
-      return typeSubstitution;
-      /*List<JavaType> objectTypes = listOfTypes(symbols.objectType, formalTypeSubstitutedTypes.size());
-      TypeSubstitution newSubstitution = new TypeSubstitution();
-      if (IntStream.range(0, formalTypeSubstitutedTypes.size()).noneMatch(i -> handledFormals.get(formalTypeSubstitutedTypes.get(i)).contains(objectTypes.get(i)))) {
-        newSubstitution = inferTypeSubstitution(method, formalTypeSubstitutedTypes, objectTypes);
-      }
-      result = mergeTypeSubstitutions(substitution, newSubstitution);*/
+      return TypeSubstitution.uncheckedTypeSubstitution();
     } else if (argType.isSubtypeOf(formalType.erasure()) && argType.isClass()) {
       for (JavaType superType : ((ClassJavaType) argType).superTypes()) {
         if (sameErasure(formalType, superType)) {
@@ -173,14 +165,6 @@ private static boolean isRawTypeOfType(JavaType rawType, JavaType type) {
     return rawType == type.erasure();
   }
 
-  private static List<JavaType> listOfTypes(JavaType type, int size) {
-    List<JavaType> result = new ArrayList<>(size);
-    for (int j = 0; j < size; j++) {
-      result.add(type);
-    }
-    return result;
-  }
-
   private static boolean sameErasure(JavaType type1, JavaType type2) {
     return type1.erasure() == type2.erasure();
   }
@@ -200,7 +184,7 @@ private TypeSubstitution inferTypeSubstitutionInWildcardType(MethodJavaSymbol me
   }
 
   private static TypeSubstitution mergeTypeSubstitutions(TypeSubstitution currentSubstitution, TypeSubstitution newSubstitution) {
-    if(newSubstitution.unchecked) {
+    if(newSubstitution.isUnchecked()) {
       return newSubstitution;
     }
     TypeSubstitution result = new TypeSubstitution();
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitution.java b/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitution.java
index 9875fa7cc2..478d412898 100644
--- a/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitution.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitution.java
@@ -28,9 +28,15 @@
 import java.util.Map;
 
 public class TypeSubstitution {
-  public boolean unchecked = false;
   private LinkedHashMap<TypeVariableJavaType, JavaType> substitutions = Maps.newLinkedHashMap();
 
+  private static final TypeSubstitution UNCHECKED = new TypeSubstitution() {
+    @Override
+    public boolean isUnchecked() {
+      return true;
+    }
+  };
+
   public TypeSubstitution() {
     // default behavior
   }
@@ -40,6 +46,13 @@ public TypeSubstitution(TypeSubstitution typeSubstitution) {
     this.substitutions = Maps.newLinkedHashMap(typeSubstitution.substitutions);
   }
 
+  public boolean isUnchecked() {
+    return false;
+  }
+  public static TypeSubstitution uncheckedTypeSubstitution() {
+    return UNCHECKED;
+  }
+
   @CheckForNull
   public JavaType substitutedType(JavaType javaType) {
     return substitutions.get(javaType);
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitutionSolver.java b/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitutionSolver.java
index f0b4f6ff99..b30338e687 100644
--- a/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitutionSolver.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/TypeSubstitutionSolver.java
@@ -195,7 +195,7 @@ JavaType applySiteSubstitution(@Nullable JavaType resolvedType, JavaType callSit
   }
 
   List<JavaType> applySubstitutionToFormalParameters(List<JavaType> types, TypeSubstitution substitution) {
-    if(substitution.unchecked) {
+    if(substitution.isUnchecked()) {
       return types.stream().map(JavaType::erasure).collect(Collectors.toList());
     }
     if (substitution.size() == 0 || types.isEmpty()) {
diff --git a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
index 9c02c2f6c8..23e3ef1d2a 100644
--- a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
@@ -1710,7 +1710,6 @@ public void parameterized_innerclass_constructor_resolution() {
     assertThat(res.symbol("<init>", 7).usages()).hasSize(1);
     assertThat(res.symbol("<init>", 17).usages()).hasSize(1);
     assertThat(res.symbol("<init>", 27).usages()).hasSize(1);
-    // this should be of size 1
     assertThat(res.symbol("<init>", 37).usages()).hasSize(1);
   }
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/resolve/TypeInferenceSolverTest.java b/java-frontend/src/test/java/org/sonar/java/resolve/TypeInferenceSolverTest.java
index 1a9e3a3643..50e9813756 100644
--- a/java-frontend/src/test/java/org/sonar/java/resolve/TypeInferenceSolverTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/resolve/TypeInferenceSolverTest.java
@@ -105,13 +105,13 @@ public void inferTypeSubstitution_varargs_and_generics() {
     List<JavaType> args = Lists.<JavaType>newArrayList(aRawType, aRawType);
     TypeSubstitution substitution = typeSubstitutionForTypeParametersWithVarargs(formals, args, T);
     assertThat(substitution.substitutedType(T)).isNull();
-    assertThat(substitution.unchecked).isTrue();
+    assertThat(substitution.isUnchecked()).isTrue();
 
     // raw type with generic type : A, A<String>
     args = Lists.<JavaType>newArrayList(aRawType, parametrizedTypeCache.getParametrizedTypeType(aType.symbol, new TypeSubstitution().add(X, symbols.stringType)));
     substitution = typeSubstitutionForTypeParametersWithVarargs(formals, args, T);
     assertThat(substitution.substitutedType(T)).isNull();
-    assertThat(substitution.unchecked).isTrue();
+    assertThat(substitution.isUnchecked()).isTrue();
   }
 
   @Test
