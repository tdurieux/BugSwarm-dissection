diff --git a/doc/changelog.rst b/doc/changelog.rst
index 6dae9b79..a0ae37fd 100644
--- a/doc/changelog.rst
+++ b/doc/changelog.rst
@@ -1,6 +1,7 @@
 Changelog
 =========
 
+* :feature:`771` Keyword arguments to ``registers_on`` now get forwarded to Gossip's ``register`` API
 * :feature:`769` Added a new configuration flag, ``log.show_raw_param_values``, defaulting to ``False``. If set to True, log lines for beginnings of tests will contain actual parametrization values instead of format-safe strings.
 * :feature:`528` ``slash.exclude`` can now exclude combinations of parameter values
 * :bug:`783` Session errors in children are now handled and reported when running with parallel
diff --git a/slash/plugins/__init__.py b/slash/plugins/__init__.py
index 53b7dd00..74361d52 100644
--- a/slash/plugins/__init__.py
+++ b/slash/plugins/__init__.py
@@ -1,14 +1,18 @@
 from ..utils.marks import mark
 from ..utils import parallel_utils
-from .interface import PluginInterface
+from .interface import PluginInterface # pylint: disable=unused-import
 
-def registers_on(hook_name):
+
+
+def registers_on(hook_name, **kwargs):
     """Marks the decorated plugin method to register on a custom hook, rather than
     the method name in the 'slash' group, which is the default behavior for plugins
 
     Specifying ``registers_on(None)`` means that this is not a hook entry point at all.
+
+    .. note:: All keyword arguments are forwarded to gossip's ``register`` API
     """
-    return mark("register_on", hook_name, append=True)
+    return mark("register_on", RegistrationInfo(hook_name, expect_exists=False, register_kwargs=kwargs), append=True)
 
 
 def parallel_mode(mode):
@@ -45,4 +49,4 @@ def provides(what):
     return mark("plugin_provides", what, append=True)
 
 
-from .plugin_manager import manager, IncompatiblePlugin, UnknownPlugin, IllegalPluginName # pylint: disable=unused-import
+from .plugin_manager import manager, IncompatiblePlugin, UnknownPlugin, IllegalPluginName, RegistrationInfo # pylint: disable=unused-import
diff --git a/slash/plugins/plugin_manager.py b/slash/plugins/plugin_manager.py
index 7fbd8f4e..b060f519 100644
--- a/slash/plugins/plugin_manager.py
+++ b/slash/plugins/plugin_manager.py
@@ -1,9 +1,11 @@
 import collections
 import gossip
+import itertools
 import os
 import re
 import sys
 from .interface import PluginInterface
+from .registration_info import RegistrationInfo
 from .._compat import itervalues, reraise
 from ..utils.marks import try_get_mark
 from ..utils import parallel_utils
@@ -16,7 +18,6 @@
 
 _logger = logbook.Logger(__name__)
 
-RegistrationInfo = collections.namedtuple("RegistrationInfo", ("hook_name", "expect_exists"))
 _SKIPPED_PLUGIN_METHOD_NAMES = set(dir(PluginInterface))
 PluginInfo = collections.namedtuple("PluginInfo", ("plugin_instance", "is_internal"))
 _DEPRECATED_CHARACTERS = '-_'
@@ -346,11 +347,11 @@ def _get_plugin_registrations(self, plugin):
             registration_list = try_get_mark(method, 'register_on', NOTHING)
 
             if registration_list is not NOTHING:
-                registration_list = [RegistrationInfo(hook_name, False) for hook_name in registration_list]
+                registration_list = registration_list[:]
             else:
                 if method_name.startswith('_'):
                     continue
-                registration_list = [RegistrationInfo("slash.{}".format(method_name), True)]
+                registration_list = [RegistrationInfo("slash.{}".format(method_name), expect_exists=True)]
 
             for registration_info in registration_list:
                 if registration_info.hook_name is None:
@@ -360,8 +361,17 @@ def _get_plugin_registrations(self, plugin):
                 if not try_get_mark(method, 'register_if', True):
                     continue
 
-                plugin_needs = try_get_mark(method, 'plugin_needs', []) + global_needs
-                plugin_provides = try_get_mark(method, 'plugin_provides', []) + global_provides
+                plugin_needs = list(
+                    itertools.chain(
+                        try_get_mark(method, 'plugin_needs', []),
+                        global_needs,
+                        registration_info.register_kwargs.get('needs', [])))
+
+                plugin_provides = list(
+                    itertools.chain(
+                        try_get_mark(method, 'plugin_provides', []),
+                        global_provides,
+                        registration_info.register_kwargs.get('provides', [])))
 
                 try:
                     if registration_info.expect_exists:
@@ -377,11 +387,12 @@ def _get_plugin_registrations(self, plugin):
                 assert hook is not None
                 register_no_op_hooks.discard(registration_info.hook_name)
 
-                kwargs = {
+                kwargs = registration_info.register_kwargs.copy()
+                kwargs.update({
                     'needs': plugin_needs,
                     'provides': plugin_provides,
                     'token': self._get_token(plugin_name),
-                }
+                })
                 if registration_info.hook_name == 'slash.session_start':
                     has_session_start = True
                     kwargs['toggles_on'] = plugin.__toggles__['session']
diff --git a/slash/plugins/registration_info.py b/slash/plugins/registration_info.py
new file mode 100644
index 00000000..10ad2db5
--- /dev/null
+++ b/slash/plugins/registration_info.py
@@ -0,0 +1,7 @@
+class RegistrationInfo(object):
+
+    def __init__(self, hook_name, expect_exists, register_kwargs=None):
+        assert isinstance(expect_exists, bool)
+        self.hook_name = hook_name
+        self.expect_exists = expect_exists
+        self.register_kwargs = register_kwargs or {}
diff --git a/tests/test_plugin_dependency.py b/tests/test_plugin_dependency.py
index 6f803390..78dfa756 100644
--- a/tests/test_plugin_dependency.py
+++ b/tests/test_plugin_dependency.py
@@ -1,6 +1,7 @@
 import pytest
 import slash.plugins
 from .conftest import Checkpoint
+from .utils import maybe_decorate
 from slash.plugins import PluginInterface
 from gossip.exceptions import CannotResolveDependencies
 
@@ -10,20 +11,20 @@
 def test_needs_provides_plugin_name(needs_decorate_method, provides_decorate_method, checkpoint1, checkpoint2):
 
     @slash.plugins.active  # pylint: disable=abstract-method, unused-variable
-    @_maybe_decorate(slash.plugins.needs('p'), not needs_decorate_method)
+    @maybe_decorate(slash.plugins.needs('p'), not needs_decorate_method)
     @autoname
     class NeedsPlugin(PluginInterface):
 
-        @_maybe_decorate(slash.plugins.needs('p'), needs_decorate_method)
+        @maybe_decorate(slash.plugins.needs('p'), needs_decorate_method)
         def session_start(self):
             checkpoint2()
 
     @slash.plugins.active  # pylint: disable=abstract-method, unused-variable
-    @_maybe_decorate(slash.plugins.provides('p'), not provides_decorate_method)
+    @maybe_decorate(slash.plugins.provides('p'), not provides_decorate_method)
     @autoname
     class ProvidesPlugin(PluginInterface):
 
-        @_maybe_decorate(slash.plugins.provides('p'), provides_decorate_method)
+        @maybe_decorate(slash.plugins.provides('p'), provides_decorate_method)
         def session_start(self):
             checkpoint1()
 
@@ -253,13 +254,13 @@ def test_provides_needs_with_inheritence_on_class_level(checkpoint, checkpoint1,
     '''
     # pylint: disable=abstract-method
 
-    @_maybe_decorate(slash.plugins.provides('x'), provides_parent_level)
+    @maybe_decorate(slash.plugins.provides('x'), provides_parent_level)
     class PluginAParent(slash.plugins.interface.PluginInterface):
 
         def test_start(self):
             pass
 
-    @_maybe_decorate(slash.plugins.provides('x'), not provides_parent_level)
+    @maybe_decorate(slash.plugins.provides('x'), not provides_parent_level)
     class PluginA(PluginAParent):
 
         def get_name(self):
@@ -269,14 +270,14 @@ def session_start(self):
             checkpoint1()
 
 
-    @_maybe_decorate(slash.plugins.needs('x'), needs_parent_level)
+    @maybe_decorate(slash.plugins.needs('x'), needs_parent_level)
     class PluginBParent(slash.plugins.interface.PluginInterface):
 
         def error_added(self, result, error): # pylint: disable=unused-argument
             checkpoint()
 
 
-    @_maybe_decorate(slash.plugins.needs('x'), not needs_parent_level)
+    @maybe_decorate(slash.plugins.needs('x'), not needs_parent_level)
     class PluginB(PluginBParent):
 
         def get_name(self):
@@ -562,14 +563,6 @@ def session_end(self):
         slash.hooks.session_end()  # pylint: disable=no-member
     assert caught.value.unmet_dependencies == set(['x', 'y', 'z'])
 
-def _maybe_decorate(decorator, flag):
-
-    def returned(func):
-        if flag:
-            func = decorator(func)
-        return func
-    return returned
-
 
 def autoname(plugin):
     def get_name(self):
diff --git a/tests/test_plugins.py b/tests/test_plugins.py
index 9a6a81d9..b28be014 100644
--- a/tests/test_plugins.py
+++ b/tests/test_plugins.py
@@ -8,7 +8,7 @@
 from slash import hooks, plugins
 from slash.plugins import IncompatiblePlugin, PluginInterface
 
-from .utils import NamedPlugin
+from .utils import NamedPlugin, maybe_decorate
 
 
 
@@ -28,6 +28,39 @@ def some_method_here(self):
     assert not checkpoint.called
 
 
+@pytest.mark.parametrize('class_level_needs', [True, False])
+@pytest.mark.parametrize('class_level_provides', [True, False])
+def test_registers_on_kwargs(class_level_needs, class_level_provides):
+
+    needs_decorator = plugins.needs('other_requirement')
+    provides_decorator = plugins.provides('another_provided_requirement')
+
+    @slash.plugins.active  # pylint: disable=unused-variable
+    @maybe_decorate(needs_decorator, class_level_needs)
+    @maybe_decorate(provides_decorator, class_level_provides)
+    class SamplePlugin(PluginInterface):
+
+        def get_name(self):
+            return 'sample'
+
+        @plugins.registers_on('some.hook', provides=['provided_requirement'], needs=['some_requirement'], tags=['tag'])
+        @maybe_decorate(needs_decorator, not class_level_needs)
+        @maybe_decorate(provides_decorator, not class_level_provides)
+        def plugin_method(self):
+            pass
+
+
+    @gossip.register('some.hook', provides=['some_requirement', 'other_requirement'])
+    def _unused():
+        pass
+
+    gossip.trigger('some.hook')
+    hook = gossip.get_hook('some.hook')
+    [registration] = [reg for reg in hook.get_registrations() if reg.func.__name__ == 'plugin_method']
+    assert registration.tags == {'tag'}
+    assert registration.needs == frozenset(['some_requirement', 'other_requirement'])
+    assert registration.provides == frozenset(['provided_requirement', 'another_provided_requirement'])
+
 
 def test_registers_on_with_private_methods(restore_plugins_on_cleanup, checkpoint):
 
diff --git a/tests/utils/__init__.py b/tests/utils/__init__.py
index 2cc15fb1..fb78b9dc 100644
--- a/tests/utils/__init__.py
+++ b/tests/utils/__init__.py
@@ -168,3 +168,12 @@ def __repr__(self):
         1/0                     # pylint: disable=pointless-statement
 
     __str__ = __repr__
+
+
+def maybe_decorate(decorator, flag):
+
+    def returned(func):
+        if flag:
+            func = decorator(func)
+        return func
+    return returned
