diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/CookieShouldNotContainSensitiveDataCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/CookieShouldNotContainSensitiveDataCheck.java
index 3c313e4c7e..336088c3dd 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/security/CookieShouldNotContainSensitiveDataCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/CookieShouldNotContainSensitiveDataCheck.java
@@ -21,14 +21,17 @@
 
 import java.util.Arrays;
 import java.util.List;
+import org.apache.commons.lang.StringUtils;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
-
+import org.sonar.java.model.LiteralUtils;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.LiteralTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.NewClassTree;
+import org.sonar.plugins.java.api.tree.Tree;
 
 @Rule(key = "S2255")
 public class CookieShouldNotContainSensitiveDataCheck extends AbstractMethodDetection {
@@ -43,7 +46,7 @@
     private static final String SPRING_COOKIE = "org.springframework.security.web.savedrequest.SavedCookie";
   }
 
-  private static final List<String> cookieArgumentTypes = Arrays.asList(
+  private static final List<String> COOKIE_ARGUMENT_TYPES = Arrays.asList(
       ClassName.SERVLET_COOKIE,
       ClassName.JAX_RS_COOKIE,
       "org.apache.shiro.web.servlet.Cookie"
@@ -51,14 +54,15 @@
 
   private static final String CONSTRUCTOR = "<init>";
   private static final String SET_VALUE_METHOD = "setValue";
+  private static final String JAVA_LANG_STRING = "java.lang.String";
 
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return Arrays.asList(
       // setters
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SERVLET_COOKIE)).name(SET_VALUE_METHOD).withAnyParameters(),
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.NET_HTTP_COOKIE)).name(SET_VALUE_METHOD).withAnyParameters(),
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SHIRO_COOKIE)).name(SET_VALUE_METHOD).withAnyParameters(),
+      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SERVLET_COOKIE)).name(SET_VALUE_METHOD).parameters(JAVA_LANG_STRING),
+      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.NET_HTTP_COOKIE)).name(SET_VALUE_METHOD).parameters(JAVA_LANG_STRING),
+      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SHIRO_COOKIE)).name(SET_VALUE_METHOD).parameters(JAVA_LANG_STRING),
       // constructors
       MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SERVLET_COOKIE)).name(CONSTRUCTOR).withAnyParameters(),
       MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.NET_HTTP_COOKIE)).name(CONSTRUCTOR).withAnyParameters(),
@@ -70,7 +74,9 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree methodTree) {
-    reportIssue(methodTree.arguments(), MESSAGE);
+    if (isNotNullOrWhitespace(methodTree.arguments().get(0))) {
+      reportIssue(methodTree.arguments(), MESSAGE);
+    }
   }
 
   @Override
@@ -87,7 +93,7 @@ private static boolean firstArgumentIsCookie(NewClassTree newClassTree) {
       return false;
     }
     ExpressionTree firstArgument = newClassTree.arguments().get(0);
-    return cookieArgumentTypes.stream().anyMatch(type -> firstArgument.symbolType().isSubtypeOf(type));
+    return COOKIE_ARGUMENT_TYPES.stream().anyMatch(type -> firstArgument.symbolType().isSubtypeOf(type));
   }
 
   private static boolean secondArgumentIsValue(NewClassTree newClassTree) {
@@ -95,6 +101,11 @@ private static boolean secondArgumentIsValue(NewClassTree newClassTree) {
       return false;
     }
     ExpressionTree secondArgument = newClassTree.arguments().get(1);
-    return secondArgument.symbolType().isSubtypeOf("java.lang.String");
+    return secondArgument.symbolType().isSubtypeOf(JAVA_LANG_STRING) && isNotNullOrWhitespace(secondArgument);
+  }
+
+  private static boolean isNotNullOrWhitespace(Tree tree) {
+    return !tree.is(Tree.Kind.NULL_LITERAL)
+        && !(tree.is(Tree.Kind.STRING_LITERAL) && StringUtils.isBlank(LiteralUtils.trimQuotes(((LiteralTree) tree).value())));
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/LDAPDeserializationCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/LDAPDeserializationCheck.java
index 83f8e4a973..bac76601d4 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/security/LDAPDeserializationCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/LDAPDeserializationCheck.java
@@ -39,7 +39,7 @@
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return Arrays.asList(
       MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(CLASS_NAME)).name("<init>").withAnyParameters(),
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(CLASS_NAME)).name("setReturningObjFlag").withAnyParameters());
+      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(CLASS_NAME)).name("setReturningObjFlag").parameters("boolean"));
   }
   @Override
   protected void onConstructorFound(NewClassTree newClassTree) {
@@ -52,9 +52,6 @@ protected void onConstructorFound(NewClassTree newClassTree) {
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree methodTree) {
-    if (methodTree.arguments().size() != 1) {
-      return;
-    }
     ExpressionTree setValue = methodTree.arguments().get(0);
     reportIfTrue(setValue);
   }
diff --git a/java-checks/src/test/files/checks/security/AESAlgorithmCheck.java b/java-checks/src/test/files/checks/security/AESAlgorithmCheck.java
index 74cd78367e..9f14091813 100644
--- a/java-checks/src/test/files/checks/security/AESAlgorithmCheck.java
+++ b/java-checks/src/test/files/checks/security/AESAlgorithmCheck.java
@@ -17,6 +17,8 @@ public void foo(java.util.Properties props) {
     Cipher.getInstance(algo); // Noncompliant
 
     Cipher.getInstance("AES" + "/ECB/NoPadding"); // Noncompliant
+    Cipher.getInstance(null);
+    Cipher.getInstance("");
   }
 
   abstract java.security.Provider getProvider();
diff --git a/java-checks/src/test/files/checks/security/CookieShouldNotContainSensitiveDataCheck.java b/java-checks/src/test/files/checks/security/CookieShouldNotContainSensitiveDataCheck.java
index c275ea5295..7c5b165ff5 100644
--- a/java-checks/src/test/files/checks/security/CookieShouldNotContainSensitiveDataCheck.java
+++ b/java-checks/src/test/files/checks/security/CookieShouldNotContainSensitiveDataCheck.java
@@ -9,12 +9,13 @@
 class S2255 {
   private static final String VALUE = "value";
 
-  void servletCookie(){
+  void servletCookie(Cookie c){
     Cookie cookie = new Cookie("name", "value"); // Noncompliant [[sc=40;ec=47]] {{If the data stored in this cookie is sensitive, it should be stored internally in the user session.}}
     cookie.setValue("value"); // Noncompliant [[sc=20;ec=29]]
     String x = "value";
     cookie.setValue(x); // Noncompliant
     cookie.setValue(VALUE); // Noncompliant
+    c.setValue("x"); // Noncompliant
   }
 
   void jaxRsCookie() {
@@ -25,13 +26,15 @@ void jaxRsCookie() {
     new NewCookie(cookie); // Noncompliant
   }
 
-  void httpCookie() {
+  void httpCookie(HttpCookie hc) {
     HttpCookie cookie = new HttpCookie("name", "value"); // Noncompliant
     cookie.setValue("value"); // Noncompliant
+    hc.setValue("x"); // Noncompliant
   }
 
   void shiroCookie(SimpleCookie cookie) {
     SimpleCookie sc = new SimpleCookie(cookie); // Noncompliant
+    cookie.setValue("value"); // Noncompliant
     sc.setValue("value"); // Noncompliant
   }
 
@@ -51,7 +54,24 @@ void compliant(Cookie c1, HttpCookie c2, javax.ws.rs.core.Cookie c3, NewCookie c
     c4.getValue();
     c5.getValue();
     c6.getValue();
+    c1.setValue(null);
+    c1.setValue("");
+    c1.setValue("   ");
+    c2.setValue(null);
+    c2.setValue("");
+    c2.setValue("   ");
+    c5.setValue(null);
+    c5.setValue("");
+    c5.setValue("    ");
     new SimpleCookie();
     new SimpleCookie("name");
+    new Cookie("name", "");
+    new Cookie("name", "  ");
+    new Cookie("name", null);
+    new javax.ws.rs.core.Cookie("name", "");
+    new HttpCookie("name", null);
+    new HttpCookie("name", "");
+    new SavedCookie("n", "", "c", "d", 1, "p", true, 1);
+    new SavedCookie("n", "   ", "c", "d", 1, "p", true, 1);
   }
 }
diff --git a/java-checks/src/test/files/checks/security/LDAPAuthenticatedConnectionCheck.java b/java-checks/src/test/files/checks/security/LDAPAuthenticatedConnectionCheck.java
index 5cd638e7c0..aac6e3b750 100644
--- a/java-checks/src/test/files/checks/security/LDAPAuthenticatedConnectionCheck.java
+++ b/java-checks/src/test/files/checks/security/LDAPAuthenticatedConnectionCheck.java
@@ -2,6 +2,7 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.naming.Context;
+import javax.xml.XMLConstants;
 
 class S4433 {
 
@@ -13,6 +14,7 @@ void method1() {
   void method2() {
     Hashtable<String, String> env = new Hashtable<>();
     env.put(Context.SECURITY_AUTHENTICATION, "none"); // Noncompliant
+    env.put(XMLConstants.FEATURE_SECURE_PROCESSING, "none");
   }
 
   void method3(java.util.Properties props) {
diff --git a/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java b/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java
index 58a50dcf15..eb47d4151c 100644
--- a/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java
+++ b/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java
@@ -136,3 +136,7 @@ DocumentBuilderFactory no_property() {
   }
 
 }
+
+class Foo {
+  XMLInputFactory factory = XMLInputFactory.newInstance();
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/helpers/ConstantUtilsTest.java b/java-checks/src/test/java/org/sonar/java/checks/helpers/ConstantUtilsTest.java
index fb43e56143..d5f2b71f8c 100644
--- a/java-checks/src/test/java/org/sonar/java/checks/helpers/ConstantUtilsTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/helpers/ConstantUtilsTest.java
@@ -19,6 +19,7 @@
  */
 package org.sonar.java.checks.helpers;
 
+import com.sonar.sslr.api.typed.ActionParser;
 import java.io.File;
 import java.util.Collections;
 import java.util.List;
@@ -35,11 +36,14 @@
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.VariableTree;
 
 import static org.fest.assertions.Assertions.assertThat;
+import static org.sonar.java.checks.helpers.ConstantUtils.resolveAsIntConstant;
 
 public class ConstantUtilsTest {
 
+  private final ActionParser<Tree> parser = JavaParser.createParser();
   private final ClassTree classTree = parse();
 
   @Test
@@ -82,9 +86,25 @@ public void other() {
     assertThat(resolveAsStrings("other")).containsExactly(null, null);
   }
 
+  @Test
+  public void uncompilable_expressions() {
+    assertThat(resolveAsIntConstant(expression("42 + 1"))).isEqualTo(43);
+    assertThat(resolveAsIntConstant(expression("42 + true"))).isNull();
+    assertThat(resolveAsIntConstant(expression("42L + true"))).isNull();
+    assertThat(resolveAsIntConstant(expression("true + 42"))).isNull();
+    assertThat(resolveAsIntConstant(expression("unknownVar"))).isNull();
+  }
+
+  private ExpressionTree expression(String expressionAsString) {
+    CompilationUnitTree compilationUnit = (CompilationUnitTree) parser.parse("class A { Object obj = " + expressionAsString + "; } ");
+    ClassTree classTree = (ClassTree) compilationUnit.types().get(0);
+    VariableTree field = (VariableTree) classTree.members().get(0);
+    return field.initializer();
+  }
+
   private ClassTree parse() {
-    File file = new File("src/test/java//org/sonar/java/checks/helpers/ClassWithConstants.java");
-    CompilationUnitTree tree = (CompilationUnitTree) JavaParser.createParser().parse(file);
+    File file = new File("src/test/java/org/sonar/java/checks/helpers/ClassWithConstants.java");
+    CompilationUnitTree tree = (CompilationUnitTree) parser.parse(file);
     SemanticModel.createFor(tree, new SquidClassLoader(Collections.singletonList(new File("target/test-classes"))));
     return (ClassTree) tree.types().get(0);
   }
diff --git a/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java b/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
index 8408e3aa5b..7edb239a9c 100644
--- a/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
@@ -62,6 +62,9 @@ public static void setUp() {
       .collect(Collectors.toList());
   }
 
+  /**
+   * The variables below are used in the setUp method above to create the 'variables' list which is used in tests
+   */
   int x1 = 42;
   int x2 = -7;
   int x3 = +3;
@@ -184,11 +187,13 @@ public void is_0xff() {
     assertThat(LiteralUtils.is0xff(tree)).isFalse();
   }
 
+  @Test
   public void isTrue_withNonBooleanLiteral_returnsFalse() {
     ExpressionTree tree = getFirstExpression("void foo(java.util.Properties props){ props.setProperty(\"myKey\", \"myValue\"); }");
     assertThat(LiteralUtils.isTrue(tree)).isFalse();
   }
 
+  @Test
   public void isFalse_withNonBooleanLiteral_returnsFalse() {
     ExpressionTree tree = getFirstExpression("void foo(java.util.Properties props){ props.setProperty(\"myKey\", \"myValue\"); }");
     assertThat(LiteralUtils.isFalse(tree)).isFalse();
