diff --git a/doc/source/code_ref/coordinates.rst b/doc/source/code_ref/coordinates.rst
index 294c482eef..267429fa3a 100644
--- a/doc/source/code_ref/coordinates.rst
+++ b/doc/source/code_ref/coordinates.rst
@@ -19,15 +19,28 @@ The easiest interface to the coordinates module is through the `~astropy.coordin
 
   >>> import astropy.units as u
   >>> from astropy.coordinates import SkyCoord
-  >>> import sunpy.coordinates
-  >>> c = SkyCoord(-100*u.arcsec, 500*u.arcsec, frame='helioprojective')
-  >>> c = SkyCoord(x=-72241.0*u.km, y=361206.1*u.km, z=589951.4*u.km, frame='heliocentric')
-  >>> c = SkyCoord(70*u.deg, -30*u.deg, frame='heliographic_stonyhurst')
+  >>> from sunpy.coordinates import frames
+  >>> c = SkyCoord(-100*u.arcsec, 500*u.arcsec, frame=frames.Helioprojective)
+  >>> c = SkyCoord(x=-72241.0*u.km, y=361206.1*u.km, z=589951.4*u.km, frame=frames.Heliocentric)
+  >>> c = SkyCoord(70*u.deg, -30*u.deg, frame=frames.HeliographicStonyhurst)
   >>> c
   <SkyCoord (HelioGraphicStonyhurst: dateobs=None): (lon, lat, rad) in (deg, deg, km)
       (70.0, -30.0, 695508.0)>
 
 
+It is also possible to use strings to define the frame but in that case make sure to
+explicitly import `sunpy.coordinates` as it registers solar coordinate frames with
+astropy coordinates.
+
+  >>> import astropy.units as u
+  >>> from astropy.coordinates import SkyCoord
+  >>> import sunpy.coordinates
+  >>> c = SkyCoord(-100*u.arcsec, 500*u.arcsec, frame='helioprojective')
+  >>> c
+  <SkyCoord (Helioprojective: D0=149597870.7 km, dateobs=None, L0=0.0 deg, B0=0.0 deg, rsun=695508.0 km): (Tx, Ty) in arcsec
+    (-100.,  500.)>
+
+
 SunPy implements support for the following solar physics coordinate systems:
 
 * Helioprojective (Cartesian) `~sunpy.coordinates.frames.HelioProjective`
@@ -48,7 +61,7 @@ than a list of `~astropy.coordinates.SkyCoord` objects, because it will be
 `~astropy.coordinates.SkyCoord` in a ``for`` loop.
 ::
 
-   >>> c = SkyCoord([-500, 400]*u.arcsec, [100, 200]*u.arcsec, frame='helioprojective')
+   >>> c = SkyCoord([-500, 400]*u.arcsec, [100, 200]*u.arcsec, frame=frames.Helioprojective)
    >>> c
    <SkyCoord (HelioProjective: D0=149597870.7 km, dateobs=None, L0=0.0 deg, B0=0.0 deg, rsun=695508.0 km): (Tx, Ty) in arcsec
        [(-500.0, 100.0), (400.0, 200.0)]>
@@ -69,7 +82,7 @@ description of all the properties of the frames see `sunpy.coordinates.frames`.
 
 For the helioprojective frame the coordinates are access as ``Tx`` and ``Ty`` representing theta x and y. These are the same coordinates that are often referred to as 'solar-x' and 'solar-y'.
 
-  >>> c = SkyCoord(-500*u.arcsec, 100*u.arcsec, frame='helioprojective')
+  >>> c = SkyCoord(-500*u.arcsec, 100*u.arcsec, frame=frames.Helioprojective)
   >>> c.Tx
   <Longitude180 -500.0 arcsec>
   >>> c.Ty
@@ -80,7 +93,7 @@ For the helioprojective frame the coordinates are access as ``Tx`` and ``Ty`` re
 
 Heliocentric normally a Cartesian frame so the coordinates are accessed as ``x,y,z``:
 
-  >>> c = SkyCoord(-72241.0*u.km, 361206.1*u.km, 589951.4*u.km, frame='heliocentric')
+  >>> c = SkyCoord(-72241.0*u.km, 361206.1*u.km, 589951.4*u.km, frame=frames.Heliocentric)
   >>> c.x
   <Quantity -72241.0 km>
   >>> c.y
@@ -93,7 +106,7 @@ Heliocentric normally a Cartesian frame so the coordinates are accessed as ``x,y
 
 Both the heliographic frames use latitude, longitude and radius which are accessed as follows:
 
-   >>> c = SkyCoord(70*u.deg, -30*u.deg, frame='heliographic_stonyhurst')
+   >>> c = SkyCoord(70*u.deg, -30*u.deg, frame=frames.HeliographicStonyhurst)
    >>> c.lat
    <Latitude -30.0 deg>
    >>> c.lon
@@ -110,7 +123,7 @@ Both ``Helioprojective`` and ``Heliocentric`` frames are defined by the location
 It is possible to convert from a ``Helioprojective`` frame with one observer location to another ``Helioprojecitve`` frame with a different observer location, by converting through ``Heliographic``, this does involve making an assumption of the radius of the Sun to calculate the position on the solar sphere. The conversion can be performed as follows::
 
   # Input coordinate
-  >>> hpc1 = SkyCoord(0*u.arcsec, 0*u.arcsec, frame='helioprojective')
+  >>> hpc1 = SkyCoord(0*u.arcsec, 0*u.arcsec, frame=frames.Helioprojective)
   # Define the location of the new observer as a Helioprojective frame
   >>> hpc_out = sunpy.coordinates.Helioprojective(L0=10*u.deg)
   # Perform the conversion
@@ -190,7 +203,6 @@ If you want to obtain a un-realized coordinate frame corresponding to a
 `~sunpy.map.GenericMap` object you can do the following::
 
   >>> from astropy.wcs.utils import wcs_to_celestial_frame
-  >>> import sunpy.coordinates
   >>> import sunpy.map
   >>> from sunpy.data.sample import AIA_171_IMAGE
 
diff --git a/sunpy/coordinates/great_arc.py b/sunpy/coordinates/great_arc.py
index 5577b499bd..b2c5968e3d 100644
--- a/sunpy/coordinates/great_arc.py
+++ b/sunpy/coordinates/great_arc.py
@@ -37,9 +37,8 @@ def great_arc(start_point, end_point, center=None, number_points=100):
 
     Example
     -------
-    >>> from astropy.coordinates import SkyCoord
     >>> import astropy.units as u
-    >>> import sunpy.coordinates
+    >>> from astropy.coordinates import SkyCoord
     >>> from sunpy.coordinates import great_arc
     >>> import sunpy.map
     >>> from sunpy.data.sample import AIA_171_IMAGE
diff --git a/sunpy/io/src/ana/_pyana.c b/sunpy/io/src/ana/_pyana.c
index a09fcb8a58..74cdf4dbb3 100644
--- a/sunpy/io/src/ana/_pyana.c
+++ b/sunpy/io/src/ana/_pyana.c
@@ -9,7 +9,7 @@ version of the original anarw routines.
 // Headers
 #include <Python.h>				// For python extension
 #include <numpy/arrayobject.h> 	// For numpy
-#ifdef WIN32
+#ifndef __USE_GNU
 #include <time.h>
 #else
 #include <sys/time.h>
diff --git a/sunpy/map/compositemap.py b/sunpy/map/compositemap.py
index 65f73a65f7..0721cedd5b 100644
--- a/sunpy/map/compositemap.py
+++ b/sunpy/map/compositemap.py
@@ -301,7 +301,7 @@ def set_zorder(self, index, zorder):
         """
         self._maps[index].zorder = zorder
 
-    def draw_limb(self, index=None, axes=None):
+    def draw_limb(self, index=None, axes=None, **kwargs):
         """Draws a circle representing the solar limb.
 
         Parameters
@@ -315,6 +315,10 @@ def draw_limb(self, index=None, axes=None):
         Returns
         -------
         `matplotlib.axes.Axes`
+
+        Notes
+        -----
+        Keyword arguments are passed onto `sunpy.map.mapbase.GenericMap.draw_limb`.
         """
         if index is None:
             for i, amap in enumerate(self._maps):
@@ -326,10 +330,10 @@ def draw_limb(self, index=None, axes=None):
         if not index_check or index is None:
             raise ValueError("Specified index does not have all the required attributes to draw limb.")
 
-        return self._maps[index].draw_limb(axes=axes)
+        return self._maps[index].draw_limb(axes=axes, **kwargs)
 
     @u.quantity_input(grid_spacing=u.deg)
-    def draw_grid(self, index=None, axes=None, grid_spacing=20*u.deg):
+    def draw_grid(self, index=None, axes=None, grid_spacing=20*u.deg, **kwargs):
         """Draws a grid over the surface of the Sun.
 
         Parameters
@@ -346,6 +350,10 @@ def draw_grid(self, index=None, axes=None, grid_spacing=20*u.deg):
         Returns
         -------
         `matplotlib.axes.Axes` object
+
+        Notes
+        -----
+        Keyword arguments are passed onto `sunpy.map.mapbase.GenericMap.draw_grid`.
         """
         needed_attrs = ['rsun_meters', 'dsun', 'heliographic_latitude',
                         'heliographic_longitude']
@@ -359,10 +367,10 @@ def draw_grid(self, index=None, axes=None, grid_spacing=20*u.deg):
         if not index_check or index is None:
             raise ValueError("Specified index does not have all the required attributes to draw grid.")
 
-        ax = self._maps[index].draw_grid(axes=axes, grid_spacing=grid_spacing)
+        ax = self._maps[index].draw_grid(axes=axes, grid_spacing=grid_spacing, **kwargs)
         return ax
 
-    def plot(self, axes=None, annotate=True, # pylint: disable=W0613
+    def plot(self, axes=None, annotate=True,  # pylint: disable=W0613
              title="SunPy Composite Plot", **matplot_args):
         """Plots the composite map object using matplotlib
 
@@ -468,11 +476,11 @@ def peek(self, colorbar=True, basic_plot=False, draw_limb=True,
             axes = plt.Axes(figure, [0., 0., 1., 1.])
             axes.set_axis_off()
             figure.add_axes(axes)
-            matplot_args.update({'annotate':False})
+            matplot_args.update({'annotate': False})
         else:
             axes = figure.add_subplot(111)
 
-        ret = self.plot(axes=axes,**matplot_args)
+        ret = self.plot(axes=axes, **matplot_args)
 
         if not isinstance(colorbar, bool) and isinstance(colorbar, int):
             figure.colorbar(ret[colorbar])
diff --git a/sunpy/map/mapbase.py b/sunpy/map/mapbase.py
index ad8818a211..0d7334696d 100644
--- a/sunpy/map/mapbase.py
+++ b/sunpy/map/mapbase.py
@@ -1394,7 +1394,7 @@ def superpixel(self, dimensions, offset=(0, 0)*u.pixel, func=np.sum):
 # #### Visualization #### #
 
     @u.quantity_input(grid_spacing=u.deg)
-    def draw_grid(self, axes=None, grid_spacing=15*u.deg):
+    def draw_grid(self, axes=None, grid_spacing=15*u.deg, **kwargs):
         """
         Draws a coordinate overlay on the plot in the Heliographic Stonyhurst
         coordinate system.
@@ -1415,6 +1415,10 @@ def draw_grid(self, axes=None, grid_spacing=15*u.deg):
         -------
         overlay: `~astropy.visualization.wcsaxes.coordinates_map.CoordinatesMap`
             The wcsaxes coordinate overlay instance.
+
+        Notes
+        -----
+        Keyword arguments are passed onto the `sunpy.visualization.wcsaxes_compat.wcsaxes_heliographic_overlay` function.
         """
 
         if not axes:
@@ -1422,7 +1426,8 @@ def draw_grid(self, axes=None, grid_spacing=15*u.deg):
         if not wcsaxes_compat.is_wcsaxes(axes):
             raise TypeError("Overlay grids can only be plotted on WCSAxes plots.")
         return wcsaxes_compat.wcsaxes_heliographic_overlay(axes,
-                                                           grid_spacing=grid_spacing)
+                                                           grid_spacing=grid_spacing,
+                                                           **kwargs)
 
     def draw_limb(self, axes=None, **kwargs):
         """
@@ -1436,14 +1441,12 @@ def draw_limb(self, axes=None, **kwargs):
         Returns
         -------
         circ: list
-            A list containing the `matplotlib.patches.Circle` object that
+            A list containing the `~matplotlib.patches.Circle` object that
             has been added to the axes.
 
         Notes
         -----
-        keyword arguments are passed onto the Circle Patch, see:
-        http://matplotlib.org/api/artist_api.html#matplotlib.patches.Patch
-        http://matplotlib.org/api/artist_api.html#matplotlib.patches.Circle
+        Keyword arguments are passed onto `matplotlib.patches.Circle`.
         """
 
         if not axes:
diff --git a/sunpy/net/dataretriever/client.py b/sunpy/net/dataretriever/client.py
index 286dea805f..81beafab3f 100644
--- a/sunpy/net/dataretriever/client.py
+++ b/sunpy/net/dataretriever/client.py
@@ -248,7 +248,7 @@ def query(self, *args, **kwargs):
         kwergs.update(kwargs)
         urls = self._get_url_for_timerange(
             self.map_.get('TimeRange'), **kwergs)
-        if getattr(self, "_get_time_for_url", None):
+        if urls and getattr(self, "_get_time_for_url", None):
             return QueryResponse.create(self.map_, urls, self._get_time_for_url(urls))
         return QueryResponse.create(self.map_, urls)
 
diff --git a/sunpy/net/dataretriever/sources/eve.py b/sunpy/net/dataretriever/sources/eve.py
index f38280ea72..b3670f6abd 100644
--- a/sunpy/net/dataretriever/sources/eve.py
+++ b/sunpy/net/dataretriever/sources/eve.py
@@ -3,13 +3,18 @@
 # Google Summer of Code 2014
 
 from __future__ import absolute_import, division, print_function
+import datetime
 
+from sunpy.time import TimeRange
+from sunpy.util.scraper import Scraper
 from sunpy.extern.six.moves.urllib.parse import urljoin
 
 from ..client import GenericClient
 
 
 __all__ = ['EVEClient']
+BASEURL = ('http://lasp.colorado.edu/eve/data_access/evewebdata/quicklook/'
+           'L0CS/SpWx/%Y/%Y%m%d_EVE_L0CS_DIODES_1m.txt')
 
 
 class EVEClient(GenericClient):
@@ -39,7 +44,7 @@ def _get_url_for_timerange(self, timerange, **kwargs):
 
         Parameters
         ----------
-        timerange: sunpy.time.TimeRange
+        timerange: `sunpy.time.TimeRange`
             time range for which data is to be downloaded.
 
         Returns
@@ -47,27 +52,23 @@ def _get_url_for_timerange(self, timerange, **kwargs):
         urls : list
             list of URLs corresponding to the requested time range
         """
-        days = timerange.get_dates()
-        urls = []
-        for day in days:
-            urls.append(self._get_url_for_date(day, **kwargs))
-        return urls
 
-    def _get_url_for_date(self, date, **kwargs):
-        """
-        Return URL for corresponding date.
-
-        Parameters
-        ----------
-        date : Python datetime object
-
-        Returns
-        -------
-        URL : string
-        """
-        base_url = 'http://lasp.colorado.edu/eve/data_access/evewebdata/quicklook/L0CS/SpWx/'
-        return urljoin(base_url,
-                                date.strftime('%Y/%Y%m%d') + '_EVE_L0CS_DIODES_1m.txt')
+        # If start of time range is before 00:00, converted to such, so
+        # files of the requested time ranger are included.
+        # This is done because the archive contains daily files.
+        if timerange.start.time() != datetime.time(0, 0):
+            timerange = TimeRange('{:%Y-%m-%d}'.format(timerange.start), timerange.end)
+        eve = Scraper(BASEURL)
+        return eve.filelist(timerange)
+
+    def _get_time_for_url(self, urls):
+        eve = Scraper(BASEURL)
+        times = list()
+        for url in urls:
+            t0 = eve._extractDateURL(url)
+            # hard coded full day as that's the normal.
+            times.append(TimeRange(t0, t0 + datetime.timedelta(days=1)))
+        return times
 
     def _makeimap(self):
         """
diff --git a/sunpy/net/dataretriever/sources/norh.py b/sunpy/net/dataretriever/sources/norh.py
index 899d0045b1..4089b0c8fe 100644
--- a/sunpy/net/dataretriever/sources/norh.py
+++ b/sunpy/net/dataretriever/sources/norh.py
@@ -2,15 +2,18 @@
 #  This Module was developed under funding provided by
 #  Google Summer of Code 2014
 
+import datetime
 import astropy.units as u
 
-from sunpy.extern.six.moves.urllib.parse import urljoin
+from sunpy.time import TimeRange
+from sunpy.util.scraper import Scraper
 
 from sunpy.net import attrs as a
 from ..client import GenericClient
 
 __all__ = ['NoRHClient']
 
+BASEURL = 'ftp://solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/%Y/%m/{freq}%y%m%d'
 
 class NoRHClient(GenericClient):
 
@@ -28,29 +31,6 @@ def _get_url_for_timerange(self, timerange, **kwargs):
         urls : list
             list of URLs corresponding to the requested time range
         """
-        days = timerange.get_dates()
-        urls = []
-        for day in days:
-            urls.append(self._get_url_for_date(day, **kwargs))
-        return urls
-
-    def _get_url_for_date(self, date, **kwargs):
-        """
-        Return URL for corresponding date.
-
-        Parameters
-        ----------
-        date : Python datetime object
-
-        Returns
-        -------
-        string
-            The URL for the corresponding date.
-        """
-
-        # default urllib password anonymous@ is not accepted by the NoRH FTP
-        # server. include an accepted password in base url
-        baseurl = 'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/'
 
         # We allow queries with no Wavelength but error here so that the query
         # does not get passed to VSO and spit out garbage.
@@ -67,16 +47,33 @@ def _get_url_for_date(self, date, **kwargs):
 
         wavelength = wavelength.to(u.GHz, equivalencies=u.spectral())
         if wavelength == 34 * u.GHz:
-            final_url = urljoin(baseurl,
-                                date.strftime('%Y/%m/' + 'tcz' + '%y%m%d'))
+            freq = 'tcz'
         elif wavelength == 17 * u.GHz:
-            final_url = urljoin(baseurl,
-                                date.strftime('%Y/%m/' + 'tca' + '%y%m%d'))
+            freq = 'tca'
         else:
             raise ValueError("NORH Data can be downloaded for 17GHz or 34GHz,"
                              " see http://solar.nro.nao.ac.jp/norh/doc/manuale/node65.html")
 
-        return final_url
+        # If start of time range is before 00:00, converted to such, so
+        # files of the requested time ranger are included.
+        # This is done because the archive contains daily files.
+        if timerange.start.time() != datetime.time(0, 0):
+            timerange = TimeRange('{:%Y-%m-%d}'.format(timerange.start), timerange.end)
+        norh = Scraper(BASEURL, freq=freq)
+        # TODO: warn user that some files may have not been listed, like for example:
+        #       tca160504_224657 on ftp://solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2016/05/
+        #       as it doesn't follow pattern.
+        return norh.filelist(timerange)
+
+    def _get_time_for_url(self, urls):
+        freq = urls[0].split('/')[-1][0:3]  # extract the frequency label
+        crawler = Scraper(BASEURL, freq=freq)
+        times = list()
+        for url in urls:
+            t0 = crawler._extractDateURL(url)
+            # hard coded full day as that's the normal.
+            times.append(TimeRange(t0, t0 + datetime.timedelta(days=1)))
+        return times
 
     def _makeimap(self):
         """
diff --git a/sunpy/net/dataretriever/tests/test_eve.py b/sunpy/net/dataretriever/tests/test_eve.py
index 039df8a31e..cc9c6a7739 100644
--- a/sunpy/net/dataretriever/tests/test_eve.py
+++ b/sunpy/net/dataretriever/tests/test_eve.py
@@ -17,7 +17,7 @@
 
 LCClient = eve.EVEClient()
 
-
+@pytest.mark.online
 @pytest.mark.parametrize("timerange,url_start,url_end", [
     (TimeRange('2012/4/21', '2012/4/21'),
      'http://lasp.colorado.edu/eve/data_access/evewebdata/quicklook/L0CS/SpWx/2012/20120421_EVE_L0CS_DIODES_1m.txt',
@@ -39,12 +39,6 @@ def test_get_url_for_time_range(timerange, url_start, url_end):
     assert urls[-1] == url_end
 
 
-@pytest.mark.online
-def test_get_url_for_date():
-    url = LCClient._get_url_for_date(datetime.date(2013, 2, 13))
-    assert url == 'http://lasp.colorado.edu/eve/data_access/evewebdata/quicklook/L0CS/SpWx/2013/20130213_EVE_L0CS_DIODES_1m.txt'
-
-
 def test_can_handle_query():
     ans1 = eve.EVEClient._can_handle_query(
         Time('2012/8/9', '2012/8/10'), Instrument('eve'), Level(0))
@@ -62,7 +56,7 @@ def test_query():
     assert isinstance(qr1, QueryResponse)
     assert len(qr1) == 2
     assert qr1.time_range().start == parse_time('2012/08/09')
-    assert qr1.time_range().end == parse_time('2012/08/10')
+    assert qr1.time_range().end == parse_time('2012/08/11') # includes end.
 
 
 @pytest.mark.online
@@ -109,4 +103,3 @@ def test_levels(time):
     qr = Fido.search(time, eve_a, a.Level(0) | a.Level(1))
     clients = {type(a.client) for a in qr.responses}
     assert clients.symmetric_difference({VSOClient, eve.EVEClient}) == set()
-
diff --git a/sunpy/net/dataretriever/tests/test_norh.py b/sunpy/net/dataretriever/tests/test_norh.py
index 27eac6ceb7..94567ee006 100644
--- a/sunpy/net/dataretriever/tests/test_norh.py
+++ b/sunpy/net/dataretriever/tests/test_norh.py
@@ -11,20 +11,22 @@
 from sunpy.net import attrs as a
 
 from hypothesis import given
-from sunpy.net.tests.strategies import time_attr
+from sunpy.net.tests.strategies import time_attr, range_time
 
+
+@pytest.mark.online
 @pytest.mark.parametrize("timerange,url_start,url_end", [
     (TimeRange('2012/4/21', '2012/4/21'),
-     'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/04/tca120421',
-     'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/04/tca120421'
+     'ftp://anonymous:data@sunpy.org@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/04/tca120421',
+     'ftp://anonymous:data@sunpy.org@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/04/tca120421'
      ),
     (TimeRange('2012/12/1', '2012/12/2'),
-     'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/12/tca121201',
-     'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/12/tca121202'
+     'ftp://anonymous:data@sunpy.org@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/12/tca121201',
+     'ftp://anonymous:data@sunpy.org@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/12/tca121202'
      ),
     (TimeRange('2012/3/7', '2012/3/14'),
-     'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/03/tca120307',
-     'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/03/tca120314'
+     'ftp://anonymous:data@sunpy.org@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/03/tca120307',
+     'ftp://anonymous:data@sunpy.org@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2012/03/tca120314'
      )
 ])
 def test_get_url_for_time_range(timerange, url_start, url_end):
@@ -34,11 +36,6 @@ def test_get_url_for_time_range(timerange, url_start, url_end):
     assert urls[-1] == url_end
 
 
-def test_get_url_for_date():
-    url = norh.NoRHClient()._get_url_for_date(datetime.date(2011, 3, 14), wavelength=17*u.GHz)
-    assert url == 'ftp://anonymous:mozilla@example.com@solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/2011/03/tca110314'
-
-
 @given(time_attr())
 def test_can_handle_query(time):
     ans1 = norh.NoRHClient._can_handle_query(time, a.Instrument('norh'))
@@ -50,20 +47,21 @@ def test_can_handle_query(time):
     assert ans2 is False
 
 
-@given(time_attr())
-def test_query(time):
-    qr1 = norh.NoRHClient().query(time, a.Instrument('norh'), a.Wavelength(17 * u.GHz))
-    assert isinstance(qr1, QueryResponse)
-    assert qr1.time_range().start == time.start
-    assert qr1.time_range().end == time.end
-
-
-@given(time_attr())
-def test_query_34(time):
-    qr1 = norh.NoRHClient().query(time, a.Instrument('norh'), a.Wavelength(34 * u.GHz))
+@pytest.mark.online
+@pytest.mark.parametrize("wave", [a.Wavelength(17*u.GHz), a.Wavelength(34*u.GHz)])
+@given(time=range_time(datetime.datetime(1992, 6, 1)))
+def test_query(time, wave):
+    qr1 = norh.NoRHClient().query(time, a.Instrument('norh'), wave)
     assert isinstance(qr1, QueryResponse)
-    assert qr1.time_range().start == time.start
-    assert qr1.time_range().end == time.end
+    # Not all hypothesis queries are going to produce results, and
+    if qr1:
+        # There are no observations everyday
+        #  so the results found have to be equal or later than the queried time
+        #  (looking at the date because it may search for miliseconds, but only date is available)
+        assert qr1.time_range().start.date() >= time.start.date()
+        #  and the end time equal or smaller.
+        # hypothesis can give same start-end, but the query will give you from start to end (so +1)
+        assert qr1.time_range().end <= time.end + datetime.timedelta(days=1)
 
 
 # Don't use time_attr here for speed.
diff --git a/sunpy/net/tests/strategies.py b/sunpy/net/tests/strategies.py
index 8c77a9f728..6237a67b17 100644
--- a/sunpy/net/tests/strategies.py
+++ b/sunpy/net/tests/strategies.py
@@ -27,11 +27,10 @@ def offline_instruments():
     Returns a strategy for any instrument that does not need the internet to do
     a query
     """
-    offline_instr = ['lyra', 'norh', 'noaa-indices', 'noaa-predict', 'goes']
+    offline_instr = ['lyra', 'noaa-indices', 'noaa-predict', 'goes']
     offline_instr = st.builds(a.Instrument, st.sampled_from(offline_instr))
 
-    eve = st.just(a.Instrument('eve') & a.Level(0))
-    return st.one_of(offline_instr, eve)
+    return st.one_of(offline_instr)
 
 
 def online_instruments():
@@ -82,8 +81,8 @@ def goes_time(draw, time=datetimes(timezones=[],
     return a.Time(tr)
 
 
-def rhessi_time():
-    time = datetimes(timezones=[], max_year=datetime.datetime.utcnow().year,
-                     min_year=2002)
-    time = time.filter(lambda x: x > parse_time('2002-02-01'))
+def range_time(min_date, max_date=datetime.datetime.utcnow()):
+    time = datetimes(timezones=[], max_year=max_date.year,
+                     min_year=1960)
+    time = time.filter(lambda x: min_date < x < max_date)
     return time_attr(time=time)
diff --git a/sunpy/net/tests/test_fido.py b/sunpy/net/tests/test_fido.py
index fefd21fb39..f41b8fddca 100644
--- a/sunpy/net/tests/test_fido.py
+++ b/sunpy/net/tests/test_fido.py
@@ -17,7 +17,7 @@
 from sunpy import config
 
 from .strategies import (online_instruments, offline_instruments,
-                         time_attr, rhessi_time, goes_time)
+                         time_attr, range_time, goes_time)
 
 TIMEFORMAT = config.get("general", "time_format")
 
@@ -43,7 +43,7 @@ def online_query(draw, instrument=online_instruments(), time=time_attr()):
     query = draw(instrument)
     # If we have AttrAnd then we don't have RHESSI
     if isinstance(query, a.Instrument) and query.value == 'rhessi':
-        query = query & draw(rhessi_time())
+        query = query & draw(range_time(parse_time('2002-02-01')))
     return query
 
 
@@ -95,6 +95,7 @@ def test_save_path():
 """
 
 
+@pytest.mark.online
 def test_unified_response():
     start = parse_time("2012/1/1")
     end = parse_time("2012/1/2")
diff --git a/sunpy/util/scraper.py b/sunpy/util/scraper.py
index 8e064200fe..3354acbe21 100644
--- a/sunpy/util/scraper.py
+++ b/sunpy/util/scraper.py
@@ -3,6 +3,7 @@
 import os
 import datetime
 import re
+from ftplib import FTP
 
 from bs4 import BeautifulSoup
 from sunpy.extern import six
@@ -65,7 +66,9 @@ def __init__(self, pattern, **kwargs):
         else:
             now = datetime.datetime.now()
             milliseconds_ = int(now.microsecond / 1000.)
-            self.now = now.strftime(self.pattern[0:milliseconds.start()] + str(milliseconds_) + self.pattern[milliseconds.end():])
+            self.now = now.strftime(self.pattern[0:milliseconds.start()] +
+                                    str(milliseconds_) +
+                                    self.pattern[milliseconds.end():])
 
     def matches(self, filepath, date):
         return date.strftime(self.pattern) == filepath
@@ -90,9 +93,9 @@ def range(self, timerange):
             range given. Notice that these directories may not exist
             in the archive.
         """
-        #find directory structure - without file names
+        # find directory structure - without file names
         directorypattern = os.path.dirname(self.pattern) + '/'
-        #TODO what if there's not slashes?
+        # TODO what if there's not slashes?
         rangedelta = timerange.dt
         timestep = self._smallerPattern(directorypattern)
         if timestep is None:
@@ -102,13 +105,13 @@ def range(self, timerange):
             n_steps = rangedelta.total_seconds()/timestep.total_seconds()
             TotalTimeElements = int(round(n_steps)) + 1
             directories = [(timerange.start + n * timestep).strftime(directorypattern)
-                        for n in range(TotalTimeElements)] #todo if date <= endate
+                           for n in range(TotalTimeElements)]  # TODO if date <= endate
             return directories
 
     def _URL_followsPattern(self, url):
         """Check whether the url provided follows the pattern"""
         pattern = self.pattern
-        for k,v in six.iteritems(TIME_CONVERSIONS):
+        for k, v in six.iteritems(TIME_CONVERSIONS):
             pattern = pattern.replace(k, v)
         matches = re.match(pattern, url)
         if matches:
@@ -117,6 +120,10 @@ def _URL_followsPattern(self, url):
 
     def _extractDateURL(self, url):
         """Extracts the date from a particular url following the pattern"""
+
+        # remove the user and passwd from files if there:
+        url = url.replace("anonymous:data@sunpy.org@", "")
+
         # url_to_list substitutes '.' and '_' for '/' to then create
         # a list of all the blocks in times - assuming they are all
         # separated with either '.', '_' or '/'
@@ -131,6 +138,13 @@ def _extractDateURL(self, url):
         for pattern_elem, url_elem in zip(pattern_list, url_list):
             time_formats = [x for x in time_order if x in pattern_elem]
             if len(time_formats) > 0:
+                # Find whether there's text that should not be here
+                toremove = re.split('%.', pattern_elem)
+                if len(toremove) > 0:
+                    for bit in toremove:
+                        if bit != '':
+                            url_elem = url_elem.replace(bit, '', 1)
+                            pattern_elem = pattern_elem.replace(bit, '', 1)
                 final_date.append(url_elem)
                 final_pattern.append(pattern_elem)
                 for time_bit in time_formats:
@@ -143,14 +157,14 @@ def _extractDateURL(self, url):
         for k, v in six.iteritems(TIME_CONVERSIONS):
             re_together = re_together.replace(k, v)
 
-        #   Create new empty lists
+        #   Lists to contain the unique elements of the date and the pattern
         final_date = list()
         final_pattern = list()
         re_together = re_together.replace('[A-Z]', '\\[A-Z]')
-        for p,r in zip(pattern_together.split('%')[1:], re_together.split('\\')[1:]):
+        for p, r in zip(pattern_together.split('%')[1:], re_together.split('\\')[1:]):
             if p == 'e':
                 continue
-            regexp = '\\{}'.format(r) if not r.startswith('[') else r
+            regexp = r'\{}'.format(r) if not r.startswith('[') else r
             pattern = '%{}'.format(p)
             date_part = re.search(regexp, date_together)
             date_together = date_together[:date_part.start()] + \
@@ -185,9 +199,20 @@ def filelist(self, timerange):
         >>> timerange = TimeRange('2015-01-01','2015-01-01T16:00:00')
         >>> print(solmon.filelist(timerange))
         ['http://solarmonitor.org/data/2015/01/01/fits/swap/swap_00174_fd_20150101_025423.fts.gz']
+
+        Note
+        ----
+
+        The search is strict with the time range, so if the archive scraped
+        contains daily files, but the range doesn't start from the beginning
+        of the day, then the file for that day won't be selected. The end of
+        the timerange will normally be OK as includes the file on such end.
+
         """
         directories = self.range(timerange)
         filesurls = []
+        if directories[0][0:3] == "ftp":  # TODO use urlsplit from pr #1807
+            return self._ftpfileslist(timerange)
         for directory in directories:
             try:
                 opn = urlopen(directory)
@@ -205,9 +230,29 @@ def filelist(self, timerange):
                 finally:
                     opn.close()
             except:
-                pass
+                raise
         return filesurls
 
+    def _ftpfileslist(self, timerange):
+        directories = self.range(timerange)
+        filesurls = list()
+        domain = directories[0].find('//')
+        domain_slash = directories[0].find('/', 6)  # TODO: Use also urlsplit from pr #1807
+        ftpurl = directories[0][domain + 2:domain_slash]
+        with FTP(ftpurl, user="anonymous", passwd="data@sunpy.org") as ftp:
+            for directory in directories:
+                ftp.cwd(directory[domain_slash:])
+                for file_i in ftp.nlst():
+                    fullpath = directory + file_i
+                    if self._URL_followsPattern(fullpath):
+                        datehref = self._extractDateURL(fullpath)
+                        if (datehref >= timerange.start and
+                            datehref <= timerange.end):
+                            filesurls.append(fullpath)
+        filesurls = ['ftp://anonymous:data@sunpy.org@' + url[domain + 2:] for url in filesurls]
+        return filesurls
+
+
     def _smallerPattern(self, directoryPattern):
         """Obtain the smaller time step for the given pattern"""
         try:
@@ -219,7 +264,7 @@ def _smallerPattern(self, directoryPattern):
                 return datetime.timedelta(hours=1)
             elif any(day in directoryPattern for day in ["%d", "%j"]):
                 return datetime.timedelta(days=1)
-            elif any(month in directoryPattern for month in ["%b","%B","%m"]):
+            elif any(month in directoryPattern for month in ["%b", "%B", "%m"]):
                 return datetime.timedelta(days=31)
             elif any(year in directoryPattern for year in ["%Y", "%y"]):
                 return datetime.timedelta(days=365)
@@ -227,4 +272,3 @@ def _smallerPattern(self, directoryPattern):
                 return None
         except:
             raise
-
diff --git a/sunpy/util/tests/test_scraper.py b/sunpy/util/tests/test_scraper.py
index 59760d6f6b..90f054d61c 100644
--- a/sunpy/util/tests/test_scraper.py
+++ b/sunpy/util/tests/test_scraper.py
@@ -2,9 +2,7 @@
 
 import pytest
 import datetime
-import os
 
-import sunpy.data.test
 from sunpy.time import TimeRange
 from sunpy.util.scraper import Scraper
 
@@ -15,24 +13,28 @@
     ('%y%b', datetime.timedelta(days=31)),
 ]
 
+
 def testDirectoryDatePattern():
     s = Scraper('%Y/%m/%d/%Y%m%d_%H%M%S_59.fit.gz')
     testpath = '2014/03/05/20140305_013000_59.fit.gz'
-    d = datetime.datetime(2014,3,5,1,30)
+    d = datetime.datetime(2014, 3, 5, 1, 30)
     assert s.matches(testpath, d)
 
+
 def testDirectoryDatePatternFalse():
     s = Scraper('%Y/%m/%d/%Y%m%d_%H%M%S_59.fit.gz')
     testpath = '2013/03/05/20140305_013000_59.fit.gz'
-    d = datetime.datetime(2014,3,5,1,30)
+    d = datetime.datetime(2014, 3, 5, 1, 30)
     assert not s.matches(testpath, d)
 
+
 def testDirectoryObsPattern():
-    s = Scraper('%y%m%d/{observatory}_%Y%m%d.fits', observatory = 'SDO')
+    s = Scraper('%y%m%d/{observatory}_%Y%m%d.fits', observatory='SDO')
     testpath = '140305/SDO_20140305.fits'
-    d = datetime.datetime(2014,3,5)
+    d = datetime.datetime(2014, 3, 5)
     assert s.matches(testpath, d)
 
+
 def testDirectoryRange():
     s = Scraper('%Y/%m/%d/%Y%m%d_%H.fit.gz')
     directory_list = ['2009/12/30/', '2009/12/31/', '2010/01/01/',
@@ -40,6 +42,7 @@ def testDirectoryRange():
     timerange = TimeRange('2009-12-30', '2010-01-03')
     assert s.range(timerange) == directory_list
 
+
 def testDirectoryRangeFalse():
     s = Scraper('%Y%m%d/%Y%m%d_%H.fit.gz')
     directory_list = ['20091230/', '20091231/', '20100101/',
@@ -47,39 +50,45 @@ def testDirectoryRangeFalse():
     timerange = TimeRange('2009/12/30', '2010/01/03')
     assert s.range(timerange) != directory_list
 
+
 def testNoDateDirectory():
     s = Scraper('mySpacecraft/myInstrument/xMinutes/aaa%y%b.ext')
     directory_list = ['mySpacecraft/myInstrument/xMinutes/']
     timerange = TimeRange('2009/11/20', '2010/01/03')
     assert s.range(timerange) == directory_list
 
+
 @pytest.mark.parametrize('pattern, mintime', PATTERN_EXAMPLES)
 def test_smallerPattern(pattern, mintime):
-    assert  mintime == Scraper('')._smallerPattern(pattern)
+    assert mintime == Scraper('')._smallerPattern(pattern)
+
 
 def testDirectoryRangeHours():
     s = Scraper('%Y%m%d_%H/%H%M.csv')
     timerange = TimeRange('2009-12-31T23:40:00', '2010-01-01T01:15:00')
-    assert len(s.range(timerange)) == 3 #3 directories (1 per hour)
+    assert len(s.range(timerange)) == 3  # 3 directories (1 per hour)
+
 
 def testDirectoryRange_single():
     s = Scraper('%Y%m%d/%H_%M.csv')
-    startdate = datetime.datetime(2010,10,10,5,00)
-    enddate = datetime.datetime(2010,10,10,7,00)
+    startdate = datetime.datetime(2010, 10, 10, 5, 0)
+    enddate = datetime.datetime(2010, 10, 10, 7, 0)
     timerange = TimeRange(startdate, enddate)
     assert len(s.range(timerange)) == 1
 
+
 def testDirectoryRange_Month():
     s = Scraper('%Y%m/%d/%j_%H.txt')
-    startdate = datetime.datetime(2008, 2,20,10)
+    startdate = datetime.datetime(2008, 2, 20, 10)
     enddate = datetime.datetime(2008, 3, 2, 5)
     timerange = TimeRange(startdate, enddate)
     assert len(s.range(timerange)) == 12
-    startdate = datetime.datetime(2009, 2,20,10)
+    startdate = datetime.datetime(2009, 2, 20, 10)
     enddate = datetime.datetime(2009, 3, 2, 5)
     timerange = TimeRange(startdate, enddate)
     assert len(s.range(timerange)) == 11
 
+
 def testNoDirectory():
     s = Scraper('files/%Y%m%d_%H%M.dat')
     startdate = datetime.datetime(2010, 1, 10, 20, 30)
@@ -87,6 +96,7 @@ def testNoDirectory():
     timerange = TimeRange(startdate, enddate)
     assert len(s.range(timerange)) == 1
 
+
 def testExtractDates_usingPattern():
     # Standard pattern
     s = Scraper('data/%Y/%m/%d/fits/swap/swap_00174_fd_%Y%m%d_%H%M%S.fts.gz')
@@ -99,15 +109,41 @@ def testExtractDates_usingPattern():
     timeURL = datetime.datetime(2014, 5, 14, 20, 1, 35)
     assert s._extractDateURL(testURL) == timeURL
 
+
+def testExtractDates_notSeparators():
+    s = Scraper('data/%Y/%m/swap%m%d_%H%M%S')
+    testURL = 'data/2014/05/swap0514_200135'
+    timeURL = datetime.datetime(2014, 5, 14, 20, 1, 35)
+    assert s._extractDateURL(testURL) == timeURL
+
+
+def testExtractDates_notSeparators_andSimilar():
+    s = Scraper('data/%Y/Jun%b%d_%H%M%S')
+    testURL = 'data/2014/JunJun14_200135'
+    timeURL = datetime.datetime(2014, 6, 14, 20, 1, 35)
+    assert s._extractDateURL(testURL) == timeURL
+    testURL = 'data/2014/JunMay14_200135'
+    timeURL = datetime.datetime(2014, 5, 14, 20, 1, 35)
+    assert s._extractDateURL(testURL) == timeURL
+    # and testing with the month afterwards
+    s = Scraper('data/%Y/%dJun%b_%H%M%S')
+    testURL = 'data/2014/14JunJun_200135'
+    timeURL = datetime.datetime(2014, 6, 14, 20, 1, 35)
+    assert s._extractDateURL(testURL) == timeURL
+
+
 def testURL_pattern():
     s = Scraper('fd_%Y%m%d_%H%M%S.fts')
     assert s._URL_followsPattern('fd_20130410_231211.fts')
     assert not s._URL_followsPattern('fd_20130410_231211.fts.gz')
     assert not s._URL_followsPattern('fd_20130410_ar_231211.fts.gz')
 
+
 @pytest.mark.xfail
 def testURL_patternMilliseconds():
     s = Scraper('fd_%Y%m%d_%H%M%S_%e.fts')
+    # NOTE: Seems that if below fails randomly - not understood why
+    #       with `== True` fails a bit less...
     assert s._URL_followsPattern('fd_20130410_231211_119.fts')
     assert not s._URL_followsPattern('fd_20130410_231211.fts.gz')
     assert not s._URL_followsPattern('fd_20130410_ar_231211.fts.gz')
@@ -125,13 +161,14 @@ def testURL_patternMilliseconds():
 #     enddate = datetime.datetime(2010, 1, 20, 20, 30)
 #     assert len(s.filelist(TimeRange(startdate, enddate))) == 0
 
+
 @pytest.mark.xfail
 @pytest.mark.online
 def testFilesRange_sameDirectory_remote():
     pattern = ('http://solarmonitor.org/data/%Y/%m/%d/'
                'fits/{instrument}/'
                '{instrument}_00174_fd_%Y%m%d_%H%M%S.fts.gz')
-    s = Scraper(pattern, instrument = 'swap')
+    s = Scraper(pattern, instrument='swap')
     startdate = datetime.datetime(2014, 5, 14, 0, 0)
     enddate = datetime.datetime(2014, 5, 14, 6, 30)
     timerange = TimeRange(startdate, enddate)
@@ -141,13 +178,22 @@ def testFilesRange_sameDirectory_remote():
     timerange = TimeRange(startdate, enddate)
     assert len(s.filelist(timerange)) == 0
 
+
 @pytest.mark.xfail
 @pytest.mark.online
 def testFilesRange_sameDirectory_months_remote():
     pattern = ('http://www.srl.caltech.edu/{spacecraft}/DATA/{instrument}/'
                'Ahead/1minute/AeH%y%b.1m')
-    s = Scraper(pattern, spacecraft='STEREO', instrument = 'HET')
+    s = Scraper(pattern, spacecraft='STEREO', instrument='HET')
     startdate = datetime.datetime(2007, 8, 1)
     enddate = datetime.datetime(2007, 9, 10)
     timerange = TimeRange(startdate, enddate)
     assert len(s.filelist(timerange)) == 2
+
+
+@pytest.mark.online
+def test_ftp():
+    pattern = 'ftp://solar-pub.nao.ac.jp/pub/nsro/norh/data/tcx/%Y/%m/tca%y%m%d'
+    s = Scraper(pattern)
+    timerange = TimeRange('2016/5/18 15:28:00', '2016/5/20 16:30:50')
+    assert len(s.filelist(timerange)) == 2
diff --git a/sunpy/visualization/wcsaxes_compat.py b/sunpy/visualization/wcsaxes_compat.py
index e17d6cf9c1..135ee63f98 100644
--- a/sunpy/visualization/wcsaxes_compat.py
+++ b/sunpy/visualization/wcsaxes_compat.py
@@ -39,7 +39,7 @@ def is_wcsaxes(axes):
         return False
 
 
-def gca_wcs(wcs, fig=None):
+def gca_wcs(wcs, fig=None, slices=None):
     """
     Get the current axes, and return a WCSAxes if possible.
 
@@ -49,11 +49,17 @@ def gca_wcs(wcs, fig=None):
         A `~astropy.wcs.WCS` object used to create a new axes.
     fig : `matplotlib.figure.Figure`
         The figure in which to check for the axes.
+    slices : `tuple`
+        ``slices`` is passed to `~astropy.visualization.wcsaxes.WCSAxes`
+        to describe which two dimensions of the `~astropy.wcs.WCS` object
+        are being plotted.
+        This slices the multidimensional wcs object in the way it needs
+        to be sliced.
 
     Returns
     -------
-    ax : `matplotlib.axes.Axes` or `wcsaxes.WCSAxes` object.
-        The current axes, or a new one if created.
+    ax : `matplotlib.axes.Axes` or `~astropy.visualization.wcsaxes.WCSAxes`
+        object. The current axes, or a new one if created.
 
     """
 
@@ -62,7 +68,7 @@ def gca_wcs(wcs, fig=None):
 
     if not len(fig.get_axes()):
         if not _FORCE_NO_WCSAXES:
-            ax = plt.gca(projection=wcs)
+            ax = plt.gca(projection=wcs, slices=slices)
         else:
             ax = plt.gca()
 
@@ -76,18 +82,19 @@ def get_world_transform(axes):
     """
     Get the transformation to world coordinates.
 
-    If the axes is a `wcaxes.WCSAxes` instance this returns the transform to
-    the ``'world'`` coordinates, otherwise it returns the transform to the
-    matplotlib data coordinates, which are assumed to be in world coordinates.
+    If the axes is a `~astropy.visualization.wcsaxes.WCSAxes` instance this
+    returns the transform to the ``'world'`` coordinates, otherwise it returns
+    the transform to the matplotlib data coordinates, which are assumed to be in
+    world coordinates.
 
     Parameters
     ----------
-    axes : `wcsaxes.WCSAxes` or `matplotlib.axes.Axes` obejct.
-        The axes to get the transform from.
+    axes : `~astropy.visualization.wcsaxes.WCSAxes` or `~matplotlib.axes.Axes`
+        object. The axes to get the transform from.
 
     Returns
     -------
-    transform : `matplotlib.transforms.CompositeGenericTransform`
+    transform : `~matplotlib.transforms.CompositeGenericTransform`
         The transformation object.
     """
     if is_wcsaxes(axes):
@@ -123,8 +130,9 @@ def default_wcs_grid(axes, units, ctypes):
 
     Parameters
     ----------
-    axes : `wcsaxes.WCSAxes` object.
-        The `~wcsaxes.WCSAxes` object to draw the world coordinate grid on.
+    axes : `~astropy.visualization.wcsaxes.WCSAxes` object.
+        The `~astropy.visualization.wcsaxes.WCSAxes` object to draw the world
+        coordinate grid on.
 
     units : `tuple`
         The axes units axes x y order.
@@ -163,7 +171,7 @@ def default_wcs_grid(axes, units, ctypes):
 
 
 @u.quantity_input(grid_spacing=u.deg)
-def wcsaxes_heliographic_overlay(axes, grid_spacing=10*u.deg):
+def wcsaxes_heliographic_overlay(axes, grid_spacing=10*u.deg, **kwargs):
     """
     Create a heliographic overlay using wcsaxes.
 
@@ -171,16 +179,21 @@ def wcsaxes_heliographic_overlay(axes, grid_spacing=10*u.deg):
 
     Parameters
     ----------
-    axes : `wcsaxes.WCSAxes` object.
-        The `~wcsaxes.WCSAxes` object to create the HGS overlay on.
+    axes : `~astropy.visualization.wcsaxes.WCSAxes` object.
+        The `~astropy.visualization.wcsaxes.WCSAxes` object to create the HGS overlay on.
 
-    grid_spacing: `astropy.units.Quantity`
+    grid_spacing: `~astropy.units.Quantity`
         Spacing for longitude and latitude grid in degrees.
 
     Returns
     -------
-    overlay : wcsaxes overlay
+    overlay : `~astropy.visualization.wcsaxes.WCSAxes` overlay
         The overlay object.
+
+    Notes
+    -----
+    Keywords are passed to `~astropy.visualization.wcsaxes.coordinates_map.CoordinatesMap.grid`.
+
     """
 
     # Unpack spacing
@@ -205,10 +218,13 @@ def wcsaxes_heliographic_overlay(axes, grid_spacing=10*u.deg):
     lon.set_ticks_position('tr')
     lat.set_ticks_position('tr')
 
-    lon.set_ticks(spacing=lon_space, color='white')
-    lat.set_ticks(spacing=lat_space, color='white')
+    grid_kw = {'color': 'white', 'zorder': 100, 'alpha': 0.5}
+    grid_kw.update(kwargs)
+
+    lon.set_ticks(spacing=lon_space, color=grid_kw['color'])
+    lat.set_ticks(spacing=lat_space, color=grid_kw['color'])
 
-    overlay.grid(color='white', alpha=0.5)
+    overlay.grid(**grid_kw)
 
     if axes.title:
         x, y = axes.title.get_position()
