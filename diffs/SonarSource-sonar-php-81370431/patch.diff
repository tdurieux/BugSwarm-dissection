diff --git a/php-frontend/src/main/java/org/sonar/php/parser/NewPHPGrammar.java b/php-frontend/src/main/java/org/sonar/php/parser/NewPHPGrammar.java
index c2e4c9c77..db8089aaf 100644
--- a/php-frontend/src/main/java/org/sonar/php/parser/NewPHPGrammar.java
+++ b/php-frontend/src/main/java/org/sonar/php/parser/NewPHPGrammar.java
@@ -22,16 +22,24 @@
 import com.sonar.sslr.api.typed.GrammarBuilder;
 import org.sonar.php.api.PHPKeyword;
 import org.sonar.php.api.PHPPunctuator;
+import org.sonar.php.tree.impl.SeparatedList;
 import org.sonar.php.tree.impl.lexical.InternalSyntaxToken;
+import org.sonar.php.tree.impl.statement.ForEachStatementTreeImpl.ForEachStatementHeader;
+import org.sonar.php.tree.impl.statement.ForStatementTreeImpl.ForStatementHeader;
 import org.sonar.plugins.php.api.tree.declaration.NamespaceNameTree;
 import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
 import org.sonar.plugins.php.api.tree.statement.BlockTree;
 import org.sonar.plugins.php.api.tree.statement.BreakStatementTree;
 import org.sonar.plugins.php.api.tree.statement.CatchBlockTree;
 import org.sonar.plugins.php.api.tree.statement.ContinueStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
 import org.sonar.plugins.php.api.tree.statement.EmptyStatementTree;
 import org.sonar.plugins.php.api.tree.statement.ExpressionStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForStatementTree;
 import org.sonar.plugins.php.api.tree.statement.GotoStatementTree;
+import org.sonar.plugins.php.api.tree.statement.IfStatementTree;
 import org.sonar.plugins.php.api.tree.statement.LabelTree;
 import org.sonar.plugins.php.api.tree.statement.ReturnStatementTree;
 import org.sonar.plugins.php.api.tree.statement.StatementTree;
@@ -86,13 +94,12 @@ public StatementTree STATEMENT() {
     return b.<StatementTree>nonterminal(PHPLexicalGrammar.STATEMENT)
         .is(b.firstOf(
             BLOCK(),
-//            ALTERNATIVE_IF_STATEMENT(),
             THROW_STATEMENT(),
-//            IF_STATEMENT(),
+            IF_STATEMENT(),
 //            WHILE_STATEMENT(),
 //            DO_WHILE_STATEMENT(),
-//            FOREACH_STATEMENT(),
-//            FOR_STATEMENT(),
+            FOREACH_STATEMENT(),
+            FOR_STATEMENT(),
 //            SWITCH_STATEMENT(),
             BREAK_STATEMENT(),
             CONTINUE_STATEMENT(),
@@ -112,6 +119,141 @@ public StatementTree STATEMENT() {
         ));
   }
 
+  public IfStatementTree IF_STATEMENT() {
+    return b.<IfStatementTree>nonterminal(PHPLexicalGrammar.IF_STATEMENT)
+        .is(b.firstOf(STANDARD_IF_STATEMENT(), ALTERNATIVE_IF_STATEMENT()));
+  }
+
+  public IfStatementTree STANDARD_IF_STATEMENT() {
+    return b.<IfStatementTree>nonterminal(PHPLexicalGrammar.STANDARD_IF_STATEMENT)
+        .is(f.ifStatement(
+            b.token(PHPKeyword.IF),
+            //fixme (Lena) : should be PARENTHESIS_EXPRESSION
+            EXPRESSION(),
+            STATEMENT(),
+            b.zeroOrMore(ELSEIF_CLAUSE()),
+            b.optional(ELSE_CLAUSE())
+        ));
+  }
+
+  public IfStatementTree ALTERNATIVE_IF_STATEMENT() {
+    return b.<IfStatementTree>nonterminal(PHPLexicalGrammar.ALTERNATIVE_IF_STATEMENT)
+        .is(f.alternativeIfStatement(
+            b.token(PHPKeyword.IF),
+            //fixme (Lena) : should be PARENTHESIS_EXPRESSION
+            EXPRESSION(),
+            b.token(PHPPunctuator.COLON),
+            //fixme (Lena) : should be INNER_STATEMENT_LIST
+            b.zeroOrMore(STATEMENT()),
+            b.zeroOrMore(ALTERNATIVE_ELSEIF_CLAUSE()),
+            b.optional(ALTERNATIVE_ELSE_CLAUSE()),
+            b.token(PHPKeyword.ENDIF),
+            EOS()
+        ));
+  }
+
+  public ElseClauseTree ELSE_CLAUSE() {
+    return b.<ElseClauseTree>nonterminal(PHPLexicalGrammar.ELSE_CLAUSE)
+        .is(f.elseClause(b.token(PHPKeyword.ELSE), STATEMENT()));
+  }
+
+  public ElseifClauseTree ELSEIF_CLAUSE() {
+    return b.<ElseifClauseTree>nonterminal(PHPLexicalGrammar.ELSEIF_CLAUSE)
+        .is(f.elseifClause(
+            b.token(PHPKeyword.ELSEIF),
+            //fixme (Lena) : should be PARENTHESIS_EXPRESSION
+            EXPRESSION(),
+            STATEMENT()
+        ));
+  }
+
+  public ElseClauseTree ALTERNATIVE_ELSE_CLAUSE() {
+    return b.<ElseClauseTree>nonterminal(PHPLexicalGrammar.ALTERNATIVE_ELSE_CLAUSE)
+        .is(f.alternativeElseClause(
+            b.token(PHPKeyword.ELSE),
+            b.token(PHPPunctuator.COLON),
+            //fixme (Lena) : should be INNER_STATEMENT_LIST
+            b.zeroOrMore(STATEMENT())
+        ));
+  }
+
+  public ElseifClauseTree ALTERNATIVE_ELSEIF_CLAUSE() {
+    return b.<ElseifClauseTree>nonterminal(PHPLexicalGrammar.ALTERNATIVE_ELSEIF_CLAUSE)
+        .is(f.alternativeElseifClause(
+            b.token(PHPKeyword.ELSEIF),
+            //fixme (Lena) : should be PARENTHESIS_EXPRESSION
+            EXPRESSION(),
+            b.token(PHPPunctuator.COLON),
+            //fixme (Lena) : should be INNER_STATEMENT_LIST
+            b.zeroOrMore(STATEMENT())
+        ));
+  }
+
+  public ForStatementTree FOR_STATEMENT() {
+    return b.<ForStatementTree>nonterminal(PHPLexicalGrammar.FOR_STATEMENT)
+        .is(b.firstOf(
+            f.forStatement(
+                FOR_STATEMENT_HEADER(),
+                STATEMENT()
+            ),
+            f.forStatementAlternative(
+                FOR_STATEMENT_HEADER(),
+                b.token(PHPPunctuator.COLON),
+                //fixme (Lena) : should be INNER_STATEMENT_LIST
+                b.zeroOrMore(STATEMENT()),
+                b.token(PHPKeyword.ENDFOR),
+                EOS()
+            ))
+        );
+  }
+
+  public ForStatementHeader FOR_STATEMENT_HEADER() {
+    return b.<ForStatementHeader>nonterminal()
+        .is(f.forStatementHeader(
+            b.token(PHPKeyword.FOR), b.token(PHPPunctuator.LPARENTHESIS),
+            b.optional(FOR_EXPR()),
+            b.token(PHPPunctuator.SEMICOLON),
+            b.optional(FOR_EXPR()),
+            b.token(PHPPunctuator.SEMICOLON),
+            b.optional(FOR_EXPR()),
+            b.token(PHPPunctuator.RPARENTHESIS)
+        ));
+  }
+
+  public SeparatedList<ExpressionTree> FOR_EXPR() {
+    return b.<SeparatedList<ExpressionTree>>nonterminal(PHPLexicalGrammar.FOR_EXRR)
+        .is(f.forExpr(
+            EXPRESSION(),
+            b.zeroOrMore(f.newTuple12(b.token(PHPPunctuator.COMMA), EXPRESSION()))
+        ));
+  }
+
+  public ForEachStatementTree FOREACH_STATEMENT() {
+    return b.<ForEachStatementTree>nonterminal(PHPLexicalGrammar.FOREACH_STATEMENT)
+        .is(b.firstOf(
+            f.forEachStatement(FOREACH_STATEMENT_HEADER(), STATEMENT()),
+            f.forEachStatementAlternative(
+                FOREACH_STATEMENT_HEADER(),
+                b.token(PHPPunctuator.COLON),
+                //fixme (Lena) : should be INNER_STATEMENT_LIST
+                b.zeroOrMore(STATEMENT()),
+                b.token(PHPKeyword.ENDFOREACH),
+                EOS()
+            ))
+        );
+  }
+
+  public ForEachStatementHeader FOREACH_STATEMENT_HEADER() {
+    return b.<ForEachStatementHeader>nonterminal()
+        .is(f.forEachStatementHeader(
+            b.token(PHPKeyword.FOREACH), b.token(PHPPunctuator.LPARENTHESIS),
+            EXPRESSION(), b.token(PHPKeyword.AS),
+            // fixme (Lena) : both EXPRESSION() should be FOREACH_VARIABLE
+            b.optional(f.newTuple10(EXPRESSION(), b.token(PHPPunctuator.DOUBLEARROW))), EXPRESSION(),
+            b.token(PHPPunctuator.RPARENTHESIS)
+        ));
+  }
+
   public ThrowStatementTree THROW_STATEMENT() {
     return b.<ThrowStatementTree>nonterminal(PHPLexicalGrammar.THROW_STATEMENT)
         .is(f.throwStatement(b.token(PHPKeyword.THROW), EXPRESSION(), EOS()));
@@ -161,7 +303,12 @@ public CatchBlockTree CATCH_BLOCK() {
 
   public BlockTree BLOCK() {
     return b.<BlockTree>nonterminal(PHPLexicalGrammar.BLOCK)
-        .is(f.block(b.token(PHPPunctuator.LCURLYBRACE), b.zeroOrMore(STATEMENT()), b.token(PHPPunctuator.RCURLYBRACE)));
+        .is(f.block(
+            b.token(PHPPunctuator.LCURLYBRACE),
+            //fixme (Lena) : should be INNER_STATEMENT_LIST
+            b.zeroOrMore(STATEMENT()),
+            b.token(PHPPunctuator.RCURLYBRACE)
+        ));
   }
 
   public GotoStatementTree GOTO_STATEMENT() {
diff --git a/php-frontend/src/main/java/org/sonar/php/parser/PHPLexicalGrammar.java b/php-frontend/src/main/java/org/sonar/php/parser/PHPLexicalGrammar.java
index 1bebd17c4..8ef7e84c3 100644
--- a/php-frontend/src/main/java/org/sonar/php/parser/PHPLexicalGrammar.java
+++ b/php-frontend/src/main/java/org/sonar/php/parser/PHPLexicalGrammar.java
@@ -105,7 +105,7 @@
   ELSEIF_CLAUSE,
   ELSE_CLAUSE,
   ALTERNATIVE_IF_STATEMENT,
-  ALTERNATIVE_ELSEIF_LIST,
+  STANDARD_IF_STATEMENT,
   ALTERNATIVE_ELSEIF_CLAUSE,
   ALTERNATIVE_ELSE_CLAUSE,
   WHILE_STATEMENT,
@@ -113,10 +113,8 @@
   DO_WHILE_STATEMENT,
   ALTERNATIVE_DO_WHILE_STATEMENT,
   FOR_STATEMENT,
-  ALTERNATIVE_FOR_STATEMENT,
   FOR_EXRR,
   FOREACH_STATEMENT,
-  ALTERNATIVE_FOREACH_STATEMENT,
   FOREACH_EXPR,
   FOREACH_VARIABLE,
   SWITCH_STATEMENT,
diff --git a/php-frontend/src/main/java/org/sonar/php/parser/TreeFactory.java b/php-frontend/src/main/java/org/sonar/php/parser/TreeFactory.java
index 3ec91a47f..7d0263be3 100644
--- a/php-frontend/src/main/java/org/sonar/php/parser/TreeFactory.java
+++ b/php-frontend/src/main/java/org/sonar/php/parser/TreeFactory.java
@@ -30,9 +30,16 @@
 import org.sonar.php.tree.impl.statement.BreakStatementTreeImpl;
 import org.sonar.php.tree.impl.statement.CatchBlockTreeImpl;
 import org.sonar.php.tree.impl.statement.ContinueStatementTreeImpl;
+import org.sonar.php.tree.impl.statement.ElseClauseTreeImpl;
+import org.sonar.php.tree.impl.statement.ElseifClauseTreeImpl;
 import org.sonar.php.tree.impl.statement.EmptyStatementImpl;
 import org.sonar.php.tree.impl.statement.ExpressionStatementTreeImpl;
+import org.sonar.php.tree.impl.statement.ForEachStatementTreeImpl;
+import org.sonar.php.tree.impl.statement.ForEachStatementTreeImpl.ForEachStatementHeader;
+import org.sonar.php.tree.impl.statement.ForStatementTreeImpl;
+import org.sonar.php.tree.impl.statement.ForStatementTreeImpl.ForStatementHeader;
 import org.sonar.php.tree.impl.statement.GotoStatementTreeImpl;
+import org.sonar.php.tree.impl.statement.IfStatementTreeImpl;
 import org.sonar.php.tree.impl.statement.LabelTreeImpl;
 import org.sonar.php.tree.impl.statement.ReturnStatementTreeImpl;
 import org.sonar.php.tree.impl.statement.ThrowStatementTreeImpl;
@@ -45,9 +52,14 @@
 import org.sonar.plugins.php.api.tree.statement.BreakStatementTree;
 import org.sonar.plugins.php.api.tree.statement.CatchBlockTree;
 import org.sonar.plugins.php.api.tree.statement.ContinueStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
 import org.sonar.plugins.php.api.tree.statement.EmptyStatementTree;
 import org.sonar.plugins.php.api.tree.statement.ExpressionStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForStatementTree;
 import org.sonar.plugins.php.api.tree.statement.GotoStatementTree;
+import org.sonar.plugins.php.api.tree.statement.IfStatementTree;
 import org.sonar.plugins.php.api.tree.statement.LabelTree;
 import org.sonar.plugins.php.api.tree.statement.ReturnStatementTree;
 import org.sonar.plugins.php.api.tree.statement.StatementTree;
@@ -56,6 +68,7 @@
 
 import javax.annotation.Nullable;
 import java.util.Collections;
+import java.util.LinkedList;
 import java.util.List;
 
 public class TreeFactory {
@@ -68,6 +81,14 @@
     }
   }
 
+  private <T extends Tree> SeparatedList<T> optionalSeparatedList(Optional<SeparatedList<T>> list) {
+    if (list.isPresent()) {
+      return list.get();
+    } else {
+      return new SeparatedList<>(new LinkedList<T>(), new LinkedList<InternalSyntaxToken>());
+    }
+  }
+
   /**
    * [ START ] Statement
    */
@@ -182,6 +203,143 @@ public ThrowStatementTree throwStatement(InternalSyntaxToken throwToken, Express
     return new ThrowStatementTreeImpl(throwToken, expression, eosToken);
   }
 
+  public ForEachStatementTree forEachStatement(ForEachStatementHeader header, StatementTree statement) {
+    return new ForEachStatementTreeImpl(header, statement);
+  }
+
+  public ForEachStatementTree forEachStatementAlternative(
+      ForEachStatementHeader header,
+      InternalSyntaxToken colonToken, Optional<List<StatementTree>> statements, InternalSyntaxToken endForEachToken, InternalSyntaxToken eosToken
+  ) {
+    return new ForEachStatementTreeImpl(header, colonToken, optionalList(statements), endForEachToken, eosToken);
+  }
+
+  public ForEachStatementHeader forEachStatementHeader(
+      InternalSyntaxToken forEachToken, InternalSyntaxToken openParenthesisToken,
+      ExpressionTree expression, InternalSyntaxToken asToken, Optional<Tuple<ExpressionTree, InternalSyntaxToken>> optionalKey, ExpressionTree value,
+      InternalSyntaxToken closeParenthesisToken
+  ) {
+    return new ForEachStatementHeader(
+        forEachToken, openParenthesisToken,
+        expression, asToken, getForEachKey(optionalKey), getForEachArrow(optionalKey), value,
+        closeParenthesisToken
+    );
+  }
+
+  @Nullable
+  private ExpressionTree getForEachKey(Optional<Tuple<ExpressionTree, InternalSyntaxToken>> optionalKey) {
+    if (optionalKey.isPresent()) {
+      return optionalKey.get().first();
+    } else {
+      return null;
+    }
+  }
+
+  @Nullable
+  private InternalSyntaxToken getForEachArrow(Optional<Tuple<ExpressionTree, InternalSyntaxToken>> optionalKey) {
+    if (optionalKey.isPresent()) {
+      return optionalKey.get().second();
+    } else {
+      return null;
+    }
+  }
+
+  public ForStatementHeader forStatementHeader(
+      InternalSyntaxToken forToken, InternalSyntaxToken lParenthesis,
+      Optional<SeparatedList<ExpressionTree>> init, InternalSyntaxToken semicolon1,
+      Optional<SeparatedList<ExpressionTree>> condition, InternalSyntaxToken semicolon2,
+      Optional<SeparatedList<ExpressionTree>> update, InternalSyntaxToken rParenthesis
+  ) {
+    return new ForStatementHeader(
+        forToken, lParenthesis,
+        optionalSeparatedList(init),
+        semicolon1,
+        optionalSeparatedList(condition),
+        semicolon2,
+        optionalSeparatedList(update),
+        rParenthesis
+    );
+  }
+
+  public ForStatementTree forStatement(ForStatementHeader forStatementHeader, StatementTree statement) {
+    return new ForStatementTreeImpl(forStatementHeader, statement);
+  }
+
+  public ForStatementTree forStatementAlternative(
+      ForStatementHeader forStatementHeader, InternalSyntaxToken colonToken,
+      Optional<List<StatementTree>> statements, InternalSyntaxToken endForToken, InternalSyntaxToken eos
+  ) {
+    return new ForStatementTreeImpl(forStatementHeader, colonToken, optionalList(statements), endForToken, eos);
+  }
+
+  public SeparatedList<ExpressionTree> forExpr(ExpressionTree expression, Optional<List<Tuple<InternalSyntaxToken, ExpressionTree>>> listOptional) {
+    ImmutableList.Builder<ExpressionTree> elements = ImmutableList.builder();
+    ImmutableList.Builder<InternalSyntaxToken> separators = ImmutableList.builder();
+
+    elements.add(expression);
+
+    if (listOptional.isPresent()) {
+      for (Tuple<InternalSyntaxToken, ExpressionTree> tuple : listOptional.get()) {
+        separators.add(tuple.first());
+        elements.add(tuple.second());
+      }
+    }
+
+    return new SeparatedList(elements.build(), separators.build());
+  }
+
+  public ElseClauseTree elseClause(InternalSyntaxToken elseToken, StatementTree statement) {
+    return new ElseClauseTreeImpl(elseToken, statement);
+  }
+
+  public IfStatementTree ifStatement(
+      InternalSyntaxToken ifToken, ExpressionTree expression, StatementTree statement,
+      Optional<List<ElseifClauseTree>> elseIfClauses, Optional<ElseClauseTree> elseClause
+  ) {
+    return new IfStatementTreeImpl(ifToken, expression, statement, optionalList(elseIfClauses), elseClause.orNull());
+  }
+
+  public ElseifClauseTree elseifClause(InternalSyntaxToken elseifToken, ExpressionTree condition, StatementTree statement) {
+    return new ElseifClauseTreeImpl(elseifToken, condition, statement);
+  }
+
+  public IfStatementTree alternativeIfStatement(
+      InternalSyntaxToken ifToken, ExpressionTree condition, InternalSyntaxToken colonToken,
+      Optional<List<StatementTree>> statements, Optional<List<ElseifClauseTree>> elseifClauses, Optional<ElseClauseTree> elseClause,
+      InternalSyntaxToken endIfToken, InternalSyntaxToken eosToken
+  ) {
+    return new IfStatementTreeImpl(
+        ifToken,
+        condition,
+        colonToken,
+        optionalList(statements),
+        optionalList(elseifClauses),
+        elseClause.orNull(),
+        endIfToken,
+        eosToken
+    );
+  }
+
+  public ElseClauseTree alternativeElseClause(InternalSyntaxToken elseToken, InternalSyntaxToken colonToken, Optional<List<StatementTree>> statements) {
+    return new ElseClauseTreeImpl(
+        elseToken,
+        colonToken,
+        optionalList(statements)
+    );
+  }
+
+  public ElseifClauseTree alternativeElseifClause(
+      InternalSyntaxToken elseifToken, ExpressionTree condition, InternalSyntaxToken colonToken,
+      Optional<List<StatementTree>> statements
+  ) {
+    return new ElseifClauseTreeImpl(
+        elseifToken,
+        condition,
+        colonToken,
+        optionalList(statements)
+    );
+  }
+
   /**
    * [ END ] Statement
    */
diff --git a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/BlockTreeImpl.java b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/BlockTreeImpl.java
index 05ce6c61e..0aad72e14 100644
--- a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/BlockTreeImpl.java
+++ b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/BlockTreeImpl.java
@@ -75,6 +75,6 @@ public Kind getKind() {
 
   @Override
   public void accept(TreeVisitor visitor) {
-
+    visitor.visitBlock(this);
   }
 }
diff --git a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ElseClauseTreeImpl.java b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ElseClauseTreeImpl.java
new file mode 100644
index 000000000..44b24051a
--- /dev/null
+++ b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ElseClauseTreeImpl.java
@@ -0,0 +1,91 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import com.google.common.collect.Iterators;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.php.tree.impl.lexical.InternalSyntaxToken;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.visitors.TreeVisitor;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class ElseClauseTreeImpl extends PHPTree implements ElseClauseTree {
+
+  private final Kind KIND;
+
+  private final InternalSyntaxToken elseToken;
+  private final InternalSyntaxToken colonToken;
+  private final List<StatementTree> statement;
+
+  public ElseClauseTreeImpl(InternalSyntaxToken elseToken, StatementTree statement) {
+    this.KIND = Kind.ELSE_CLAUSE;
+    this.elseToken = elseToken;
+    this.statement = Collections.singletonList(statement);
+    this.colonToken = null;
+  }
+
+  public ElseClauseTreeImpl(InternalSyntaxToken elseToken, InternalSyntaxToken colonToken, List<StatementTree> statements) {
+    this.KIND = Kind.ALTERNATIVE_ELSE_CLAUSE;
+    this.elseToken = elseToken;
+    this.statement = statements;
+    this.colonToken = colonToken;
+  }
+
+  @Override
+  public SyntaxToken elseToken() {
+    return elseToken;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken colonToken() {
+    return colonToken;
+  }
+
+  @Override
+  public List<StatementTree> statement() {
+    return statement;
+  }
+
+  @Override
+  public Kind getKind() {
+    return KIND;
+  }
+
+  @Override
+  public Iterator<Tree> childrenIterator() {
+    return Iterators.concat(
+        Iterators.forArray(elseToken, colonToken),
+        statement.iterator()
+    );
+  }
+
+  @Override
+  public void accept(TreeVisitor visitor) {
+    visitor.visitElseClause(this);
+  }
+}
diff --git a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ElseifClauseTreeImpl.java b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ElseifClauseTreeImpl.java
new file mode 100644
index 000000000..db62903ad
--- /dev/null
+++ b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ElseifClauseTreeImpl.java
@@ -0,0 +1,104 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import com.google.common.collect.Iterators;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.php.tree.impl.lexical.InternalSyntaxToken;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.visitors.TreeVisitor;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class ElseifClauseTreeImpl extends PHPTree implements ElseifClauseTree {
+
+  private final Kind KIND;
+
+  private final InternalSyntaxToken elseifToken;
+  private final ExpressionTree condition;
+  private final InternalSyntaxToken colonToken;
+  private final List<StatementTree> statement;
+
+  public ElseifClauseTreeImpl(InternalSyntaxToken elseifToken, ExpressionTree condition, StatementTree statement) {
+    this.KIND = Kind.ELSEIF_CLAUSE;
+
+    this.elseifToken = elseifToken;
+    this.condition = condition;
+    this.statement = Collections.singletonList(statement);
+
+    this.colonToken = null;
+  }
+
+  public ElseifClauseTreeImpl(InternalSyntaxToken elseifToken, ExpressionTree condition, InternalSyntaxToken colonToken, List<StatementTree> statements) {
+    this.KIND = Kind.ALTERNATIVE_ELSEIF_CLAUSE;
+
+    this.elseifToken = elseifToken;
+    this.condition = condition;
+    this.statement = statements;
+
+    this.colonToken = colonToken;
+  }
+
+  @Override
+  public SyntaxToken elseifToken() {
+    return elseifToken;
+  }
+
+  @Override
+  public ExpressionTree condition() {
+    return condition;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken colonToken() {
+    return colonToken;
+  }
+
+  @Override
+  public List<StatementTree> statement() {
+    return statement;
+  }
+
+  @Override
+  public Kind getKind() {
+    return KIND;
+  }
+
+  @Override
+  public Iterator<Tree> childrenIterator() {
+    return Iterators.concat(
+        Iterators.forArray(elseifToken, condition, colonToken),
+        statement.iterator()
+    );
+  }
+
+  @Override
+  public void accept(TreeVisitor visitor) {
+    visitor.visitElseifClause(this);
+  }
+}
diff --git a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ForEachStatementTreeImpl.java b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ForEachStatementTreeImpl.java
new file mode 100644
index 000000000..773b4f8c1
--- /dev/null
+++ b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ForEachStatementTreeImpl.java
@@ -0,0 +1,228 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import com.google.common.collect.Iterators;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.php.tree.impl.lexical.InternalSyntaxToken;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.visitors.TreeVisitor;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class ForEachStatementTreeImpl extends PHPTree implements ForEachStatementTree {
+
+  private final Kind KIND;
+
+  private final ForEachStatementHeader header;
+  private final InternalSyntaxToken colonToken;
+  private final List<StatementTree> statement;
+  private final InternalSyntaxToken endforeachToken;
+  private final InternalSyntaxToken eosToken;
+
+  public ForEachStatementTreeImpl(ForEachStatementHeader header, StatementTree statement) {
+    this(Kind.FOREACH_STATEMENT, header, null, Collections.singletonList(statement), null, null);
+  }
+
+  public ForEachStatementTreeImpl(
+      ForEachStatementHeader header, InternalSyntaxToken colonToken,
+      List<StatementTree> statements, InternalSyntaxToken endForEachToken, InternalSyntaxToken eosToken
+  ) {
+    this(Kind.ALTERNATIVE_FOREACH_STATEMENT, header, colonToken, statements, endForEachToken, eosToken);
+  }
+
+  private ForEachStatementTreeImpl(
+      Kind kind,
+      ForEachStatementHeader header, @Nullable InternalSyntaxToken colonToken,
+      List<StatementTree> statements, @Nullable InternalSyntaxToken endForEachToken, @Nullable InternalSyntaxToken eosToken
+  ) {
+    this.header = header;
+    this.colonToken = colonToken;
+    this.statement = statements;
+    this.endforeachToken = endForEachToken;
+    this.eosToken = eosToken;
+
+    this.KIND = kind;
+  }
+
+  @Override
+  public SyntaxToken foreachToken() {
+    return header.foreachToken();
+  }
+
+  @Override
+  public SyntaxToken openParenthesisToken() {
+    return header.openParenthesisToken();
+  }
+
+  @Override
+  public ExpressionTree expression() {
+    return header.expression();
+  }
+
+  @Override
+  public SyntaxToken asToken() {
+    return header.asToken();
+  }
+
+  @Nullable
+  @Override
+  public ExpressionTree key() {
+    return header.key();
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken doubleArrowToken() {
+    return header.doubleArrowToken();
+  }
+
+  @Override
+  public ExpressionTree value() {
+    return header.value();
+  }
+
+  @Override
+  public SyntaxToken closeParenthesisToken() {
+    return header.closeParenthesisToken();
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken colonToken() {
+    return colonToken;
+  }
+
+  @Override
+  public List<StatementTree> statement() {
+    return statement;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken endforeachToken() {
+    return endforeachToken;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken eosToken() {
+    return eosToken;
+  }
+
+  @Override
+  public Kind getKind() {
+    return KIND;
+  }
+
+  @Override
+  public Iterator<Tree> childrenIterator() {
+    return Iterators.concat(
+        Iterators.forArray(foreachToken(), openParenthesisToken(), expression(), asToken(), key(), doubleArrowToken(), value(), closeParenthesisToken(), colonToken),
+        statement.iterator(),
+        Iterators.forArray(endforeachToken, eosToken));
+  }
+
+  @Override
+  public void accept(TreeVisitor visitor) {
+    visitor.visitForEachStatement(this);
+  }
+
+  /**
+   * Utility class hidden from API (it's mainly created to avoid duplication in grammar)
+   */
+  public static class ForEachStatementHeader implements Tree {
+
+    private final InternalSyntaxToken foreachToken;
+    private final InternalSyntaxToken openParenthesisToken;
+    private final ExpressionTree expression;
+    private final InternalSyntaxToken asToken;
+    private final ExpressionTree key;
+    private final InternalSyntaxToken doubleArrowToken;
+    private final ExpressionTree value;
+    private final InternalSyntaxToken closeParenthesisToken;
+
+    public ForEachStatementHeader(
+        InternalSyntaxToken foreachToken, InternalSyntaxToken openParenthesisToken,
+        ExpressionTree expression, InternalSyntaxToken asToken, ExpressionTree key, InternalSyntaxToken doubleArrowToken, ExpressionTree value,
+        InternalSyntaxToken closeParenthesisToken
+    ) {
+      this.foreachToken = foreachToken;
+      this.openParenthesisToken = openParenthesisToken;
+      this.expression = expression;
+      this.asToken = asToken;
+      this.key = key;
+      this.doubleArrowToken = doubleArrowToken;
+      this.value = value;
+      this.closeParenthesisToken = closeParenthesisToken;
+    }
+
+    @Override
+    public boolean is(Kind... kind) {
+      return false;
+    }
+
+    @Override
+    public void accept(TreeVisitor visitor) {
+      throw new IllegalStateException("class ForEachStatementHeader is used only internally for building the tree and should not be used to tree visiting.");
+    }
+
+    public InternalSyntaxToken foreachToken() {
+      return foreachToken;
+    }
+
+    public InternalSyntaxToken openParenthesisToken() {
+      return openParenthesisToken;
+    }
+
+    public ExpressionTree expression() {
+      return expression;
+    }
+
+    public InternalSyntaxToken asToken() {
+      return asToken;
+    }
+
+    @Nullable
+    public ExpressionTree key() {
+      return key;
+    }
+
+    @Nullable
+    public InternalSyntaxToken doubleArrowToken() {
+      return doubleArrowToken;
+    }
+
+    public ExpressionTree value() {
+      return value;
+    }
+
+    public InternalSyntaxToken closeParenthesisToken() {
+      return closeParenthesisToken;
+    }
+  }
+}
diff --git a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ForStatementTreeImpl.java b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ForStatementTreeImpl.java
new file mode 100644
index 000000000..d1db12698
--- /dev/null
+++ b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/ForStatementTreeImpl.java
@@ -0,0 +1,231 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import com.google.common.base.Functions;
+import com.google.common.collect.Iterators;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.php.tree.impl.SeparatedList;
+import org.sonar.php.tree.impl.lexical.InternalSyntaxToken;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.ForStatementTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.visitors.TreeVisitor;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class ForStatementTreeImpl extends PHPTree implements ForStatementTree {
+
+  private final Kind KIND;
+
+  private final ForStatementHeader header;
+  private final InternalSyntaxToken colonToken;
+  private final List<StatementTree> statement;
+  private final InternalSyntaxToken endForToken;
+  private final InternalSyntaxToken eosToken;
+
+  private ForStatementTreeImpl(
+      Kind kind,
+      ForStatementHeader header,
+      @Nullable InternalSyntaxToken colonToken, List<StatementTree> statement,
+      @Nullable InternalSyntaxToken endForToken, @Nullable InternalSyntaxToken eosToken
+  ) {
+    this.header = header;
+    this.colonToken = colonToken;
+    this.endForToken = endForToken;
+    this.statement = statement;
+    this.eosToken = eosToken;
+
+    this.KIND = kind;
+  }
+
+  public ForStatementTreeImpl(ForStatementHeader header, InternalSyntaxToken colonToken, List<StatementTree> statement, InternalSyntaxToken endForToken, InternalSyntaxToken eosToken) {
+    this(Kind.ALTERNATIVE_FOR_STATEMENT, header, colonToken, statement, endForToken, eosToken);
+  }
+
+  public ForStatementTreeImpl(ForStatementHeader header, StatementTree statement) {
+    this(Kind.FOR_STATEMENT, header, null, Collections.singletonList(statement), null,  null);
+  }
+
+  @Override
+  public SyntaxToken forToken() {
+    return header.forToken();
+  }
+
+  @Override
+  public SyntaxToken openParenthesisToken() {
+    return header.openParenthesisToken();
+  }
+
+  @Override
+  public SeparatedList<ExpressionTree> init() {
+    return header.init();
+  }
+
+  @Override
+  public SyntaxToken firstSemicolonToken() {
+    return header.firstSemicolonToken();
+  }
+
+  @Override
+  public SeparatedList<ExpressionTree> condition() {
+    return header.condition();
+  }
+
+  @Override
+  public SyntaxToken secondSemicolonToken() {
+    return header.secondSemicolonToken();
+  }
+
+  @Override
+  public SeparatedList<ExpressionTree> update() {
+    return header.update();
+  }
+
+  @Override
+  public SyntaxToken closeParenthesisToken() {
+    return header.closeParenthesisToken();
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken colonToken() {
+    return colonToken;
+  }
+
+  @Override
+  public List<StatementTree> statement() {
+    return statement;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken endforToken() {
+    return endForToken;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken eosToken() {
+    return eosToken;
+  }
+
+  @Override
+  public Kind getKind() {
+    return KIND;
+  }
+
+  @Override
+  public Iterator<Tree> childrenIterator() {
+    return Iterators.concat(
+        Iterators.forArray(forToken(), openParenthesisToken()),
+        init().elementsAndSeparators(Functions.<ExpressionTree>identity()),
+        Iterators.singletonIterator(firstSemicolonToken()),
+        condition().elementsAndSeparators(Functions.<ExpressionTree>identity()),
+        Iterators.singletonIterator(secondSemicolonToken()),
+        update().elementsAndSeparators(Functions.<ExpressionTree>identity()),
+        Iterators.forArray(closeParenthesisToken(), colonToken),
+        statement.iterator(),
+        Iterators.forArray(endForToken, eosToken));
+  }
+
+  @Override
+  public void accept(TreeVisitor visitor) {
+    visitor.visitForStatement(this);
+  }
+
+  /**
+   * Utility class hidden from API (it's mainly created to avoid duplication in grammar)
+   */
+  public static class ForStatementHeader implements Tree {
+
+    private final InternalSyntaxToken forToken;
+    private final InternalSyntaxToken openParenthesisToken;
+    private final SeparatedList<ExpressionTree> init;
+    private final InternalSyntaxToken firstSemicolonToken;
+    private final SeparatedList<ExpressionTree> condition;
+    private final InternalSyntaxToken secondSemicolonToken;
+    private final SeparatedList<ExpressionTree> update;
+    private final InternalSyntaxToken closeParenthesisToken;
+
+    public ForStatementHeader(
+        InternalSyntaxToken forToken, InternalSyntaxToken openParenthesisToken,
+        SeparatedList<ExpressionTree> init, InternalSyntaxToken firstSemicolonToken,
+        SeparatedList<ExpressionTree> condition, InternalSyntaxToken secondSemicolonToken,
+        SeparatedList<ExpressionTree> update, InternalSyntaxToken closeParenthesisToken
+    ) {
+      this.forToken = forToken;
+      this.openParenthesisToken = openParenthesisToken;
+      this.init = init;
+      this.firstSemicolonToken = firstSemicolonToken;
+      this.condition = condition;
+      this.secondSemicolonToken = secondSemicolonToken;
+      this.update = update;
+      this.closeParenthesisToken = closeParenthesisToken;
+    }
+
+    @Override
+    public boolean is(Kind... kind) {
+      return false;
+    }
+
+    @Override
+    public void accept(TreeVisitor visitor) {
+      throw new IllegalStateException("class ForStatementHeader is used only internally for building the tree and should not be used to tree visiting.");
+    }
+
+    public InternalSyntaxToken forToken() {
+      return forToken;
+    }
+
+    public InternalSyntaxToken openParenthesisToken() {
+      return openParenthesisToken;
+    }
+
+    public SeparatedList<ExpressionTree> init() {
+      return init;
+    }
+
+    public InternalSyntaxToken firstSemicolonToken() {
+      return firstSemicolonToken;
+    }
+
+    public SeparatedList<ExpressionTree> condition() {
+      return condition;
+    }
+
+    public InternalSyntaxToken secondSemicolonToken() {
+      return secondSemicolonToken;
+    }
+
+    public SeparatedList<ExpressionTree> update() {
+      return update;
+    }
+
+    public InternalSyntaxToken closeParenthesisToken() {
+      return closeParenthesisToken;
+    }
+  }
+}
diff --git a/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/IfStatementTreeImpl.java b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/IfStatementTreeImpl.java
new file mode 100644
index 000000000..c36124aea
--- /dev/null
+++ b/php-frontend/src/main/java/org/sonar/php/tree/impl/statement/IfStatementTreeImpl.java
@@ -0,0 +1,150 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import com.google.common.collect.Iterators;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.php.tree.impl.lexical.InternalSyntaxToken;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
+import org.sonar.plugins.php.api.tree.statement.IfStatementTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.visitors.TreeVisitor;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class IfStatementTreeImpl extends PHPTree implements IfStatementTree {
+
+  private final Kind KIND;
+
+  private final InternalSyntaxToken ifToken;
+  private final ExpressionTree condition;
+  private final InternalSyntaxToken colonToken;
+  private final List<StatementTree> statement;
+  private final List<ElseifClauseTree> elseifClauses;
+  private final ElseClauseTree elseClause;
+  private final InternalSyntaxToken endifToken;
+  private final InternalSyntaxToken eosToken;
+
+  public IfStatementTreeImpl(
+      InternalSyntaxToken ifToken, ExpressionTree condition, StatementTree statement,
+      List<ElseifClauseTree> elseifClauses, ElseClauseTree elseClause
+  ) {
+    KIND = Kind.IF_STATEMENT;
+
+    this.ifToken = ifToken;
+    this.condition = condition;
+    this.statement = Collections.singletonList(statement);
+    this.elseifClauses = elseifClauses;
+    this.elseClause = elseClause;
+
+    this.colonToken = null;
+    this.endifToken = null;
+    this.eosToken = null;
+  }
+
+  public IfStatementTreeImpl(
+      InternalSyntaxToken ifToken, ExpressionTree condition, InternalSyntaxToken colonToken,
+      List<StatementTree> statements, List<ElseifClauseTree> elseifClauses, ElseClauseTree elseClause,
+      InternalSyntaxToken endifToken, InternalSyntaxToken eosToken
+  ) {
+    KIND = Kind.ALTRNATIVE_IF_STATEMENT;
+
+    this.ifToken = ifToken;
+    this.condition = condition;
+    this.statement = statements;
+    this.elseifClauses = elseifClauses;
+    this.elseClause = elseClause;
+
+    this.colonToken = colonToken;
+    this.endifToken = endifToken;
+    this.eosToken = eosToken;
+  }
+
+  @Override
+  public SyntaxToken ifToken() {
+    return ifToken;
+  }
+
+  @Override
+  public ExpressionTree condition() {
+    return condition;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken colonToken() {
+    return colonToken;
+  }
+
+  @Override
+  public List<StatementTree> statement() {
+    return statement;
+  }
+
+  @Override
+  public List<ElseifClauseTree> elseifClauses() {
+    return elseifClauses;
+  }
+
+  @Nullable
+  @Override
+  public ElseClauseTree elseClause() {
+    return elseClause;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken endifToken() {
+    return endifToken;
+  }
+
+  @Nullable
+  @Override
+  public SyntaxToken eosToken() {
+    return eosToken;
+  }
+
+  @Override
+  public Kind getKind() {
+    return KIND;
+  }
+
+  @Override
+  public Iterator<Tree> childrenIterator() {
+    return Iterators.concat(
+        Iterators.forArray(ifToken, condition, colonToken),
+        statement.iterator(),
+        elseifClauses.iterator(),
+        Iterators.forArray(elseClause, endifToken, eosToken)
+    );
+  }
+
+  @Override
+  public void accept(TreeVisitor visitor) {
+    visitor.visitIfStatement(this);
+  }
+}
diff --git a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseClauseTree.java b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseClauseTree.java
index 5d5abb0ba..a3d0d66ac 100644
--- a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseClauseTree.java
+++ b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseClauseTree.java
@@ -28,12 +28,12 @@
 @Beta
 public interface ElseClauseTree extends StatementTree {
 
-  SyntaxToken elseKeyword();
+  SyntaxToken elseToken();
 
   @Nullable
   SyntaxToken colonToken();
 
-  List<StatementTree> statements();
+  List<StatementTree> statement();
 
 }
 
diff --git a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseifClauseTree.java b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseifClauseTree.java
index 5919d98e3..a26afe429 100644
--- a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseifClauseTree.java
+++ b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ElseifClauseTree.java
@@ -20,7 +20,7 @@
 package org.sonar.plugins.php.api.tree.statement;
 
 import com.google.common.annotations.Beta;
-import org.sonar.plugins.php.api.tree.expression.ParenthesisedExpressionTree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
 import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
 
 import javax.annotation.Nullable;
@@ -31,12 +31,13 @@
 
   SyntaxToken elseifToken();
 
-  ParenthesisedExpressionTree condition();
+  // fixme (Lena) : should be ParenthesisedExpressionTree
+  ExpressionTree condition();
 
   @Nullable
   SyntaxToken colonToken();
 
-  List<StatementTree> statements();
+  List<StatementTree> statement();
 
 }
 
diff --git a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ForStatementTree.java b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ForStatementTree.java
index b9e53efc6..2e0f45766 100644
--- a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ForStatementTree.java
+++ b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/ForStatementTree.java
@@ -35,19 +35,19 @@
 
   SyntaxToken forToken();
 
-  SyntaxToken openParenthesis();
+  SyntaxToken openParenthesisToken();
 
   SeparatedList<ExpressionTree> init();
 
-  SyntaxToken firstSemicolon();
+  SyntaxToken firstSemicolonToken();
 
   SeparatedList<ExpressionTree> condition();
 
-  SyntaxToken secondSemicolon();
+  SyntaxToken secondSemicolonToken();
 
   SeparatedList<ExpressionTree> update();
 
-  SyntaxToken closeParenthesis();
+  SyntaxToken closeParenthesisToken();
 
   @Nullable
   SyntaxToken colonToken();
@@ -55,7 +55,7 @@
   List<StatementTree> statement();
 
   @Nullable
-  SyntaxToken endForToken();
+  SyntaxToken endforToken();
 
   @Nullable
   SyntaxToken eosToken();
diff --git a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/IfStatementTree.java b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/IfStatementTree.java
index f0501c570..536699c1b 100644
--- a/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/IfStatementTree.java
+++ b/php-frontend/src/main/java/org/sonar/plugins/php/api/tree/statement/IfStatementTree.java
@@ -20,8 +20,7 @@
 package org.sonar.plugins.php.api.tree.statement;
 
 import com.google.common.annotations.Beta;
-import org.sonar.plugins.php.api.tree.Tree;
-import org.sonar.plugins.php.api.tree.expression.ParenthesisedExpressionTree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
 import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
 
 import javax.annotation.Nullable;
@@ -35,21 +34,21 @@
 
   SyntaxToken ifToken();
 
-  ParenthesisedExpressionTree condition();
+  // fixme (Lena) : should be ParenthesisedExpressionTree
+  ExpressionTree condition();
 
   @Nullable
   SyntaxToken colonToken();
 
-  List<Tree> statements();
+  List<StatementTree> statement();
 
-  @Nullable
   List<ElseifClauseTree> elseifClauses();
 
   @Nullable
   ElseClauseTree elseClause();
 
   @Nullable
-  SyntaxToken endIfToken();
+  SyntaxToken endifToken();
 
   @Nullable
   SyntaxToken eosToken();
diff --git a/php-frontend/src/main/java/org/sonar/plugins/php/api/visitors/TreeVisitor.java b/php-frontend/src/main/java/org/sonar/plugins/php/api/visitors/TreeVisitor.java
index 5020ba4b4..2699829b3 100644
--- a/php-frontend/src/main/java/org/sonar/plugins/php/api/visitors/TreeVisitor.java
+++ b/php-frontend/src/main/java/org/sonar/plugins/php/api/visitors/TreeVisitor.java
@@ -23,12 +23,18 @@
 import org.sonar.php.tree.impl.expression.IdentifierTreeImpl;
 import org.sonar.plugins.php.api.tree.declaration.NamespaceNameTree;
 import org.sonar.plugins.php.api.tree.expression.VariableIdentifierTree;
+import org.sonar.plugins.php.api.tree.statement.BlockTree;
 import org.sonar.plugins.php.api.tree.statement.BreakStatementTree;
 import org.sonar.plugins.php.api.tree.statement.CatchBlockTree;
 import org.sonar.plugins.php.api.tree.statement.ContinueStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
 import org.sonar.plugins.php.api.tree.statement.EmptyStatementTree;
 import org.sonar.plugins.php.api.tree.statement.ExpressionStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForStatementTree;
 import org.sonar.plugins.php.api.tree.statement.GotoStatementTree;
+import org.sonar.plugins.php.api.tree.statement.IfStatementTree;
 import org.sonar.plugins.php.api.tree.statement.LabelTree;
 import org.sonar.plugins.php.api.tree.statement.ReturnStatementTree;
 import org.sonar.plugins.php.api.tree.statement.ThrowStatementTree;
@@ -52,6 +58,18 @@
    * [ START ] Statement
    */
 
+  void visitElseifClause(ElseifClauseTree tree);
+
+  void visitIfStatement(IfStatementTree tree);
+
+  void visitElseClause(ElseClauseTree tree);
+
+  void visitBlock(BlockTree tree);
+
+  void visitForStatement(ForStatementTree tree);
+
+  void visitForEachStatement(ForEachStatementTree tree);
+
   void visitThrowStatement(ThrowStatementTree tree);
 
   void visitEmptyStatement(EmptyStatementTree tree);
diff --git a/php-frontend/src/test/java/org/sonar/php/parser/statement/ForExprTest.java b/php-frontend/src/test/java/org/sonar/php/parser/statement/ForExprTest.java
deleted file mode 100644
index 1af6e230c..000000000
--- a/php-frontend/src/test/java/org/sonar/php/parser/statement/ForExprTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * SonarQube PHP Plugin
- * Copyright (C) 2010 SonarSource and Akram Ben Aissi
- * sonarqube@googlegroups.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 3 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
- */
-package org.sonar.php.parser.statement;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.sonar.php.parser.PHPGrammar;
-import org.sonar.php.parser.RuleTest;
-
-public class ForExprTest extends RuleTest {
-
-  @Before
-  public void setUp() {
-    setTestedRule(PHPGrammar.FOR_EXRR);
-  }
-
-  @Test
-  public void test() {
-
-    matches("$i = 1");
-    matches("$i = 1, $j = 1");
-  }
-}
diff --git a/php-frontend/src/test/java/org/sonar/php/parser/statement/ForStatementTest.java b/php-frontend/src/test/java/org/sonar/php/parser/statement/ForStatementTest.java
index 3378fd5fa..e581ec62f 100644
--- a/php-frontend/src/test/java/org/sonar/php/parser/statement/ForStatementTest.java
+++ b/php-frontend/src/test/java/org/sonar/php/parser/statement/ForStatementTest.java
@@ -19,24 +19,24 @@
  */
 package org.sonar.php.parser.statement;
 
-import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.php.parser.PHPLexicalGrammar;
 import org.sonar.php.parser.RuleTest;
 
-public class ForStatementTest extends RuleTest {
+import static org.sonar.php.utils.Assertions.assertThat;
 
-  @Before
-  public void setUp() {
-    setTestedRule(PHPGrammar.FOR_STATEMENT);
-  }
+public class ForStatementTest extends RuleTest {
 
   @Test
   public void test() {
-
-    matches("for ($i = 1; $i <= a; $i++) {}");
-    matches("for ($i = 1; ; $i++) {}");
-    matches("for (; ; ) {}");
-    matches("for (; ; ): endfor;");
+    assertThat(PHPLexicalGrammar.FOR_STATEMENT)
+        //todo (Lena) improve these tests with more adequate expressions
+      .matches("for ($a; $b; $c) {}")
+      .matches("for ($a1, $a2;  $b1, $b2;  $c1, $c2) {}")
+      .matches("for ($a; ; $c) {}")
+      .matches("for (; ; ) {}")
+      .matches("for (; ; ): {} {} endfor;")
+      .matches("for (; ; ): {} endfor;")
+      .matches("for (; ; ): endfor;");
   }
 }
diff --git a/php-frontend/src/test/java/org/sonar/php/parser/statement/ForeachStatementTest.java b/php-frontend/src/test/java/org/sonar/php/parser/statement/ForeachStatementTest.java
index 6149a3a1a..caabf7ccd 100644
--- a/php-frontend/src/test/java/org/sonar/php/parser/statement/ForeachStatementTest.java
+++ b/php-frontend/src/test/java/org/sonar/php/parser/statement/ForeachStatementTest.java
@@ -19,23 +19,25 @@
  */
 package org.sonar.php.parser.statement;
 
-import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.parser.PHPGrammar;
-import org.sonar.php.parser.RuleTest;
+import org.sonar.php.parser.PHPLexicalGrammar;
 
-public class ForeachStatementTest extends RuleTest {
+import static org.sonar.php.utils.Assertions.assertThat;
 
-  @Before
-  public void setUp() {
-    setTestedRule(PHPGrammar.FOREACH_STATEMENT);
-  }
+public class ForeachStatementTest {
 
   @Test
   public void test() {
+    assertThat(PHPLexicalGrammar.FOREACH_STATEMENT)
+      .matches("foreach ($a as $b) {}")
+      .matches("foreach ($a as $b) : {} endforeach ;")
+      .matches("foreach ($a as $b) : {} {} endforeach ;")
+      .matches("foreach ($a as $b) ;")
+      .matches("foreach ($a as $b => $c) {}")
+      .matches("foreach ($a as $b => $c) : {} endforeach ;")
 
-    matches("foreach ($a as $b) {}");
-    matches("foreach ($a as $b) ;");
-    matches("foreach ($a as $b => $c) {}");
+      .notMatches("foreach ($a as $b) : {} endfor ;")
+      .notMatches("foreach ($a as $b) : {} endforeach")
+      .notMatches("foreach ($a as $b) {} {}");
   }
 }
diff --git a/php-frontend/src/test/java/org/sonar/php/parser/statement/IfStatementTest.java b/php-frontend/src/test/java/org/sonar/php/parser/statement/IfStatementTest.java
index e38aef066..b87193515 100644
--- a/php-frontend/src/test/java/org/sonar/php/parser/statement/IfStatementTest.java
+++ b/php-frontend/src/test/java/org/sonar/php/parser/statement/IfStatementTest.java
@@ -19,30 +19,38 @@
  */
 package org.sonar.php.parser.statement;
 
-import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.parser.PHPGrammar;
-import org.sonar.php.parser.RuleTest;
+import org.sonar.php.parser.PHPLexicalGrammar;
 
-public class IfStatementTest extends RuleTest {
+import static org.sonar.php.utils.Assertions.assertThat;
 
-  @Before
-  public void setUp() {
-    setTestedRule(PHPGrammar.IF_STATEMENT);
-  }
+public class IfStatementTest {
 
   @Test
   public void test() {
+    assertThat(PHPLexicalGrammar.IF_STATEMENT)
+        // fixme (Lena) : replace all conditions by parenthesised expressions
+      .matches("if $a {}")
+      .matches("if $a {} elseif $a {}")
+      .matches("if $a {} elseif $a {} elseif $a {}")
+      .matches("if $a {} elseif $a {} else {}")
+      .matches("if $a {} else {}")
+
+      .matches("if $a : endif;")
+      .matches("if $a : elseif $a: endif;")
+      .matches("if $a : elseif $a: else: endif;")
+      .matches("if $a : else: endif;")
+
+
+      .notMatches("if $a : {}")
 
-    matches("if ($a) {}");
-    matches("if ($a) {} elseif ($a) {}");
-    matches("if ($a) {} elseif ($a) {} else {}");
-    matches("if ($a) {} else {}");
-    matches("if ($a) ; else ;");
+    ;
   }
 
   @Test
   public void realLife() throws Exception {
-    matches("if (\"#$a\") {\n $x = ''; }");
+    assertThat(PHPLexicalGrammar.IF_STATEMENT)
+        //fixme (Lena): should match
+      .notMatches("if (\"#$a\") {\n $x = ''; }");
   }
 }
diff --git a/php-frontend/src/test/java/org/sonar/php/parser/statement/NewIfStatementTest.java b/php-frontend/src/test/java/org/sonar/php/parser/statement/NewIfStatementTest.java
deleted file mode 100644
index 85a29aeba..000000000
--- a/php-frontend/src/test/java/org/sonar/php/parser/statement/NewIfStatementTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * SonarQube PHP Plugin
- * Copyright (C) 2010 SonarSource and Akram Ben Aissi
- * sonarqube@googlegroups.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 3 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
- */
-package org.sonar.php.parser.statement;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.sonar.php.parser.PHPGrammar;
-import org.sonar.php.parser.RuleTest;
-
-public class NewIfStatementTest extends RuleTest {
-
-  @Before
-  public void setUp() {
-    setTestedRule(PHPGrammar.ALTERNATIVE_IF_STATEMENT);
-  }
-
-  @Test
-  public void test() {
-
-    matches("if ($a): endif;");
-    matches("if ($a): elseif (a): endif;");
-    matches("if ($a): elseif (a): else: endif;");
-    matches("if ($a): else: endif;");
-  }
-}
diff --git a/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ExpressionStatementTreeTest.java b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ExpressionStatementTreeTest.java
index 7023a4f4d..ee4826001 100644
--- a/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ExpressionStatementTreeTest.java
+++ b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ExpressionStatementTreeTest.java
@@ -22,12 +22,20 @@
 import org.junit.Test;
 import org.sonar.php.PHPTreeModelTest;
 import org.sonar.php.parser.PHPLexicalGrammar;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.statement.ExpressionStatementTree;
+
+import static org.fest.assertions.Assertions.assertThat;
 
 public class ExpressionStatementTreeTest extends PHPTreeModelTest {
 
   @Test
   public void test() throws Exception {
-    parse("$a;", PHPLexicalGrammar.EXPRESSION_STATEMENT);
+    ExpressionStatementTree tree = parse("$a;", PHPLexicalGrammar.EXPRESSION_STATEMENT);
+
+    assertThat(tree.is(Kind.EXPRESSION_STATEMENT)).isTrue();
+    assertThat(tree.expression().is(Kind.VARIABLE_IDENTIFIER)).isTrue();
+    assertThat(tree.eosToken().text()).isEqualTo(";");
   }
 
 }
diff --git a/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ForEachStatementTreeTest.java b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ForEachStatementTreeTest.java
new file mode 100644
index 000000000..312d6c22a
--- /dev/null
+++ b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ForEachStatementTreeTest.java
@@ -0,0 +1,70 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import org.junit.Test;
+import org.sonar.php.PHPTreeModelTest;
+import org.sonar.php.parser.PHPLexicalGrammar;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public class ForEachStatementTreeTest extends PHPTreeModelTest {
+
+  @Test
+  public void standard_syntax() throws Exception {
+    ForEachStatementTree tree = parse("foreach ($a as $b) {}", PHPLexicalGrammar.FOREACH_STATEMENT);
+
+    assertThat(tree.is(Kind.FOREACH_STATEMENT)).isTrue();
+    assertThat(tree.expression().is(Kind.VARIABLE_IDENTIFIER)).isTrue();
+    assertThat(tree.value().is(Kind.VARIABLE_IDENTIFIER)).isTrue();
+    assertThat(tree.key()).isNull();
+    assertThat(tree.doubleArrowToken()).isNull();
+    assertThat(tree.colonToken()).isNull();
+    assertThat(tree.endforeachToken()).isNull();
+    assertThat(tree.eosToken()).isNull();
+    assertThat(tree.statement()).hasSize(1);
+    assertThat(tree.statement().get(0).is(Kind.BLOCK)).isTrue();
+  }
+
+  @Test
+  public void alternative_syntax() throws Exception {
+    ForEachStatementTree tree = parse("foreach ($a as $b) : {} {} endforeach ;", PHPLexicalGrammar.FOREACH_STATEMENT);
+
+    assertThat(tree.is(Kind.ALTERNATIVE_FOREACH_STATEMENT)).isTrue();
+    assertThat(tree.expression().is(Kind.VARIABLE_IDENTIFIER)).isTrue();
+    assertThat(tree.value().is(Kind.VARIABLE_IDENTIFIER)).isTrue();
+    assertThat(tree.key()).isNull();
+    assertThat(tree.doubleArrowToken()).isNull();
+    assertThat(tree.colonToken().text()).isEqualTo(":");
+    assertThat(tree.endforeachToken().text()).isEqualTo("endforeach");
+    assertThat(tree.eosToken().text()).isEqualTo(";");
+    assertThat(tree.statement()).hasSize(2);
+  }
+
+  @Test
+  public void syntax_with_key() throws Exception {
+    ForEachStatementTree tree = parse("foreach ($a as $key => $b) {}", PHPLexicalGrammar.FOREACH_STATEMENT);
+    assertThat(tree.key()).isNotNull();
+    assertThat(tree.doubleArrowToken()).isNotNull();
+  }
+
+}
diff --git a/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ForStatementTreeTest.java b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ForStatementTreeTest.java
new file mode 100644
index 000000000..2783827a5
--- /dev/null
+++ b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/ForStatementTreeTest.java
@@ -0,0 +1,60 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import org.junit.Test;
+import org.sonar.php.PHPTreeModelTest;
+import org.sonar.php.parser.PHPLexicalGrammar;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.statement.ForStatementTree;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public class ForStatementTreeTest extends PHPTreeModelTest {
+
+  @Test
+  public void standard_syntax() throws Exception {
+    ForStatementTree tree = parse("for ($a; ; $c, $b) {}", PHPLexicalGrammar.FOR_STATEMENT);
+
+    assertThat(tree.is(Kind.FOR_STATEMENT)).isTrue();
+    assertThat(tree.init()).hasSize(1);
+    assertThat(tree.condition()).hasSize(0);
+    assertThat(tree.update()).hasSize(2);
+    assertThat(tree.colonToken()).isNull();
+    assertThat(tree.endforToken()).isNull();
+    assertThat(tree.eosToken()).isNull();
+    assertThat(tree.statement()).hasSize(1);
+    assertThat(tree.statement().get(0).is(Kind.BLOCK)).isTrue();
+  }
+
+  @Test
+  public void alternative_syntax() throws Exception {
+    ForStatementTree tree = parse("for (; ;) : endfor ;", PHPLexicalGrammar.FOR_STATEMENT);
+
+    assertThat(tree.is(Kind.ALTERNATIVE_FOR_STATEMENT)).isTrue();
+    assertThat(tree.init()).hasSize(0);
+    assertThat(tree.condition()).hasSize(0);
+    assertThat(tree.update()).hasSize(0);
+    assertThat(tree.colonToken()).isNotNull();
+    assertThat(tree.endforToken()).isNotNull();
+    assertThat(tree.eosToken()).isNotNull();
+    assertThat(tree.statement()).hasSize(0);
+  }
+}
diff --git a/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/IfStatementTreeTest.java b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/IfStatementTreeTest.java
new file mode 100644
index 000000000..9a410b5da
--- /dev/null
+++ b/php-frontend/src/test/java/org/sonar/php/tree/impl/statement/IfStatementTreeTest.java
@@ -0,0 +1,98 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.tree.impl.statement;
+
+import org.junit.Test;
+import org.sonar.php.PHPTreeModelTest;
+import org.sonar.php.parser.PHPLexicalGrammar;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
+import org.sonar.plugins.php.api.tree.statement.IfStatementTree;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public class IfStatementTreeTest extends PHPTreeModelTest {
+
+  @Test
+  public void standard_syntax() throws Exception {
+    IfStatementTree tree = parse("if $a {} else {}", PHPLexicalGrammar.IF_STATEMENT);
+
+    assertThat(tree.is(Kind.IF_STATEMENT)).isTrue();
+    assertThat(tree.ifToken().text()).isEqualTo("if");
+    assertThat(tree.condition()).isNotNull();
+    assertThat(tree.statement()).hasSize(1);
+    ElseClauseTree elseClause = tree.elseClause();
+    assertThat(elseClause).isNotNull();
+    assertThat(elseClause.is(Kind.ELSE_CLAUSE)).isTrue();
+    assertThat(elseClause.statement()).hasSize(1);
+    assertThat(tree.elseifClauses()).hasSize(0);
+    assertThat(tree.colonToken()).isNull();
+    assertThat(tree.endifToken()).isNull();
+    assertThat(tree.eosToken()).isNull();
+  }
+
+  @Test
+  public void alternative_syntax() throws Exception {
+    IfStatementTree tree = parse("if $a : elseif $a : else : {} {} endif;", PHPLexicalGrammar.IF_STATEMENT);
+
+    assertThat(tree.is(Kind.ALTRNATIVE_IF_STATEMENT)).isTrue();
+    assertThat(tree.colonToken()).isNotNull();
+    assertThat(tree.statement()).hasSize(0);
+
+    ElseClauseTree elseClause = tree.elseClause();
+    assertThat(elseClause).isNotNull();
+    assertThat(elseClause.is(Kind.ALTERNATIVE_ELSE_CLAUSE)).isTrue();
+    assertThat(elseClause.statement()).hasSize(2);
+
+    assertThat(tree.elseifClauses()).hasSize(1);
+    assertThat(tree.elseifClauses().get(0).is(Kind.ALTERNATIVE_ELSEIF_CLAUSE)).isTrue();
+
+    assertThat(tree.endifToken()).isNotNull();
+    assertThat(tree.eosToken()).isNotNull();
+  }
+
+  @Test
+  public void standard_syntax_without_else() throws Exception {
+    IfStatementTree tree = parse("if $a {}", PHPLexicalGrammar.IF_STATEMENT);
+
+    assertThat(tree.statement()).hasSize(1);
+    assertThat(tree.elseClause()).isNull();
+    assertThat(tree.elseifClauses()).hasSize(0);
+  }
+
+  @Test
+  public void elseif_syntax() throws Exception {
+    IfStatementTree tree = parse("if $a {} elseif $b {} elseif $c {} else {}", PHPLexicalGrammar.IF_STATEMENT);
+
+    assertThat(tree.statement()).hasSize(1);
+    assertThat(tree.elseClause()).isNotNull();
+    assertThat(tree.elseifClauses()).hasSize(2);
+
+    ElseifClauseTree elseifClause = tree.elseifClauses().get(0);
+    assertThat(elseifClause.is(Kind.ELSEIF_CLAUSE)).isTrue();
+    assertThat(elseifClause.statement()).hasSize(1);
+    assertThat(elseifClause.condition()).isNotNull();
+    assertThat(elseifClause.colonToken()).isNull();
+
+    assertThat(tree.elseifClauses().get(1).statement()).hasSize(1);
+  }
+
+}
diff --git a/sonar-php-plugin/pom.xml b/sonar-php-plugin/pom.xml
index 5080be6b2..f8c4859be 100644
--- a/sonar-php-plugin/pom.xml
+++ b/sonar-php-plugin/pom.xml
@@ -92,8 +92,8 @@
             <configuration>
               <rules>
                 <requireFilesSize>
-                  <maxsize>3700000</maxsize>
-                  <minsize>3500000</minsize>
+                  <maxsize>3800000</maxsize>
+                  <minsize>3600000</minsize>
                   <files>
                     <file>${project.build.directory}/${project.build.finalName}.jar</file>
                   </files>
