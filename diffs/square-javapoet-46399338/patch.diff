diff --git a/src/main/java/com/squareup/javawriter/builders/AnnotationSpec.java b/src/main/java/com/squareup/javawriter/builders/AnnotationSpec.java
index da836604..0384e488 100644
--- a/src/main/java/com/squareup/javawriter/builders/AnnotationSpec.java
+++ b/src/main/java/com/squareup/javawriter/builders/AnnotationSpec.java
@@ -33,7 +33,7 @@
   public final ImmutableSortedMap<String, Snippet> members;
 
   private AnnotationSpec(Builder builder) {
-    this.type = checkNotNull(builder.type);
+    this.type = checkNotNull(builder.type, "type");
     this.members = ImmutableSortedMap.copyOf(builder.members);
   }
 
@@ -45,8 +45,10 @@ void emit(CodeWriter codeWriter, boolean inline) {
       codeWriter.emit("@$T$L", type, suffix);
     } else if (members.keySet().equals(ImmutableSet.of("value"))) {
       // @Named("foo")
-      codeWriter.emit("@$T(");
+      codeWriter.emit("@$T(", type);
+      codeWriter.indent(2);
       codeWriter.emit(getOnlyElement(members.values()));
+      codeWriter.unindent(2);
       codeWriter.emit(")$L", suffix);
     } else {
       // Inline:
@@ -58,8 +60,7 @@ void emit(CodeWriter codeWriter, boolean inline) {
       //       nullable = false
       //   )
       codeWriter.emit("@$T($L", type, separator);
-      codeWriter.indent();
-      codeWriter.indent();
+      codeWriter.indent(2);
       for (Iterator<Map.Entry<String, Snippet>> i = members.entrySet().iterator(); i.hasNext();) {
         Map.Entry<String, Snippet> entry = i.next();
         codeWriter.emit("$L = ", entry.getKey());
@@ -67,14 +68,17 @@ void emit(CodeWriter codeWriter, boolean inline) {
         if (i.hasNext()) codeWriter.emit(",");
         codeWriter.emit("$L", separator);
       }
-      codeWriter.unindent();
-      codeWriter.unindent();
+      codeWriter.unindent(2);
       codeWriter.emit(")$L", suffix);
     }
   }
 
   public static AnnotationSpec of(Class<? extends Annotation> annotation) {
-    return new Builder().type(ClassName.fromClass(annotation)).build();
+    return of(ClassName.fromClass(annotation));
+  }
+
+  public static AnnotationSpec of(ClassName annotation) {
+    return new Builder().type(annotation).build();
   }
 
   @Override public boolean equals(Object o) {
diff --git a/src/main/java/com/squareup/javawriter/builders/CodeWriter.java b/src/main/java/com/squareup/javawriter/builders/CodeWriter.java
index 1f905fc2..a31cbf32 100644
--- a/src/main/java/com/squareup/javawriter/builders/CodeWriter.java
+++ b/src/main/java/com/squareup/javawriter/builders/CodeWriter.java
@@ -34,8 +34,8 @@
 import java.util.Map;
 import javax.lang.model.element.Modifier;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This
@@ -55,13 +55,21 @@ public CodeWriter(StringBuilder out, ImmutableMap<ClassName, String> importedTyp
   }
 
   public CodeWriter indent() {
-    indentLevel++;
+    return indent(1);
+  }
+
+  public CodeWriter indent(int levels) {
+    indentLevel += levels;
     return this;
   }
 
   public CodeWriter unindent() {
-    checkState(indentLevel > 0);
-    indentLevel--;
+    return unindent(1);
+  }
+
+  public CodeWriter unindent(int levels) {
+    checkArgument(indentLevel - levels >= 0);
+    indentLevel -= levels;
     return this;
   }
 
@@ -71,7 +79,7 @@ public CodeWriter pushVisibleType(TypeName typeName) {
   }
 
   public CodeWriter popVisibleType(TypeName typeName) {
-    checkState(visibleTypes.remove(typeName));
+    checkArgument(visibleTypes.remove(typeName));
     return this;
   }
 
@@ -81,15 +89,25 @@ public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean i
     }
   }
 
-  public void emitModifiers(ImmutableSet<Modifier> modifiers) {
+  /**
+   * Emits {@code modifiers} in the standard order. Modifiers in {@code implicitModifiers} will not
+   * be emitted.
+   */
+  public void emitModifiers(
+      ImmutableSet<Modifier> modifiers, ImmutableSet<Modifier> implicitModifiers) {
     if (!modifiers.isEmpty()) {
       for (Modifier modifier : EnumSet.copyOf(modifiers)) {
+        if (implicitModifiers.contains(modifier)) continue;
         emitAndIndent(Ascii.toLowerCase(modifier.name()));
         emitAndIndent(" ");
       }
     }
   }
 
+  public void emitModifiers(ImmutableSet<Modifier> modifiers) {
+    emitModifiers(modifiers, ImmutableSet.<Modifier>of());
+  }
+
   public CodeWriter emit(String format, Object... args) {
     return emit(new Snippet(format, args));
   }
diff --git a/src/main/java/com/squareup/javawriter/builders/FieldSpec.java b/src/main/java/com/squareup/javawriter/builders/FieldSpec.java
index 49bae9c5..c0376afe 100644
--- a/src/main/java/com/squareup/javawriter/builders/FieldSpec.java
+++ b/src/main/java/com/squareup/javawriter/builders/FieldSpec.java
@@ -18,6 +18,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javawriter.TypeName;
+import com.squareup.javawriter.TypeNames;
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -42,9 +43,13 @@ private FieldSpec(Builder builder) {
     this.initializer = builder.initializer;
   }
 
-  void emit(CodeWriter codeWriter) {
+  public boolean hasModifier(Modifier modifier) {
+    return modifiers.contains(modifier);
+  }
+
+  void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) {
     codeWriter.emitAnnotations(annotations, false);
-    codeWriter.emitModifiers(modifiers);
+    codeWriter.emitModifiers(modifiers, implicitModifiers);
     codeWriter.emit("$T $L", type, name);
     if (initializer != null) {
       codeWriter.emit(" = ");
@@ -80,6 +85,10 @@ public Builder type(TypeName type) {
       return this;
     }
 
+    public Builder type(Class<?> type) {
+      return type(TypeNames.forClass(type));
+    }
+
     public Builder name(Name name) {
       this.name = name;
       return this;
diff --git a/src/main/java/com/squareup/javawriter/builders/MethodSpec.java b/src/main/java/com/squareup/javawriter/builders/MethodSpec.java
index 7cc8eb63..d075d90d 100644
--- a/src/main/java/com/squareup/javawriter/builders/MethodSpec.java
+++ b/src/main/java/com/squareup/javawriter/builders/MethodSpec.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javawriter.ClassName;
 import com.squareup.javawriter.TypeName;
 import com.squareup.javawriter.TypeNames;
 import com.squareup.javawriter.VoidName;
@@ -26,6 +27,7 @@
 import java.util.List;
 import javax.lang.model.element.Modifier;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /** A generated method declaration. */
@@ -38,6 +40,11 @@
   public final ImmutableList<Snippet> snippets;
 
   private MethodSpec(Builder builder) {
+    checkArgument(builder.returnType != null ^ builder.name == Name.CONSTRUCTOR,
+        "unexpected return type %s for %s", builder.returnType, builder.name);
+    checkArgument(builder.snippets.isEmpty() || !builder.modifiers.contains(Modifier.ABSTRACT),
+        "abstract method %s cannot have code", builder.name);
+
     this.annotations = ImmutableList.copyOf(builder.annotations);
     this.modifiers = ImmutableSet.copyOf(builder.modifiers);
     this.returnType = builder.returnType;
@@ -46,10 +53,15 @@ private MethodSpec(Builder builder) {
     this.snippets = ImmutableList.copyOf(builder.snippets);
   }
 
-  void emit(CodeWriter codeWriter) {
+  void emit(CodeWriter codeWriter, ClassName enclosing, ImmutableSet<Modifier> implicitModifiers) {
     codeWriter.emitAnnotations(annotations, false);
-    codeWriter.emitModifiers(modifiers);
-    codeWriter.emit("$T $L(", returnType, name);
+    codeWriter.emitModifiers(modifiers, implicitModifiers);
+
+    if (name == Name.CONSTRUCTOR) {
+      codeWriter.emit("$L(", enclosing.simpleName());
+    } else {
+      codeWriter.emit("$T $L(", returnType, name);
+    }
 
     boolean firstParameter = true;
     for (ParameterSpec parameterSpec : parameters) {
@@ -57,6 +69,12 @@ void emit(CodeWriter codeWriter) {
       parameterSpec.emit(codeWriter);
       firstParameter = false;
     }
+
+    if (hasModifier(Modifier.ABSTRACT)) {
+      codeWriter.emit(");\n");
+      return;
+    }
+
     codeWriter.emit(") {\n");
 
     codeWriter.indent();
@@ -68,6 +86,10 @@ void emit(CodeWriter codeWriter) {
     codeWriter.emit("}\n");
   }
 
+  public boolean hasModifier(Modifier modifier) {
+    return modifiers.contains(modifier);
+  }
+
   public static final class Builder {
     private final List<AnnotationSpec> annotations = new ArrayList<>();
     private final List<Modifier> modifiers = new ArrayList<>();
@@ -100,6 +122,12 @@ public Builder returns(TypeName returnType) {
       return this;
     }
 
+    public Builder constructor() {
+      returnType = null;
+      name = Name.CONSTRUCTOR;
+      return this;
+    }
+
     public Builder name(String name) {
       this.name = new Name(name);
       return this;
diff --git a/src/main/java/com/squareup/javawriter/builders/Name.java b/src/main/java/com/squareup/javawriter/builders/Name.java
index 36c65b0f..86d1f32c 100644
--- a/src/main/java/com/squareup/javawriter/builders/Name.java
+++ b/src/main/java/com/squareup/javawriter/builders/Name.java
@@ -23,6 +23,8 @@
  * {@code public_} or {@code public1}.
  */
 public final class Name {
+  static final Name CONSTRUCTOR = new Name("<init>");
+
   public final String seed;
 
   public Name(String seed) {
diff --git a/src/main/java/com/squareup/javawriter/builders/ParameterSpec.java b/src/main/java/com/squareup/javawriter/builders/ParameterSpec.java
index 6a2167e4..91a0d25f 100644
--- a/src/main/java/com/squareup/javawriter/builders/ParameterSpec.java
+++ b/src/main/java/com/squareup/javawriter/builders/ParameterSpec.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javawriter.ClassName;
 import com.squareup.javawriter.TypeName;
 import com.squareup.javawriter.TypeNames;
 import java.lang.annotation.Annotation;
@@ -41,6 +42,10 @@ private ParameterSpec(Builder builder) {
     this.name = checkNotNull(builder.name);
   }
 
+  public boolean hasModifier(Modifier modifier) {
+    return modifiers.contains(modifier);
+  }
+
   void emit(CodeWriter codeWriter) {
     codeWriter.emitAnnotations(annotations, true);
     codeWriter.emitModifiers(modifiers);
@@ -63,6 +68,11 @@ public Builder addAnnotation(Class<? extends Annotation> annotation) {
       return this;
     }
 
+    public Builder addAnnotation(ClassName annotation) {
+      this.annotations.add(AnnotationSpec.of(annotation));
+      return this;
+    }
+
     public Builder addModifiers(Modifier... modifiers) {
       Collections.addAll(this.modifiers, modifiers);
       return this;
diff --git a/src/main/java/com/squareup/javawriter/builders/Snippet.java b/src/main/java/com/squareup/javawriter/builders/Snippet.java
index 28ec2607..864b6c54 100644
--- a/src/main/java/com/squareup/javawriter/builders/Snippet.java
+++ b/src/main/java/com/squareup/javawriter/builders/Snippet.java
@@ -16,6 +16,7 @@
 package com.squareup.javawriter.builders;
 
 import com.google.common.collect.ImmutableList;
+import java.util.Arrays;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
@@ -67,7 +68,7 @@ public Snippet(String format, Object[] args) {
     }
 
     checkArgument(args.length == expectedArgsLength,
-        "expected %s args but was %s", expectedArgsLength, args);
+        "expected %s args for %s but was %s", expectedArgsLength, format, Arrays.toString(args));
 
     this.formatParts = formatPartsBuilder.build();
     this.args = ImmutableList.copyOf(args);
diff --git a/src/main/java/com/squareup/javawriter/builders/TypeSpec.java b/src/main/java/com/squareup/javawriter/builders/TypeSpec.java
index f9d324c0..a58259fd 100644
--- a/src/main/java/com/squareup/javawriter/builders/TypeSpec.java
+++ b/src/main/java/com/squareup/javawriter/builders/TypeSpec.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.javawriter.builders;
 
+import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javawriter.ClassName;
@@ -42,6 +43,25 @@
   private TypeSpec(Builder builder) {
     checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,
         "types must have either a name or anonymous type arguments");
+    boolean isInterface = builder.type == Type.INTERFACE;
+    boolean typeIsAbstract = builder.modifiers.contains(Modifier.ABSTRACT) || isInterface;
+    for (MethodSpec methodSpec : builder.methodSpecs) {
+      checkArgument(typeIsAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),
+          "non-abstract type %s cannot declare abstract method %s", builder.name, methodSpec.name);
+      checkArgument(!isInterface || methodSpec.hasModifier(Modifier.ABSTRACT),
+          "interface %s cannot declare non-abstract method %s", builder.name, methodSpec.name);
+      checkArgument(!isInterface || methodSpec.hasModifier(Modifier.PUBLIC),
+          "interface %s cannot declare non-public method %s", builder.name, methodSpec.name);
+    }
+    for (FieldSpec fieldSpec : builder.fieldSpecs) {
+      if (isInterface) {
+        checkArgument(fieldSpec.hasModifier(Modifier.PUBLIC)
+            && fieldSpec.hasModifier(Modifier.STATIC)
+            && fieldSpec.hasModifier(Modifier.FINAL),
+            "interface %s field %s must be public static final", builder.name, fieldSpec.name);
+      }
+    }
+
     this.annotations = ImmutableList.copyOf(builder.annotations);
     this.modifiers = ImmutableSet.copyOf(builder.modifiers);
     this.type = checkNotNull(builder.type);
@@ -52,6 +72,10 @@ private TypeSpec(Builder builder) {
     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);
   }
 
+  public boolean hasModifier(Modifier modifier) {
+    return modifiers.contains(modifier);
+  }
+
   void emit(CodeWriter codeWriter) {
     if (anonymousTypeArguments != null) {
       codeWriter.emit("new $T(", supertype);
@@ -60,29 +84,42 @@ void emit(CodeWriter codeWriter) {
     } else {
       codeWriter.emitAnnotations(annotations, false);
       codeWriter.emitModifiers(modifiers);
-      codeWriter.emit("class $L {\n", name.simpleName());
+      codeWriter.emit("$L $L {\n", Ascii.toLowerCase(type.name()), name.simpleName());
     }
 
     codeWriter.indent();
-
     boolean firstMember = true;
     for (FieldSpec fieldSpec : fieldSpecs) {
       if (!firstMember) codeWriter.emit("\n");
-      fieldSpec.emit(codeWriter);
+      fieldSpec.emit(codeWriter, type.implicitFieldModifiers);
       firstMember = false;
     }
     for (MethodSpec methodSpec : methodSpecs) {
       if (!firstMember) codeWriter.emit("\n");
-      methodSpec.emit(codeWriter);
+      methodSpec.emit(codeWriter, name, type.implicitMethodModifiers);
       firstMember = false;
     }
-
     codeWriter.unindent();
+
     codeWriter.emit(anonymousTypeArguments != null ? "}" : "}\n");
   }
 
   public static enum Type {
-    CLASS, INTERFACE, ENUM
+    CLASS(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of()),
+    INTERFACE(ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL),
+        ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT)),
+    ENUM(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of());
+
+    private ImmutableSet<Modifier> implicitFieldModifiers
+        = ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
+    private ImmutableSet<Modifier> implicitMethodModifiers
+        = ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT);
+
+    private Type(ImmutableSet<Modifier> implicitFieldModifiers,
+        ImmutableSet<Modifier> implicitMethodModifiers) {
+      this.implicitFieldModifiers = implicitFieldModifiers;
+      this.implicitMethodModifiers = implicitMethodModifiers;
+    }
   }
 
   public static final class Builder {
diff --git a/src/test/java/com/squareup/javawriter/builders/TypeSpecTest.java b/src/test/java/com/squareup/javawriter/builders/TypeSpecTest.java
index 64340a2b..73623ca9 100644
--- a/src/test/java/com/squareup/javawriter/builders/TypeSpecTest.java
+++ b/src/test/java/com/squareup/javawriter/builders/TypeSpecTest.java
@@ -20,7 +20,6 @@
 import com.squareup.javawriter.ParameterizedTypeName;
 import com.squareup.javawriter.WildcardName;
 import java.io.Serializable;
-import java.util.ArrayList;
 import java.util.List;
 import javax.lang.model.element.Modifier;
 import org.junit.Test;
@@ -134,7 +133,7 @@
     TypeSpec taco = new TypeSpec.Builder()
         .name(ClassName.create("com.squareup.tacos", "Taco"))
         .addField(new FieldSpec.Builder()
-            .addModifiers(Modifier.STATIC, Modifier.FINAL)
+            .addModifiers(Modifier.STATIC, Modifier.FINAL, Modifier.FINAL)
             .type(thingThangOfFooBar)
             .name("NAME")
             .initializer("$L", aThingThang)
@@ -167,6 +166,189 @@
         + "}\n");
   }
 
+  @Test public void annotatedParameters() throws Exception {
+    TypeSpec service = new TypeSpec.Builder()
+        .name(ClassName.create("com.squareup.tacos", "Foo"))
+        .addMethod(new MethodSpec.Builder()
+            .addModifiers(Modifier.PUBLIC)
+            .constructor()
+            .addParameter(new ParameterSpec.Builder()
+                .type(long.class)
+                .name("id")
+                .build())
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(ClassName.create("com.squareup.tacos", "Ping"))
+                .type(String.class)
+                .name("one")
+                .build())
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(ClassName.create("com.squareup.tacos", "Ping"))
+                .type(String.class)
+                .name("two")
+                .build())
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(new AnnotationSpec.Builder()
+                    .type(ClassName.create("com.squareup.tacos", "Pong"))
+                    .addMember("value", "$S", "pong")
+                    .build())
+                .type(String.class)
+                .name("three")
+                .build())
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(ClassName.create("com.squareup.tacos", "Ping"))
+                .type(String.class)
+                .name("four")
+                .build())
+            .addCode("/* code snippets */\n")
+            .build())
+        .build();
+
+    assertThat(toString(service)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "import com.squareup.tacos.Ping;\n"
+        + "import com.squareup.tacos.Pong;\n"
+        + "import java.lang.String;\n"
+        + "\n"
+        + "class Foo {\n"
+        + "  public Foo(long id, @Ping String one, @Ping String two, @Pong(\"pong\") String three, "
+        + "@Ping String four) {\n"
+        + "    /* code snippets */\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void retrofitStyleInterface() throws Exception {
+    ClassName observable = ClassName.create("com.squareup.tacos", "Observable");
+    ClassName fooBar = ClassName.create("com.squareup.tacos", "FooBar");
+    ClassName thing = ClassName.create("com.squareup.tacos", "Thing");
+    ClassName things = ClassName.create("com.squareup.tacos", "Things");
+    ClassName map = ClassName.create("java.util", "Map");
+    ClassName string = ClassName.create("java.lang", "String");
+    ClassName headers = ClassName.create("com.squareup.tacos", "Headers");
+    ClassName post = ClassName.create("com.squareup.tacos", "POST");
+    ClassName body = ClassName.create("com.squareup.tacos", "Body");
+    ClassName queryMap = ClassName.create("com.squareup.tacos", "QueryMap");
+    ClassName header = ClassName.create("com.squareup.tacos", "Header");
+    TypeSpec service = new TypeSpec.Builder()
+        .name(ClassName.create("com.squareup.tacos", "Service"))
+        .type(TypeSpec.Type.INTERFACE)
+        .addMethod(new MethodSpec.Builder()
+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+            .addAnnotation(new AnnotationSpec.Builder()
+                .type(headers)
+                .addMember("value", "{\n$S,\n$S\n}",
+                    "Accept: application/json", "User-Agent: foobar")
+                .build())
+            .addAnnotation(new AnnotationSpec.Builder()
+                .type(post)
+                .addMember("value", "$S", "/foo/bar")
+                .build())
+            .returns(ParameterizedTypeName.create(observable, fooBar))
+            .name("fooBar")
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(body)
+                .type(ParameterizedTypeName.create(things, thing))
+                .name("things")
+                .build())
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(new AnnotationSpec.Builder()
+                    .type(queryMap)
+                    .addMember("encodeValues", "false")
+                    .build())
+                .type(ParameterizedTypeName.create(map, string, string))
+                .name("query")
+                .build())
+            .addParameter(new ParameterSpec.Builder()
+                .addAnnotation(new AnnotationSpec.Builder()
+                    .type(header)
+                    .addMember("value", "$S", "Authorization")
+                    .build())
+                .type(string)
+                .name("authorization")
+                .build())
+            .build())
+        .build();
+
+    assertThat(toString(service)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "import com.squareup.tacos.Body;\n"
+        + "import com.squareup.tacos.FooBar;\n"
+        + "import com.squareup.tacos.Header;\n"
+        + "import com.squareup.tacos.Headers;\n"
+        + "import com.squareup.tacos.Observable;\n"
+        + "import com.squareup.tacos.POST;\n"
+        + "import com.squareup.tacos.QueryMap;\n"
+        + "import com.squareup.tacos.Thing;\n"
+        + "import com.squareup.tacos.Things;\n"
+        + "import java.lang.String;\n"
+        + "import java.util.Map;\n"
+        + "\n"
+        + "interface Service {\n"
+        + "  @Headers({\n"
+        + "      \"Accept: application/json\",\n"
+        + "      \"User-Agent: foobar\"\n"
+        + "      })\n"
+        + "  @POST(\"/foo/bar\")\n"
+        + "  Observable<FooBar> fooBar(@Body Things<Thing> things, @QueryMap(encodeValues = false) "
+        + "Map<String, String> query, @Header(\"Authorization\") String authorization);\n"
+        + "}\n");
+  }
+
+  @Test public void annotatedField() throws Exception {
+    TypeSpec taco = new TypeSpec.Builder()
+        .name(ClassName.create("com.squareup.tacos", "Taco"))
+        .addField(new FieldSpec.Builder()
+            .addAnnotation(new AnnotationSpec.Builder()
+                .type(ClassName.create("com.squareup.tacos", "JsonAdapter"))
+                .addMember("value", "$T.class", ClassName.create("com.squareup.tacos", "Foo"))
+                .build())
+            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
+            .type(String.class)
+            .name("thing")
+            .build())
+        .build();
+    assertThat(toString(taco)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "import com.squareup.tacos.Foo;\n"
+        + "import com.squareup.tacos.JsonAdapter;\n"
+        + "import java.lang.String;\n"
+        + "\n"
+        + "class Taco {\n"
+        + "  @JsonAdapter(Foo.class)\n"
+        + "  private final String thing;\n"
+        + "}\n");
+  }
+
+  @Test public void annotatedClass() throws Exception {
+    ClassName someType = ClassName.create("com.squareup.tacos", "SomeType");
+    TypeSpec taco = new TypeSpec.Builder()
+        .addAnnotation(new AnnotationSpec.Builder()
+            .type(ClassName.create("com.squareup.tacos", "Something"))
+            .addMember("hi", "$T.$N", someType, "FIELD")
+            .addMember("hey", "$L", 12)
+            .addMember("hello", "$S", "goodbye")
+            .build())
+        .name(ClassName.create("com.squareup.tacos", "Foo"))
+        .addModifiers(Modifier.PUBLIC)
+        .build();
+    assertThat(toString(taco)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "import com.squareup.tacos.SomeType;\n"
+        + "import com.squareup.tacos.Something;\n"
+        + "\n"
+        + "@Something(\n"
+        + "    hello = \"goodbye\",\n"
+        + "    hey = 12,\n"
+        + "    hi = SomeType.FIELD\n"
+        + ")\n"
+        + "public class Foo {\n"
+        + "}\n");
+  }
+
   private String toString(TypeSpec typeSpec) {
     return new JavaFile.Builder()
         .classSpec(typeSpec)
