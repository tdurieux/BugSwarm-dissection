diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
index a4f5f62f8..f7822c71a 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
@@ -3,13 +3,12 @@
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * A {@link Converter} which uses Jackson for reading and writing entities.
@@ -17,7 +16,7 @@
  * @author Kai Waldron (kaiwaldron@gmail.com)
  */
 public class JacksonConverter implements Converter {
-  private static final String MIME_TYPE = "application/json; charset=UTF-8";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
   private final ObjectMapper objectMapper;
 
@@ -29,31 +28,26 @@ public JacksonConverter(ObjectMapper objectMapper) {
     this.objectMapper = objectMapper;
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
-    InputStream in = null;
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
     try {
       JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      in = body.in();
-      return objectMapper.readValue(in, javaType);
+      return objectMapper.readValue(is, javaType);
     } finally {
       try {
-        if (in != null) {
-          in.close();
-        }
+        is.close();
       } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     try {
       JavaType javaType = objectMapper.getTypeFactory().constructType(type);
       String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
-      return new TypedByteArray(MIME_TYPE, json.getBytes("UTF-8"));
+      return RequestBody.create(MEDIA_TYPE, json);
     } catch (JsonProcessingException e) {
-      throw new AssertionError(e);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+      throw new RuntimeException(e);
     }
   }
 }
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
index ab5e9ceb6..4114ba075 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
@@ -3,53 +3,55 @@
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JacksonConverterTest {
-  private static final String MIME_TYPE = "application/json; charset=UTF-8";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
   private static final MyObject OBJECT = new MyObject("hello world", 10);
   private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
 
   private final JacksonConverter converter = new JacksonConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput typedOutput = converter.toBody(OBJECT, MyObject.class);
-    assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
-    assertThat(asString(typedOutput)).isEqualTo(JSON);
+    RequestBody body = converter.toBody(OBJECT, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(JSON);
   }
 
   @Test public void deserialize() throws Exception {
-    TypedInput input = new TypedByteArray(MIME_TYPE, JSON.getBytes());
-    MyObject result = (MyObject) converter.fromBody(input, MyObject.class);
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
     assertThat(result).isEqualTo(OBJECT);
   }
 
   @Test public void deserializeWrongValue() throws Exception {
-    TypedInput input = new TypedByteArray(MIME_TYPE, "{\"foo\":\"bar\"}".getBytes());
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
     try {
-      converter.fromBody(input, MyObject.class);
+      converter.fromBody(body, MyObject.class);
     } catch (UnrecognizedPropertyException ignored) {
     }
   }
 
   @Test public void deserializeWrongClass() throws Exception {
-    TypedInput input = new TypedByteArray(MIME_TYPE, JSON.getBytes());
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
     try {
-      converter.fromBody(input, String.class);
+      converter.fromBody(body, String.class);
     } catch (JsonMappingException ignored) {
     }
   }
 
-  private String asString(TypedOutput typedOutput) throws Exception {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    typedOutput.writeTo(bytes);
-    return new String(bytes.toByteArray());
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 
   static class MyObject {
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
index c2935210a..b9270c44e 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
@@ -2,20 +2,20 @@
 package retrofit.converter;
 
 import com.google.protobuf.AbstractMessageLite;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers. */
 public class ProtoConverter implements Converter {
-  private static final String MIME_TYPE = "application/x-protobuf";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -24,30 +24,31 @@
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     }
 
-    String mimeType = body.mimeType();
-    if (!MIME_TYPE.equals(mimeType)) {
-      throw new RuntimeException("Response content type was not a proto: " + mimeType);
-    }
-
+    InputStream is = body.byteStream();
     try {
       Method parseFrom = c.getMethod("parseFrom", InputStream.class);
-      return parseFrom.invoke(null, body.in());
+      return parseFrom.invoke(null, is);
     } catch (InvocationTargetException e) {
       throw new RuntimeException(c.getName() + ".parseFrom() failed", e.getCause());
     } catch (NoSuchMethodException e) {
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     } catch (IllegalAccessException e) {
       throw new AssertionError();
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof AbstractMessageLite)) {
       throw new IllegalArgumentException(
           "Expected a protobuf message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((AbstractMessageLite) object).toByteArray();
-    return new TypedByteArray(MIME_TYPE, bytes);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
index 828588a30..99bcc58f5 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
@@ -1,15 +1,16 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
-import com.google.common.io.BaseEncoding;
 import com.google.protobuf.InvalidProtocolBufferException;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -19,22 +20,22 @@
   private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
   private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
 
-  private final ProtoConverter protoConverter = new ProtoConverter();
+  private final ProtoConverter converter = new ProtoConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = protoConverter.toBody(PROTO, Phone.class);
-    assertThat(protoBytes.mimeType()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(ENCODED_PROTO)));
+    RequestBody body = converter.toBody(PROTO, Phone.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
   @Test public void deserialize() throws Exception {
-    Object proto = protoConverter.fromBody(decodeBase64(ENCODED_PROTO), Phone.class);
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
     assertThat(proto).isEqualTo(PROTO);
   }
 
   @Test public void deserializeWrongClass() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), String.class);
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
@@ -43,7 +44,7 @@
 
   @Test public void deserializeWrongType() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
+      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
@@ -52,33 +53,21 @@
 
   @Test public void deserializeWrongValue() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64("////"), Phone.class);
+      converter.fromBody(protoResponse("////"), Phone.class);
       fail();
     } catch (RuntimeException expected) {
       assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
     }
   }
 
-  @Test public void deserializeWrongMime() throws Exception {
-    try {
-      protoConverter.fromBody(decodeBase64("////", "yummy/bytes"), Phone.class);
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Response content type was not a proto: yummy/bytes");
-    }
-  }
-
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
-  }
-
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, "application/x-protobuf");
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
+        encodedProto).toByteArray());
   }
 
-  private static TypedByteArray decodeBase64(String base64, String mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(mime, BaseEncoding.base64().decode(base64));
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
   }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
index 266d35c33..93374412c 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
@@ -1,16 +1,15 @@
 package retrofit.converter;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStreamWriter;
 import java.lang.reflect.Type;
-
-import org.simpleframework.xml.core.Persister;
 import org.simpleframework.xml.Serializer;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import org.simpleframework.xml.core.Persister;
 
 /**
  * A {@link Converter} which uses SimpleXML for reading and writing entities.
@@ -20,7 +19,8 @@
 public class SimpleXMLConverter implements Converter {
   private static final boolean DEFAULT_STRICT = true;
   private static final String CHARSET = "UTF-8";
-  private static final String MIME_TYPE = "application/xml; charset=" + CHARSET;
+  private static final MediaType MEDIA_TYPE =
+      MediaType.parse("application/xml; charset=" + CHARSET);
 
   private final Serializer serializer;
 
@@ -43,35 +43,34 @@ public SimpleXMLConverter(Serializer serializer, boolean strict) {
     this.strict = strict;
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
     try {
-      return serializer.read((Class<?>) type, body.in(), strict);
+      return serializer.read((Class<?>) type, is, strict);
     } catch (IOException e) {
       throw e;
     } catch (Exception e) {
       throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object source, Type type) {
-    OutputStreamWriter osw = null;
-
+  @Override public RequestBody toBody(Object source, Type type) {
+    byte[] bytes;
     try {
       ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      osw = new OutputStreamWriter(bos, CHARSET);
+      OutputStreamWriter osw = new OutputStreamWriter(bos, CHARSET);
       serializer.write(source, osw);
       osw.flush();
-      return new TypedByteArray(MIME_TYPE, bos.toByteArray());
+      bytes = bos.toByteArray();
     } catch (Exception e) {
       throw new AssertionError(e);
-    } finally {
-      try {
-        if (osw != null) {
-          osw.close();
-        }
-      } catch (IOException ignored) {
-      }
     }
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 
   public boolean isStrict() {
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
index cd0b3e6f2..3da7ee887 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
@@ -1,6 +1,12 @@
 package retrofit.converter;
 
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Before;
 import org.junit.Test;
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
@@ -9,65 +15,55 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class SimpleXMLConverterTest {
-	private static final String MIME_TYPE = "application/xml; charset=UTF-8";
+	private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+	private static final MyObject OBJ = new MyObject("hello world", 10);
+  private static final String XML =
+      "<my-object><message>hello world</message><count>10</count></my-object>";
 
-	private final MyObject obj = new MyObject("hello world", 10);
-	private final String objAsXML = String.format(
-			"<my-object><message>%s</message><count>%d</count></my-object>",
-			obj.getMessage(), obj.getCount());
-	private final Converter converter = initConverter();
+	private Converter converter;
 
-	private static Converter initConverter() {
+	@Before public void setUp() {
 		Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
 		Persister persister = new Persister(format);
-		return new SimpleXMLConverter(persister);
+		converter = new SimpleXMLConverter(persister);
 	}
 
-	@Test
-	public void serialize() throws Exception {
-		final TypedOutput typedOutput = converter.toBody(obj, MyObject.class);
-		assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
-		assertThat(asString(typedOutput)).isEqualTo(objAsXML);
+	@Test public void serialize() throws Exception {
+		RequestBody body = converter.toBody(OBJ, MyObject.class);
+		assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+		assertBody(body).isEqualTo(XML);
 	}
 
-	@Test
-	public void deserialize() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				objAsXML.getBytes());
-		final MyObject result = (MyObject) converter.fromBody(input,
-				MyObject.class);
-		assertThat(result).isEqualTo(obj);
+	@Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+		MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+		assertThat(result).isEqualTo(OBJ);
 	}
 
 	@Test public void deserializeWrongValue() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				"<myObject><foo/><bar/></myObject>".getBytes());
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
     try {
-      converter.fromBody(input, MyObject.class);
+      converter.fromBody(body, MyObject.class);
     } catch (RuntimeException ignored) {
     }
 	}
 
-	@Test
-	public void deserializeWrongClass() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				objAsXML.getBytes());
-		Object result = converter.fromBody(input, String.class);
+	@Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+		Object result = converter.fromBody(body, String.class);
 		assertThat(result).isNull();
 	}
 
-	private String asString(TypedOutput typedOutput) throws Exception {
-		final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-		typedOutput.writeTo(bytes);
-		return new String(bytes.toByteArray());
-	}
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
+      throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
 
 	@Default(value = DefaultType.FIELD)
 	static class MyObject {
diff --git a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
index c1fc1e00d..af3ea1941 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
@@ -1,18 +1,18 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.Wire;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers using Wire. */
 public class WireConverter implements Converter {
-  private static final String MIME_TYPE = "application/x-protobuf";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
   private final Wire wire;
 
@@ -27,7 +27,7 @@ public WireConverter(Wire wire) {
   }
 
   @SuppressWarnings("unchecked") //
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -36,31 +36,24 @@ public WireConverter(Wire wire) {
       throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
     }
 
-    if (!MIME_TYPE.equalsIgnoreCase(body.mimeType())) {
-      throw new IllegalStateException("Expected a proto but was: " + body.mimeType());
-    }
-
-    InputStream in = null;
+    InputStream in = body.byteStream();
     try {
-      in = body.in();
       return wire.parseFrom(in, (Class<Message>) c);
     } finally {
-      if (in != null) {
-        try {
-          in.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        in.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof Message)) {
       throw new IllegalArgumentException(
           "Expected a proto message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((Message) object).toByteArray();
-    return new TypedByteArray(MIME_TYPE, bytes);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
index fdd967b2f..cc719fcbb 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
@@ -1,15 +1,15 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
-import com.google.common.io.BaseEncoding;
-import com.squareup.wire.Wire;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -17,24 +17,24 @@
 public final class WireConverterTest {
   private static final Person PROTO =
       new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
-  private static final String PROTO_ENCODED = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
+  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
 
-  private WireConverter converter = new WireConverter(new Wire());
+  private final WireConverter converter = new WireConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = converter.toBody(PROTO, Person.class);
-    assertThat(protoBytes.mimeType()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(PROTO_ENCODED)));
+    RequestBody body = converter.toBody(PROTO, Person.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
   @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(decodeBase64(PROTO_ENCODED), Person.class);
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
     assertThat(proto).isEqualTo(PROTO);
   }
 
   @Test public void deserializeWrongClass() throws Exception {
     try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED), String.class);
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
@@ -43,7 +43,7 @@
 
   @Test public void deserializeWrongType() throws Exception {
     try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED),
+      converter.fromBody(protoResponse(ENCODED_PROTO),
           ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
@@ -53,32 +53,20 @@
 
   @Test public void deserializeWrongValue() throws Exception {
     try {
-      converter.fromBody(decodeBase64("////"), Person.class);
+      converter.fromBody(protoResponse("////"), Person.class);
       fail();
     } catch (IOException ignored) {
     }
   }
 
-  @Test public void deserializeWrongMime() throws Exception {
-    try {
-      converter.fromBody(decodeBase64("////", "yummy/bytes"), Person.class);
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Expected a proto but was: yummy/bytes");
-    }
-  }
-
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
-  }
-
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, "application/x-protobuf");
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
+        ByteString.decodeBase64(encodedProto).toByteArray());
   }
 
-  private static TypedByteArray decodeBase64(String base64, String mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(mime, BaseEncoding.base64().decode(base64));
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
index 28331b72e..390bb9b01 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpException.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
@@ -2,7 +2,9 @@
 package retrofit;
 
 import com.squareup.okhttp.Headers;
-import retrofit.client.Response;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import retrofit.converter.Converter;
 
 import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
@@ -99,8 +101,14 @@ public MockHttpException withHeader(String name, String value) {
     return this;
   }
 
-  Response toResponse(Converter converter) {
-    return new Response("", code, reason, headers.build(),
-        new MockTypedInput(converter, responseBody));
+  Response toResponse(Request request, Converter converter) {
+    return new Response.Builder()
+        .code(code)
+        .message(reason)
+        .headers(headers.build())
+        .body(new MockResponseBody(converter, responseBody))
+        .protocol(Protocol.HTTP_1_1)
+        .request(request)
+        .build();
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
index 8cc23faec..93112f6d1 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
@@ -1,8 +1,8 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.lang.reflect.Type;
-import retrofit.client.Response;
 
 class MockHttpRetrofitError extends RetrofitError {
   private final Object body;
diff --git a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
new file mode 100644
index 000000000..03f1194e9
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
@@ -0,0 +1,46 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import retrofit.converter.Converter;
+
+class MockResponseBody extends ResponseBody {
+  private final Converter converter;
+  private final Object body;
+
+  private byte[] bytes;
+
+  MockResponseBody(Converter converter, Object body) {
+    this.converter = converter;
+    this.body = body;
+  }
+
+  @Override public MediaType contentType() {
+    return MediaType.parse("application/unknown");
+  }
+
+  @Override public long contentLength() {
+    try {
+      initBytes();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+    return bytes.length;
+  }
+
+  @Override public BufferedSource source() {
+    return new Buffer().write(bytes);
+  }
+
+  private synchronized void initBytes() throws IOException {
+    if (bytes == null) {
+      Buffer buffer = new Buffer();
+      converter.toBody(body, body.getClass()).writeTo(buffer);
+      bytes = buffer.readByteArray();
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
index dd664fac7..981d7bb0c 100644
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
@@ -1,6 +1,8 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -10,8 +12,6 @@
 import java.util.Random;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import rx.Observable;
 import rx.Scheduler;
 import rx.functions.Func1;
@@ -283,7 +283,7 @@ private Request buildRequest(RestMethodInfo methodInfo, RequestInterceptor inter
 
     private Object invokeSync(RestMethodInfo methodInfo, Object[] args, Request request)
         throws Throwable {
-      String url = request.getUrl();
+      String url = request.urlString();
 
       if (calculateIsFailure()) {
         sleep(calculateDelayForError());
@@ -307,7 +307,7 @@ private Object invokeSync(RestMethodInfo methodInfo, Object[] args, Request requ
           throw innerEx;
         }
         MockHttpException httpEx = (MockHttpException) innerEx;
-        Response response = httpEx.toResponse(restAdapter.converter);
+        Response response = httpEx.toResponse(request, restAdapter.converter);
 
         // Sleep for whatever amount of time is left to satisfy the network delay, if any.
         long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
@@ -319,8 +319,8 @@ private Object invokeSync(RestMethodInfo methodInfo, Object[] args, Request requ
     }
 
     private void invokeAsync(final RestMethodInfo methodInfo, final Object[] args,
-        Request request) {
-      final String url = request.getUrl();
+        final Request request) {
+      final String url = request.urlString();
       final Callback callback = (Callback) args[args.length - 1];
 
       if (calculateIsFailure()) {
@@ -354,7 +354,7 @@ private void invokeAsync(final RestMethodInfo methodInfo, final Object[] args,
             }
 
             MockHttpException httpEx = (MockHttpException) innerEx;
-            Response response = httpEx.toResponse(restAdapter.converter);
+            Response response = httpEx.toResponse(request, restAdapter.converter);
 
             RetrofitError error = new MockHttpRetrofitError(httpEx.getMessage(), url, response,
                 httpEx.responseBody, methodInfo.responseObjectType);
diff --git a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java b/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
deleted file mode 100644
index 20d100c14..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
-
-class MockTypedInput implements TypedInput {
-  private final Converter converter;
-  private final Object body;
-
-  private byte[] bytes;
-
-  MockTypedInput(Converter converter, Object body) {
-    this.converter = converter;
-    this.body = body;
-  }
-
-  @Override public String mimeType() {
-    return "application/unknown";
-  }
-
-  @Override public long length() {
-    try {
-      initBytes();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-    return bytes.length;
-  }
-
-  @Override public InputStream in() throws IOException {
-    initBytes();
-    return new ByteArrayInputStream(bytes);
-  }
-
-  private synchronized void initBytes() throws IOException {
-    if (bytes == null) {
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      converter.toBody(body, body.getClass()).writeTo(out);
-      bytes = out.toByteArray();
-    }
-  }
-}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
index f13e386d5..ed680f965 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
@@ -1,6 +1,7 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -10,9 +11,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.client.Client;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.http.GET;
 import rx.Observable;
 import rx.functions.Action1;
@@ -56,19 +54,12 @@
   private Throwable nextError;
 
   @Before public void setUp() throws IOException {
-    Client client = new Client() {
-      @Override public void execute(Request request, AsyncCallback callback) {
-        throw new AssertionError();
-      }
-    };
-
     httpExecutor = spy(new SynchronousExecutor());
     callbackExecutor = spy(new SynchronousExecutor());
 
     RestAdapter restAdapter = new RestAdapter.Builder() //
-        .setClient(client)
         .setCallbackExecutor(callbackExecutor)
-        .setEndpoint("http://example.com")
+        .setEndpoint("none")
         .setErrorHandler(new ErrorHandler() {
           @Override public Throwable handleError(RetrofitError cause) {
             if (nextError != null) {
@@ -397,8 +388,8 @@
       long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
       assertThat(tookMs).isGreaterThanOrEqualTo(100);
       assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-      assertThat(e.getResponse().getStatus()).isEqualTo(404);
-      assertThat(e.getResponse().getReason()).isEqualTo("Not Found");
+      assertThat(e.getResponse().code()).isEqualTo(404);
+      assertThat(e.getResponse().message()).isEqualTo("Not Found");
       assertThat(e.getBody()).isSameAs(expected);
       assertThat(e.getSuccessType()).isEqualTo(Object.class);
     }
@@ -440,8 +431,8 @@
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
     assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().getStatus()).isEqualTo(404);
-    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getResponse().code()).isEqualTo(404);
+    assertThat(error.getResponse().message()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
     assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
@@ -484,8 +475,8 @@
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
     assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().getStatus()).isEqualTo(404);
-    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getResponse().code()).isEqualTo(404);
+    assertThat(error.getResponse().message()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
     assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
@@ -525,8 +516,8 @@
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
     assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().getStatus()).isEqualTo(400);
-    assertThat(error.getResponse().getReason()).isEqualTo("Bad Request");
+    assertThat(error.getResponse().code()).isEqualTo(400);
+    assertThat(error.getResponse().message()).isEqualTo("Bad Request");
     assertThat(error.getBody()).isNull();
     assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 4298f9e33..65f1bc5ed 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -15,7 +15,7 @@
  */
 package retrofit;
 
-import retrofit.client.Response;
+import com.squareup.okhttp.Response;
 
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
new file mode 100644
index 000000000..db7c14d63
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -0,0 +1,47 @@
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+
+class ExceptionCatchingRequestBody extends ResponseBody {
+  private final ResponseBody delegate;
+  private IOException thrownException;
+
+  ExceptionCatchingRequestBody(ResponseBody delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() {
+    return delegate.contentLength();
+  }
+
+  @Override public BufferedSource source() {
+    return Okio.buffer(new ForwardingSource(delegate.source()) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        try {
+          return super.read(sink, byteCount);
+        } catch (IOException e) {
+          thrownException = e;
+          throw e;
+        }
+      }
+    });
+  }
+
+  IOException getThrownException() {
+    return thrownException;
+  }
+
+  boolean threwException() {
+    return thrownException != null;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java b/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java
deleted file mode 100644
index 40e222b15..000000000
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package retrofit;
-
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.mime.TypedInput;
-
-class ExceptionCatchingTypedInput implements TypedInput {
-  private final TypedInput delegate;
-  private final ExceptionCatchingInputStream delegateStream;
-
-  ExceptionCatchingTypedInput(TypedInput delegate) throws IOException {
-    this.delegate = delegate;
-    this.delegateStream = new ExceptionCatchingInputStream(delegate.in());
-  }
-
-  @Override public String mimeType() {
-    return delegate.mimeType();
-  }
-
-  @Override public long length() {
-    return delegate.length();
-  }
-
-  @Override public InputStream in() throws IOException {
-    return delegateStream;
-  }
-
-  IOException getThrownException() {
-    return delegateStream.thrownException;
-  }
-
-  boolean threwException() {
-    return delegateStream.thrownException != null;
-  }
-
-  private static class ExceptionCatchingInputStream extends InputStream {
-    private final InputStream delegate;
-    private IOException thrownException;
-
-    ExceptionCatchingInputStream(InputStream delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public int read() throws IOException {
-      try {
-        return delegate.read();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer) throws IOException {
-      try {
-        return delegate.read(buffer);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
-      try {
-        return delegate.read(buffer, offset, length);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public long skip(long byteCount) throws IOException {
-      try {
-        return delegate.skip(byteCount);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int available() throws IOException {
-      try {
-        return delegate.available();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      try {
-        delegate.close();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public synchronized void mark(int readLimit) {
-      delegate.mark(readLimit);
-    }
-
-    @Override public synchronized void reset() throws IOException {
-      try {
-        delegate.reset();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public boolean markSupported() {
-      return delegate.markSupported();
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 218ac3bed..928fd1ae8 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -18,7 +18,9 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+import com.squareup.okhttp.OkHttpClient;
 import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
 import retrofit.converter.Converter;
 import retrofit.converter.GsonConverter;
 
@@ -51,6 +53,14 @@ Executor defaultCallbackExecutor() {
     return new Utils.SynchronousExecutor();
   }
 
+  OkHttpClient defaultClient() {
+    OkHttpClient client = new OkHttpClient();
+    client.setConnectTimeout(15, TimeUnit.SECONDS);
+    client.setReadTimeout(15, TimeUnit.SECONDS);
+    client.setWriteTimeout(15, TimeUnit.SECONDS);
+    return client;
+  }
+
   /** Provides sane defaults for operation on Android. */
   private static class Android extends Platform {
     @Override Executor defaultCallbackExecutor() {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index f0e6b552e..ba15b5a2d 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -16,27 +16,22 @@
 package retrofit;
 
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.net.URLEncoder;
 import java.util.Map;
-import retrofit.client.Request;
+import okio.BufferedSink;
 import retrofit.converter.Converter;
 import retrofit.http.Body;
-import retrofit.http.Field;
-import retrofit.http.FieldMap;
-import retrofit.http.Part;
-import retrofit.http.PartMap;
+import retrofit.http.Header;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
-import retrofit.mime.FormUrlEncodedTypedOutput;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
   private static final Headers NO_HEADERS = Headers.of();
@@ -47,9 +42,7 @@
   private final boolean async;
   private final String apiUrl;
 
-  private final FormUrlEncodedTypedOutput formBody;
-  private final MultipartTypedOutput multipartBody;
-  private TypedOutput body;
+  private RequestBody body;
 
   private String relativeUrl;
   private StringBuilder queryParams;
@@ -75,26 +68,6 @@
     if (requestQuery != null) {
       queryParams = new StringBuilder().append('?').append(requestQuery);
     }
-
-    switch (methodInfo.requestType) {
-      case FORM_URL_ENCODED:
-        formBody = new FormUrlEncodedTypedOutput();
-        multipartBody = null;
-        body = formBody;
-        break;
-      case MULTIPART:
-        formBody = null;
-        multipartBody = new MultipartTypedOutput();
-        body = multipartBody;
-        break;
-      case SIMPLE:
-        formBody = null;
-        multipartBody = null;
-        // If present, 'body' will be set in 'setArguments' call.
-        break;
-      default:
-        throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
-    }
   }
 
   @Override public void addHeader(String name, String value) {
@@ -247,9 +220,9 @@ void setArguments(Object[] args) {
           QueryMap queryMap = (QueryMap) annotation;
           addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
         }
-      } else if (annotationType == retrofit.http.Header.class) {
+      } else if (annotationType == Header.class) {
         if (value != null) { // Skip null values.
-          String name = ((retrofit.http.Header) annotation).value();
+          String name = ((Header) annotation).value();
           if (value instanceof Iterable) {
             for (Object iterableValue : (Iterable<?>) value) {
               if (iterableValue != null) { // Skip null values.
@@ -267,90 +240,93 @@ void setArguments(Object[] args) {
             addHeader(name, value.toString());
           }
         }
-      } else if (annotationType == Field.class) {
-        if (value != null) { // Skip null values.
-          Field field = (Field) annotation;
-          String name = field.value();
-          boolean encodeName = field.encodeName();
-          boolean encodeValue = field.encodeValue();
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
-              }
-            }
-          } else {
-            formBody.addField(name, encodeName, value.toString(), encodeValue);
-          }
-        }
-      } else if (annotationType == FieldMap.class) {
-        if (value != null) { // Skip null values.
-          FieldMap fieldMap = (FieldMap) annotation;
-          boolean encodeNames = fieldMap.encodeNames();
-          boolean encodeValues = fieldMap.encodeValues();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " field map contained null key.");
-            }
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
-                  encodeValues);
-            }
-          }
-        }
-      } else if (annotationType == Part.class) {
-        if (value != null) { // Skip null values.
-          String name = ((Part) annotation).value();
-          String transferEncoding = ((Part) annotation).encoding();
-          if (value instanceof TypedOutput) {
-            multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-          } else if (value instanceof String) {
-            multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-          } else {
-            multipartBody.addPart(name, transferEncoding,
-                converter.toBody(value, value.getClass()));
-          }
-        }
-      } else if (annotationType == PartMap.class) {
-        if (value != null) { // Skip null values.
-          String transferEncoding = ((PartMap) annotation).encoding();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " part map contained null key.");
-            }
-            String entryName = entryKey.toString();
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              if (entryValue instanceof TypedOutput) {
-                multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-              } else if (entryValue instanceof String) {
-                multipartBody.addPart(entryName, transferEncoding,
-                    new TypedString((String) entryValue));
-              } else {
-                multipartBody.addPart(entryName, transferEncoding,
-                    converter.toBody(entryValue, entryValue.getClass()));
-              }
-            }
-          }
-        }
+      // TODO bring back form url encoding!
+      //} else if (annotationType == Field.class) {
+      //  if (value != null) { // Skip null values.
+      //    Field field = (Field) annotation;
+      //    String name = field.value();
+      //    boolean encodeName = field.encodeName();
+      //    boolean encodeValue = field.encodeValue();
+      //    if (value instanceof Iterable) {
+      //      for (Object iterableValue : (Iterable<?>) value) {
+      //        if (iterableValue != null) { // Skip null values.
+      //          formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
+      //        }
+      //      }
+      //    } else if (value.getClass().isArray()) {
+      //      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+      //        Object arrayValue = Array.get(value, x);
+      //        if (arrayValue != null) { // Skip null values.
+      //          formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
+      //        }
+      //      }
+      //    } else {
+      //      formBody.addField(name, encodeName, value.toString(), encodeValue);
+      //    }
+      //  }
+      //} else if (annotationType == FieldMap.class) {
+      //  if (value != null) { // Skip null values.
+      //    FieldMap fieldMap = (FieldMap) annotation;
+      //    boolean encodeNames = fieldMap.encodeNames();
+      //    boolean encodeValues = fieldMap.encodeValues();
+      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+      //      Object entryKey = entry.getKey();
+      //      if (entryKey == null) {
+      //        throw new IllegalArgumentException(
+      //            "Parameter #" + (i + 1) + " field map contained null key.");
+      //      }
+      //      Object entryValue = entry.getValue();
+      //      if (entryValue != null) { // Skip null values.
+      //        formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
+      //            encodeValues);
+      //      }
+      //    }
+      //  }
+      // TODO bring back multipart!
+      //} else if (annotationType == Part.class) {
+      //  if (value != null) { // Skip null values.
+      //    String name = ((Part) annotation).value();
+      //    String transferEncoding = ((Part) annotation).encoding();
+      //    if (value instanceof RequestBody) {
+      //      multipartBody.addPart((RequestBody) value);
+      //      multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
+      //    } else if (value instanceof String) {
+      //      multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
+      //    } else {
+      //      multipartBody.addPart(name, transferEncoding,
+      //          converter.toBody(value, value.getClass()));
+      //    }
+      //  }
+      //} else if (annotationType == PartMap.class) {
+      //  if (value != null) { // Skip null values.
+      //    String transferEncoding = ((PartMap) annotation).encoding();
+      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+      //      Object entryKey = entry.getKey();
+      //      if (entryKey == null) {
+      //        throw new IllegalArgumentException(
+      //            "Parameter #" + (i + 1) + " part map contained null key.");
+      //      }
+      //      String entryName = entryKey.toString();
+      //      Object entryValue = entry.getValue();
+      //      if (entryValue != null) { // Skip null values.
+      //        if (entryValue instanceof TypedOutput) {
+      //          multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
+      //        } else if (entryValue instanceof String) {
+      //          multipartBody.addPart(entryName, transferEncoding,
+      //              new TypedString((String) entryValue));
+      //        } else {
+      //          multipartBody.addPart(entryName, transferEncoding,
+      //              converter.toBody(entryValue, entryValue.getClass()));
+      //        }
+      //      }
+      //    }
+      //  }
       } else if (annotationType == Body.class) {
         if (value == null) {
           throw new IllegalArgumentException("Body parameter value must not be null.");
         }
-        if (value instanceof TypedOutput) {
-          body = (TypedOutput) value;
+        if (value instanceof RequestBody) {
+          body = (RequestBody) value;
         } else {
           body = converter.toBody(value, value.getClass());
         }
@@ -362,9 +338,9 @@ void setArguments(Object[] args) {
   }
 
   Request build() {
-    if (multipartBody != null && multipartBody.getPartCount() == 0) {
-      throw new IllegalStateException("Multipart requests must contain at least one part.");
-    }
+    //if (multipartBody != null && multipartBody.getPartCount() == 0) {
+    //  throw new IllegalStateException("Multipart requests must contain at least one part.");
+    //}
 
     String apiUrl = this.apiUrl;
     StringBuilder url = new StringBuilder(apiUrl);
@@ -380,11 +356,11 @@ Request build() {
       url.append(queryParams);
     }
 
-    TypedOutput body = this.body;
+    RequestBody body = this.body;
     Headers.Builder headerBuilder = this.headers;
     if (contentTypeHeader != null) {
       if (body != null) {
-        body = new MimeOverridingTypedOutput(body, contentTypeHeader);
+        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
       } else {
         if (headerBuilder == null) {
           headerBuilder = new Headers.Builder();
@@ -395,32 +371,32 @@ Request build() {
 
     Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
 
-    return new Request(requestMethod, url.toString(), headers, body);
+    return new Request.Builder()
+        .url(url.toString())
+        .method(requestMethod, body)
+        .headers(headers)
+        .build();
   }
 
-  private static class MimeOverridingTypedOutput implements TypedOutput {
-    private final TypedOutput delegate;
-    private final String mimeType;
+  private static class MediaTypeOverridingRequestBody extends RequestBody {
+    private final RequestBody delegate;
+    private final MediaType mediaType;
 
-    MimeOverridingTypedOutput(TypedOutput delegate, String mimeType) {
+    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
       this.delegate = delegate;
-      this.mimeType = mimeType;
-    }
-
-    @Override public String fileName() {
-      return delegate.fileName();
+      this.mediaType = MediaType.parse(mediaType);
     }
 
-    @Override public String mimeType() {
-      return mimeType;
+    @Override public MediaType contentType() {
+      return mediaType;
     }
 
-    @Override public long length() {
-      return delegate.length();
+    @Override public long contentLength() throws IOException {
+      return delegate.contentLength();
     }
 
-    @Override public void writeTo(OutputStream out) throws IOException {
-      delegate.writeTo(out);
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      delegate.writeTo(sink);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index f4a01b398..8ced3ef0b 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -15,6 +15,10 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -25,14 +29,8 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
-import retrofit.client.Client;
-import retrofit.client.OkClient;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.converter.Converter;
 import retrofit.http.Header;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * Adapts a Java interface to a REST API.
@@ -110,10 +108,10 @@
   final Converter converter;
   final ErrorHandler errorHandler;
 
-  private final Client client;
+  private final OkHttpClient client;
   private RxSupport rxSupport;
 
-  private RestAdapter(Endpoint endpoint, Client client, Executor callbackExecutor,
+  private RestAdapter(Endpoint endpoint, OkHttpClient client, Executor callbackExecutor,
       RequestInterceptor requestInterceptor, Converter converter, ErrorHandler errorHandler) {
     this.endpoint = endpoint;
     this.client = client;
@@ -217,32 +215,27 @@ private Throwable handleError(RetrofitError actualError) {
 
     private void invokeAsync(final RestMethodInfo methodInfo, final Request request,
         final Callback callback) {
-      Client.AsyncCallback async = new Client.AsyncCallback() {
-        @Override public void onResponse(Response response) {
+      client.newCall(request).enqueue(new com.squareup.okhttp.Callback() {
+        @Override public void onFailure(Request request, IOException e) {
+          callFailure(callback, RetrofitError.networkError(request.urlString(), e));
+        }
+
+        @Override public void onResponse(Response response) throws IOException {
           try {
             handleAsyncResponse(methodInfo, request, response, callback);
           } catch (RetrofitError e) {
             Throwable throwable = errorHandler.handleError(e);
             if (throwable != e) {
-              e = RetrofitError.unexpectedError(request.getUrl(), throwable);
+              e = RetrofitError.unexpectedError(request.urlString(), throwable);
             }
             callFailure(callback, e);
           } catch (IOException e) {
-            callFailure(callback, RetrofitError.networkError(request.getUrl(), e));
+            callFailure(callback, RetrofitError.networkError(request.urlString(), e));
           } catch (Throwable t) {
-            callFailure(callback, RetrofitError.unexpectedError(request.getUrl(), t));
+            callFailure(callback, RetrofitError.unexpectedError(request.urlString(), t));
           }
         }
-
-        @Override public void onFailure(IOException e) {
-          callFailure(callback, RetrofitError.networkError(request.getUrl(), e));
-        }
-      };
-      try {
-        client.execute(request, async);
-      } catch (RuntimeException e) {
-        callFailure(callback, RetrofitError.unexpectedError(request.getUrl(), e));
-      }
+      });
     }
 
     private Object invokeRx(final RestMethodInfo methodInfo, final Request request) {
@@ -270,13 +263,12 @@ private Object invokeRx(final RestMethodInfo methodInfo, final Request request)
 
     private void handleAsyncResponse(RestMethodInfo methodInfo, Request request, Response response,
         Callback callback) throws IOException {
-      String url = request.getUrl();
       Type type = methodInfo.responseObjectType;
 
-      int statusCode = response.getStatus();
+      int statusCode = response.code();
       if (statusCode < 200 || statusCode >= 300) {
         response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(url, response, converter, type);
+        throw RetrofitError.httpError(request.urlString(), response, converter, type);
       }
 
       // Caller requested the raw Response object directly.
@@ -293,13 +285,13 @@ private void handleAsyncResponse(RestMethodInfo methodInfo, Request request, Res
 
     private void handleAsyncResponseBody(Request request, Response response, Type type,
         Callback callback) throws IOException {
-      TypedInput body = response.getBody();
+      ResponseBody body = response.body();
       if (body == null) {
         callResponse(callback, null, response);
         return;
       }
 
-      ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
+      ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(body);
       try {
         Object convert = converter.fromBody(wrapped, type);
         callResponse(callback, convert, response);
@@ -311,8 +303,8 @@ private void handleAsyncResponseBody(Request request, Response response, Type ty
         }
 
         // The response body was partially read by the converter. Replace it with null.
-        response = Utils.replaceResponseBody(response, null);
-        throw RetrofitError.unexpectedError(request.getUrl(), response, converter, type, e);
+        response = response.newBuilder().body(null).build();
+        throw RetrofitError.unexpectedError(request.urlString(), response, converter, type, e);
       }
     }
 
@@ -352,7 +344,7 @@ private Request createRequest(RestMethodInfo methodInfo, Object[] args) {
    */
   public static class Builder {
     private Endpoint endpoint;
-    private Client client;
+    private OkHttpClient client;
     private Executor callbackExecutor;
     private RequestInterceptor requestInterceptor;
     private Converter converter;
@@ -373,7 +365,7 @@ public Builder setEndpoint(Endpoint endpoint) {
     }
 
     /** The HTTP client used for requests. */
-    public Builder setClient(Client client) {
+    public Builder setClient(OkHttpClient client) {
       if (client == null) {
         throw new NullPointerException("Client may not be null.");
       }
@@ -437,7 +429,7 @@ private void ensureSaneDefaults() {
         converter = Platform.get().defaultConverter();
       }
       if (client == null) {
-        client = new OkClient();
+        client = Platform.get().defaultClient();
       }
       if (callbackExecutor == null) {
         callbackExecutor = Platform.get().defaultCallbackExecutor();
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index 9fb14daf4..cdc45159b 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -15,6 +15,7 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
@@ -25,7 +26,6 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import retrofit.client.Response;
 import retrofit.http.Body;
 import retrofit.http.Field;
 import retrofit.http.FieldMap;
@@ -142,12 +142,14 @@ private void parseMethodAnnotations() {
         if (requestType != RequestType.SIMPLE) {
           throw methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.MULTIPART;
+        throw new UnsupportedOperationException("Multipart shall return!");
+        //requestType = RequestType.MULTIPART;
       } else if (annotationType == FormUrlEncoded.class) {
         if (requestType != RequestType.SIMPLE) {
           throw methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.FORM_URL_ENCODED;
+        throw new UnsupportedOperationException("Form URL encoding shall return!");
+        //requestType = RequestType.FORM_URL_ENCODED;
       } else if (annotationType == Streaming.class) {
         if (responseObjectType != Response.class) {
           throw methodError(
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
index f0a093708..dfaecfe0a 100644
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/RetrofitError.java
@@ -15,11 +15,11 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
-import retrofit.client.Response;
 import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
 
 public class RetrofitError extends RuntimeException {
   public static RetrofitError networkError(String url, IOException exception) {
@@ -35,7 +35,7 @@ public static RetrofitError unexpectedError(String url, Response response, Conve
 
   public static RetrofitError httpError(String url, Response response, Converter converter,
       Type successType) {
-    String message = response.getStatus() + " " + response.getReason();
+    String message = response.code() + " " + response.message();
     return new RetrofitError(message, url, response, converter, successType, Kind.HTTP, null);
   }
 
@@ -117,14 +117,14 @@ public Object getBodyAs(Type type) {
     if (response == null) {
       return null;
     }
-    TypedInput body = response.getBody();
+    ResponseBody body = response.body();
     if (body == null) {
       return null;
     }
     try {
       return converter.fromBody(body, type);
     } catch (IOException e) {
-      throw new RuntimeException(e); // Body is a byte[], can't be a real IO exception.
+      throw new RuntimeException(e); // Body is a Buffer, can't be a real IO exception.
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index f26f34a04..1b9f9ddb4 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,17 +16,16 @@
  */
 package retrofit;
 
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.concurrent.Executor;
-import retrofit.client.Response;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Source;
 
 final class Utils {
-  private static final int BUFFER_SIZE = 0x1000;
-
   static <T> T checkNotNull(T object, String message, Object... args) {
     if (object == null) {
       throw new NullPointerException(String.format(message, args));
@@ -35,53 +34,32 @@
   }
 
   /**
-   * Creates a {@code byte[]} from reading the entirety of an {@link InputStream}. May return an
-   * empty array but never {@code null}.
-   * <p>
-   * Copied from Guava's {@code ByteStreams} class.
-   */
-  static byte[] streamToBytes(InputStream stream) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    if (stream != null) {
-      byte[] buf = new byte[BUFFER_SIZE];
-      int r;
-      while ((r = stream.read(buf)) != -1) {
-        baos.write(buf, 0, r);
-      }
-    }
-    return baos.toByteArray();
-  }
-
-  /**
-   * Conditionally replace a {@link Response} with an identical copy whose body is backed by a
-   * byte[] rather than an input stream.
+   * Replace a {@link Response} with an identical copy whose body is backed by a
+   * {@link Buffer} rather than a {@link Source}.
    */
   static Response readBodyToBytesIfNecessary(Response response) throws IOException {
-    TypedInput body = response.getBody();
-    if (body == null || body instanceof TypedByteArray) {
-      return response;
-    }
+    final ResponseBody body = response.body();
 
-    String bodyMime = body.mimeType();
-    InputStream is = body.in();
-    try {
-      byte[] bodyBytes = Utils.streamToBytes(is);
-      body = new TypedByteArray(bodyMime, bodyBytes);
+    BufferedSource source = body.source();
+    final Buffer buffer = new Buffer();
+    buffer.writeAll(source);
+    source.close();
 
-      return replaceResponseBody(response, body);
-    } finally {
-      if (is != null) {
-        try {
-          is.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-  }
+    return response.newBuilder()
+        .body(new ResponseBody() {
+          @Override public MediaType contentType() {
+            return body.contentType();
+          }
+
+          @Override public long contentLength() {
+            return buffer.size();
+          }
 
-  static Response replaceResponseBody(Response response, TypedInput body) {
-    return new Response(response.getUrl(), response.getStatus(), response.getReason(),
-        response.getHeaders(), body);
+          @Override public BufferedSource source() {
+            return buffer;
+          }
+        })
+        .build();
   }
 
   static <T> void validateServiceClass(Class<T> service) {
diff --git a/retrofit/src/main/java/retrofit/client/Client.java b/retrofit/src/main/java/retrofit/client/Client.java
deleted file mode 100644
index 1712c81e3..000000000
--- a/retrofit/src/main/java/retrofit/client/Client.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.IOException;
-
-/**
- * Abstraction of an HTTP client which can execute {@link Request Requests}. This class must be
- * thread-safe as invocation may happen from multiple threads simultaneously.
- */
-public interface Client {
-  void execute(Request request, AsyncCallback callback);
-
-  interface AsyncCallback {
-    void onResponse(Response response);
-    void onFailure(IOException e);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/OkClient.java b/retrofit/src/main/java/retrofit/client/OkClient.java
deleted file mode 100644
index f77bf8549..000000000
--- a/retrofit/src/main/java/retrofit/client/OkClient.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.TimeUnit;
-import okio.BufferedSink;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-/** Retrofit client that uses OkHttp for communication. */
-public class OkClient implements Client {
-  private static OkHttpClient generateDefaultOkHttp() {
-    OkHttpClient client = new OkHttpClient();
-    client.setConnectTimeout(15, TimeUnit.SECONDS);
-    client.setReadTimeout(15, TimeUnit.SECONDS);
-    client.setWriteTimeout(15, TimeUnit.SECONDS);
-    return client;
-  }
-
-  private final OkHttpClient client;
-
-  public OkClient() {
-    this(generateDefaultOkHttp());
-  }
-
-  public OkClient(OkHttpClient client) {
-    if (client == null) throw new NullPointerException("client == null");
-    this.client = client;
-  }
-
-  @Override public void execute(Request request, final AsyncCallback callback) {
-    client.newCall(createRequest(request)).enqueue(new Callback() {
-      @Override public void onFailure(com.squareup.okhttp.Request request, IOException e) {
-        callback.onFailure(e);
-      }
-
-      @Override public void onResponse(com.squareup.okhttp.Response response) throws IOException {
-        callback.onResponse(parseResponse(response));
-      }
-    });
-  }
-
-  static com.squareup.okhttp.Request createRequest(Request request) {
-    return new com.squareup.okhttp.Request.Builder()
-        .url(request.getUrl())
-        .headers(request.getHeaders())
-        .method(request.getMethod(), createRequestBody(request.getBody()))
-        .build();
-  }
-
-  static Response parseResponse(com.squareup.okhttp.Response response) {
-    return new Response(response.request().urlString(), response.code(), response.message(),
-        response.headers(), createResponseBody(response.body()));
-  }
-
-  private static RequestBody createRequestBody(final TypedOutput body) {
-    if (body == null) {
-      return null;
-    }
-    final MediaType mediaType = MediaType.parse(body.mimeType());
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return mediaType;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        body.writeTo(sink.outputStream());
-      }
-
-      @Override public long contentLength() {
-        return body.length();
-      }
-    };
-  }
-
-  private static TypedInput createResponseBody(final ResponseBody body) {
-    if (body.contentLength() == 0) {
-      return null;
-    }
-    return new TypedInput() {
-      @Override public String mimeType() {
-        MediaType mediaType = body.contentType();
-        return mediaType == null ? null : mediaType.toString();
-      }
-
-      @Override public long length() {
-        return body.contentLength();
-      }
-
-      @Override public InputStream in() throws IOException {
-        return body.byteStream();
-      }
-    };
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Request.java b/retrofit/src/main/java/retrofit/client/Request.java
deleted file mode 100644
index a45b2f587..000000000
--- a/retrofit/src/main/java/retrofit/client/Request.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import com.squareup.okhttp.Headers;
-import retrofit.mime.TypedOutput;
-
-/** Encapsulates all of the information necessary to make an HTTP request. */
-public final class Request {
-  private final String method;
-  private final String url;
-  private final Headers headers;
-  private final TypedOutput body;
-
-  public Request(String method, String url, Headers headers, TypedOutput body) {
-    if (method == null) {
-      throw new NullPointerException("Method must not be null.");
-    }
-    if (url == null) {
-      throw new NullPointerException("URL must not be null.");
-    }
-    if (headers == null) {
-      throw new NullPointerException("Headers must not be null.");
-    }
-    this.method = method;
-    this.url = url;
-    this.headers = headers;
-    this.body = body;
-  }
-
-  /** HTTP method verb. */
-  public String getMethod() {
-    return method;
-  }
-
-  /** Target URL. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Returns an unmodifiable list of headers. May be {@code null}. */
-  public Headers getHeaders() {
-    return headers;
-  }
-
-  /** Returns the request body or {@code null}. */
-  public TypedOutput getBody() {
-    return body;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Response.java b/retrofit/src/main/java/retrofit/client/Response.java
deleted file mode 100644
index 940182f5d..000000000
--- a/retrofit/src/main/java/retrofit/client/Response.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import com.squareup.okhttp.Headers;
-import retrofit.mime.TypedInput;
-
-/**
- * An HTTP response.
- * <p>
- * When used directly as a data type for an interface method, the response body is buffered to a
- * {@code byte[]}. Annotate the method with {@link retrofit.http.Streaming @Streaming} for an
- * unbuffered stream from the network.
- */
-public final class Response {
-  private final String url;
-  private final int status;
-  private final String reason;
-  private final Headers headers;
-  private final TypedInput body;
-
-  public Response(String url, int status, String reason, Headers headers, TypedInput body) {
-    if (url == null) {
-      throw new IllegalArgumentException("url == null");
-    }
-    if (status < 200) {
-      throw new IllegalArgumentException("Invalid status code: " + status);
-    }
-    if (reason == null) {
-      throw new IllegalArgumentException("reason == null");
-    }
-    if (headers == null) {
-      throw new IllegalArgumentException("headers == null");
-    }
-
-    this.url = url;
-    this.status = status;
-    this.reason = reason;
-    this.headers = headers;
-    this.body = body;
-  }
-
-  /** Request URL. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Status line code. */
-  public int getStatus() {
-    return status;
-  }
-
-  /** Status line reason phrase. */
-  public String getReason() {
-    return reason;
-  }
-
-  /** An unmodifiable collection of headers. */
-  public Headers getHeaders() {
-    return headers;
-  }
-
-  /** Response body. May be {@code null}. */
-  public TypedInput getBody() {
-    return body;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/converter/Converter.java
index f038978ed..8c93f9934 100644
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ b/retrofit/src/main/java/retrofit/converter/Converter.java
@@ -15,10 +15,10 @@
  */
 package retrofit.converter;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * Arbiter for converting objects to and from their representation in HTTP.
@@ -31,7 +31,7 @@
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
    */
-  Object fromBody(TypedInput body, Type type) throws IOException;
+  Object fromBody(ResponseBody body, Type type) throws IOException;
 
   /**
    * Convert an object to an appropriate representation for HTTP transport.
@@ -39,5 +39,5 @@
    * @param object Object instance to convert.
    * @return Representation of the specified object as bytes.
    */
-  TypedOutput toBody(Object object, Type type);
+  RequestBody toBody(Object object, Type type);
 }
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
index 3c2211b1d..746194dca 100644
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
@@ -16,21 +16,22 @@
 package retrofit.converter;
 
 import com.google.gson.Gson;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
-import retrofit.mime.MimeUtil;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import java.nio.charset.Charset;
 
 /**
  * A {@link Converter} which uses GSON for serialization and deserialization of entities.
  */
 public class GsonConverter implements Converter {
   private final Gson gson;
-  private final String charset;
+  private final Charset charset;
+  private final MediaType mediaType;
 
   /**
    * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
@@ -45,69 +46,38 @@ public GsonConverter() {
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
    */
   public GsonConverter(Gson gson) {
-    this(gson, "UTF-8");
+    this(gson, Charset.forName("UTF-8"));
   }
 
   /**
    * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use the specified charset.
    */
-  public GsonConverter(Gson gson, String charset) {
+  public GsonConverter(Gson gson, Charset charset) {
     this.gson = gson;
     this.charset = charset;
+    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
-    String charset = this.charset;
-    if (body.mimeType() != null) {
-      charset = MimeUtil.parseCharset(body.mimeType(), charset);
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    Charset charset = this.charset;
+    if (body.contentType() != null) {
+      charset = body.contentType().charset(charset);
     }
-    InputStreamReader isr = null;
+
+    InputStream is = body.byteStream();
     try {
-      isr = new InputStreamReader(body.in(), charset);
-      return gson.fromJson(isr, type);
+      return gson.fromJson(new InputStreamReader(is, charset), type);
     } finally {
-      if (isr != null) {
-        try {
-          isr.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        is.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
-    try {
-      String json = gson.toJson(object, type);
-      return new JsonTypedOutput(json.getBytes(charset), charset);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static class JsonTypedOutput implements TypedOutput {
-    private final byte[] jsonBytes;
-    private final String mimeType;
-
-    JsonTypedOutput(byte[] jsonBytes, String encode) {
-      this.jsonBytes = jsonBytes;
-      this.mimeType = "application/json; charset=" + encode;
-    }
-
-    @Override public String fileName() {
-      return null;
-    }
-
-    @Override public String mimeType() {
-      return mimeType;
-    }
-
-    @Override public long length() {
-      return jsonBytes.length;
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      out.write(jsonBytes);
-    }
+  @Override public RequestBody toBody(Object object, Type type) {
+    String json = gson.toJson(object, type);
+    return RequestBody.create(mediaType, json);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 2e7de1166..e4f26800c 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -21,7 +21,6 @@
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static retrofit.mime.MultipartTypedOutput.DEFAULT_TRANSFER_ENCODING;
 
 /**
  * Denotes a single part of a multi-part request.
@@ -55,5 +54,5 @@
 public @interface Part {
   String value();
   /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default DEFAULT_TRANSFER_ENCODING;
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index d8fb9942b..83aaebb82 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -21,7 +21,6 @@
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static retrofit.mime.MultipartTypedOutput.DEFAULT_TRANSFER_ENCODING;
 
 /**
  * Denotes name and value parts of a multi-part request
@@ -51,5 +50,5 @@
 @Retention(RUNTIME)
 public @interface PartMap {
   /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default DEFAULT_TRANSFER_ENCODING;
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java b/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
deleted file mode 100644
index dc3a865d7..000000000
--- a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.URLEncoder;
-
-public final class FormUrlEncodedTypedOutput implements TypedOutput {
-  final ByteArrayOutputStream content = new ByteArrayOutputStream();
-
-  public void addField(String name, String value) {
-    addField(name, true, value, true);
-  }
-
-  public void addField(String name, boolean encodeName, String value, boolean encodeValue) {
-    if (name == null) {
-      throw new NullPointerException("name");
-    }
-    if (value == null) {
-      throw new NullPointerException("value");
-    }
-    if (content.size() > 0) {
-      content.write('&');
-    }
-    try {
-      if (encodeName) {
-        name = URLEncoder.encode(name, "UTF-8");
-      }
-      if (encodeValue) {
-        value = URLEncoder.encode(value, "UTF-8");
-      }
-
-      content.write(name.getBytes("UTF-8"));
-      content.write('=');
-      content.write(value.getBytes("UTF-8"));
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return "application/x-www-form-urlencoded; charset=UTF-8";
-  }
-
-  @Override public long length() {
-    return content.size();
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(content.toByteArray());
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/MimeUtil.java b/retrofit/src/main/java/retrofit/mime/MimeUtil.java
deleted file mode 100644
index d96b57a3c..000000000
--- a/retrofit/src/main/java/retrofit/mime/MimeUtil.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import static java.util.regex.Pattern.CASE_INSENSITIVE;
-
-public final class MimeUtil {
-  private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
-
-  /**
-   * Parse the MIME type from a {@code Content-Type} header value or default to "UTF-8".
-   *
-   * @deprecated Use {@link #parseCharset(String, String)}.
-   */
-  @Deprecated
-  public static String parseCharset(String mimeType) {
-    return parseCharset(mimeType, "UTF-8");
-  }
-
-  /** Parse the MIME type from a {@code Content-Type} header value. */
-  public static String parseCharset(String mimeType, String defaultCharset) {
-    Matcher match = CHARSET.matcher(mimeType);
-    if (match.find()) {
-      return match.group(1).replaceAll("[\"\\\\]", "");
-    }
-    return defaultCharset;
-  }
-
-  private MimeUtil() {
-    // No instances.
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
deleted file mode 100644
index 8067cfdd7..000000000
--- a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.UUID;
-
-public final class MultipartTypedOutput implements TypedOutput {
-  public static final String DEFAULT_TRANSFER_ENCODING = "binary";
-
-  private static final class MimePart {
-    private final TypedOutput body;
-    private final String name;
-    private final String transferEncoding;
-    private final boolean isFirst;
-    private final String boundary;
-
-    private byte[] partBoundary;
-    private byte[] partHeader;
-    private boolean isBuilt;
-
-    public MimePart(String name, String transferEncoding, TypedOutput body, String boundary,
-        boolean isFirst) {
-      this.name = name;
-      this.transferEncoding = transferEncoding;
-      this.body = body;
-      this.isFirst = isFirst;
-      this.boundary = boundary;
-    }
-
-    public void writeTo(OutputStream out) throws IOException {
-      build();
-      out.write(partBoundary);
-      out.write(partHeader);
-      body.writeTo(out);
-    }
-
-    public long size() {
-      build();
-      if (body.length() > -1) {
-        return body.length() + partBoundary.length + partHeader.length;
-      } else {
-        return -1;
-      }
-    }
-
-    private void build() {
-      if (isBuilt) return;
-      partBoundary = buildBoundary(boundary, isFirst, false);
-      partHeader = buildHeader(name, transferEncoding, body);
-      isBuilt = true;
-    }
-  }
-
-  private final List<MimePart> mimeParts = new LinkedList<MimePart>();
-
-  private final byte[] footer;
-  private final String boundary;
-  private long length;
-
-  public MultipartTypedOutput() {
-    this(UUID.randomUUID().toString());
-  }
-
-  MultipartTypedOutput(String boundary) {
-    this.boundary = boundary;
-    footer = buildBoundary(boundary, false, true);
-    length = footer.length;
-  }
-
-  List<byte[]> getParts() throws IOException {
-    List<byte[]> parts = new ArrayList<byte[]>(mimeParts.size());
-    for (MimePart part : mimeParts) {
-      ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      part.writeTo(bos);
-      parts.add(bos.toByteArray());
-    }
-    return parts;
-  }
-
-  public void addPart(String name, TypedOutput body) {
-    addPart(name, DEFAULT_TRANSFER_ENCODING, body);
-  }
-
-  public void addPart(String name, String transferEncoding, TypedOutput body) {
-    if (name == null) {
-      throw new NullPointerException("Part name must not be null.");
-    }
-    if (transferEncoding == null) {
-      throw new NullPointerException("Transfer encoding must not be null.");
-    }
-    if (body == null) {
-      throw new NullPointerException("Part body must not be null.");
-    }
-
-    MimePart part = new MimePart(name, transferEncoding, body, boundary, mimeParts.isEmpty());
-    mimeParts.add(part);
-
-    long size = part.size();
-    if (size == -1) {
-      length = -1;
-    } else if (length != -1) {
-      length += size;
-    }
-  }
-
-  public int getPartCount() {
-    return mimeParts.size();
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return "multipart/form-data; boundary=" + boundary;
-  }
-
-  @Override public long length() {
-    return length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    for (MimePart part : mimeParts) {
-      part.writeTo(out);
-    }
-    out.write(footer);
-  }
-
-  private static byte[] buildBoundary(String boundary, boolean first, boolean last) {
-    try {
-      // Pre-size for the last boundary, the worst case scenario.
-      StringBuilder sb = new StringBuilder(boundary.length() + 8);
-
-      if (!first) {
-        sb.append("\r\n");
-      }
-      sb.append("--");
-      sb.append(boundary);
-      if (last) {
-        sb.append("--");
-      }
-      sb.append("\r\n");
-      return sb.toString().getBytes("UTF-8");
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart boundary", ex);
-    }
-  }
-
-  private static byte[] buildHeader(String name, String transferEncoding, TypedOutput value) {
-    try {
-      // Initial size estimate based on always-present strings and conservative value lengths.
-      StringBuilder headers = new StringBuilder(128);
-
-      headers.append("Content-Disposition: form-data; name=\"");
-      headers.append(name);
-
-      String fileName = value.fileName();
-      if (fileName != null) {
-        headers.append("\"; filename=\"");
-        headers.append(fileName);
-      }
-
-      headers.append("\"\r\nContent-Type: ");
-      headers.append(value.mimeType());
-
-      long length = value.length();
-      if (length != -1) {
-        headers.append("\r\nContent-Length: ").append(length);
-      }
-
-      headers.append("\r\nContent-Transfer-Encoding: ");
-      headers.append(transferEncoding);
-      headers.append("\r\n\r\n");
-
-      return headers.toString().getBytes("UTF-8");
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart header", ex);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java b/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
deleted file mode 100644
index 3403684fc..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-
-/**
- * Byte array and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedByteArray implements TypedInput, TypedOutput {
-  private final String mimeType;
-  private final byte[] bytes;
-
-  /**
-   * Constructs a new typed byte array.  Sets mimeType to {@code application/unknown} if absent.
-   *
-   * @throws NullPointerException if bytes are null
-   */
-  public TypedByteArray(String mimeType, byte[] bytes) {
-    if (mimeType == null) {
-      mimeType = "application/unknown";
-    }
-    if (bytes == null) {
-      throw new NullPointerException("bytes");
-    }
-    this.mimeType = mimeType;
-    this.bytes = bytes;
-  }
-
-  public byte[] getBytes() {
-    return bytes;
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return mimeType;
-  }
-
-  @Override public long length() {
-    return bytes.length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(bytes);
-  }
-
-  @Override public InputStream in() throws IOException {
-    return new ByteArrayInputStream(bytes);
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    TypedByteArray that = (TypedByteArray) o;
-
-    if (!Arrays.equals(bytes, that.bytes)) return false;
-    if (!mimeType.equals(that.mimeType)) return false;
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = mimeType.hashCode();
-    result = 31 * result + Arrays.hashCode(bytes);
-    return result;
-  }
-
-  @Override public String toString() {
-    return "TypedByteArray[length=" + length() + "]";
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedFile.java b/retrofit/src/main/java/retrofit/mime/TypedFile.java
deleted file mode 100644
index 43fcd3a07..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedFile.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/**
- * File and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedFile implements TypedInput, TypedOutput {
-  private static final int BUFFER_SIZE = 4096;
-
-  private final String mimeType;
-  private final File file;
-
-  /**
-   * Constructs a new typed file.
-   *
-   * @throws NullPointerException if file or mimeType is null
-   */
-  public TypedFile(String mimeType, File file) {
-    if (mimeType == null) {
-      throw new NullPointerException("mimeType");
-    }
-    if (file == null) {
-      throw new NullPointerException("file");
-    }
-    this.mimeType = mimeType;
-    this.file = file;
-  }
-
-  /** Returns the file. */
-  public File file() {
-    return file;
-  }
-
-  @Override public String mimeType() {
-    return mimeType;
-  }
-
-  @Override public long length() {
-    return file.length();
-  }
-
-  @Override public String fileName() {
-    return file.getName();
-  }
-
-  @Override public InputStream in() throws IOException {
-    return new FileInputStream(file);
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    byte[] buffer = new byte[BUFFER_SIZE];
-    FileInputStream in = new FileInputStream(file);
-    try {
-      int read;
-      while ((read = in.read(buffer)) != -1) {
-        out.write(buffer, 0, read);
-      }
-    } finally {
-      in.close();
-    }
-  }
-
-  /**
-   * Atomically moves the contents of this file to a new location.
-   *
-   * @param destination file
-   * @throws java.io.IOException if the move fails
-   */
-  public void moveTo(TypedFile destination) throws IOException {
-    if (!mimeType().equals(destination.mimeType())) {
-      throw new IOException("Type mismatch.");
-    }
-    if (!file.renameTo(destination.file())) {
-      throw new IOException("Rename failed!");
-    }
-  }
-
-  @Override public String toString() {
-    return file.getAbsolutePath() + " (" + mimeType() + ")";
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o instanceof TypedFile) {
-      TypedFile rhs = (TypedFile) o;
-      return file.equals(rhs.file);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    return file.hashCode();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedInput.java b/retrofit/src/main/java/retrofit/mime/TypedInput.java
deleted file mode 100644
index f05afb84d..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedInput.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Binary data with an associated mime type.
- *
- * @author Jake Wharton (jw@squareup.com)
- */
-public interface TypedInput {
-
-  /** Returns the mime type. */
-  String mimeType();
-
-  /** Length in bytes. Returns {@code -1} if length is unknown. */
-  long length();
-
-  /**
-   * Read bytes as stream. Unless otherwise specified, this method may only be called once. It is
-   * the responsibility of the caller to close the stream.
-   */
-  InputStream in() throws IOException;
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedOutput.java b/retrofit/src/main/java/retrofit/mime/TypedOutput.java
deleted file mode 100644
index f15055f8f..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedOutput.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Binary data with an associated mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public interface TypedOutput {
-  /** Original filename.
-   *
-   * Used only for multipart requests, may be null. */
-  String fileName();
-
-  /** Returns the mime type. */
-  String mimeType();
-
-  /** Length in bytes or -1 if unknown. */
-  long length();
-
-  /** Writes these bytes to the given output stream. */
-  void writeTo(OutputStream out) throws IOException;
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedString.java b/retrofit/src/main/java/retrofit/mime/TypedString.java
deleted file mode 100644
index 087caa870..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedString.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.UnsupportedEncodingException;
-
-public class TypedString extends TypedByteArray {
-
-  public TypedString(String string) {
-    super("text/plain; charset=UTF-8", convertToBytes(string));
-  }
-
-  private static byte[] convertToBytes(String string) {
-    try {
-      return string.getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Override public String toString() {
-    try {
-      return "TypedString[" + new String(getBytes(), "UTF-8") + "]";
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError("Must be able to decode UTF-8");
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
index 2d153d0c5..7eb38142c 100644
--- a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
+++ b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
@@ -1,16 +1,17 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.client.Client;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.http.GET;
 import rx.Observable;
 import rx.Observer;
 
+import static com.squareup.okhttp.Protocol.HTTP_1_1;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.junit.Assert.fail;
@@ -34,22 +35,27 @@
   static class TestException extends Exception {
   }
 
-  /* An HTTP client which always returns a 400 response */
-  static class MockInvalidResponseClient implements Client {
-    @Override public void execute(Request request, AsyncCallback callback) {
-      callback.onResponse(new Response("", 400, "invalid request", Headers.of(), null));
-    }
-  }
-
-  ExampleClient client;
+  ExampleClient example;
   ErrorHandler errorHandler;
 
   @Before public void setup() {
     errorHandler = mock(ErrorHandler.class);
 
-    client = new RestAdapter.Builder() //
+    OkHttpClient client = new OkHttpClient();
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return new Response.Builder()
+            .code(400)
+            .message("Invalid")
+            .request(chain.request())
+            .protocol(HTTP_1_1)
+            .build();
+      }
+    });
+
+    example = new RestAdapter.Builder() //
         .setEndpoint("http://example.com")
-        .setClient(new MockInvalidResponseClient())
+        .setClient(client)
         .setErrorHandler(errorHandler)
         .setCallbackExecutor(new Utils.SynchronousExecutor())
         .build()
@@ -61,7 +67,7 @@
     doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
 
     try {
-      client.throwsCustomException();
+      example.throwsCustomException();
       failBecauseExceptionWasNotThrown(TestException.class);
     } catch (TestException e) {
       assertThat(e).isSameAs(exception);
@@ -72,7 +78,7 @@
     final TestException exception = new TestException();
     doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
 
-    client.onErrorWrappedCustomException(new Callback<Response>() {
+    example.onErrorWrappedCustomException(new Callback<Response>() {
 
       @Override public void success(Response response, Response response2) {
         failBecauseExceptionWasNotThrown(TestException.class);
@@ -88,7 +94,7 @@
     final TestException exception = new TestException();
     doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
 
-    client.onErrorCustomException().subscribe(new Observer<Response>() {
+    example.onErrorCustomException().subscribe(new Observer<Response>() {
       @Override public void onCompleted() {
         failBecauseExceptionWasNotThrown(TestException.class);
       }
@@ -107,7 +113,7 @@
     doReturn(null).when(errorHandler).handleError(any(RetrofitError.class));
 
     try {
-      client.throwsCustomException();
+      example.throwsCustomException();
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).isEqualTo("Error handler returned null for wrapped exception.");
diff --git a/retrofit/src/test/java/retrofit/MockClient.java b/retrofit/src/test/java/retrofit/MockClient.java
new file mode 100644
index 000000000..20ed8b3ea
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/MockClient.java
@@ -0,0 +1,49 @@
+package retrofit;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+
+import static com.squareup.okhttp.Protocol.HTTP_1_1;
+
+final class MockClient implements Interceptor {
+  private Deque<Object> events = new ArrayDeque<Object>();
+  private Deque<Request> requests = new ArrayDeque<Request>();
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request request = chain.request();
+    requests.addLast(request);
+
+    Object event = events.removeFirst();
+    if (event instanceof IOException) {
+      throw (IOException) event;
+    }
+    if (event instanceof RuntimeException) {
+      throw (RuntimeException) event;
+    }
+    if (event instanceof Response.Builder) {
+      Response.Builder response = (Response.Builder) event;
+      return response.request(request).protocol(HTTP_1_1).build();
+    }
+    throw new IllegalStateException("Unknown event " + event.getClass());
+  }
+
+  public void enqueueResponse(Response.Builder response) {
+    events.addLast(response);
+  }
+
+  public void enqueueUnexpectedException(RuntimeException exception) {
+    events.addLast(exception);
+  }
+
+  public void enqueueIOException(IOException exception) {
+    events.addLast(exception);
+  }
+
+  public Request takeRequest() {
+    return requests.removeFirst();
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 5af756e05..bd74aff23 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -2,32 +2,32 @@
 package retrofit;
 
 import com.google.gson.Gson;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
 import java.util.Arrays;
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okio.Buffer;
+import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.converter.Converter;
 import retrofit.converter.GsonConverter;
 import retrofit.http.Body;
 import retrofit.http.DELETE;
 import retrofit.http.Field;
 import retrofit.http.FieldMap;
-import retrofit.http.FormUrlEncoded;
 import retrofit.http.GET;
 import retrofit.http.HEAD;
+import retrofit.http.Header;
 import retrofit.http.Headers;
-import retrofit.http.Multipart;
 import retrofit.http.PATCH;
 import retrofit.http.POST;
 import retrofit.http.PUT;
@@ -38,14 +38,8 @@
 import retrofit.http.QueryMap;
 import retrofit.http.RestMethod;
 import retrofit.http.Streaming;
-import retrofit.mime.MimeHelper;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 import rx.Observable;
 
-import static com.google.common.base.Charsets.UTF_8;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -93,9 +87,9 @@ Response method() {
     }
 
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("CUSTOM1");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("CUSTOM1");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.body()).isNull();
   }
 
   @RestMethod(value = "CUSTOM2", hasBody = true)
@@ -104,53 +98,55 @@ Response method() {
     String value();
   }
 
+  @Ignore // TODO https://github.com/square/okhttp/issues/229
   @Test public void custom2Method() {
     class Example {
       @CUSTOM2("/foo") //
-      Response method(@Body TypedInput body) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, new TypedString("hi"));
-    assertThat(request.getMethod()).isEqualTo("CUSTOM2");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo");
-    assertTypedBytes(request.getBody(), "hi");
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-    }
-  }
+      Response method(@Body RequestBody body) {
+        return null;
+      }
+    }
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("CUSTOM2");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertBody(request.body(), "hi");
+  }
+
+  //@Test public void onlyOneEncodingIsAllowedMultipartFirst() {
+  //  class Example {
+  //    @Multipart //
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+  //  }
+  //}
+  //
+  //@Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @Multipart //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+  //  }
+  //}
 
   @Test public void invalidPathParam() throws Exception {
     class Example {
@@ -383,38 +379,38 @@ Response method(@PartMap Map<String, String> params) {
     }
   }
 
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
-    }
-  }
+  //@Test public void multipartFailsOnNonBodyMethod() {
+  //  class Example {
+  //    @Multipart //
+  //    @GET("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+  //  }
+  //}
+  //
+  //@Test public void multipartFailsWithNoParts() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
+  //  }
+  //}
 
   @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
@@ -448,38 +444,38 @@ Response method(@FieldMap Map<String, String> a) {
     }
   }
 
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
-    }
-  }
+  //@Test public void formEncodingFailsOnNonBodyMethod() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @GET("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
+  //  }
+  //}
+  //
+  //@Test public void formEncodingFailsWithNoParts() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
+  //  }
+  //}
 
   @Test public void headersFailWhenEmptyOnMethod() {
     class Example {
@@ -610,22 +606,22 @@ Response method(@Body int o1, @Body int o2) {
     }
   }
 
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Response method(@Part("one") int o1, @Body int o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
-    }
-  }
+  //@Test public void bodyInNonBodyRequest() {
+  //  class Example {
+  //    @Multipart //
+  //    @PUT("/") //
+  //    Response method(@Part("one") int o1, @Body int o2) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
+  //  }
+  //}
 
   @Test public void get() {
     class Example {
@@ -635,10 +631,10 @@ Response method() {
       }
     }
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void delete() {
@@ -649,10 +645,10 @@ Response method() {
       }
     }
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("DELETE");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("DELETE");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "");
   }
 
   @Test public void head() {
@@ -663,52 +659,55 @@ Response method() {
       }
     }
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("HEAD");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("HEAD");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "hi");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
   }
 
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
-    assertThat(request.getMethod()).isEqualTo("PUT");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "hi");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
   }
 
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
-    assertThat(request.getMethod()).isEqualTo("PATCH");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "hi");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PATCH");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
   }
 
   @Test public void getWithPathParam() {
@@ -719,10 +718,10 @@ Response method(@Path("ping") String ping) {
       }
     }
     Request request = buildRequest(Example.class, "po ng");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodedPathParam() {
@@ -733,10 +732,10 @@ Response method(@Path(value = "ping", encode = false) String ping) {
       }
     }
     Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithInterceptorPathParam() {
@@ -752,10 +751,10 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithInterceptorEncodedPathParam() {
@@ -771,10 +770,10 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathParamAndInterceptorPathParam() {
@@ -790,10 +789,10 @@ Response method(@Path("ping") String ping) {
       }
     };
     Request request = buildRequest(Example.class, "pong");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithInterceptorQueryParam() {
@@ -809,10 +808,10 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=po+ng");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=po+ng");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathParamAndInterceptorQueryParam() {
@@ -828,10 +827,10 @@ Response method(@Path("kit") String kit) {
       }
     };
     Request request = buildRequest(Example.class, "kat");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/kat/?ping=pong");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/kat/?ping=pong");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithInterceptorPathParamAndInterceptorQueryParam() {
@@ -848,10 +847,10 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathParamAndInterceptorPathParamAndInterceptorQueryParam() {
@@ -868,10 +867,10 @@ Response method(@Path("ping") String ping) {
       }
     };
     Request request = buildRequest(Example.class, "pong");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void pathParamRequired() {
@@ -897,10 +896,10 @@ Response method(@Query("ping") String ping) {
       }
     }
     Request request = buildRequest(Example.class, "pong");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodedQueryParam() {
@@ -911,10 +910,10 @@ Response method(@Query(value = "ping", encodeValue = false) String ping) {
       }
     }
     Request request = buildRequest(Example.class, "p+o+n+g");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodeNameQueryParam() {
@@ -925,10 +924,10 @@ Response method(@Query(value = "pi ng", encodeName = true) String ping) {
       }
     }
     Request request = buildRequest(Example.class, "pong");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?pi+ng=pong");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=pong");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodeNameEncodedValueQueryParam() {
@@ -939,10 +938,10 @@ Response method(@Query(value = "pi ng", encodeName = true, encodeValue = false)
       }
     }
     Request request = buildRequest(Example.class, "po+ng");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?pi+ng=po+ng");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=po+ng");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void queryParamOptionalOmitsQuery() {
@@ -953,7 +952,7 @@ Response method(@Query("ping") String ping) {
       }
     }
     Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
   }
 
   @Test public void queryParamOptional() {
@@ -965,7 +964,7 @@ Response method(@Query("foo") String foo, @Query("ping") String ping,
       }
     }
     Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
   }
 
   @Test public void getWithQueryUrlAndParam() {
@@ -976,10 +975,10 @@ Response method(@Query("ping") String ping) {
       }
     }
     Request request = buildRequest(Example.class, "pong");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithQuery() {
@@ -990,10 +989,10 @@ Response method() {
       }
     }
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryParam() {
@@ -1006,10 +1005,10 @@ Response method(@Path("ping") String ping, @Query("kit") String kit,
     }
 
     Request request = buildRequest(Example.class, "pong", "kat", "raff");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryQuestionMarkParam() {
@@ -1021,10 +1020,10 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
     }
 
     Request request = buildRequest(Example.class, "pong?", "kat?");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryAmpersandParam() {
@@ -1036,10 +1035,10 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
     }
 
     Request request = buildRequest(Example.class, "pong&", "kat&");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryHashParam() {
@@ -1051,10 +1050,10 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
     }
 
     Request request = buildRequest(Example.class, "pong#", "kat#");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithQueryParamList() {
@@ -1067,10 +1066,10 @@ Response method(@Query("key") List<Object> keys) {
 
     List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
     Request request = buildRequest(Example.class, values);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithQueryParamArray() {
@@ -1083,10 +1082,10 @@ Response method(@Query("key") Object[] keys) {
 
     Object[] values = { 1, 2, null, "three" };
     Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithQueryParamPrimitiveArray() {
@@ -1099,10 +1098,10 @@ Response method(@Query("key") int[] keys) {
 
     int[] values = { 1, 2, 3 };
     Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithQueryParamMap() {
@@ -1119,10 +1118,10 @@ Response method(@QueryMap Map<String, Object> query) {
     params.put("ping", "pong");
 
     Request request = buildRequest(Example.class, params);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodedQueryParamMap() {
@@ -1139,10 +1138,10 @@ Response method(@QueryMap(encodeValues = false) Map<String, Object> query) {
     params.put("ping", "p%20g");
 
     Request request = buildRequest(Example.class, params);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&ping=p%20g");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&ping=p%20g");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodeNameQueryParamMap() {
@@ -1159,10 +1158,10 @@ Response method(@QueryMap(encodeNames = true) Map<String, Object> query) {
     params.put("pi ng", "p g");
 
     Request request = buildRequest(Example.class, params);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void getWithEncodeNameEncodedValueQueryParamMap() {
@@ -1180,10 +1179,10 @@ Response method(
     params.put("pi ng", "p%20g");
 
     Request request = buildRequest(Example.class, params);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void normalPostWithPathParam() {
@@ -1194,10 +1193,10 @@ Response method(@Path("ping") String ping) {
       }
     }
     Request request = buildRequest(Example.class, "pong");
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertBody(request.body(), "");
   }
 
   @Test public void bodyGson() {
@@ -1208,30 +1207,31 @@ Response method(@Body Object body) {
       }
     }
     Request request = buildRequest(Example.class, Arrays.asList("quick", "brown", "fox"));
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
   }
 
   @Test public void bodyTypedInput() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "hi");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
   }
 
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1252,377 +1252,377 @@ Response method(@Path("ping") String ping, @Body Object body, @Path("kit") Strin
     }
     Request request =
         buildRequest(Example.class, "pong", Arrays.asList("quick", "brown", "fox"), "kat");
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-
-  @Test public void simpleMultipart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@Part("ping") String ping, @Part("kit") TypedInput kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), UTF_8);
-    assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-
-    String two = new String(iterator.next(), UTF_8);
-    assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  }
-
-  @Test public void multipartWithEncoding() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") TypedInput kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), UTF_8);
-    assertThat(one).contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .endsWith("\r\npong");
-
-    String two = new String(iterator.next(), UTF_8);
-    assertThat(two).contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .endsWith("\r\nkat");
-  }
-
-  @Test public void multipartPartMap() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@PartMap Map<String, Object> parts) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("ping", "pong");
-    params.put("kit", new TypedString("kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), UTF_8);
-    assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-
-    String two = new String(iterator.next(), UTF_8);
-    assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  }
-
-  @Test public void multipartPartMapWithEncoding() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("ping", "pong");
-    params.put("kit", new TypedString("kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), UTF_8);
-    assertThat(one).contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .endsWith("\r\npong");
-
-    String two = new String(iterator.next(), UTF_8);
-    assertThat(two).contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .endsWith("\r\nkat");
-  }
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@PartMap Map<String, Object> parts) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("ping", "pong");
-    params.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter #1 part map contained null key.");
-    }
-  }
-
-  @Test public void multipartNullRemovesPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@Part("ping") String ping, @Part("fizz") String fizz) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong", null);
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders().size()).isZero();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(1);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), UTF_8);
-    assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
-  }
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@Part("ping") TypedInput ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertTypedBytes(request.getBody(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field(value = "na+me", encodeName = false) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba r");
-    assertTypedBytes(request.getBody(), "na+me=ba+r");
-  }
-
-  @Test public void formEncodedWithEncodedValueFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field(value = "na me", encodeValue = false) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba+r");
-    assertTypedBytes(request.getBody(), "na+me=ba+r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertTypedBytes(request.getBody(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertTypedBytes(request.getBody(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertTypedBytes(request.getBody(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertTypedBytes(request.getBody(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("k+it", "k at");
-    fieldMap.put("pin+g", "po ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertTypedBytes(request.getBody(), "k+it=k+at&pin+g=po+ng");
-  }
-
-  @Test public void formEncodedWithEncodedValueFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("k it", "k+at");
-    fieldMap.put("pin g", "po+ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertTypedBytes(request.getBody(), "k+it=k+at&pin+g=po+ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertTypedBytes(request.getBody(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter #1 field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
-    }
-  }
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
+  }
+  //
+  //@Test public void simpleMultipart() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") String ping, @Part("kit") TypedInput kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartWithEncoding() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part(value = "ping", encoding = "8-bit") String ping,
+  //        @Part(value = "kit", encoding = "7-bit") TypedInput kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n")
+  //      .contains("Content-Transfer-Encoding: 8-bit")
+  //      .endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"")
+  //      .contains("Content-Transfer-Encoding: 7-bit")
+  //      .endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartPartMap() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put("kit", new TypedString("kat"));
+  //
+  //  Request request = buildRequest(Example.class, params);
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartPartMapWithEncoding() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put("kit", new TypedString("kat"));
+  //
+  //  Request request = buildRequest(Example.class, params);
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n")
+  //      .contains("Content-Transfer-Encoding: 8-bit")
+  //      .endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"")
+  //      .contains("Content-Transfer-Encoding: 8-bit")
+  //      .endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartPartMapRejectsNullKeys() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put(null, "kat");
+  //
+  //  try {
+  //    buildRequest(Example.class, params);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Parameter #1 part map contained null key.");
+  //  }
+  //}
+  //
+  //@Test public void multipartNullRemovesPart() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") String ping, @Part("fizz") String fizz) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "pong", null);
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(1);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
+  //}
+  //
+  //@Test public void multipartPartOptional() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") RequestBody ping) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class, new Object[] { null });
+  //    fail();
+  //  } catch (IllegalStateException e) {
+  //    assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
+  //  }
+  //}
+  //
+  //@Test public void simpleFormEncoded() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") String foo, @Field("ping") String ping) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "bar", "pong");
+  //  assertBody(request.body(), "foo=bar&ping=pong");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedNameFieldParam() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field(value = "na+me", encodeName = false) String foo) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "ba r");
+  //  assertBody(request.body(), "na+me=ba+r");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedValueFieldParam() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field(value = "na me", encodeValue = false) String foo) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "ba+r");
+  //  assertBody(request.body(), "na+me=ba+r");
+  //}
+  //
+  //@Test public void formEncodedFieldOptional() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") String foo, @Field("ping") String ping,
+  //        @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "bar", null, "kat");
+  //  assertBody(request.body(), "foo=bar&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldList() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldArray() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Object[] values = { 1, 2, null, "three" };
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldPrimitiveArray() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  int[] values = { 1, 2, 3 };
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedNameFieldParamMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("k+it", "k at");
+  //  fieldMap.put("pin+g", "po ng");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedValueFieldParamMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("k it", "k+at");
+  //  fieldMap.put("pin g", "po+ng");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
+  //}
+  //
+  //@Test public void formEncodedFieldMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("kit", "kat");
+  //  fieldMap.put("foo", null);
+  //  fieldMap.put("ping", "pong");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "kit=kat&ping=pong");
+  //}
+  //
+  //@Test public void fieldMapRejectsNullKeys() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method(@FieldMap Map<String, Object> a) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("kit", "kat");
+  //  fieldMap.put("foo", null);
+  //  fieldMap.put(null, "pong");
+  //
+  //  try {
+  //    buildRequest(Example.class, fieldMap);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Parameter #1 field map contained null key.");
+  //  }
+  //}
+  //
+  //@Test public void fieldMapMustBeAMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method(@FieldMap List<String> a) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
+  //  }
+  //}
 
   @Test public void simpleHeaders() {
     class Example {
@@ -1636,13 +1636,13 @@ Response method() {
       }
     }
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void simpleInterceptorHeaders() {
@@ -1659,13 +1659,13 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void headersAndInterceptorHeaders() {
@@ -1682,20 +1682,20 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void allThreeHeaderTypes() {
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Response method(@retrofit.http.Header("fizz") String fizz) {
+      Response method(@Header("fizz") String fizz) {
         return null;
       }
     }
@@ -1705,92 +1705,93 @@ Response method(@retrofit.http.Header("fizz") String fizz) {
       }
     };
     Request request = buildRequest(Example.class, "buzz");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(3);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
     assertThat(headers.get("fizz")).isEqualTo("buzz");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@retrofit.http.Header("kit") BigInteger kit) {
+      Response method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
     Request request = buildRequest(Example.class, new BigInteger("1234"));
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(1);
     assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void headerParam() {
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Response method(@retrofit.http.Header("kit") String kit) {
+      Response method(@Header("kit") String kit) {
         return null;
       }
     }
     Request request = buildRequest(Example.class, "kat");
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@retrofit.http.Header("foo") List<String> kit) {
+      Response method(@Header("foo") List<String> kit) {
         return null;
       }
     }
     Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@retrofit.http.Header("foo") String[] kit) {
+      Response method(@Header("foo") String[] kit) {
         return null;
       }
     }
     Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
-    assertThat(request.getMethod()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.getHeaders();
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void contentTypeAnnotationHeaderOverrides() {
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("Plain"));
-    assertThat(request.getBody().mimeType()).isEqualTo("text/not-plain");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
   @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
@@ -1802,7 +1803,7 @@ Response method() {
       }
     }
     Request request = buildRequest(Example.class);
-    assertThat(request.getHeaders().get("Content-Type")).isEqualTo("text/not-plain");
+    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
   }
 
   @Test public void contentTypeInterceptorHeaderAddsHeaderWithNoBody() {
@@ -1818,27 +1819,27 @@ Response method() {
       }
     };
     Request request = buildRequest(Example.class);
-    assertThat(request.getHeaders().get("Content-Type")).isEqualTo("text/not-plain");
+    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
   }
 
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Response method(@retrofit.http.Header("Content-Type") String contentType,
-          @Body TypedInput body) {
+      Response method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, "text/not-plain", new TypedString("Plain"));
-    assertThat(request.getBody().mimeType()).isEqualTo("text/not-plain");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    Request request = buildRequest(Example.class, "text/not-plain", body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
-  private static void assertTypedBytes(TypedOutput bytes, String expected) {
+  private static void assertBody(RequestBody body, String expected) {
+    assertThat(body).isNotNull();
+    Buffer buffer = new Buffer();
     try {
-      assertThat(bytes).isNotNull();
-      ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      bytes.writeTo(baos);
-      assertThat(new String(baos.toByteArray(), "UTF-8")).isEqualTo(expected);
+      body.writeTo(buffer);
+      assertThat(buffer.readUtf8()).isEqualTo(expected);
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index bc444fa26..54b1c4895 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -2,88 +2,57 @@
 package retrofit;
 
 import com.google.gson.JsonParseException;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.Executor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import retrofit.client.MockClient;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.http.Body;
 import retrofit.http.GET;
 import retrofit.http.Headers;
 import retrofit.http.POST;
-import retrofit.http.Path;
 import retrofit.http.Streaming;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 import rx.Observable;
 import rx.functions.Action1;
 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
+import static org.junit.Assert.fail;
 import static retrofit.Utils.SynchronousExecutor;
 
 public class RestAdapterTest {
-  private static final com.squareup.okhttp.Headers NO_HEADERS = com.squareup.okhttp.Headers.of();
-  private static final com.squareup.okhttp.Headers TWO_HEADERS =
-      new com.squareup.okhttp.Headers.Builder()
-          .add("Content-Type", "application/json")
-          .add("Content-Length", "42")
-          .build();
-
-  /** Not all servers play nice and add content-type headers to responses. */
-  private static final TypedInput NO_MIME_BODY = new TypedInput() {
-    @Override public String mimeType() {
-      return null;
-    }
-
-    @Override public long length() {
-      return 2;
-    }
-
-    @Override public InputStream in() throws IOException {
-      return new ByteArrayInputStream("Hi".getBytes("UTF-8"));
-    }
-  };
-
   private interface Example {
     @Headers("Foo: Bar")
     @GET("/") String something();
     @Headers("Foo: Bar")
-    @POST("/") Object something(@Body TypedOutput body);
     @GET("/") void something(Callback<String> callback);
     @GET("/") Response direct();
     @GET("/") void direct(Callback<Response> callback);
     @GET("/") @Streaming Response streaming();
     @POST("/") Observable<String> observable(@Body String body);
-    @POST("/{x}/{y}") Observable<Response> observable(@Path("x") String x, @Path("y") String y);
   }
   private interface InvalidExample extends Example {
   }
 
-  private final MockClient mockClient = new MockClient();
-  private final Executor mockCallbackExecutor = spy(new SynchronousExecutor());
-  private final Example example = new RestAdapter.Builder() //
-      .setClient(mockClient)
-      .setCallbackExecutor(mockCallbackExecutor)
-      .setEndpoint("http://example.com")
-      .build()
-      .create(Example.class);
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Example example;
+
+  @Before public void setUp() {
+    OkHttpClient client = new OkHttpClient();
+
+    example = new RestAdapter.Builder() //
+        .setClient(client)
+        .setCallbackExecutor(new SynchronousExecutor())
+        .setEndpoint(server.getUrl("/").toString())
+        .build()
+        .create(Example.class);
+  }
 
   @Test public void objectMethodsStillWork() {
     assertThat(example.hashCode()).isNotZero();
@@ -94,230 +63,169 @@
   @Test public void interfaceWithExtendIsNotSupported() {
     try {
       new RestAdapter.Builder().setEndpoint("http://foo/").build().create(InvalidExample.class);
-      fail("Interface inheritance should not be supported.");
+      fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
     }
   }
 
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    mockClient.enqueueResponse(
-        new Response("http://example.com/", 200, "OK", NO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-  }
-
-  @Test public void asynchronousUsesCalbackExecutor() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
-    mockClient.enqueueResponse(response);
-    Callback<String> callback = mock(Callback.class);
-
-    example.something(callback);
-
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq("Hey"), same(response));
+    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+    String string = example.something();
+    assertThat(string).isEqualTo("Hi");
   }
 
   @Test public void malformedResponseThrowsConversionException() throws Exception {
-    mockClient.enqueueResponse(
-        new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("{")));
-
+    server.enqueue(new MockResponse().setBody("{"));
     try {
       example.something();
-      fail("RetrofitError expected on malformed response body.");
+      fail();
     } catch (RetrofitError e) {
       assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.UNEXPECTED);
-      assertThat(e.getResponse().getStatus()).isEqualTo(200);
+      assertThat(e.getResponse().code()).isEqualTo(200);
       assertThat(e.getCause()).isInstanceOf(JsonParseException.class);
-      assertThat(e.getResponse().getBody()).isNull();
+      assertThat(e.getResponse().body()).isNull();
     }
   }
 
   @Test public void errorResponseThrowsHttpError() throws Exception {
-    mockClient.enqueueResponse(
-        new Response("http://example.com/", 500, "Internal Server Error", NO_HEADERS, null));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken"));
 
     try {
       example.something();
-      fail("RetrofitError expected on non-2XX response code.");
+      fail();
     } catch (RetrofitError e) {
       assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+      assertThat(e.getResponse().code()).isEqualTo(500);
       assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
   @Test public void clientExceptionThrowsNetworkError() throws Exception {
-    IOException exception = new IOException("I'm broken!");
-    mockClient.enqueueIOException(exception);
+    server.enqueue(new MockResponse().setBody("Hi").setSocketPolicy(DISCONNECT_AT_START));
 
     try {
       example.something();
-      fail("RetrofitError expected when client throws exception.");
+      fail();
     } catch (RetrofitError e) {
       assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-      assertThat(e.getCause()).isSameAs(exception);
-    }
-  }
-
-  @Test public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
-    TypedInput body = spy(new TypedString("{}"));
-    InputStream bodyStream = mock(InputStream.class, new Answer() {
-      @Override public Object answer(InvocationOnMock invocation) throws Throwable {
-        throw new IOException("I'm broken!");
-      }
-    });
-    doReturn(bodyStream).when(body).in();
-
-    mockClient.enqueueResponse(new Response("http://example.com/", 200, "OK", NO_HEADERS, body));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on malformed response body.");
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-      assertThat(e.getCause()).hasMessage("I'm broken!");
-    }
-  }
-
-  @Test public void unexpectedExceptionThrows() throws IOException {
-    RuntimeException exception = new RuntimeException("More breakage.");
-    mockClient.enqueueUnexpectedException(exception);
-
-    try {
-      example.something();
-      fail("RetrofitError expected when unexpected exception thrown.");
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.UNEXPECTED);
-      assertThat(e.getCause()).isSameAs(exception);
     }
   }
 
   @Test public void getResponseDirectly() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, null);
-    mockClient.enqueueResponse(response);
-    assertThat(example.direct()).isSameAs(response);
+    server.enqueue(new MockResponse().setBody("Hey"));
+    Response response = example.direct();
+    assertThat(response.body().string()).isEqualTo("Hey");
   }
 
   @Test public void streamingResponse() throws Exception {
-    final InputStream is = new ByteArrayInputStream("Hey".getBytes("UTF-8"));
-    TypedInput in = new TypedInput() {
-      @Override public String mimeType() {
-        return "text/string";
-      }
-
-      @Override public long length() {
-        return 3;
-      }
-
-      @Override public InputStream in() throws IOException {
-        return is;
-      }
-    };
-
-    mockClient.enqueueResponse(new Response("http://example.com/", 200, "OK", NO_HEADERS, in));
-
+    server.enqueue(new MockResponse().setBody("Hey").setBodyDelayTimeMs(500));
     Response response = example.streaming();
-    assertThat(response.getBody().in()).isSameAs(is);
-  }
-
-  @Test public void closeInputStream() throws IOException {
-    // Set logger and profiler on example to make sure we exercise all the code paths.
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setCallbackExecutor(mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .build()
-        .create(Example.class);
-
-    ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
-    TypedInput typedInput = mock(TypedInput.class);
-    when(typedInput.in()).thenReturn(is);
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, typedInput);
-    mockClient.enqueueResponse(response);
-    example.something();
-    verify(is).close();
+    long startNs = System.nanoTime();
+    response.body().string();
+    long tookNs = System.nanoTime() - startNs;
+    assertThat(tookNs).isGreaterThanOrEqualTo(500);
   }
 
   @Test public void getResponseDirectlyAsync() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
-    mockClient.enqueueResponse(response);
-    Callback<Response> callback = mock(Callback.class);
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    final AtomicReference<Response> responseRef = new AtomicReference<Response>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.direct(new Callback<Response>() {
+      @Override public void success(Response response, Response response2) {
+        responseRef.set(response);
+        latch.countDown();
+      }
 
-    example.direct(callback);
+      @Override public void failure(RetrofitError error) {
+        throw new AssertionError();
+      }
+    });
+    latch.await(1, TimeUnit.SECONDS);
 
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(response), same(response));
+    assertThat(responseRef.get().body().string()).isEqualTo("Hey");
   }
 
   @Test public void getAsync() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
-    mockClient.enqueueResponse(response);
-    Callback<String> callback = mock(Callback.class);
-
-    example.something(callback);
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.something(new Callback<String>() {
+      @Override public void success(String body, Response response) {
+        bodyRef.set(body);
+        latch.countDown();
+      }
 
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
+      @Override public void failure(RetrofitError error) {
+        throw new AssertionError();
+      }
+    });
+    latch.await(1, TimeUnit.SECONDS);
 
-    ArgumentCaptor<String> responseCaptor = ArgumentCaptor.forClass(String.class);
-    verify(callback).success(responseCaptor.capture(), same(response));
-    assertThat(responseCaptor.getValue()).isEqualTo("Hey");
+    assertThat(bodyRef.get()).isEqualTo("Hey");
   }
 
-
   @Test public void errorAsync() throws Exception {
-    Response response = new Response("http://example.com/", 500, "Broken!", NO_HEADERS, new TypedString("Hey"));
-    mockClient.enqueueResponse(response);
-    Callback<String> callback = mock(Callback.class);
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken!").setBody("Hey"));
 
-    example.something(callback);
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.something(new Callback<String>() {
+      @Override public void success(String s, Response response) {
+        throw new AssertionError();
+      }
 
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
+      @Override public void failure(RetrofitError error) {
+        errorRef.set(error);
+        latch.countDown();
+      }
+    });
+    latch.await(1, TimeUnit.SECONDS);
 
-    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
-    verify(callback).failure(errorCaptor.capture());
-    RetrofitError error = errorCaptor.getValue();
-    assertThat(error.getResponse().getStatus()).isEqualTo(500);
-    assertThat(error.getResponse().getReason()).isEqualTo("Broken!");
+    RetrofitError error = errorRef.get();
+    assertThat(error.getResponse().code()).isEqualTo(500);
+    assertThat(error.getResponse().message()).isEqualTo("Broken!");
     assertThat(error.getSuccessType()).isEqualTo(String.class);
     assertThat(error.getBody()).isEqualTo("Hey");
   }
 
   @Test public void observableCallsOnNext() throws Exception {
-    mockClient.enqueueResponse(
-        new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
-    Action1<String> action = mock(Action1.class);
-    example.observable("Howdy").subscribe(action);
-    verify(action).call(eq("hello"));
-  }
+    server.enqueue(new MockResponse().setBody("hello"));
+
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.observable("Howdy").subscribe(new Action1<String>() {
+      @Override public void call(String body) {
+        bodyRef.set(body);
+        latch.countDown();
+      }
+    });
+    latch.await(1, TimeUnit.SECONDS);
 
-  @Test public void observableCallsOnError() throws Exception {
-    mockClient.enqueueResponse(
-        new Response("http://example.com/", 300, "FAIL", NO_HEADERS, new TypedString("bummer")));
-    Action1<String> onSuccess = mock(Action1.class);
-    Action1<Throwable> onError = mock(Action1.class);
-    example.observable("Howdy").subscribe(onSuccess, onError);
-    verifyZeroInteractions(onSuccess);
-
-    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
-    verify(onError).call(errorCaptor.capture());
-    RetrofitError value = errorCaptor.getValue();
-    assertThat(value.getSuccessType()).isEqualTo(String.class);
+    assertThat(bodyRef.get()).isEqualTo("hello");
   }
 
-  @Test public void observableHandlesParams() throws Exception {
-    mockClient.enqueueResponse(
-        new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
-    ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
-    Action1<Response> action = mock(Action1.class);
-    example.observable("X", "Y").subscribe(action);
+  @Test public void observableCallsOnError() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
 
-    Request request = mockClient.takeRequest();
-    assertThat(request.getUrl()).contains("/X/Y");
+    final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.observable("Howdy").subscribe(new Action1<String>() {
+      @Override public void call(String s) {
+        throw new AssertionError();
+      }
+    }, new Action1<Throwable>() {
+      @Override public void call(Throwable throwable) {
+        errorRef.set(throwable);
+        latch.countDown();
+      }
+    });
+    latch.await(1, TimeUnit.SECONDS);
 
-    verify(action).call(responseCaptor.capture());
-    Response response = responseCaptor.getValue();
-    assertThat(response.getStatus()).isEqualTo(200);
+    RetrofitError error = (RetrofitError) errorRef.get();
+    assertThat(error.getResponse().code()).isEqualTo(500);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
index e0e5f842b..a66d93bd2 100644
--- a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
@@ -2,13 +2,13 @@
 package retrofit;
 
 import com.google.gson.reflect.TypeToken;
+import com.squareup.okhttp.Response;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.junit.Test;
-import retrofit.client.Response;
 import retrofit.http.Body;
 import retrofit.http.GET;
 import retrofit.http.POST;
diff --git a/retrofit/src/test/java/retrofit/TestingUtils.java b/retrofit/src/test/java/retrofit/TestingUtils.java
index 2ad42be65..cc65e72f6 100644
--- a/retrofit/src/test/java/retrofit/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/TestingUtils.java
@@ -1,14 +1,7 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.io.IOException;
 import java.lang.reflect.Method;
-import java.util.Map;
-import retrofit.mime.MimeHelper;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-
-import static org.assertj.core.api.Assertions.assertThat;
 
 public final class TestingUtils {
   public static Method onlyMethod(Class c) {
@@ -18,16 +11,4 @@ public static Method onlyMethod(Class c) {
     }
     throw new IllegalArgumentException("More than one method declared.");
   }
-
-  public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
-    MultipartTypedOutput typedOutput = MimeHelper.newMultipart("foobarbaz");
-    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
-      typedOutput.addPart(part.getKey(), part.getValue());
-    }
-    return typedOutput;
-  }
-
-  public static void assertBytes(byte[] bytes, String expected) throws IOException {
-    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
-  }
 }
diff --git a/retrofit/src/test/java/retrofit/client/MockClient.java b/retrofit/src/test/java/retrofit/client/MockClient.java
deleted file mode 100644
index 0173d3364..000000000
--- a/retrofit/src/test/java/retrofit/client/MockClient.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package retrofit.client;
-
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Deque;
-
-public final class MockClient implements Client {
-  private final Deque<Object> events = new ArrayDeque<Object>();
-  private final Deque<Request> requests = new ArrayDeque<Request>();
-
-  public void enqueueResponse(Response response) {
-    events.add(new ResponseEvent(response));
-  }
-
-  public void enqueueIOException(IOException exception) {
-    events.add(new IOExceptionEvent(exception));
-  }
-
-  public void enqueueUnexpectedException(RuntimeException exception) {
-    events.add(new UnexpectedExceptionEvent(exception));
-  }
-
-  public Request takeRequest() {
-    return requests.pop();
-  }
-
-  @Override public void execute(Request request, AsyncCallback callback) {
-    requests.add(request);
-
-    Object event = events.pop();
-    if (event instanceof ResponseEvent) {
-      callback.onResponse(((ResponseEvent) event).response);
-    } else if (event instanceof IOExceptionEvent) {
-      callback.onFailure(((IOExceptionEvent) event).exception);
-    } else if (event instanceof UnexpectedExceptionEvent) {
-      throw ((UnexpectedExceptionEvent) event).exception;
-    } else {
-      throw new IllegalStateException("Unknown event " + event.getClass());
-    }
-  }
-
-  private static final class ResponseEvent {
-    final Response response;
-
-    private ResponseEvent(Response response) {
-      this.response = response;
-    }
-  }
-
-  private static final class IOExceptionEvent {
-    final IOException exception;
-
-    private IOExceptionEvent(IOException exception) {
-      this.exception = exception;
-    }
-  }
-
-  private static final class UnexpectedExceptionEvent {
-    final RuntimeException exception;
-
-    private UnexpectedExceptionEvent(RuntimeException exception) {
-      this.exception = exception;
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/client/OkClientTest.java b/retrofit/src/test/java/retrofit/client/OkClientTest.java
deleted file mode 100644
index 0ec413ae6..000000000
--- a/retrofit/src/test/java/retrofit/client/OkClientTest.java
+++ /dev/null
@@ -1,164 +0,0 @@
-// Copyright 2014 Square, Inc.
-package retrofit.client;
-
-import com.google.common.io.ByteStreams;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import org.junit.Test;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedString;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit.TestingUtils.assertBytes;
-
-public final class OkClientTest {
-  private static final String HOST = "http://example.com";
-
-  @Test public void get() {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", Headers.of(), null);
-    com.squareup.okhttp.Request okRequest = OkClient.createRequest(request);
-
-    assertThat(okRequest.method()).isEqualTo("GET");
-    assertThat(okRequest.urlString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
-    assertThat(okRequest.headers().size()).isEqualTo(0);
-    assertThat(okRequest.body()).isNull();
-  }
-
-  @Test public void post() throws IOException {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", Headers.of(), body);
-    com.squareup.okhttp.Request okRequest = OkClient.createRequest(request);
-
-    assertThat(okRequest.method()).isEqualTo("POST");
-    assertThat(okRequest.urlString()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(okRequest.headers().size()).isEqualTo(0);
-
-    RequestBody okBody = okRequest.body();
-    assertThat(okBody).isNotNull();
-
-    Buffer buffer = new Buffer();
-    okBody.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo("hi");
-  }
-
-  @Test public void headers() {
-    Headers headers = new Headers.Builder()
-        .add("kit", "kat")
-        .add("foo", "bar")
-        .add("ping", "")
-        .build();
-    Request request = new Request("GET", HOST + "/this/", headers, null);
-    com.squareup.okhttp.Request okRequest = OkClient.createRequest(request);
-
-    Headers okHeaders = okRequest.headers();
-    assertThat(okHeaders.size()).isEqualTo(3);
-    assertThat(okHeaders.get("kit")).isEqualTo("kat");
-    assertThat(okHeaders.get("foo")).isEqualTo("bar");
-    assertThat(okHeaders.get("ping")).isEqualTo("");
-  }
-
-  @Test public void response() throws IOException {
-    com.squareup.okhttp.Response okResponse = new com.squareup.okhttp.Response.Builder()
-        .code(200).message("OK")
-        .body(new TestResponseBody("hello", "text/plain"))
-        .addHeader("foo", "bar")
-        .addHeader("kit", "kat")
-        .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder()
-            .url(HOST + "/foo/bar/")
-            .get()
-            .build())
-        .build();
-    Response response = OkClient.parseResponse(okResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    Headers headers = response.getHeaders();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("foo")).isEqualTo("bar");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    TypedInput responseBody = response.getBody();
-    assertThat(responseBody.mimeType()).isEqualTo("text/plain");
-    assertBytes(ByteStreams.toByteArray(responseBody.in()), "hello");
-  }
-
-  @Test public void responseNoContentType() throws IOException {
-    com.squareup.okhttp.Response okResponse = new com.squareup.okhttp.Response.Builder()
-        .code(200).message("OK")
-        .body(new TestResponseBody("hello", null))
-        .addHeader("foo", "bar")
-        .addHeader("kit", "kat")
-        .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder()
-            .url(HOST + "/foo/bar/")
-            .get()
-            .build())
-        .build();
-    Response response = OkClient.parseResponse(okResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    Headers headers = response.getHeaders();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("foo")).isEqualTo("bar");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    TypedInput responseBody = response.getBody();
-    assertThat(responseBody.mimeType()).isNull();
-    assertBytes(ByteStreams.toByteArray(responseBody.in()), "hello");
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    com.squareup.okhttp.Response okResponse = new com.squareup.okhttp.Response.Builder()
-        .code(200)
-        .message("OK")
-        .body(new TestResponseBody("", null))
-        .addHeader("foo", "bar")
-        .addHeader("kit", "kat")
-        .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder()
-            .url(HOST + "/foo/bar/")
-            .get()
-            .build())
-        .build();
-    Response response = OkClient.parseResponse(okResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    Headers headers = response.getHeaders();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("foo")).isEqualTo("bar");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(response.getBody()).isNull();
-  }
-
-  private static final class TestResponseBody extends ResponseBody {
-    private final Buffer buffer;
-    private final String contentType;
-
-    private TestResponseBody(String content, String contentType) {
-      this.buffer = new Buffer().writeUtf8(content);
-      this.contentType = contentType;
-    }
-
-    @Override public MediaType contentType() {
-      return contentType == null ? null : MediaType.parse(contentType);
-    }
-
-    @Override public long contentLength() {
-      return buffer.size();
-    }
-
-    @Override public BufferedSource source() {
-      return buffer.clone();
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
index 9a81b13e5..98c10c93b 100644
--- a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
+++ b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
@@ -7,14 +7,17 @@
 import com.google.gson.JsonObject;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 
 public final class GsonConverterTest {
@@ -51,25 +54,25 @@
   }
 
   @Test public void serialization() throws IOException {
-    TypedOutput output = converter.toBody(new Impl("value"), Impl.class);
-    assertJson("{\"theName\":\"value\"}", output);
+    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
+    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
   }
 
   @Test public void serializationTypeUsed() throws IOException {
-    TypedOutput output = converter.toBody(new Impl("value"), Example.class);
-    assertJson("{\"name\":\"value\"}", output);
+    RequestBody body = converter.toBody(new Impl("value"), Example.class);
+    assertBody(body).isEqualTo("{\"name\":\"value\"}");
   }
 
   @Test public void deserialization() throws IOException {
-    TypedString json = new TypedString("{\"theName\":\"value\"}");
-    Impl impl = (Impl) converter.fromBody(json, Impl.class);
+    ResponseBody body =
+        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
+    Impl impl = (Impl) converter.fromBody(body, Impl.class);
     assertEquals("value", impl.getName());
   }
 
-  private void assertJson(String expected, TypedOutput output) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    output.writeTo(baos);
-    String json = new String(baos.toByteArray(), "UTF-8");
-    assertEquals(expected, json);
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 }
diff --git a/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java b/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java
deleted file mode 100644
index 0e3f79df4..000000000
--- a/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class FormUrlEncodingTypedOutputTest {
-  @Test public void urlEncoding() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("a&b", "c=d");
-    fe.addField("space, the", "final frontier");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    fe.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo("a%26b=c%3Dd&space%2C+the=final+frontier");
-  }
-
-  @Test public void utf8encoding() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("ooɟ", "ɹɐq");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    fe.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo("oo%C9%9F=%C9%B9%C9%90q");
-  }
-
-  @Test public void encodedPairs() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("sim", "ple");
-
-    ByteArrayOutputStream out1 = new ByteArrayOutputStream();
-    fe.writeTo(out1);
-    String actual1 = new String(out1.toByteArray(), "UTF-8");
-    assertThat(actual1).isEqualTo("sim=ple");
-
-    fe.addField("hey", "there");
-    fe.addField("help", "me");
-
-    ByteArrayOutputStream out2 = new ByteArrayOutputStream();
-    fe.writeTo(out2);
-    String actual2 = new String(out2.toByteArray(), "UTF-8");
-    assertThat(actual2).isEqualTo("sim=ple&hey=there&help=me");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MimeHelper.java b/retrofit/src/test/java/retrofit/mime/MimeHelper.java
deleted file mode 100644
index 9df96901f..000000000
--- a/retrofit/src/test/java/retrofit/mime/MimeHelper.java
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.util.List;
-
-public class MimeHelper {
-  public static List<byte[]> getParts(MultipartTypedOutput output) {
-    try {
-      return output.getParts();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static MultipartTypedOutput newMultipart(String boundary) {
-    return new MultipartTypedOutput(boundary);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java b/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java
deleted file mode 100644
index 5019ef6b2..000000000
--- a/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2012 Square, Inc.
-package retrofit.mime;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit.mime.MimeUtil.parseCharset;
-
-public class MimeUtilTest {
-  @Test public void charsetParsing() {
-    assertThat(parseCharset("text/plain;charset=utf-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=utf-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;  charset=utf-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \tcharset=utf-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; CHARSET=utf-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=UTF-8", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"utf-8\"", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;charset=utf-8;other=thing", "ERROR")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; notthecharset=utf-16;", "UTF-8")).isEqualToIgnoringCase("UTF-8");
-  }
-
-  @SuppressWarnings("deprecation")
-  @Test public void oldCharsetParsing() {
-    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;charset=utf-8;other=thing")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase("UTF-8");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java b/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java
deleted file mode 100644
index 66e026275..000000000
--- a/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class MultipartTypedOutputTest {
-  @Test public void singlePart() throws Exception {
-    String expected = "" //
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"greet\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 13\r\n"
-        + "Content-Transfer-Encoding: binary\r\n" //
-        + "\r\n" //
-        + "Hello, World!\r\n" //
-        + "--123--\r\n";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("greet", new TypedString("Hello, World!"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-
-  @Test public void singlePartWithTransferEncoding() throws Exception {
-    String expected = "" //
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"greet\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 13\r\n"
-        + "Content-Transfer-Encoding: 8-bit\r\n" //
-        + "\r\n" //
-        + "Hello, World!\r\n" //
-        + "--123--\r\n";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("greet", "8-bit", new TypedString("Hello, World!"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-
-  @Test public void threeParts() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"quick\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 5\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "brown\r\n"
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"fox\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 5\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "jumps\r\n"
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"lazy\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 3\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "dog\r\n"
-        + "--123--\r\n";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("quick", new TypedString("brown"));
-    mto.addPart("fox", new TypedString("jumps"));
-    mto.addPart("lazy", new TypedString("dog"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-
-  @Test public void withPartOfUnknownLength() throws Exception {
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-
-    mto.addPart("first", new TypedString("value"));
-    mto.addPart("second", new TypedString("unknown size") {
-      @Override public long length() {
-        return -1;
-      }
-    });
-
-    assertThat(mto.length()).isEqualTo(-1);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java b/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java
deleted file mode 100644
index b076a0328..000000000
--- a/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.mime;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class TypedByteArrayTest {
-  private static final String GIF = "image/gif";
-
-  @Test public void objectEquals() {
-    TypedByteArray a1 = new TypedByteArray(GIF, new byte[] { 10, 20 });
-    TypedByteArray a2 = new TypedByteArray(GIF, new byte[] { 10, 20 });
-    TypedByteArray b = new TypedByteArray(GIF, new byte[] { 8, 12 });
-
-    assertThat(a1).isEqualTo(a2);
-    assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
-    assertThat(a1).isNotEqualTo(b);
-    assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/TypedFileTest.java b/retrofit/src/test/java/retrofit/mime/TypedFileTest.java
deleted file mode 100644
index 4d1cc69c2..000000000
--- a/retrofit/src/test/java/retrofit/mime/TypedFileTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.mime;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class TypedFileTest {
-  private static final String PNG = "image/png";
-
-  @Test public void objectEquals() {
-    TypedFile a1 = new TypedFile(PNG, new File("a.png"));
-    TypedFile a2 = new TypedFile(PNG, new File("a.png"));
-    TypedFile b = new TypedFile(PNG, new File("b.png"));
-
-    assertThat(a1).isNotEqualTo(b);
-    assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
-    assertThat(a1).isEqualTo(a2);
-    assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
-  }
-
-  @Test public void objectToString() {
-    File file = new File("/path/to/file.png");
-
-    assertThat(new TypedFile(PNG, file).toString()) //
-        .isEqualTo(file.getAbsolutePath() + " (image/png)");
-  }
-
-  @Test public void length() throws IOException {
-    File tempFile = File.createTempFile("foo", ".tmp");
-    try {
-      TypedFile typedFile = new TypedFile(PNG, tempFile);
-      assertThat(typedFile.length()).isZero();
-
-      writeToFile(tempFile, new byte[] { 0, 1, 2, 3, 4 });
-
-      assertThat(tempFile.length()).isEqualTo(5);
-      assertThat(typedFile.length()).isEqualTo(5);
-    } finally {
-      tempFile.delete();
-    }
-  }
-
-  private static void writeToFile(File file, byte[] data) throws IOException {
-    FileOutputStream fos = new FileOutputStream(file);
-    try {
-      fos.write(data);
-    } finally {
-      fos.close();
-    }
-  }
-}
