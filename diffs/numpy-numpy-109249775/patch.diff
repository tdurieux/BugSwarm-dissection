diff --git a/benchmarks/benchmarks/bench_indexing.py b/benchmarks/benchmarks/bench_indexing.py
index 3e5a2ee6025..a62a2050e28 100644
--- a/benchmarks/benchmarks/bench_indexing.py
+++ b/benchmarks/benchmarks/bench_indexing.py
@@ -2,10 +2,13 @@
 
 from .common import Benchmark, get_squares_, get_indexes_, get_indexes_rand_
 
+from os.path import join as pjoin
+import shutil
 import sys
 import six
 from numpy import memmap, float32, array
 import numpy as np
+from tempfile import mkdtemp
 
 
 class Indexing(Benchmark):
@@ -37,9 +40,15 @@ def time_op(self, indexes, sel, op):
 
 class IndexingSeparate(Benchmark):
     def setup(self):
-        self.fp = memmap('tmp.dat', dtype=float32, mode='w+', shape=(50, 60))
+        self.tmp_dir = mkdtemp()
+        self.fp = memmap(pjoin(self.tmp_dir, 'tmp.dat'),
+                         dtype=float32, mode='w+', shape=(50, 60))
         self.indexes = array([3, 4, 6, 10, 20])
 
+    def teardown(self):
+        del self.fp
+        shutil.rmtree(self.tmp_dir)
+
     def time_mmap_slicing(self):
         for i in range(1000):
             self.fp[5:10]
diff --git a/benchmarks/benchmarks/common.py b/benchmarks/benchmarks/common.py
index 066d4b13063..18a09fd4055 100644
--- a/benchmarks/benchmarks/common.py
+++ b/benchmarks/benchmarks/common.py
@@ -22,8 +22,9 @@
     'int32', 'float32',
     'int64', 'float64',  'complex64',
     'longfloat', 'complex128',
-    'complex256',
 ]
+if 'complex256' in numpy.typeDict:
+    TYPES1.append('complex256')
 
 
 def memoize(func):
diff --git a/numpy/ma/core.py b/numpy/ma/core.py
index 3dfe0c4e359..91ffdbf64aa 100644
--- a/numpy/ma/core.py
+++ b/numpy/ma/core.py
@@ -771,8 +771,9 @@ def __init__(self, a, b):
 
     def __call__(self, x):
         "Execute the call behavior."
-        return umath.logical_or(umath.greater(x, self.b),
-                                umath.less(x, self.a))
+        with np.errstate(invalid='ignore'):
+            return umath.logical_or(umath.greater(x, self.b),
+                                    umath.less(x, self.a))
 
 
 class _DomainTan:
@@ -789,7 +790,8 @@ def __init__(self, eps):
 
     def __call__(self, x):
         "Executes the call behavior."
-        return umath.less(umath.absolute(umath.cos(x)), self.eps)
+        with np.errstate(invalid='ignore'):
+            return umath.less(umath.absolute(umath.cos(x)), self.eps)
 
 
 class _DomainSafeDivide:
@@ -809,7 +811,8 @@ def __call__(self, a, b):
             self.tolerance = np.finfo(float).tiny
         # don't call ma ufuncs from __array_wrap__ which would fail for scalars
         a, b = np.asarray(a), np.asarray(b)
-        return umath.absolute(a) * self.tolerance >= umath.absolute(b)
+        with np.errstate(invalid='ignore'):
+            return umath.absolute(a) * self.tolerance >= umath.absolute(b)
 
 
 class _DomainGreater:
@@ -824,7 +827,8 @@ def __init__(self, critical_value):
 
     def __call__(self, x):
         "Executes the call behavior."
-        return umath.less_equal(x, self.critical_value)
+        with np.errstate(invalid='ignore'):
+            return umath.less_equal(x, self.critical_value)
 
 
 class _DomainGreaterEqual:
@@ -839,7 +843,8 @@ def __init__(self, critical_value):
 
     def __call__(self, x):
         "Executes the call behavior."
-        return umath.less(x, self.critical_value)
+        with np.errstate(invalid='ignore'):
+            return umath.less(x, self.critical_value)
 
 
 class _MaskedUnaryOperation:
@@ -887,7 +892,8 @@ def __call__(self, a, *args, **kwargs):
         else:
             # Case 1.2. : Function without a domain
             # Get the result and the mask
-            result = self.f(d, *args, **kwargs)
+            with np.errstate(divide='ignore', invalid='ignore'):
+                result = self.f(d, *args, **kwargs)
             m = getmask(a)
 
         if not result.ndim:
@@ -1123,7 +1129,7 @@ def __call__(self, a, b, *args, **kwargs):
         # Apply the domain
         domain = ufunc_domain.get(self.f, None)
         if domain is not None:
-            m |= filled(domain(da, db), True)
+            m |= domain(da, db)
         # Take care of the scalar case first
         if (not m.ndim):
             if m:
@@ -2948,9 +2954,11 @@ def __array_wrap__(self, obj, context=None):
             if domain is not None:
                 # Take the domain, and make sure it's a ndarray
                 if len(args) > 2:
-                    d = filled(reduce(domain, args), True)
+                    with np.errstate(divide='ignore', invalid='ignore'):
+                        d = filled(reduce(domain, args), True)
                 else:
-                    d = filled(domain(*args), True)
+                    with np.errstate(divide='ignore', invalid='ignore'):
+                        d = filled(domain(*args), True)
                 # Fill the result where the domain is wrong
                 try:
                     # Binary domain: take the last value
@@ -2965,8 +2973,8 @@ def __array_wrap__(self, obj, context=None):
                 np.copyto(result, fill_value, where=d)
                 # Update the mask
                 if m is nomask:
-                    if d is not nomask:
-                        m = d
+                    if any(d):
+                        m = True if all(d) else d
                 else:
                     # Don't modify inplace, we risk back-propagation
                     m = (m | d)
@@ -4219,22 +4227,38 @@ def get_real(self):
         return result
     real = property(fget=get_real, doc="Real part")
 
-    def count(self, axis=None):
+    def count(self, axis=None, **kwargs):
         """
         Count the non-masked elements of the array along the given axis.
 
         Parameters
         ----------
-        axis : int, optional
-            Axis along which to count the non-masked elements. If `axis` is
-            `None`, all non-masked elements are counted.
+        axis : None or int or tuple of ints, optional
+            Axis or axes along which the count is performed.
+            The default (`axis` = `None`) is perform the count sum over all
+            the dimensions of the input array. `axis` may be negative, in
+            which case it counts from the last to the first axis.
+
+            .. versionadded:: 1.10.0
+
+            If this is a tuple of ints, the count is performed on multiple
+            axes, instead of a single axis or all the axes as before.
+        out : ndarray, optional
+            Alternate output array in which to place the result.  The default
+            is ``None``; if provided, it must have the same shape as the
+            expected output, but the type will be cast if necessary.  See
+            `doc.ufuncs` for details.
+        keepdims : bool, optional
+            If this is set to True, the axes which are reduced are left
+            in the result as dimensions with size one. With this option,
+            the result will broadcast correctly against the array.
 
         Returns
         -------
-        result : int or ndarray
-            If `axis` is `None`, an integer count is returned. When `axis` is
-            not `None`, an array with shape determined by the lengths of the
-            remaining axes, is returned.
+        result : ndarray or scalar
+            An array with the same shape as self, with the specified
+            axis removed.   If self is a 0-d array, or if `axis` is None, a scalar
+            is returned.
 
         See Also
         --------
@@ -4266,21 +4290,26 @@ def count(self, axis=None):
 
         """
         m = self._mask
-        s = self.shape
         if m is nomask:
+            # see _count_reduce_items in _methods.py
             if axis is None:
-                return self.size
-            else:
-                n = s[axis]
-                t = list(s)
-                del t[axis]
-                return np.full(t, n, dtype=np.intp)
-        n1 = np.size(m, axis)
-        n2 = np.sum(m, axis=axis, dtype=np.intp)
-        if axis is None:
-            return (n1 - n2)
-        else:
-            return narray(n1 - n2)
+                axis = tuple(range(self.ndim))
+            if not isinstance(axis, tuple):
+                axis = (axis,)
+            items = 1
+            for ax in axis:
+                items *= self.shape[ax]
+            if kwargs.get('keepdims', False):
+                out_dims = list(self.shape)
+                for a in axis:
+                    out_dims[a] = 1
+                return items*ones(out_dims)
+            return items
+        if self is masked:
+            return 0
+        # use data's class (eg so if it's a matrix, keeps dims)
+        im = (~m).view(type=type(self.data))
+        return im.sum(axis=axis, dtype=np.intp, **kwargs)
 
     flatten = _arraymethod('flatten')
 
@@ -4529,28 +4558,20 @@ def iscontiguous(self):
         """
         return self.flags['CONTIGUOUS']
 
-    def all(self, axis=None, out=None):
+    def all(self, axis=None, out=None, **kwargs):
         """
-        Check if all of the elements of `a` are true.
+        Returns True if all elements evaluate to True.
 
-        Performs a :func:`logical_and` over the given axis and returns the result.
-        Masked values are considered as True during computation.
-        For convenience, the output array is masked where ALL the values along the
-        current axis are masked: if the output would have been a scalar and that
-        all the values are masked, then the output is `masked`.
+        The output array is masked where ALL the values along the current axis
+        are masked: if the output would have been a scalar and that all the
+        values are masked, then the output is `masked`.
 
-        Parameters
-        ----------
-        axis : {None, integer}
-            Axis to perform the operation over.
-            If None, perform over flattened array.
-        out : {None, array}, optional
-            Array into which the result can be placed. Its type is preserved
-            and it must be of the right shape to hold the output.
+        Refer to `numpy.all` for full documentation.
 
         See Also
         --------
-        all : equivalent function
+        ndarray.all : corresponding function for ndarrays
+        numpy.all : equivalent function
 
         Examples
         --------
@@ -4563,48 +4584,41 @@ def all(self, axis=None, out=None):
         """
         mask = _check_mask_axis(self._mask, axis)
         if out is None:
-            d = self.filled(True).all(axis=axis).view(type(self))
+            d = self.filled(True).all(axis=axis, **kwargs).view(type(self))
             if d.ndim:
                 d.__setmask__(mask)
-            elif mask:
+            elif mask and self.size > 0:
                 return masked
             return d
-        self.filled(True).all(axis=axis, out=out)
+        self.filled(True).all(axis=axis, out=out, **kwargs)
         if isinstance(out, MaskedArray):
             if out.ndim or mask:
                 out.__setmask__(mask)
         return out
 
-    def any(self, axis=None, out=None):
+    def any(self, axis=None, out=None, **kwargs):
         """
-        Check if any of the elements of `a` are true.
+        Returns True if any of the elements of `a` evaluate to True.
 
-        Performs a logical_or over the given axis and returns the result.
         Masked values are considered as False during computation.
 
-        Parameters
-        ----------
-        axis : {None, integer}
-            Axis to perform the operation over.
-            If None, perform over flattened array and return a scalar.
-        out : {None, array}, optional
-            Array into which the result can be placed. Its type is preserved
-            and it must be of the right shape to hold the output.
+        Refer to `numpy.any` for full documentation.
 
         See Also
         --------
-        any : equivalent function
+        ndarray.any : corresponding function for ndarrays
+        numpy.any : equivalent function
 
         """
         mask = _check_mask_axis(self._mask, axis)
         if out is None:
-            d = self.filled(False).any(axis=axis).view(type(self))
+            d = self.filled(False).any(axis=axis, **kwargs).view(type(self))
             if d.ndim:
                 d.__setmask__(mask)
-            elif mask:
+            elif mask and self.size > 0:
                 d = masked
             return d
-        self.filled(False).any(axis=axis, out=out)
+        self.filled(False).any(axis=axis, out=out, **kwargs)
         if isinstance(out, MaskedArray):
             if out.ndim or mask:
                 out.__setmask__(mask)
@@ -4765,34 +4779,18 @@ def dot(self, b, out=None, strict=False):
         """
         return dot(self, b, out=out, strict=strict)
 
-    def sum(self, axis=None, dtype=None, out=None):
+    def sum(self, axis=None, dtype=None, out=None, **kwargs):
         """
         Return the sum of the array elements over the given axis.
+
         Masked elements are set to 0 internally.
 
-        Parameters
-        ----------
-        axis : {None, -1, int}, optional
-            Axis along which the sum is computed. The default
-            (`axis` = None) is to compute over the flattened array.
-        dtype : {None, dtype}, optional
-            Determines the type of the returned array and of the accumulator
-            where the elements are summed. If dtype has the value None and
-            the type of a is an integer type of precision less than the default
-            platform integer, then the default platform integer precision is
-            used.  Otherwise, the dtype is the same as that of a.
-        out :  {None, ndarray}, optional
-            Alternative output array in which to place the result. It must
-            have the same shape and buffer length as the expected output
-            but the type will be cast if necessary.
+        Refer to `numpy.sum` for full documentation.
 
-        Returns
-        -------
-        sum_along_axis : MaskedArray or scalar
-            An array with the same shape as self, with the specified
-            axis removed.   If self is a 0-d array, or if `axis` is None, a scalar
-            is returned.  If an output array is specified, a reference to
-            `out` is returned.
+        See Also
+        --------
+        ndarray.sum : corresponding function for ndarrays
+        numpy.sum : equivalent function
 
         Examples
         --------
@@ -4815,7 +4813,7 @@ def sum(self, axis=None, dtype=None, out=None):
         newmask = _check_mask_axis(_mask, axis)
         # No explicit output
         if out is None:
-            result = self.filled(0).sum(axis, dtype=dtype)
+            result = self.filled(0).sum(axis, dtype=dtype, **kwargs)
             rndim = getattr(result, 'ndim', 0)
             if rndim:
                 result = result.view(type(self))
@@ -4824,7 +4822,7 @@ def sum(self, axis=None, dtype=None, out=None):
                 result = masked
             return result
         # Explicit output
-        result = self.filled(0).sum(axis, dtype=dtype, out=out)
+        result = self.filled(0).sum(axis, dtype=dtype, out=out, **kwargs)
         if isinstance(out, MaskedArray):
             outmask = getattr(out, '_mask', nomask)
             if (outmask is nomask):
@@ -4834,36 +4832,13 @@ def sum(self, axis=None, dtype=None, out=None):
 
     def cumsum(self, axis=None, dtype=None, out=None):
         """
-        Return the cumulative sum of the elements along the given axis.
-        The cumulative sum is calculated over the flattened array by
-        default, otherwise over the specified axis.
+        Return the cumulative sum of the array elements over the given axis.
 
         Masked values are set to 0 internally during the computation.
         However, their position is saved, and the result will be masked at
         the same locations.
 
-        Parameters
-        ----------
-        axis : {None, -1, int}, optional
-            Axis along which the sum is computed. The default (`axis` = None) is to
-            compute over the flattened array. `axis` may be negative, in which case
-            it counts from the   last to the first axis.
-        dtype : {None, dtype}, optional
-            Type of the returned array and of the accumulator in which the
-            elements are summed.  If `dtype` is not specified, it defaults
-            to the dtype of `a`, unless `a` has an integer dtype with a
-            precision less than that of the default platform integer.  In
-            that case, the default platform integer is used.
-        out : ndarray, optional
-            Alternative output array in which to place the result. It must
-            have the same shape and buffer length as the expected output
-            but the type will be cast if necessary.
-
-        Returns
-        -------
-        cumsum : ndarray.
-            A new array holding the result is returned unless ``out`` is
-            specified, in which case a reference to ``out`` is returned.
+        Refer to `numpy.cumsum` for full documentation.
 
         Notes
         -----
@@ -4872,6 +4847,11 @@ def cumsum(self, axis=None, dtype=None, out=None):
         Arithmetic is modular when using integer types, and no error is
         raised on overflow.
 
+        See Also
+        --------
+        ndarray.cumsum : corresponding function for ndarrays
+        numpy.cumsum : equivalent function
+
         Examples
         --------
         >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
@@ -4888,60 +4868,29 @@ def cumsum(self, axis=None, dtype=None, out=None):
         result.__setmask__(self._mask)
         return result
 
-    def prod(self, axis=None, dtype=None, out=None):
+    def prod(self, axis=None, dtype=None, out=None, **kwargs):
         """
         Return the product of the array elements over the given axis.
-        Masked elements are set to 1 internally for computation.
 
-        Parameters
-        ----------
-        axis : {None, int}, optional
-            Axis over which the product is taken. If None is used, then the
-            product is over all the array elements.
-        dtype : {None, dtype}, optional
-            Determines the type of the returned array and of the accumulator
-            where the elements are multiplied. If ``dtype`` has the value ``None``
-            and the type of a is an integer type of precision less than the default
-            platform integer, then the default platform integer precision is
-            used.  Otherwise, the dtype is the same as that of a.
-        out : {None, array}, optional
-            Alternative output array in which to place the result. It must have
-            the same shape as the expected output but the type will be cast if
-            necessary.
-
-        Returns
-        -------
-        product_along_axis : {array, scalar}, see dtype parameter above.
-            Returns an array whose shape is the same as a with the specified
-            axis removed. Returns a 0d array when a is 1d or axis=None.
-            Returns a reference to the specified output array if specified.
+        Masked elements are set to 1 internally for computation.
 
-        See Also
-        --------
-        prod : equivalent function
+        Refer to `numpy.prod` for full documentation.
 
         Notes
         -----
         Arithmetic is modular when using integer types, and no error is raised
         on overflow.
 
-        Examples
+        See Also
         --------
-        >>> np.prod([1.,2.])
-        2.0
-        >>> np.prod([1.,2.], dtype=np.int32)
-        2
-        >>> np.prod([[1.,2.],[3.,4.]])
-        24.0
-        >>> np.prod([[1.,2.],[3.,4.]], axis=1)
-        array([  2.,  12.])
-
+        ndarray.prod : corresponding function for ndarrays
+        numpy.prod : equivalent function
         """
         _mask = self._mask
         newmask = _check_mask_axis(_mask, axis)
         # No explicit output
         if out is None:
-            result = self.filled(1).prod(axis, dtype=dtype)
+            result = self.filled(1).prod(axis, dtype=dtype, **kwargs)
             rndim = getattr(result, 'ndim', 0)
             if rndim:
                 result = result.view(type(self))
@@ -4950,47 +4899,24 @@ def prod(self, axis=None, dtype=None, out=None):
                 result = masked
             return result
         # Explicit output
-        result = self.filled(1).prod(axis, dtype=dtype, out=out)
+        result = self.filled(1).prod(axis, dtype=dtype, out=out, **kwargs)
         if isinstance(out, MaskedArray):
             outmask = getattr(out, '_mask', nomask)
             if (outmask is nomask):
                 outmask = out._mask = make_mask_none(out.shape)
             outmask.flat = newmask
         return out
-
     product = prod
 
     def cumprod(self, axis=None, dtype=None, out=None):
         """
-        Return the cumulative product of the elements along the given axis.
-        The cumulative product is taken over the flattened array by
-        default, otherwise over the specified axis.
+        Return the cumulative product of the array elements over the given axis.
 
         Masked values are set to 1 internally during the computation.
         However, their position is saved, and the result will be masked at
         the same locations.
 
-        Parameters
-        ----------
-        axis : {None, -1, int}, optional
-            Axis along which the product is computed. The default
-            (`axis` = None) is to compute over the flattened array.
-        dtype : {None, dtype}, optional
-            Determines the type of the returned array and of the accumulator
-            where the elements are multiplied. If ``dtype`` has the value ``None``
-            and the type of ``a`` is an integer type of precision less than the
-            default platform integer, then the default platform integer precision
-            is used.  Otherwise, the dtype is the same as that of ``a``.
-        out : ndarray, optional
-            Alternative output array in which to place the result. It must
-            have the same shape and buffer length as the expected output
-            but the type will be cast if necessary.
-
-        Returns
-        -------
-        cumprod : ndarray
-            A new array holding the result is returned unless out is specified,
-            in which case a reference to out is returned.
+        Refer to `numpy.cumprod` for full documentation.
 
         Notes
         -----
@@ -4999,6 +4925,10 @@ def cumprod(self, axis=None, dtype=None, out=None):
         Arithmetic is modular when using integer types, and no error is
         raised on overflow.
 
+        See Also
+        --------
+        ndarray.cumprod : corresponding function for ndarrays
+        numpy.cumprod : equivalent function
         """
         result = self.filled(1).cumprod(axis=axis, dtype=dtype, out=out)
         if out is not None:
@@ -5009,41 +4939,18 @@ def cumprod(self, axis=None, dtype=None, out=None):
         result.__setmask__(self._mask)
         return result
 
-    def mean(self, axis=None, dtype=None, out=None):
+    def mean(self, axis=None, dtype=None, out=None, **kwargs):
         """
-        Returns the average of the array elements.
+        Returns the average of the array elements along given axis.
 
         Masked entries are ignored.
-        The average is taken over the flattened array by default, otherwise over
-        the specified axis. Refer to `numpy.mean` for the full documentation.
-
-        Parameters
-        ----------
-        a : array_like
-            Array containing numbers whose mean is desired. If `a` is not an
-            array, a conversion is attempted.
-        axis : int, optional
-            Axis along which the means are computed. The default is to compute
-            the mean of the flattened array.
-        dtype : dtype, optional
-            Type to use in computing the mean. For integer inputs, the default
-            is float64; for floating point, inputs it is the same as the input
-            dtype.
-        out : ndarray, optional
-            Alternative output array in which to place the result. It must have
-            the same shape as the expected output but the type will be cast if
-            necessary.
 
-        Returns
-        -------
-        mean : ndarray, see dtype parameter above
-            If `out=None`, returns a new array containing the mean values,
-            otherwise a reference to the output array is returned.
+        Refer to `numpy.mean` for full documentation.
 
         See Also
         --------
-        numpy.ma.mean : Equivalent function.
-        numpy.mean : Equivalent function on non-masked arrays.
+        ndarray.mean : corresponding function for ndarrays
+        numpy.mean : Equivalent function
         numpy.ma.average: Weighted average.
 
         Examples
@@ -5058,23 +4965,51 @@ def mean(self, axis=None, dtype=None, out=None):
 
         """
         if self._mask is nomask:
-            result = super(MaskedArray, self).mean(axis=axis, dtype=dtype)
-        else:
-            dsum = self.sum(axis=axis, dtype=dtype)
-            cnt = self.count(axis=axis)
-            if cnt.shape == () and (cnt == 0):
-                result = masked
+            ret = super(MaskedArray, self).mean(axis, dtype, out, **kwargs)
+            zerocounts = self.count(axis, **kwargs) == 0
+            if out is not None:
+                if isinstance(out, MaskedArray):
+                    if any(zerocounts):
+                        out.__setmask__(zerocounts)
+                    else:
+                        out.__setmask__(nomask)
+                return out
+            # mask in case of empty slices
+            if any(zerocounts):
+                ret = ret.view(MaskedArray)
+                ret.__setmask__(zerocounts)
+            return ret
+
+        # code largely copied from _mean in numpy/core/_methods.py
+
+        rcount = self.count(axis=axis, **kwargs)
+
+        # Cast bool, unsigned int, and int to float64 by default
+        if dtype is None and issubclass(self.dtype.type,
+                                        (np.integer, np.bool_)):
+            dtype = np.dtype('f8')
+
+        ret = self.sum(axis=axis, dtype=dtype, **kwargs)
+        if ret is masked:
+            return _return_masked(out)
+        with np.errstate(divide='ignore', invalid='ignore'):
+            if isinstance(ret, np.ndarray):
+                ret = np.true_divide(
+                        ret, rcount, out=ret, casting='unsafe', subok=False)
+            elif hasattr(ret, 'dtype'):
+                ret = ret.dtype.type(ret / rcount)
             else:
-                result = dsum * 1. / cnt
+                ret = ret / rcount
+
         if out is not None:
-            out.flat = result
+            out.flat = ret
             if isinstance(out, MaskedArray):
                 outmask = getattr(out, '_mask', nomask)
                 if (outmask is nomask):
                     outmask = out._mask = make_mask_none(out.shape)
-                outmask.flat = getattr(result, '_mask', nomask)
+                outmask.flat = getattr(ret, '_mask', nomask)
             return out
-        return result
+        return ret
 
     def anom(self, axis=None, dtype=None):
         """
@@ -5108,77 +5043,143 @@ def anom(self, axis=None, dtype=None):
 
         """
         m = self.mean(axis, dtype)
-        if m is masked:
-            return m
-
         if not axis:
             return (self - m)
         else:
             return (self - expand_dims(m, axis))
 
-    def var(self, axis=None, dtype=None, out=None, ddof=0):
-        ""
+    def var(self, axis=None, dtype=None, out=None, ddof=0, **kwargs):
+        """
+        Returns the variance of the array elements along given axis.
+
+        Masked entries are ignored.
+
+        Refer to `numpy.var` for full documentation.
+
+        See Also
+        --------
+        ndarray.var : corresponding function for ndarrays
+        numpy.var : Equivalent function
+        """
         # Easy case: nomask, business as usual
         if self._mask is nomask:
-            return self._data.var(axis=axis, dtype=dtype, out=out, ddof=ddof)
-        # Some data are masked, yay!
-        cnt = self.count(axis=axis) - ddof
-        danom = self.anom(axis=axis, dtype=dtype)
-        if iscomplexobj(self):
-            danom = umath.absolute(danom) ** 2
-        else:
-            danom *= danom
-        dvar = divide(danom.sum(axis), cnt).view(type(self))
-        # Apply the mask if it's not a scalar
-        if dvar.ndim:
-            dvar._mask = mask_or(self._mask.all(axis), (cnt <= 0))
-            dvar._update_from(self)
-        elif getattr(dvar, '_mask', False):
-            # Make sure that masked is returned when the scalar is masked.
-            dvar = masked
+            ret = super(MaskedArray, self).var(axis, dtype, out, ddof, **kwargs)
+            zerocounts = self.count(axis, **kwargs) == 0
             if out is not None:
                 if isinstance(out, MaskedArray):
-                    out.flat = 0
-                    out.__setmask__(True)
-                elif out.dtype.kind in 'biu':
-                    errmsg = "Masked data information would be lost in one or "\
-                             "more location."
-                    raise MaskError(errmsg)
-                else:
-                    out.flat = np.nan
+                    if any(zerocounts):
+                        out.__setmask__(zerocounts)
+                    else:
+                        out.__setmask__(nomask)
                 return out
-        # In case with have an explicit output
+            # mask in case of empty slices
+            if any(zerocounts):
+                ret = ret.view(MaskedArray)
+                ret.__setmask__(zerocounts)
+            return ret
+
+        # code largely copied from _methods.var
+
+
+        # Cast bool, unsigned int, and int to float64 by default
+        if dtype is None and issubclass(self.dtype.type,
+                                        (np.integer, np.bool_)):
+            dtype = np.dtype('f8')
+
+        # Compute the mean, keeping same dims. Note that if dtype is not of
+        # inexact type then arraymean will not be either.
+        rcount = self.count(axis=axis, keepdims=True)
+        arrmean = self.sum(axis=axis, dtype=dtype, keepdims=True)
+
+        # quit now if sum is masked, to avoid writing to the masked singleton
+        if arrmean is masked:
+            return _return_masked(out)
+
+        with np.errstate(divide='ignore', invalid='ignore'):
+            if isinstance(arrmean, np.ndarray):
+                arrmean = np.true_divide(
+                    arrmean, rcount, out=arrmean, casting='unsafe', subok=False)
+            else:
+                arrmean = arrmean.dtype.type(arrmean / rcount)
+
+        # Compute sum of squared deviations from mean
+        # Note that x may not be inexact and that we need it to be an array,
+        # not a scalar.
+        x = asanyarray(self - arrmean)
+        if issubclass(self.dtype.type, np.complexfloating):
+            x = np.multiply(x, np.conjugate(x), out=x).real
+        else:
+            x = np.multiply(x, x, out=x)
+        ret = x.sum(axis, dtype, **kwargs)
+        if ret is masked:
+            return _return_masked(out)
+
+        # Compute degrees of freedom and make sure it is not negative.
+        rcount = self.count(axis=axis, **kwargs)
+        rcount = (rcount - ddof).clip(min=0)
+
+        # divide by degrees of freedom
+        with np.errstate(divide='ignore', invalid='ignore'):
+            if isinstance(ret, np.ndarray):
+                ret = true_divide(
+                        ret, rcount, out=ret, casting='unsafe', subok=False)
+            elif hasattr(ret, 'dtype'):
+                ret = ret.dtype.type(ret / rcount)
+            else:
+                ret = ret / rcount
+
+        # account for case we got a scalar from sum, and rcout == 0
+        if ret.ndim == 0 and np.isnan(ret):
+            ret = masked
+
         if out is not None:
-            # Set the data
-            out.flat = dvar
-            # Set the mask if needed
             if isinstance(out, MaskedArray):
-                out.__setmask__(dvar.mask)
+                out.flat = ret
+                outmask = getattr(out, '_mask', nomask)
+                if (outmask is nomask):
+                    outmask = out._mask = make_mask_none(out.shape)
+                outmask.flat = getattr(ret, '_mask', nomask)
+            else:
+                if out.dtype.kind in 'biu' and any(~ret._mask):
+                    errmsg = "Masked data information would be lost in one or "\
+                             "more location."
+                    raise MaskError(errmsg)
+                out.flat = ret.filled(np.nan)
             return out
-        return dvar
-    var.__doc__ = np.var.__doc__
 
-    def std(self, axis=None, dtype=None, out=None, ddof=0):
-        ""
-        dvar = self.var(axis=axis, dtype=dtype, out=out, ddof=ddof)
+        return ret
+
+    def std(self, axis=None, dtype=None, out=None, ddof=0, **kwargs):
+        """
+        Returns the standard deviation of the array elements along given axis.
+
+        Masked entries are ignored.
+
+        Refer to `numpy.std` for full documentation.
+
+        See Also
+        --------
+        ndarray.std : corresponding function for ndarrays
+        numpy.std : Equivalent function
+        """
+        dvar = self.var(axis, dtype, out, ddof, **kwargs)
         if dvar is not masked:
             if out is not None:
                 np.power(out, 0.5, out=out, casting='unsafe')
                 return out
             dvar = sqrt(dvar)
         return dvar
-    std.__doc__ = np.std.__doc__
 
     def round(self, decimals=0, out=None):
         """
-        Return an array rounded a to the given number of decimals.
+        Return `a` with each element rounded to the given number of decimals.
 
         Refer to `numpy.around` for full documentation.
 
         See Also
         --------
+        ndarray.around : corresponding function for ndarrays
         numpy.around : equivalent function
-
         """
         result = self._data.round(decimals=decimals, out=out).view(type(self))
         if result.ndim > 0:
@@ -5193,7 +5194,6 @@ def round(self, decimals=0, out=None):
         if isinstance(out, MaskedArray):
             out.__setmask__(self._mask)
         return out
-    round.__doc__ = ndarray.round.__doc__
 
     def argsort(self, axis=None, kind='quicksort', order=None, fill_value=None):
         """
@@ -5424,7 +5424,7 @@ def sort(self, axis=-1, kind='quicksort', order=None,
             self._mask.flat = tmp_mask
         return
 
-    def min(self, axis=None, out=None, fill_value=None):
+    def min(self, axis=None, out=None, fill_value=None, **kwargs):
         """
         Return the minimum along a given axis.
 
@@ -5459,7 +5459,7 @@ def min(self, axis=None, out=None, fill_value=None):
         # No explicit output
         if out is None:
             result = self.filled(fill_value).min(
-                axis=axis, out=out).view(type(self))
+                axis=axis, out=out, **kwargs).view(type(self))
             if result.ndim:
                 # Set the mask
                 result.__setmask__(newmask)
@@ -5470,7 +5470,7 @@ def min(self, axis=None, out=None, fill_value=None):
                 result = masked
             return result
         # Explicit output
-        result = self.filled(fill_value).min(axis=axis, out=out)
+        result = self.filled(fill_value).min(axis=axis, out=out, **kwargs)
         if isinstance(out, MaskedArray):
             outmask = getattr(out, '_mask', nomask)
             if (outmask is nomask):
@@ -5484,6 +5484,7 @@ def min(self, axis=None, out=None, fill_value=None):
             np.copyto(out, np.nan, where=newmask)
         return out
 
+    # unique to masked arrays
     def mini(self, axis=None):
         """
         Return the array minimum along the specified axis.
@@ -5523,7 +5524,7 @@ def mini(self, axis=None):
         else:
             return minimum.reduce(self, axis)
 
-    def max(self, axis=None, out=None, fill_value=None):
+    def max(self, axis=None, out=None, fill_value=None, **kwargs):
         """
         Return the maximum along a given axis.
 
@@ -5558,7 +5559,7 @@ def max(self, axis=None, out=None, fill_value=None):
         # No explicit output
         if out is None:
             result = self.filled(fill_value).max(
-                axis=axis, out=out).view(type(self))
+                axis=axis, out=out, **kwargs).view(type(self))
             if result.ndim:
                 # Set the mask
                 result.__setmask__(newmask)
@@ -5569,7 +5570,7 @@ def max(self, axis=None, out=None, fill_value=None):
                 result = masked
             return result
         # Explicit output
-        result = self.filled(fill_value).max(axis=axis, out=out)
+        result = self.filled(fill_value).max(axis=axis, out=out, **kwargs)
         if isinstance(out, MaskedArray):
             outmask = getattr(out, '_mask', nomask)
             if (outmask is nomask):
@@ -6109,8 +6110,26 @@ def __reduce__(self):
         """
         return (self.__class__, ())
 
-
 masked = masked_singleton = MaskedConstant()
+
+def _return_masked(out):
+    """Return the value "masked", writing it to out if out is not None"""
+    if out is not None:
+        if out.size != 1:
+            raise Exception("out has wrong shape")
+
+        if isinstance(out, MaskedArray):
+            out.flat = 0
+            out.__setmask__(True)
+        else:
+            if out.dtype.kind in 'biu':
+                errmsg = "Masked data information would be lost in one or "\
+                         "more location."
+                raise MaskError(errmsg)
+            out.flat = np.nan
+        return out
+    return masked
+
 masked_array = MaskedArray
 
 
@@ -6273,24 +6292,24 @@ def __init__(self):
         self.compare = greater
         self.fill_value_func = maximum_fill_value
 
-
-def min(obj, axis=None, out=None, fill_value=None):
+def min(obj, axis=None, out=None, fill_value=None, **kwargs):
     try:
-        return obj.min(axis=axis, fill_value=fill_value, out=out)
+        return obj.min(axis=axis, fill_value=fill_value, out=out, **kwargs)
     except (AttributeError, TypeError):
-        # If obj doesn't have a min method or if the method doesn't accept
-        # a fill_value argument
-        return asanyarray(obj).min(axis=axis, fill_value=fill_value, out=out)
+        # If obj doesn't have a min method, or if the method doesn't accept a
+        # fill_value argument
+        return asanyarray(obj).min(axis=axis, fill_value=fill_value,
+                                   out=out, **kwargs)
 min.__doc__ = MaskedArray.min.__doc__
 
-
-def max(obj, axis=None, out=None, fill_value=None):
+def max(obj, axis=None, out=None, fill_value=None, **kwargs):
     try:
-        return obj.max(axis=axis, fill_value=fill_value, out=out)
+        return obj.max(axis=axis, fill_value=fill_value, out=out, **kwargs)
     except (AttributeError, TypeError):
-        # If obj doesn't have a max method, or if the method doesn't accept
-        # a fill_value argument
-        return asanyarray(obj).max(axis=axis, fill_value=fill_value, out=out)
+        # If obj doesn't have a max method, or if the method doesn't accept a
+        # fill_value argument
+        return asanyarray(obj).max(axis=axis, fill_value=fill_value,
+                                   out=out, **kwargs)
 max.__doc__ = MaskedArray.max.__doc__
 
 
@@ -6456,26 +6475,9 @@ def argsort(a, axis=None, kind='quicksort', order=None, fill_value=None):
     return d.argsort(axis, kind=kind, order=order)
 argsort.__doc__ = MaskedArray.argsort.__doc__
 
-
-def argmin(a, axis=None, fill_value=None):
-    "Function version of the eponymous method."
-    if fill_value is None:
-        fill_value = default_fill_value(a)
-    d = filled(a, fill_value)
-    return d.argmin(axis=axis)
+argmin = _frommethod('argmin')
 argmin.__doc__ = MaskedArray.argmin.__doc__
-
-
-def argmax(a, axis=None, fill_value=None):
-    "Function version of the eponymous method."
-    if fill_value is None:
-        fill_value = default_fill_value(a)
-        try:
-            fill_value = -fill_value
-        except:
-            pass
-    d = filled(a, fill_value)
-    return d.argmax(axis=axis)
+argmax = _frommethod('argmax')
 argmax.__doc__ = MaskedArray.argmax.__doc__
 
 
@@ -6588,11 +6590,10 @@ def concatenate(arrays, axis=0):
         data._mask = dm.reshape(d.shape)
     return data
 
-
-def count(a, axis=None):
+def count(a, axis=None, **kwargs):
     if isinstance(a, MaskedArray):
-        return a.count(axis)
-    return masked_array(a, copy=False).count(axis)
+        return a.count(axis, **kwargs)
+    return masked_array(a, copy=False).count(axis, **kwargs)
 count.__doc__ = MaskedArray.count.__doc__
 
 
@@ -7495,8 +7496,7 @@ def allclose(a, b, masked_equal=True, rtol=1e-5, atol=1e-8):
         return False
     # No infs at all
     if not np.any(xinf):
-        d = filled(umath.less_equal(umath.absolute(x - y),
-                                    atol + rtol * umath.absolute(y)),
+        d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),
                    masked_equal)
         return np.all(d)
 
@@ -7505,8 +7505,7 @@ def allclose(a, b, masked_equal=True, rtol=1e-5, atol=1e-8):
     x = x[~xinf]
     y = y[~xinf]
 
-    d = filled(umath.less_equal(umath.absolute(x - y),
-                                atol + rtol * umath.absolute(y)),
+    d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),
                masked_equal)
 
     return np.all(d)
diff --git a/numpy/ma/extras.py b/numpy/ma/extras.py
index 9855b4e7648..9350ad5b364 100644
--- a/numpy/ma/extras.py
+++ b/numpy/ma/extras.py
@@ -24,6 +24,7 @@
 
 import itertools
 import warnings
+import operator
 
 from . import core as ma
 from .core import (
@@ -36,6 +37,7 @@
 import numpy as np
 from numpy import ndarray, array as nxarray
 import numpy.core.umath as umath
+from numpy.lib.function_base import _ureduce
 from numpy.lib.index_tricks import AxisConcatenator
 
 
@@ -471,8 +473,8 @@ def average(a, axis=None, weights=None, returned=False):
         Data to be averaged.
         Masked entries are not taken into account in the computation.
     axis : int, optional
-        Axis along which the average is computed. The default is to compute
-        the average of the flattened array.
+        Axis along which to average `a`. If `None`, averaging is done over
+        the flattened array.
     weights : array_like, optional
         The importance that each element has in the computation of the average.
         The weights array can either be 1-D (in which case its length must be
@@ -513,97 +515,44 @@ def average(a, axis=None, weights=None, returned=False):
 
     """
     a = asarray(a)
-    mask = a.mask
-    ash = a.shape
-    if ash == ():
-        ash = (1,)
-    if axis is None:
-        if mask is nomask:
-            if weights is None:
-                n = a.sum(axis=None)
-                d = float(a.size)
-            else:
-                w = filled(weights, 0.0).ravel()
-                n = umath.add.reduce(a._data.ravel() * w)
-                d = umath.add.reduce(w)
-                del w
-        else:
-            if weights is None:
-                n = a.filled(0).sum(axis=None)
-                d = float(umath.add.reduce((~mask).ravel()))
-            else:
-                w = array(filled(weights, 0.0), float, mask=mask).ravel()
-                n = add.reduce(a.ravel() * w)
-                d = add.reduce(w)
-                del w
+    m = getmask(a)
+
+    if weights is None:
+        avg = a.mean(axis)
+        scl = avg.dtype.type(a.count(axis))
     else:
-        if mask is nomask:
-            if weights is None:
-                d = ash[axis] * 1.0
-                n = add.reduce(a._data, axis)
-            else:
-                w = filled(weights, 0.0)
-                wsh = w.shape
-                if wsh == ():
-                    wsh = (1,)
-                if wsh == ash:
-                    w = np.array(w, float, copy=0)
-                    n = add.reduce(a * w, axis)
-                    d = add.reduce(w, axis)
-                    del w
-                elif wsh == (ash[axis],):
-                    r = [None] * len(ash)
-                    r[axis] = slice(None, None, 1)
-                    w = eval("w[" + repr(tuple(r)) + "] * ones(ash, float)")
-                    n = add.reduce(a * w, axis)
-                    d = add.reduce(w, axis, dtype=float)
-                    del w, r
-                else:
-                    raise ValueError('average: weights wrong shape.')
-        else:
-            if weights is None:
-                n = add.reduce(a, axis)
-                d = umath.add.reduce((~mask), axis=axis, dtype=float)
-            else:
-                w = filled(weights, 0.0)
-                wsh = w.shape
-                if wsh == ():
-                    wsh = (1,)
-                if wsh == ash:
-                    w = array(w, dtype=float, mask=mask, copy=0)
-                    n = add.reduce(a * w, axis)
-                    d = add.reduce(w, axis, dtype=float)
-                elif wsh == (ash[axis],):
-                    r = [None] * len(ash)
-                    r[axis] = slice(None, None, 1)
-                    w = eval("w[" + repr(tuple(r)) +
-                             "] * masked_array(ones(ash, float), mask)")
-                    n = add.reduce(a * w, axis)
-                    d = add.reduce(w, axis, dtype=float)
-                else:
-                    raise ValueError('average: weights wrong shape.')
-                del w
-    if n is masked or d is masked:
-        return masked
-    result = n / d
-    del n
-
-    if isinstance(result, MaskedArray):
-        if ((axis is None) or (axis == 0 and a.ndim == 1)) and \
-           (result.mask is nomask):
-            result = result._data
-        if returned:
-            if not isinstance(d, MaskedArray):
-                d = masked_array(d)
-            if isinstance(d, ndarray) and (not d.shape == result.shape):
-                d = ones(result.shape, dtype=float) * d
+        a = a + 0.0
+        wgt = np.asarray(weights)
+        # Sanity checks
+        if a.shape != wgt.shape:
+            if axis is None:
+                raise TypeError(
+                    "Axis must be specified when shapes of a and weights "
+                    "differ.")
+            if wgt.ndim != 1:
+                raise TypeError(
+                    "1D weights expected when shapes of a and weights differ.")
+            if wgt.shape[0] != a.shape[axis]:
+                raise ValueError(
+                    "Length of weights not compatible with specified axis.")
+
+            # setup wgt to broadcast along axis
+            wgt = np.array(wgt, copy=0, ndmin=a.ndim).swapaxes(-1, axis)
+
+        if m is masked:
+            wgt.fill(0)
+        elif m is not nomask:
+            wgt = wgt*(~a.mask)
+        scl = wgt.sum(axis=axis, dtype=np.result_type(a.dtype, wgt.dtype))
+        avg = np.multiply(a, wgt).sum(axis)/scl
+
     if returned:
-        return result, d
+        scl = np.multiply(avg, 0) + scl
+        return avg, scl
     else:
-        return result
+        return avg
 
-
-def median(a, axis=None, out=None, overwrite_input=False):
+def median(a, axis=None, out=None, overwrite_input=False, keepdims=False):
     """
     Compute the median along the specified axis.
 
@@ -628,6 +577,12 @@ def median(a, axis=None, out=None, overwrite_input=False):
         but it will probably be fully or partially sorted. Default is
         False. Note that, if `overwrite_input` is True, and the input
         is not already an `ndarray`, an error will be raised.
+    keepdims : bool, optional
+        If this is set to True, the axes which are reduced are left
+        in the result as dimensions with size one. With this option,
+        the result will broadcast correctly against the original `arr`.
+
+        .. versionadded:: 1.10.0
 
     Returns
     -------
@@ -665,7 +620,19 @@ def median(a, axis=None, out=None, overwrite_input=False):
     """
     if not hasattr(a, 'mask') or np.count_nonzero(a.mask) == 0:
         return masked_array(np.median(getdata(a, subok=True), axis=axis,
-                      out=out, overwrite_input=overwrite_input), copy=False)
+                            out=out, overwrite_input=overwrite_input,
+                            keepdims=keepdims), copy=False)
+    if a is masked:
+        return masked
+
+    r, k = _ureduce(a, func=_median, axis=axis, out=out,
+                    overwrite_input=overwrite_input)
+    if keepdims:
+        return r.reshape(k)
+    else:
+        return r
+
+def _median(a, axis=None, out=None, overwrite_input=False):
     if overwrite_input:
         if axis is None:
             asorted = a.ravel()
diff --git a/numpy/ma/tests/test_core.py b/numpy/ma/tests/test_core.py
index b163d3b2642..e84d1fa4f82 100644
--- a/numpy/ma/tests/test_core.py
+++ b/numpy/ma/tests/test_core.py
@@ -988,11 +988,7 @@ def test_count_func(self):
         assert_(getmask(res) is nomask)
 
         ott = array([0., 1., 2., 3.])
-        res = count(ott, 0)
-        assert_(isinstance(res, ndarray))
-        assert_(res.dtype.type is np.intp)
-
-        assert_raises(IndexError, ott.count, 1)
+        assert_raises(IndexError, ott.count, axis=1)
 
     def test_minmax_func(self):
         # Tests minimum and maximum.
@@ -1198,6 +1194,12 @@ def test_noshrinking(self):
         a /= 1.
         assert_equal(a.mask, [0, 0, 0])
 
+    def test_ufunc_nomask(self):
+        # check the case ufuncs should set the mask to false
+        m = np.ma.array([1])
+        # check we don't get array([False], dtype=bool)
+        assert_equal(np.true_divide(m, 5).mask.shape, ())
+
     def test_noshink_on_creation(self):
         # Check that the mask is not shrunk on array creation when not wanted
         a = np.ma.masked_values([1., 2.5, 3.1], 1.5, shrink=False)
@@ -1266,6 +1268,16 @@ def test_methods_with_output(self):
             assert_(result is output)
             assert_(output[0] is masked)
 
+    def test_count_mean_with_matrix(self):
+        m = np.ma.array(np.matrix([[1,2],[3,4]]), mask=np.zeros((2,2)))
+
+        assert_equal(m.count(axis=0).shape, (1,2))
+        assert_equal(m.count(axis=1).shape, (2,1))
+
+        #make sure broadcasting inside mean and var work
+        assert_equal(m.mean(axis=0), [[2., 3.]])
+        assert_equal(m.mean(axis=1), [[1.5], [3.5]])
+
     def test_eq_on_structured(self):
         # Test the equality of structured arrays
         ndtype = [('A', int), ('B', int)]
@@ -4207,6 +4219,79 @@ def test_view_to_dtype_and_type(self):
         self.assertTrue(isinstance(test, np.matrix))
         self.assertTrue(not isinstance(test, MaskedArray))
 
+class TestOptionalArgs(TestCase):
+    def test_ndarrayfuncs(self):
+        # test axis arg behaves the same as ndarray (including mutliple axes)
+
+        d = np.arange(24.0).reshape((2,3,4))
+        m = np.zeros(24, dtype=bool).reshape((2,3,4))
+        # mask out last element of last dimension
+        m[:,:,-1] = True
+        a = np.ma.array(d, mask=m)
+
+        def testaxis(f, a, d):
+            numpy_f = numpy.__getattribute__(f)
+            ma_f = np.ma.__getattribute__(f)
+
+            # test axis arg
+            assert_equal(ma_f(a, axis=1)[...,:-1], numpy_f(d[...,:-1], axis=1))
+            assert_equal(ma_f(a, axis=(0,1))[...,:-1],
+                         numpy_f(d[...,:-1], axis=(0,1)))
+
+        def testkeepdims(f, a, d):
+            numpy_f = numpy.__getattribute__(f)
+            ma_f = np.ma.__getattribute__(f)
+
+            # test keepdims arg
+            assert_equal(ma_f(a, keepdims=True).shape,
+                         numpy_f(d, keepdims=True).shape)
+            assert_equal(ma_f(a, keepdims=False).shape,
+                         numpy_f(d, keepdims=False).shape)
+
+            # test both at once
+            assert_equal(ma_f(a, axis=1, keepdims=True)[...,:-1],
+                         numpy_f(d[...,:-1], axis=1, keepdims=True))
+            assert_equal(ma_f(a, axis=(0,1), keepdims=True)[...,:-1],
+                         numpy_f(d[...,:-1], axis=(0,1), keepdims=True))
+
+        for f in ['sum', 'prod', 'mean', 'var', 'std']:
+            testaxis(f, a, d)
+            testkeepdims(f, a, d)
+
+        for f in ['min', 'max']:
+            testaxis(f, a, d)
+
+        d = (np.arange(24).reshape((2,3,4))%2 == 0)
+        a = np.ma.array(d, mask=m)
+        for f in ['all', 'any']:
+            testaxis(f, a, d)
+            testkeepdims(f, a, d)
+
+    def test_count(self):
+        # test np.ma.count specially
+
+        d = arange(24.0).reshape((2,3,4))
+        m = zeros(24, dtype=bool).reshape((2,3,4))
+        m[:,0,:] = True
+        a = np.ma.array(d, mask=m)
+
+        assert_equal(count(a), 16)
+        assert_equal(count(a, axis=1), 2*ones((2,4)))
+        assert_equal(count(a, axis=(0,1)), 4*ones((4,)))
+        assert_equal(count(a, keepdims=True), 16*ones((1,1,1)))
+        assert_equal(count(a, axis=1, keepdims=True), 2*ones((2,1,4)))
+        assert_equal(count(a, axis=(0,1), keepdims=True), 4*ones((1,1,4)))
+
+        # check the 'nomask' path
+        a = np.ma.array(d, mask=nomask)
+
+        assert_equal(count(a), 24)
+        assert_equal(count(a, axis=1), 3*ones((2,4)))
+        assert_equal(count(a, axis=(0,1)), 6*ones((4,)))
+        assert_equal(count(a, keepdims=True), 24*ones((1,1,1)))
+        assert_equal(count(a, axis=1, keepdims=True), 3*ones((2,1,4)))
+        assert_equal(count(a, axis=(0,1), keepdims=True), 6*ones((1,1,4)))
+
 
 def test_masked_array():
     a = np.ma.array([0, 1, 2, 3], mask=[0, 0, 1, 0])
diff --git a/numpy/ma/tests/test_extras.py b/numpy/ma/tests/test_extras.py
index 6138d057396..52669cb909e 100644
--- a/numpy/ma/tests/test_extras.py
+++ b/numpy/ma/tests/test_extras.py
@@ -998,7 +998,7 @@ def test_ediff1d(self):
         control = array([1, 1, 1, 4], mask=[1, 0, 0, 1])
         test = ediff1d(x)
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
 
     def test_ediff1d_tobegin(self):
@@ -1007,13 +1007,13 @@ def test_ediff1d_tobegin(self):
         test = ediff1d(x, to_begin=masked)
         control = array([0, 1, 1, 1, 4], mask=[1, 1, 0, 0, 1])
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
         #
         test = ediff1d(x, to_begin=[1, 2, 3])
         control = array([1, 2, 3, 1, 1, 1, 4], mask=[0, 0, 0, 1, 0, 0, 1])
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
 
     def test_ediff1d_toend(self):
@@ -1022,13 +1022,13 @@ def test_ediff1d_toend(self):
         test = ediff1d(x, to_end=masked)
         control = array([1, 1, 1, 4, 0], mask=[1, 0, 0, 1, 1])
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
         #
         test = ediff1d(x, to_end=[1, 2, 3])
         control = array([1, 1, 1, 4, 1, 2, 3], mask=[1, 0, 0, 1, 0, 0, 0])
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
 
     def test_ediff1d_tobegin_toend(self):
@@ -1037,14 +1037,14 @@ def test_ediff1d_tobegin_toend(self):
         test = ediff1d(x, to_end=masked, to_begin=masked)
         control = array([0, 1, 1, 1, 4, 0], mask=[1, 1, 0, 0, 1, 1])
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
         #
         test = ediff1d(x, to_end=[1, 2, 3], to_begin=masked)
         control = array([0, 1, 1, 1, 4, 1, 2, 3],
                         mask=[1, 1, 0, 0, 1, 0, 0, 0])
         assert_equal(test, control)
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
 
     def test_ediff1d_ndarray(self):
@@ -1054,13 +1054,13 @@ def test_ediff1d_ndarray(self):
         control = array([1, 1, 1, 1], mask=[0, 0, 0, 0])
         assert_equal(test, control)
         self.assertTrue(isinstance(test, MaskedArray))
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
         #
         test = ediff1d(x, to_end=masked, to_begin=masked)
         control = array([0, 1, 1, 1, 1, 0], mask=[1, 0, 0, 0, 0, 1])
         self.assertTrue(isinstance(test, MaskedArray))
-        assert_equal(test.data, control.data)
+        assert_equal(test.filled(0), control.filled(0))
         assert_equal(test.mask, control.mask)
 
     def test_intersect1d(self):
diff --git a/numpy/ma/tests/test_likenan.py b/numpy/ma/tests/test_likenan.py
new file mode 100644
index 00000000000..29b9da62974
--- /dev/null
+++ b/numpy/ma/tests/test_likenan.py
@@ -0,0 +1,424 @@
+from __future__ import division, absolute_import, print_function
+
+import warnings
+
+import numpy as np
+from numpy.testing import (
+    run_module_suite, TestCase, assert_, assert_equal, assert_almost_equal,
+    assert_raises, assert_array_equal
+    )
+
+
+# Test data
+_ndat = np.array([[0.6244, np.nan, 0.2692, 0.0116, np.nan, 0.1170],
+                  [0.5351, -0.9403, np.nan, 0.2100, 0.4759, 0.2833],
+                  [np.nan, np.nan, np.nan, 0.1042, np.nan, -0.5954],
+                  [0.1610, np.nan, np.nan, 0.1859, 0.3146, np.nan]])
+
+_madat = np.ma.array(_ndat, mask=np.isnan(_ndat))
+
+# Rows of _ndat with nans removed
+_rdat = [np.array([0.6244, 0.2692, 0.0116, 0.1170]),
+         np.array([0.5351, -0.9403, 0.2100, 0.4759, 0.2833]),
+         np.array([0.1042, -0.5954]),
+         np.array([0.1610, 0.1859, 0.3146])]
+
+
+class TestMaskedFunctions_MinMax(TestCase):
+
+    mafuncs = [np.ma.min, np.ma.max]
+    stdfuncs = [np.min, np.max]
+
+    def test_mutation(self):
+        # Check that passed array is not modified.
+        ndat = _madat.copy()
+        for f in self.mafuncs:
+            f(ndat)
+            assert_equal(ndat, _madat)
+
+    def test_keepdims(self):
+        mat = np.eye(3)
+        for mf, rf in zip(self.mafuncs, self.stdfuncs):
+            for axis in [None, 0, 1]:
+                tgt = rf(mat, axis=axis, keepdims=True)
+                res = mf(mat, axis=axis, keepdims=True)
+                assert_(res.ndim == tgt.ndim)
+
+    def test_out(self):
+        mat = np.eye(3)
+        for mf, rf in zip(self.mafuncs, self.stdfuncs):
+            resout = np.zeros(3)
+            tgt = rf(mat, axis=1)
+            res = mf(mat, axis=1, out=resout)
+            assert_almost_equal(res, resout)
+            assert_almost_equal(res, tgt)
+
+    def test_dtype_from_input(self):
+        codes = 'efdgFDG'
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            for c in codes:
+                mat = np.eye(3, dtype=c)
+                tgt = rf(mat, axis=1).dtype.type
+                res = nf(mat, axis=1).dtype.type
+                assert_(res is tgt)
+                # scalar case
+                tgt = rf(mat, axis=None).dtype.type
+                res = nf(mat, axis=None).dtype.type
+                assert_(res is tgt)
+
+    def test_result_values(self):
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            tgt = [rf(d) for d in _rdat]
+            res = nf(_madat, axis=1)
+            assert_almost_equal(res, tgt)
+
+    def test_allmasked(self):
+        mat = np.ma.array(np.ones((3,3)), mask=np.ones((3,3)))
+        for f in self.mafuncs:
+            for axis in [None, 0, 1]:
+                assert_(f(mat, axis=axis).mask.all())
+            # Check scalars
+            assert_(f(np.ma.masked) is np.ma.masked)
+
+    def test_scalar(self):
+        for f in self.mafuncs:
+            assert_(f(0.) == 0.)
+
+class TestMaskedFunctions_ArgminArgmax(TestCase):
+
+    mafuncs = [np.ma.argmin, np.ma.argmax]
+
+    def test_mutation(self):
+        # Check that passed array is not modified.
+        ndat = _madat.copy()
+        for f in self.mafuncs:
+            f(ndat)
+            assert_equal(ndat, _madat)
+
+    def test_result_values(self):
+        for f, fcmp in zip(self.mafuncs, [np.ma.greater, np.ma.less]):
+            for row in _madat:
+                ind = f(row)
+                val = row[ind]
+                assert_(val is not np.ma.masked)
+                assert_(not fcmp(val, row).any())
+                assert_(np.ma.equal(val, row[:ind]).any() in
+                                                          [False, np.ma.masked])
+
+    def test_empty(self):
+        mat = np.ma.zeros((0, 3))
+        for f in self.mafuncs:
+            for axis in [0, None]:
+                assert_raises(ValueError, f, mat, axis=axis)
+            for axis in [1]:
+                res = f(mat, axis=axis)
+                assert_equal(res, np.zeros(0))
+
+    def test_scalar(self):
+        for f in self.mafuncs:
+            assert_(f(0.) == 0.)
+
+
+class TestMaskedFunctions_IntTypes(TestCase):
+
+    int_types = (np.int8, np.int16, np.int32, np.int64, np.uint8,
+                 np.uint16, np.uint32, np.uint64)
+
+    mat = np.ma.array([127, 39, 93, 87, 46])
+
+    def integer_arrays(self):
+        for dtype in self.int_types:
+            yield self.mat.astype(dtype)
+
+    def test_mamin(self):
+        tgt = np.min(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.min(mat), tgt)
+
+    def test_mamax(self):
+        tgt = np.max(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.max(mat), tgt)
+
+    def test_maargmin(self):
+        tgt = np.argmin(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.argmin(mat), tgt)
+
+    def test_maargmax(self):
+        tgt = np.argmax(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.argmax(mat), tgt)
+
+    def test_masum(self):
+        tgt = np.sum(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.sum(mat), tgt)
+
+    def test_maprod(self):
+        tgt = np.prod(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.prod(mat), tgt)
+
+    def test_mamean(self):
+        tgt = np.mean(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.mean(mat), tgt)
+
+    def test_mavar(self):
+        tgt = np.var(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.var(mat), tgt)
+
+        tgt = np.var(mat, ddof=1)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.var(mat, ddof=1), tgt)
+
+    def test_mastd(self):
+        tgt = np.std(self.mat)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.std(mat), tgt)
+
+        tgt = np.std(self.mat, ddof=1)
+        for mat in self.integer_arrays():
+            assert_equal(np.ma.std(mat, ddof=1), tgt)
+
+
+class SharedMaskedFunctionsTestsMixin(object):
+    def test_mutation(self):
+        # Check that passed array is not modified.
+        ndat = _madat.copy()
+        for f in self.mafuncs:
+            f(ndat)
+            assert_equal(ndat, _madat)
+
+    def test_keepdims(self):
+        mat = np.eye(3)
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            for axis in [None, 0, 1]:
+                tgt = rf(mat, axis=axis, keepdims=True)
+                res = nf(mat, axis=axis, keepdims=True)
+                assert_(res.ndim == tgt.ndim)
+
+    def test_out(self):
+        mat = np.eye(3)
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            resout = np.zeros(3)
+            tgt = rf(mat, axis=1)
+            res = nf(mat, axis=1, out=resout)
+            assert_almost_equal(res, resout)
+            assert_almost_equal(res, tgt)
+
+    def test_dtype_from_dtype(self):
+        mat = np.eye(3)
+        codes = 'efdgFDG'
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            for c in codes:
+                tgt = rf(mat, dtype=np.dtype(c), axis=1).dtype.type
+                res = nf(mat, dtype=np.dtype(c), axis=1).dtype.type
+                assert_(res is tgt)
+                # scalar case
+                tgt = rf(mat, dtype=np.dtype(c), axis=None).dtype.type
+                res = nf(mat, dtype=np.dtype(c), axis=None).dtype.type
+                assert_(res is tgt)
+
+    def test_dtype_from_char(self):
+        mat = np.eye(3)
+        codes = 'efdgFDG'
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            for c in codes:
+                tgt = rf(mat, dtype=c, axis=1).dtype.type
+                res = nf(mat, dtype=c, axis=1).dtype.type
+                assert_(res is tgt)
+                # scalar case
+                tgt = rf(mat, dtype=c, axis=None).dtype.type
+                res = nf(mat, dtype=c, axis=None).dtype.type
+                assert_(res is tgt)
+
+    def test_dtype_from_input(self):
+        codes = 'efdgFDG'
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            for c in codes:
+                mat = np.eye(3, dtype=c)
+                tgt = rf(mat, axis=1).dtype.type
+                res = nf(mat, axis=1).dtype.type
+                assert_(res is tgt, "res %s, tgt %s" % (res, tgt))
+                # scalar case
+                tgt = rf(mat, axis=None).dtype.type
+                res = nf(mat, axis=None).dtype.type
+                assert_(res is tgt)
+
+    def test_result_values(self):
+        for nf, rf in zip(self.mafuncs, self.stdfuncs):
+            tgt = [rf(d) for d in _rdat]
+            res = nf(_madat, axis=1)
+            assert_almost_equal(res, tgt)
+
+    def test_scalar(self):
+        for f in self.mafuncs:
+            assert_(f(0.) == 0.)
+
+    def test_matrices(self):
+        # Check that it works and that type and
+        # shape are preserved
+        mat = np.matrix(np.eye(3))
+        for f in self.mafuncs:
+            res = f(mat, axis=0)
+            assert_(isinstance(res, np.matrix))
+            assert_(res.shape == (1, 3))
+            res = f(mat, axis=1)
+            assert_(isinstance(res, np.matrix))
+            assert_(res.shape == (3, 1))
+            res = f(mat)
+            assert_(np.isscalar(res))
+
+
+class TestMaskedFunctions_SumProd(TestCase, SharedMaskedFunctionsTestsMixin):
+
+    mafuncs = [np.ma.sum, np.ma.prod]
+    stdfuncs = [np.sum, np.prod]
+
+    def test_allmasked(self):
+        res = np.ma.sum([np.ma.masked]*3, axis=None)
+        assert_(res is np.ma.masked)
+
+    def test_empty(self):
+        for f, tgt_value in zip([np.ma.sum, np.ma.prod], [0, 1]):
+            mat = np.zeros((0, 3))
+            tgt = [tgt_value]*3
+            res = f(mat, axis=0)
+            assert_equal(res, tgt)
+            tgt = []
+            res = f(mat, axis=1)
+            assert_equal(res, tgt)
+            tgt = tgt_value
+            res = f(mat, axis=None)
+            assert_equal(res, tgt)
+
+
+class TestMaskedFunctions_MeanVarStd(TestCase, SharedMaskedFunctionsTestsMixin):
+
+    mafuncs = [np.ma.mean, np.ma.var, np.ma.std]
+    stdfuncs = [np.mean, np.var, np.std]
+
+    def test_ddof(self):
+        mafuncs = [np.ma.var, np.ma.std]
+        stdfuncs = [np.var, np.std]
+        for nf, rf in zip(mafuncs, stdfuncs):
+            for ddof in [0, 1]:
+                tgt = [rf(d, ddof=ddof) for d in _rdat]
+                res = nf(_madat, axis=1, ddof=ddof)
+                assert_almost_equal(res, tgt)
+
+    def test_ddof_too_big(self):
+        mafuncs = [np.ma.var, np.ma.std]
+        stdfuncs = [np.var, np.std]
+        dsize = [len(d) for d in _rdat]
+        for nf, rf in zip(mafuncs, stdfuncs):
+            for ddof in range(5):
+                tgt = [ddof >= d for d in dsize]
+                res = nf(_madat, axis=1, ddof=ddof)
+                assert_equal(res.mask, tgt)
+
+    def test_allmasked(self):
+        mat = np.ma.array([np.ma.masked]*9).reshape(3, 3)
+        for f in self.mafuncs:
+            for axis in [None, 0, 1]:
+                assert_(f(mat, axis=axis).mask.all())
+                # Check scalar
+                assert_(f(np.ma.masked) is np.ma.masked)
+
+class TestMaskedFunctions_Median(TestCase):
+
+    def test_mutation(self):
+        # Check that passed array is not modified.
+        ndat = _madat.copy()
+        np.ma.median(ndat)
+        assert_equal(ndat, _madat)
+
+    def test_keepdims(self):
+        mat = np.eye(3)
+        for axis in [None, 0, 1]:
+            tgt = np.median(mat, axis=axis, out=None, overwrite_input=False)
+            res = np.ma.median(mat, axis=axis, out=None, overwrite_input=False)
+            assert_(res.ndim == tgt.ndim)
+
+        d = np.ma.ones((3, 5, 7, 11))
+        # Randomly set some elements to NaN:
+        w = np.random.random((4, 200)) * np.array(d.shape)[:, None]
+        w = w.astype(np.intp)
+        d[tuple(w)] = np.ma.masked
+
+        res = np.ma.median(d, axis=None, keepdims=True)
+        assert_equal(res.shape, (1, 1, 1, 1))
+        res = np.ma.median(d, axis=(0, 1), keepdims=True)
+        assert_equal(res.shape, (1, 1, 7, 11))
+        res = np.ma.median(d, axis=(0, 3), keepdims=True)
+        assert_equal(res.shape, (1, 5, 7, 1))
+        res = np.ma.median(d, axis=(1,), keepdims=True)
+        assert_equal(res.shape, (3, 1, 7, 11))
+        res = np.ma.median(d, axis=(0, 1, 2, 3), keepdims=True)
+        assert_equal(res.shape, (1, 1, 1, 1))
+        res = np.ma.median(d, axis=(0, 1, 3), keepdims=True)
+        assert_equal(res.shape, (1, 1, 7, 1))
+
+    def test_out(self):
+        mat = np.random.rand(3, 3)
+        nan_mat = np.insert(mat, [0, 2], np.nan, axis=1)
+        ma_mat = np.ma.array(nan_mat, mask=np.isnan(nan_mat))
+        resout = np.ma.zeros(3)
+        tgt = np.median(mat, axis=1)
+        res = np.ma.median(ma_mat, axis=1, out=resout)
+        assert_almost_equal(res, resout)
+        assert_almost_equal(res, tgt)
+
+    def test_small_large(self):
+        # test the small and large code paths, current cutoff 400 elements
+        for s in [5, 20, 51, 200, 1000]:
+            d = np.ma.array(np.random.randn(4, s))
+            # Randomly set some elements to NaN:
+            w = np.random.randint(0, d.size, size=d.size // 5)
+            d.ravel()[w] = np.ma.masked
+            d[:,0] = 1.  # ensure at least one good value
+            # use normal median without masked to compare
+            tgt = []
+            for x in d:
+                nomask = np.ma.compress(np.ones(x.shape), x.filled(0))
+                tgt.append(np.median(nomask, overwrite_input=True))
+
+            assert_array_equal(np.ma.median(d, axis=-1), tgt)
+
+    def test_result_values(self):
+            tgt = [np.median(d) for d in _rdat]
+            res = np.ma.median(_madat, axis=1)
+            assert_almost_equal(res, tgt)
+
+    def test_allmasked(self):
+        mat = np.ma.array([np.ma.masked]*9).reshape(3, 3)
+        for axis in [None, 0, 1]:
+            assert_(np.ma.median(mat, axis=axis).mask.all())
+            # Check scalar
+            assert_(np.ma.median(np.ma.masked) is np.ma.masked)
+
+    def test_empty(self):
+        mat = np.zeros((0, 3))
+        for axis in [1]:
+            with warnings.catch_warnings(record=True) as w:
+                warnings.simplefilter('always')
+                assert_equal(np.ma.median(mat, axis=axis), np.zeros([]))
+                assert_(len(w) == 0)
+
+    def test_scalar(self):
+        assert_(np.ma.median(0.) == 0.)
+
+    def test_extended_axis_invalid(self):
+        d = np.ones((3, 5, 7, 11))
+        assert_raises(IndexError, np.ma.median, d, axis=-5)
+        assert_raises(IndexError, np.ma.median, d, axis=(0, -5))
+        assert_raises(IndexError, np.ma.median, d, axis=4)
+        assert_raises(IndexError, np.ma.median, d, axis=(0, 4))
+        assert_raises(ValueError, np.ma.median, d, axis=(1, 1))
+
+
+if __name__ == "__main__":
+    run_module_suite()
